<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远川的个人博客</title>
  
  <subtitle>CrazyStudent13的个人日志</subtitle>
  <link href="https://crazystudent13.github.io/atom.xml" rel="self"/>
  
  <link href="https://crazystudent13.github.io/"/>
  <updated>2024-08-06T13:43:32.860Z</updated>
  <id>https://crazystudent13.github.io/</id>
  
  <author>
    <name>CrazyStudent13</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10分钟了解defer与async</title>
    <link href="https://crazystudent13.github.io/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/"/>
    <id>https://crazystudent13.github.io/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/</id>
    <published>2024-08-05T08:02:19.000Z</published>
    <updated>2024-08-06T13:43:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>defer与async不怎么常用，而且这个涉及到<code>&lt;scrpit/&gt;</code>的基础使用方式，都是一些远古常识题，</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>async</code> 和 <code>defer</code> 是两种不同的JavaScript特性，它们的主要区别在于它们的执行顺序和时间点。</p><p>在正式进入二者的区别之前，我们需要先了解所有scprit的脚本对页面执行的阻塞的影响。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p> <strong>async</strong>属性是 HTML5 中的新属性</p></blockquote><ul><li><strong>async</strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li><li><strong>charset</strong>：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><strong>defer</strong>：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。</li><li><strong>language</strong>： 已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript 、 JavaScript1.2 或 VBScript ）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li><li><strong>src</strong>：可选。表示包含要执行代码的外部文件。</li><li><strong>type</strong>：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text&#x2F;javascript<br>和 text&#x2F;ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text&#x2F;javascript 。实际上，服务器在传送 JavaScript 文件时使用的<br>MIME 类型通常是 application&#x2F;x–javascript ，但在 type 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：<br>application&#x2F;javascript 和 application&#x2F;ecmascript 。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是<br>text&#x2F;javascript 。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text&#x2F;javascript 。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="内联形式"><a href="#内联形式" class="headerlink" title="内联形式"></a>内联形式</h4><p>这种方式指的是在 <code>html </code>文件中，添加一个<code>&lt;script&gt;&lt;/scritp&gt;</code>标签，然后将 <code>JavaScript</code>代码直接写在里面，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内联 JavaScript&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外置形式"><a href="#外置形式" class="headerlink" title="外置形式"></a>外置形式</h4><p>外置形式是将 <code>JavaScript</code> 代码写在外部的一个文件里面，在 <code>html</code> 文件中通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性引入,如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两种引入形式的比较"><a href="#两种引入形式的比较" class="headerlink" title="两种引入形式的比较"></a>两种引入形式的比较</h4><p>对于这两种方式，毫无疑问，外置形式明显好于内联形式，主要表现为以下方面:</p><ul><li><strong>可维护性</strong>：外置 Javascript 文件可以被多个页面调用而不用在每个页面上反复地书写.如果有需要改变的部分,你只需要在一处修改即可.所以外置JavaScript 导致代码工作量减少,进而使得维护手续也更加方便。</li><li><strong>可缓存</strong>：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li><li><strong>关注点分离</strong>：将 JavaScript 封装在外部的.js文件遵循了关注点分离的法则.总体来说,分离 HTML,CSS 和 JavaScript 从而让我们更容易操纵他们.而且如果是多名开发者同步工作的话,这样也更方便。</li></ul><p>因此，在今后的开发中尽量使用外置方式的形式引入<code>JavaScript</code>。</p><h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><p>如果要谈<code>&lt;script&gt;</code> 标签加载顺序问题，首先要谈的就是标签的位置。</p><p>标签的位置对于<code>JavaScript</code>加载顺序来说有着很重要的影响。</p><p>很早之前，有个经典面试题，<code>&lt;script&gt;</code> 标签放在html头部和尾部，是否有区别？会不会有不同执行结果？</p><p>显然，是有区别的。</p><h4 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h4><p>标签的位置有两种，一种是方式<code>&lt;head&gt;</code>元素里面，另外一种就是放在<code>&lt;body&gt; </code>元素中页面内容的后面（就是页面内容结尾部分）。</p><h4 id="在-lt-head-gt-内"><a href="#在-lt-head-gt-内" class="headerlink" title="在&lt;head&gt;内"></a>在<code>&lt;head&gt;</code>内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一种比较传统的做法，目的就是把所有外部文件（包括 <code>CSS</code> 文件和 <code>JavaScript</code> 文件）的引用都放在相同的地方。</p><p>可是，在文档的<code>&lt;head&gt;</code>元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。</p><p>对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。</p><p>在早年前端体系不成熟的时候，有些开发者会喜欢把<code>&lt;script/&gt;</code>标签放在<code>&lt;head&gt;</code>标签中，造成页面白屏时间极长，显得极为卡顿。</p><p>很明显，这种做法有着很明显的缺点，特别是针对于现在的移动端来说，如果超过 1s 还没有内容呈现的话将是一种很差的用户体验。</p><p>为了避免这个问题，就有了下面这种加载方式。</p><h4 id="在-lt-body-gt-内"><a href="#在-lt-body-gt-内" class="headerlink" title="在&lt;body&gt; 内"></a>在<code>&lt;body&gt;</code> 内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种方式，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。</p><p>而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p><code>&lt;script&gt;</code>的每个属性设计来肯定都是有用的，下面我们就来说一说 defer 属性。</p><p>HTML 4.01 为 <code>&lt;script&gt;</code> 标签定义了 defer 属性。</p><p>这个属性的用途是表明脚本在执行时不会影响页面的构造。</p><p>也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</p><p>因此，在<code>&lt;script&gt;</code>元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/02.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/03.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，虽然我们把 <code>&lt;script&gt;</code> 元素放在了文档的 <code>&lt;head&gt;</code> 元素中，但其中包含的脚本将延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签后再执行。</p><p>HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 <code>DOMContentLoaded</code> 事件执行。</p><p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p><blockquote><p><strong>“在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。”</strong> </p><p>这段话是《JavaScript 高级程序设计（第三版）》中的一句话，纠结了很久。自己也尝试写了一些例子，但反馈的结果都是：如果引入的 <code>&lt;script&gt;</code>标签 都使用了 <code>defer</code> 属性，他们的执行顺序都是按照他们引入的顺序来的。</p><p>那么作者为什么会写上这一句话呢，个人感觉原因是：即使在 <code>HTML5</code> 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，但支持 <code>defer</code> 属性，那么就会出现作者所描述的那种情况，所以为了安全起见，在开发中使用一个 <code>defer</code> 是非常有必要的。</p></blockquote><blockquote><p>还有一点需要注意的是，defer 属性只适用于外部脚本文件。</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>意味着函数或代码块会被异步执行。</p><p>当浏览器遇到带有 <code>async</code> 属性的资源时，它会立即开始下载该资源，同时继续加载页面。</p><p>这样可以避免由于同步执行而导致的页面加载阻塞问题。</p><p>然而，由于 <code>async</code> 并不保证具体的执行时间，所以如果在 <code>async</code> 代码中修改了 DOM（文档对象模型），可能会出现错误，特别是在依赖外部资源的场景下。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p><code>defer</code> 则是一种用于推迟执行的特性，这个属性在一些页面模板中会常见，在很多项目工程化的内容中，不常见。</p><p>它允许将脚本放置到页面的最后部分，直到其他所有资源都已加载完毕。</p><p>这样确保了在执行 <code>defer</code> 代码之前，页面已经完全准备好，从而减少了潜在的错误风险。</p><p>特别是对于那些依赖于外部资源的第三方脚本来说，使用 <code>defer</code> 可以提高应用的稳定性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>async</code> 更适合于不需要等待页面完整加载即可运行的第三方脚本，因为它提供了更高的灵活性，但可能伴随着一定的执行时机的不确定性。</p><p> <code>defer</code> 则是为了确保页面加载完成后才执行脚本，减少因页面未加载完全而引发的错误。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里算是直接搬运了其他的内容，稍微学习了一下，这是旁枝末节的内容，如果不是面试，我确实不怎么会看。</p><p><code>async</code>与<code>defer</code>的使用，算是旧时代的余声了，如有需要，按需自取。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000013615988">谈谈  标签以及其加载顺序问题，包含 defer &amp; async</a></p><p><a href="https://www.cnblogs.com/ltwlh/p/18003735">async与defer的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;defer与async不怎么常用，而且这个涉及到&lt;code&gt;&amp;lt;scrpit/&amp;gt;&lt;/code&gt;的基础使用方式，都是一些远古常识题，&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>如何准备非大厂面试</title>
    <link href="https://crazystudent13.github.io/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/"/>
    <id>https://crazystudent13.github.io/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/</id>
    <published>2024-08-02T17:41:53.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>个人没有经历大厂的面试，毕竟个人学历不够，且项目经历，技术可能都不太不符合大厂的要求。</p><p>而且，我的年龄已经打了，按照目前的经历，技术还有就业大环境来看，我这辈子估计也无缘大厂了。</p><p>不过，人总是要生活的，进不了大公司，我们也尽可能的要在中小公司拿到高一些的工资。</p><p>毕竟，没有什么东西比金钱更令人安心了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从2024年4月，一直在面试，不断刷面试题，从4月到同年8月，期间，我不间断的整理自己的项目经历，技术体系，面试常考面试题等。</p><p>通过大量的面试经历，我大概整理出中小公司常规的面试流程。</p><p>这里将自己的大量面试经历流程进行整合，以供大家参考，大家按照自己的需求酌情准备面试吧。</p><h3 id="线上交谈"><a href="#线上交谈" class="headerlink" title="线上交谈"></a>线上交谈</h3><p>大多社招，首先是和HR线上交谈，这期间主要是让HR大概了解你的概况，同时你也要了解日常作息待遇，五险一金和薪资等。</p><p>我们线上交谈的流程，无外乎就两种结果：</p><ul><li>HR主动搭话，不断的追问你的意向，主动了解你的居住地和工作经历，同时可能也会看你的。</li><li>HR迟迟不回话，或者说话有一搭没一搭，大概是这家公司的暂时不缺人，又或者对方没有看上你。</li></ul><p>如果是第一种情况，我们尽可能的按照实话将自己有利的一面展示出来就可以了，哪怕对方是外包，需要你展示自己的学信网截图，就正常发就可以。</p><p>如果对方没有看上，也没什么可急的，确认好之后，换下一家就可以。</p><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>技术老大对你的印象与能力的认可，直接决定你是否能拿到offer,所以在技术老大面前多聊技术，别谈工作时间薪资待遇那些，那是人事面的流程。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>很多时候我们自我介绍的时候，总是简单的说一下个人信息就结束了。</p><p>实际上，这时候我们最好可以将自己的长处，技术栈，个人优势在开场这个时间都说一下，便于双方交换信息，省的面试官后续再问。</p><p>这是一种高效的沟通方式，不要问一句说一句，这样会让双方都很尴尬。</p><h5 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h5><p>包括你的姓名、籍贯、年龄、专业、毕业学校（这里如果哪一项是弱势，介绍的时候可以略过）</p><ol><li>技术能力，简单介绍自己的技术栈，告诉对方你会什么?并且最擅长的技术是什么?这可以让面试官对你的技术体系大概有个数，便于后续双方互动。所以，可以针对对方公司招聘岗位的岗位职责去重点突出自己的能力。</li><li>职业经验，说清楚自己往期的工作经验，待过哪些公司，具体做过什么，如果是应届毕业生，有实习经验说实习经验，没有的话也可以重点说自己在学校内接触过的项目经验。</li><li>当前状况，居住地，是否离职，这样便于面试官判断你是什么时候可以入职。</li><li>自我评价，个人评价这点比较鸡肋，如果技术和项目经历可以说的不多，那可以用这项进行补充。如果要说，记得主要说优势，别说缺陷，因为你是在推销自己。从沟通能力、学习能力、逻辑性等方面吹自己的优势，不过不要吹的太离谱。</li></ol><p>以我个人为例，这里我以个人为例，简单的写个模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫远川，江苏**人，XX年的，有五年左右的前端开发经验，之前都在XX公司任职。</span><br><span class="line">我的技术栈主要是Vue2/3的全家桶，对源码略有了解，也做过Uni-app相关，主要以微信小程序为主。</span><br><span class="line">之前在公司早期负责公司产品开发，封装通用的业务组件，通用的工具类方法，如PC和小程序的动态表单，动态表格，包括一些需要远程查询的数据字典选项。</span><br><span class="line">后续公司产品化之后，主导低代码平台开发，实现低代码流程+流程表单生成的流程，可以同步生成小程序和PC端的单表，后续拓展了主子表的生成，通过该平台极大程度缩减了代码的人力和时间。</span><br><span class="line">目前已离职，人在苏州。</span><br></pre></td></tr></table></figure><p><strong>当你做完自我介绍后，面试官正式开始提问，做好准备!</strong></p><h4 id="项目方面"><a href="#项目方面" class="headerlink" title="项目方面"></a>项目方面</h4><p>在进入项目问题这个阶段，大概是你已经通过了面试官的八股文的阶段。</p><p>毕竟，八股文都是为了试试基础水平而提问的，只要大概试一下，面试官大概就能猜出来你的水平。</p><p>大多数有经验的面试官，在面完八股文之后，如果看到你项目履历足够的丰富之后，肯定是会问一下相关的解决方案，确认你的经历是否真实。</p><p>另外，不要去想着伪装经历，项目经历这种东西是实打实的，简单的几个问题和稍微深入，都能让你没法回应。</p><p>如果面试官开始问你项目，这个问题很重要，建议从以下角度介绍。</p><ol><li><p>项目背景，让对方知道这个项目是做什么的</p></li><li><p>你在项目中的角色，在项目中，你负责了哪些工作?</p></li><li><p>项目难点与解决方案，能说出来，说明你善于总结，同时也有自己的一套解决方案。</p></li><li><p>项目成果，你负责的部分，你的解决方案有什么亮点，主要解决了什么方案。</p></li></ol><p>这里我就不放例子了，每个人可以按照在自己的项目经历，展开写一份面试备案。</p><h4 id="反问阶段"><a href="#反问阶段" class="headerlink" title="反问阶段"></a>反问阶段</h4><p>在八股文和项目经历大概都说明白了之后，面试官大概率会问问你有什么想想问的。</p><p>不要觉得没什么想问的，这是你了解这个团队和未来工作的唯一渠道，你可以从以下角度去反问面试官。</p><ol><li>主营业务，公司的主营业务是什么？是稳定期还是开荒期？你们招我来主要的方向是想做什么？</li><li>团队配置，公司是否有测试，设计，前后端团队，整体开发基建到了什么水准？后续团队的基建方向如何？</li><li>开发流程，平时如何实现一个新需求的开发？平时是否需要做需求评审？</li></ol><p>如果面试你的技术leader层级较高，你也可以侧面确认一下公司的待遇，五险一金，公积金缴费比例，平日加班是否频繁。</p><p>通过这方面的反问，大概率可以确认一个公司的工作内容，团队水平，平日待遇等。</p><p>这些内容，足够用来判断这份工作是否合适自己，以哪方面为准，这个可以按照自己的需求来判断。</p><h3 id="HR二面"><a href="#HR二面" class="headerlink" title="HR二面"></a>HR二面</h3><p>许多公司的面试环节，可能是HR先面，而后是技术组长，之后是技术leader再面试。</p><p>如果技术面结束之后，又是HR二面要你，那就要恭喜了，说明你很大程度是进入了HR定薪阶段。</p><p>HR面试，往往是对你的综合素质进行评判，通常会有以下提问:</p><p><strong>您对自己的未来职业规划是什么?</strong></p><ol><li>想做技术大佬：主要从两个方面出发，一个实近期规划(比如深入的学习前端面向对象)</li><li>想做项目leader：还有一-个是长远规划(未来5年都在前端技术方向，如何可以转产品或者管理等)</li></ol><p><strong>您的期望薪资是多少?</strong></p><p>答:这个可以根据当前岗位给定的范围，选择自己心仪的价格+1k左右。</p><p><strong>您当前的住址在哪？</strong></p><p>这个实际上是希望你离公司很近，便于上下班。</p><p>如果你住的特别远，你也可以表示自己很快就可以搬过来。</p><p><strong>你还有其他公司offer吗?什么时候可以入职?</strong></p><p>HR这样问是想知道能不能百分百拿下你，回答这个问题的尺度一定要把握好:</p><ol><li><p>不能吹嘘，说自己已经有很多offer，否则给HR造成你入职可能性不大的错觉。</p></li><li><p>也不要说一个也没有。更不要表现出对这家公司“迫切入职”，要学会欲擒故纵。</p></li></ol><p>不过，这种套路稍微用用用就可以，实际上没必要玩这种小把戏。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我本来是懒得去整理这些内容，但是早期面试总觉得自己准备的不够充分，明明自己的技术不差，但是就是表达的不够完美。</p><p>现在大环境太烂，我手牌太少，不得不精打细算，于此，便有整理了这篇文档。</p><p>夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也。多算胜，少算不胜，而况于无算乎！——《孙子兵法》</p><p>不打无准备之仗，不打无把握之仗，目前，也只能准备好每一次面试了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7163849862599933983">web前端面试技巧-如何自我介绍？如何应对hr？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人没有经历大厂的面试，毕竟个人学历不够，且项目经历，技术可能都不太不符合大厂的要求。&lt;/p&gt;
&lt;p&gt;而且，我的年龄已经打了，按照目前的经历，技术还有就业大环境来看，我这辈子估计也无缘大厂了。&lt;/p&gt;
&lt;p&gt;不过，人总是要生活的，进不了大公司，我们也尽可能的要在中小公司拿到高一些的工资。&lt;/p&gt;
&lt;p&gt;毕竟，没有什么东西比金钱更令人安心了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解前端的图片格式</title>
    <link href="https://crazystudent13.github.io/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    <id>https://crazystudent13.github.io/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-07-21T10:00:10.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客转载：<a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a>。</p><p>关于图片，算是前端性能优化的一个核心，所以这里就不自己整理，而是尽可能的采用其他大佬整理好的标准答案了。</p><p>文中的内容我根据自己的经验确认了一下，基本没什么问题，可以放心食用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>前端开发中经常和图片打交道，那么熟悉各种图片格式的应用场景以及优劣势对于我们尤为重要。</p><p>基础的那些老古董问题让人心生烦躁，相比那些问题，图片这个问题虽然基础且老旧，但是在前端开发中确实频繁出现。</p><p>时至今日，在性能优化这里，图片的压缩依旧是一个避不开的问题。</p><p>关于网页中对图片的性能优化，后续会单独出一张内容，本次只是简单整理这些图片的格式，做个基础的了解。</p><h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul><li><strong>无损压缩</strong>：对文件的数据存储方式进行优化，采用某种算法表示重复的数据信息，能在保证图片的质量的同时降低图片的尺寸，png是其中的代表，但尺寸相比原图减少不多。<code>可以还原</code></li><li><strong>有损压缩</strong>：在压缩的时候，去除了人眼无法识别的图片细节，图片质量会下降，图片尺寸能得到很大程度的压缩。<code>不可还原</code></li><li><strong>无压缩</strong>：不会对图片进行任何压缩处理，能够精准的呈现原图片，例如：BMP。开发中我们考虑到加载性能问题，几乎不会考虑这种图片</li></ul><h3 id="GIF图"><a href="#GIF图" class="headerlink" title="GIF图"></a>GIF图</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>Gif图采用<code>LZW</code>压缩算法进行编码，采用<code>无损压缩</code>，这意味着图片在压缩后<code>质量不会受损</code>。</li><li>Gif图1987年提出的，距今发展了几十年了，<code>兼容性好</code>。</li><li><code>支持透明度</code>，GIF允许图像中的像素具有不透明和透明属性，这使得它在创建带有透明背景的图像时非常有用。</li><li><code>支持动画</code>，GIF支持简单的动画，可以用来创建循环播放的短动画，这在网页设计和用户界面方面非常有用。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>只能存储8位颜色索引，<code>色彩复杂、细节丰富的图片不适合</code>。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>适合简单的动画或者图标，例如：Logo、Icon、动图。</li><li>上报埋点时采用1 * 1像素的透明Gif图。<ul><li><code>避免跨域</code>，用图片上报而不是采用fetch或ajax去上报，用Image的src不会存在跨域行为并且也会触发请求</li><li><code>兼容性好</code>，所有浏览器都支持Image对象，即便浏览器不支持XMLHttpRequest(例如古董级的IE)，也能进行上报。相比与<code>navigator.sendBeacon</code>兼容性更好。</li><li><code>体积最小</code>，1*1的透明PNG是67字节，而Gif只需要43个字节。同样的性能比PNG图片减少35%的流量。</li><li><code>支持透明</code>，用Gif上报埋点最好是透明的，一是避免影响页面展示，而是可以不用存储颜色索引，减少图片大小。</li><li><code>避免请求取消</code>，ajax请求过程中离开页面会导致请求中断，最终导致上报失败。然而Image的src不会中断。</li></ul></li></ul><h3 id="PNG图"><a href="#PNG图" class="headerlink" title="PNG图"></a>PNG图</h3><p>PNG默认是PNG-24格式</p><h4 id="png-8"><a href="#png-8" class="headerlink" title="png-8"></a>png-8</h4><ul><li>png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。</li><li>非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。</li><li>这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。</li></ul><h4 id="png-24、png-32"><a href="#png-24、png-32" class="headerlink" title="png-24、png-32"></a>png-24、png-32</h4><ul><li>图片质量和bmp差不多，在尺寸是比bmp更小。</li><li>尺寸上比JPG、GIF更大，当然质量更高。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><code>支持透明度</code>：PNG支持透明通道，允许创建带有透明背景的图像。</li><li><code>无损压缩</code>：可以保持图片质量不损失细节。</li><li><code>广泛支持</code>：PNG是一种通用格式，计算机或移动设备都支持。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>复杂、色彩丰富图片尺寸大</li><li>不支持动画</li></ul><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><ul><li>适合图形设计，可以保存文本、线条图案等高质量、透明图像。</li><li>相机设备，适合后期对图片进行处理。</li></ul><h3 id="JPG图"><a href="#JPG图" class="headerlink" title="JPG图"></a>JPG图</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><code>有损压缩</code>:JPG格式具备出色的压缩性能，可以显著的减少图像文件的大小。这使得它在Web上显示一些质量要求不高的图像非常有用，减少加载时间</li><li><code>广泛支持</code>：是一种通用格式，在计算机以及手机设备上都广泛支持。</li><li><code>色彩丰富</code>：JPG支持24位颜色深度，因此可以显示百万种颜色。</li><li><code>可调质量</code>：用户可根据使用场景来调图片质量，较高的图片质量，会导致图片尺寸较大。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>不支持透明</code>：不能够创建带有透明背景的图像，PNG或GIF更适合这种情况。</li><li><code>损失性压缩</code>：JPG是有损压缩，而且一旦压缩无法还原，会丢失一些细节。</li><li><code>不适合带有文本或线条的图片</code>： JPG压缩在处理文本和线条方面不如其他格式好，可能会导致图像出现锯齿或模糊情况。</li><li><code>不适合Icon或者Logo</code>：相对于PNG或GIF图，在尺寸上没有优势</li></ul><h3 id="WEBP图"><a href="#WEBP图" class="headerlink" title="WEBP图"></a>WEBP图</h3><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>关于兼容性查询，想必大家或多或少都看过，这里我就不像他们那样放图浪费资源了。</p><p>想要查询图片的兼容性问题，直接访问：  <a href="https://link.zhihu.com/?target=https://caniuse.com/">Caniuse.com</a>，或者直接点击：<a href="https://caniuse.com/?search=webp">“webp” | Can I use… Support tables for HTML5, CSS3, etc</a>。</p><p>总之，IE11依然不支持Webp，需要额外引入一些JS工具来进行解决，如果你的项目需要兼容IE11，那么就要注意这个问题了。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当Web要求图片加载速度和图片显示质量时，可以适当的降低下图片质量减少图片尺寸来满足场景。</li><li>是用于要求<code>色彩丰富</code>的场景。</li></ul><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>WebP（Web Picture）是一种现代的图像格式，由Google开发，旨在提供高质量的图像压缩和更快的加载速度。WebP<code>支持有损和无损压缩</code>，以及<code>透明度</code>，是一种<code>灵活的图像格式</code>，适用于Web和移动应用程序。</p><p>对于前端来说，该图片格式常用于一种<code>优化网页加载速度</code>的手段之一。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><code>高压缩率</code>：WebP 图像通常具有更小的文件大小，相对于传统格式如JPEG和PNG，可以减少带宽使用和加速页面加载速度</li><li><code>高质量</code>：即使在较高的压缩率下，WebP 图像通常能够保持较高的图像质量，减少了压缩损失。</li><li><code>透明度</code>：WebP支持透明通道，可以用于创建带有透明背景的图像，类似于PNG格式。</li><li><code>动画</code>：WebP还支持动画图像，允许创建小型、高质量的动画。</li><li><code>广泛支持</code>：大多数浏览器都已经支持，但是目前低版本的Safri以及IE还不支持。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>兼容性</code>：考虑到目前还不能完全放弃IE以及旧版本Safri，所以还不能完全切到该图片格式。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>WebP 格式适用于网页开发，特别是那些需要快速加载的网站和移动应用程序。</li><li>它适合用于图像库、图标、按钮、背景图像、动画以及需要高质量和小文件大小的图像。</li><li>WebP 的无损压缩特性使它适用于医学图像、卫星图像、地图和其他需要高质量和完整性的图像应用。</li></ul><h4 id="开发兼容"><a href="#开发兼容" class="headerlink" title="开发兼容"></a>开发兼容</h4><p>考虑到Webp格式还存在兼容性问题，开发中如何应用Webp图片格式？</p><ul><li>如果图片资源存储在服务端，可以设计一套通用方案，在<strong>服务端根据Accept请求头判断是否支持Webp格式，如果支持返回Webp格式，否则返回PNG格式</strong>。</li><li>如果你无法说服后端去实现上述方案还想采用Webp图片优化页面加载，可以考虑维护两个格式的图片，然后使用<strong>picture标签</strong>去实现</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> srcset=<span class="string">&quot;flower.webp&quot;</span>&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> srcset=<span class="string">&quot;flower.jpg&quot;</span>&gt;</span><br><span class="line">  &lt;img <span class="attr">src</span>=<span class="string">&quot;flower.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>整理图片格式这个面试题相对来说我倒不是那么抗拒，这个问题虽然基础但是在开发中，如果专注性能优化的朋友可能会很熟悉。</p><p>早年我在优化小程序的时候，曾经在处理图片问题上废了不少功夫，那时候对图片相关的知识了解了很多，但是不成体系。</p><p>如今花了些时间整理了一下，心理倒也颇为感慨。</p><p>只是时间不够，不然我大概率还会整理一下矢量图和像素图的区别，还有一些性能优化的点。</p><p>后续在整理性能优化的相关文章的时候，我会着重整理相关内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客转载：&lt;a href=&quot;https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5&quot;&gt;聊聊几种常见的图片格式Webp、GIF、PNG、JPG&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于图片，算是前端性能优化的一个核心，所以这里就不自己整理，而是尽可能的采用其他大佬整理好的标准答案了。&lt;/p&gt;
&lt;p&gt;文中的内容我根据自己的经验确认了一下，基本没什么问题，可以放心食用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解一些HTML的知识</title>
    <link href="https://crazystudent13.github.io/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://crazystudent13.github.io/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2024-07-19T04:49:45.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>从掘金的一篇文章中摘下来的部分问题，这种级别的面试题，问问三年前的新人还好，问现在的新人多少有点过时了。</p><p>而问我这种前端老登，如果不是为了找工作，放在以前我真会喷他。</p><p>这里没什么好说的，谁叫现在是为了找工作呢，统一整理出来看看吧，我实在想不懂问这些阴间问题的到底是哪些面试官想出来的，这些面试题显得你很会搜集面试题吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇基本上都是HTML5的冷门问题，HTML的知识，真的。。。我都麻了，在掘金上刷到还有面试官来问这种问题？</p><p>呵呵，放在两年前，问这种问题只会让我感觉到这个面试官水平不行。</p><p>这些问题中不乏一些偏到犄角旮旯的垃圾问题，有些甚至是我这个前端老登都感觉真他妈离谱，真想把一些问题拍在面试官的脸上。</p><p>你这些狗日的问题，你要不查文档，你自己能答的出来吗？你到底是从哪个题库中扒出来的？你弄这些东西到底对你自己的项目有什么促进作用？这些基础问题，要是你自己不花点时间准备，你到底能回答出来多少？</p><p>这些问题对业务上的促进作用是什么？你问这些问题你要不给个为什么，我真他吗的。。。。算了，人在屋檐下。</p><p>罢了，就当是听孔乙己说茴香豆的四种写法了，真你妈的离谱。</p><h3 id="DOCUTYPE作用"><a href="#DOCUTYPE作用" class="headerlink" title="DOCUTYPE作用"></a>DOCUTYPE作用</h3><p>DOCTYPE（‌文档类型声明）‌是HTML文档中的一个重要组成部分，‌它位于HTML文档的第一行，‌位于<code>&lt;html&gt;</code>标签之前。‌</p><p>这个声明用于指定当前文档所采用的HTML版本。‌</p><p>DOCTYPE不是HTML标签，‌而是一个指令，‌告诉浏览器当前页面采用了哪个HTML版本，‌以便浏览器按照相应版本的规范来解析和渲染页面。‌</p><p><code>&lt;!DOCTYPE html&gt;</code>声明的主要作用是规范浏览器行为，‌确保HTML文档的正确解析和渲染。</p><p>这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat。</p><ul><li>document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面、（默认）。</li><li>document.compatMode： CSS1Compat：标准模式、浏览器使用W3C标准解析渲染页面。</li></ul><p>如果你的页面添加了<code>&lt;!DOCTYPE html&gt;</code>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。</p><p>这就是<code>&lt;!DOCTYPE html&gt;</code>的作用。</p><p>如果你不加，浏览器如果按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式、很可能出现兼容问题。</p><p>这个问题基本上是最初那一代的前端开发者才会知道的问题，因为最初浏览器还没有定下W3C标准，各家浏览器都按照自家的标准做事，所以那时候才有了那么多恶心的兼容问题。</p><p>在W3C标准出现之前，彼时不同浏览器的内核是不统一，割裂极度严重，IE浏览器，火狐，还有谷歌，三家浏览器各搞各的，直到后续各家浏览器出来统一制定了W3C规则之后，统一进行页面的解析。</p><p>当然，在那之后，IE浏览器依旧不老实，还是坚持要搞自己的一些小动作，所以在18年~22年左右，依然有很多政府项目要求兼容IE。</p><p>不过随着时代的发展，这种项目估计除了银行之类的ToG的政府项目才会关心，实际上都不在关注这种问题了，毕竟现在都在使用W3C标准，而坚持自己个性标准的IE浏览器，在IE11之后就进了历史垃圾堆。</p><p>在这之后，微软也宣布推出了Edge，摆脱了原有的历史包袱，使用W3C标准。</p><p>所以，到现在<code>&lt;!DOCTYPE html&gt;</code>成了前端标准的兼容行为，这个操作太过基石，以至于没什么人会去关注。</p><p>这里稍微总结一下<code>&lt;!DOCTYPE html&gt;</code>的作用</p><ul><li><strong>规范浏览器行为</strong>：‌通过指定正确的DOCTYPE，‌可以确保浏览器按照相应版本的HTML规范来解析和渲染页面，‌从而避免出现兼容性问题。‌</li><li><strong>避免混杂模式</strong>：‌早期的HTML标准中，‌如果没有提供DOCTYPE声明或者提供了错误的声明，‌浏览器会进入混杂模式（‌Quirks Mode）‌，‌这可能导致页面显示不一致或出现兼容性问题。‌通过明确指定正确的DOCTYPE，‌可以避免进入混杂模式。‌</li><li><strong>支持新特性</strong>：‌随着HTML标准的不断更新和演进，‌新版本中引入了许多新特性和语法规则。‌使用适当的DOCTYPE声明，‌可以告诉浏览器当前页面采用了哪个HTML版本，‌并使其能够理解并支持该版本中新增加的功能和语法。‌</li><li><strong>提示验证工具</strong>：‌DOCTYPE声明还对验证工具起到提示作用。‌验证工具（‌如W3C的HTML验证器）‌可以根据DOCTYPE声明来判断文档是否符合相应版本的HTML规范，‌从而帮助开发者发现和修复代码中的错误。‌</li></ul><h3 id="META的作用"><a href="#META的作用" class="headerlink" title="META的作用"></a>META的作用</h3><p>这里放一段W3C的示例，结合实例稍微说一下作用，实际开发过程中，最多可能常用到控制缩放。</p><p>至于常规keywords，description，基本上都是SEO常用到的配置，而后台管理类项目，平常基本上没人在乎这个的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;免费的 Web 教程&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, JavaScript&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Bill Gates&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>meta 元素可以使用名&#x2F;值对定义元数据，为此需要用到其 name 和 content 属性。</p><table><thead><tr><th>name</th><th>content</th><th>描述</th></tr></thead><tbody><tr><td>charset</td><td>UTF-8</td><td>声明当前页面使用的字符集</td></tr><tr><td>keywords</td><td>HTML, CSS, JavaScript</td><td>搜索引擎关键字</td></tr><tr><td>description</td><td>Free Web tutorials for HTML and CSS</td><td>网页描述</td></tr><tr><td>author</td><td>John Doe</td><td>页面作者</td></tr><tr><td>viewport</td><td>width&#x3D;device-width, initial-scale&#x3D;1.0</td><td>控制设备上缩放效果</td></tr><tr><td>http-equiv&#x3D;”refresh”</td><td>30</td><td>每 30 秒刷新一次文档</td></tr></tbody></table><p>这里大概列举了一下，至于详情，这里就不列举了。</p><p>详情这里实在不想细说，有兴趣可以自行去看<a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a>。</p><h3 id="HTML5语义化"><a href="#HTML5语义化" class="headerlink" title="HTML5语义化"></a>HTML5语义化</h3><blockquote><p>语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。</p><p>不仅对自己来说，容易阅读，书写。</p><p>别人，甚至是网络爬虫机器看你的代码和结构也容易理解。</p></blockquote><p><strong>语义化简单讲就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</strong></p><p>在解释这个概念之前，应该先解释下“结构-表现-行为”。</p><p>如果说解耦合是代码的高境界，那么“结构-表现-行为”的原则就是前台的标杆。</p><p>前端代码是有HTML + CSS + JS来实现的。他们对应的就是负责“结构-表现-行为”。</p><p>不过，现在兴起的前端技术大多要求是用来处理后台，这时候把很多以前的PC应用搬到了浏览器上。</p><p>而应用就不怎么在乎浏览器器的语义化了，秉承着能用就行的原则，大多数后台应用类的网站的语义化要求被淡化，大多数都是div一把梭。</p><p>除了页面SEO，或者是静态新闻网站之外，大多数网页开发都不再在乎应用，感兴趣的可以看看这篇博客园的博客：<a href="https://www.cnblogs.com/iamspecialone/p/11178486.html">Html的语义化</a>。</p><h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p>2024年了，还是那些个新特性，这些东西没有什么可聊的，从H5标准出来到现在，作为浏览器的基石，这些规则基本都没有什么改变。</p><p>后续会稍微整理这些新特性的详情玩法，每个特性都很基础，但是深挖之后，都是深坑，我们这里就简单的了解一下概念，应对面试就可以。</p><ol><li>语义化标签，（hrader、footer等），使得页面的内容结构化，见名知义</li><li>增强型表单，拥有多个新的表单input输入类型，可提供更好的输入控制和验证</li><li>video和audio元素，提供了播放视频和音频文件的标准方法</li><li>canvas绘图， 画布功能，通过 JavaScript 来绘制 2D 图形。</li><li>svg绘图，SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>地理定位，Geolocation（地理定位）用于定位用户的位置</li><li>拖放API，在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放</li><li>web worker，web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。</li><li>web storage，使用HTML5可以在本地存储用户的浏览数据，cookie，local storage，sessionStorage。</li><li>WebSocket，WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</li></ol><p>以上十个新特性在现代开发中衍生出了很多内容，譬如websocket的聊天室，基于canvas画布实现的流程图和很多酷炫的图表。</p><p>哪怕是最基础的语义化形成的SEO，还有表单的提交增强，都是很强力的增强，这里后续我们会基于每个特性进行深入的了解。</p><h3 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h3><p>二者的区别，这里要从请求资源类型，解析方式，权重角度来分析。</p><h4 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h4><h5 id="href（Hypertext-Reference）"><a href="#href（Hypertext-Reference）" class="headerlink" title="href（Hypertext Reference）"></a>href（Hypertext Reference）</h5><p>作用指定超链接目标的URL，主要用来建立当前元素和href引用元素的链接关系。</p><p>href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。</p><p>常用link，a标签。</p><h5 id="Src（Source）"><a href="#Src（Source）" class="headerlink" title="Src（Source）"></a>Src（Source）</h5><p>作用是指向物件的来源地址，主要指向需下载的资源。</p><p>src将其指向的资源下载并应用到当前document中，并且替换当前元素。</p><p>常用标签script，img，iframe等。</p><h4 id="浏览器解析方式和权重的不同"><a href="#浏览器解析方式和权重的不同" class="headerlink" title="浏览器解析方式和权重的不同"></a>浏览器解析方式和权重的不同</h4><p>用 href时，加载到对应位置的时，不会暂停其他资源的下载或行为。</p><ul><li>权重思想： href链接的的是当前页面的一部分附属资源。</li><li>注意点：所以CSS样式可以放在html结构的头部优先加载（因为不影响页面的核心加载，只是HTML标签的对应样式表）</li></ul><p>用src时候，会暂停其他资源的下载，直到当前资源加载，编译，执行完成了，并且把当前资源替换到src引用处了。</p><ul><li>权重思想： src加载的是当前页面的一部分。</li><li>注意点：这就是为何js脚本一般回放到document底部加载而不是头部。</li></ul><h3 id="BFC-及其应用"><a href="#BFC-及其应用" class="headerlink" title="BFC 及其应用"></a><strong>BFC 及其应用</strong></h3><p>说了半天，这个算是一个比较正常的面试题，值得重点看看。</p><p>BFC(Blcok formatting context) 直译为“块级格式化上下文”。</p><p>他是一个独立的渲染区域，只有块级元素参与，它规定了内部块级元素的布局，并且与这个区域外部毫不相关，外部元素也不会影响这个渲染区域的元素。</p><blockquote><p>简单说：BFC 就是页面上的一个隔离的独立渲染区域，区域里边的子元素不会影响到外面的元素。外边的元素也不会影响到区域里面的子元素。</p></blockquote><p>以下是一些常见的创建 BFC 的方法：</p><ol><li>浮动元素：将一个元素设置为浮动（<code>float: left</code> 或 <code>float: right</code>）会创建一个 BFC。</li><li>绝对定位元素：将一个元素设置为绝对定位（<code>position: absolute</code>）会创建一个 BFC。</li><li>固定定位元素：将一个元素设置为固定定位（<code>position: fixed</code>）会创建一个 BFC。</li><li>具有 <code>overflow</code> 属性的元素：将一个元素的 <code>overflow</code> 属性设置为非 <code>visible</code> 的值（例如 <code>overflow: hidden</code>、<code>overflow: auto</code> 或 <code>overflow: scroll</code>）会创建一个 BFC。</li><li>具有 <code>display</code> 属性为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code> 或 <code>flex</code> 的元素：这些元素会自动创建一个 BFC。</li><li>根元素（<code>html</code> 元素）：根元素始终是一个 BFC。</li></ol><p><strong>BFC 可以解决那些问题</strong></p><ol><li>避免垂直方向的<code>margin</code>合并。问题：垂直方向上的，两个元素<code>margin</code>相遇，两元素间的距离并不等于两个<code>margin</code>之和。而是等于最大的<code>margin</code>。小的<code>margin</code>会被大的<code>margin</code>吞并。</li><li>清除浮动元素的影响。问题：如果父元素包含一个浮动元素，那么其他元素可能会受到浮动元素的影响，导致布局混乱。但是给父元素变成BFC，浮动元素对其他元素的布局不再产生影响。</li><li>防止高度塌陷。问题：父元素不写高度时，子元素浮动后，导致父元素会发生高度塌陷（造成父元素高度为0）。但是将父元素变成BFC，就不会造成高度塌陷，最简单的方法是，给父元素设置<code>overflow: hidden</code>属性。</li><li>垂直布局。问题：父元素包含多个子元素，并且这些子元素的高度不同，那么在没有创建 BFC 的情况下，这些子元素可能会在垂直方向上重叠。但是将父元素变成BFC，子元素在垂直方向上就能正确排列。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>真的是。。。越整理越感觉离谱，我都感觉自己人生中浪费了数个小时在整理这些冷门问题到底在干嘛。</p><p>实话实说，这些老古董问题，在我眼里除了AI应该知道之外，正常的前端开发都不需要知道，最多就大概了解一下就行，哪怕是专门拿来问都有点显得掉架子，正经的老开发很难去了解这些问题。</p><p>我实在想不通为什么有很多傻逼面试官会问到这种老古董的冷僻问题，他自己平时难道用得到吗？难道这些人平时自己就能用得到？就是为了考察所谓的基础？这些基础到底有什么用？</p><p>我不说别的，DOCUTYPE的作用这个，在这些年里真的会有人遇到这方面的问题吗？兼容IE11? 除非是银行项目，到底是哪些人还他妈的固执的在用IE11?</p><p>很多政府项目都不在要求兼容IE11了，偏偏这些人还在要求，这是否有点太离谱了？</p><p>只能说，内卷化的极端时间里，现在找个工作太难，导致这种不知道从哪抠出来的冷僻问题居然成了热门的面试题，真他妈的傻逼。</p><p>除了外行和新手，我真的想不懂这些问题对开发的意义，哪怕多问问项目实现的难点我都不会对这些面试官有意见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7280007125999681588">我在公司是怎么做面试官的？</a></p><p><a href="https://www.cnblogs.com/tianmiaogongzuoshi/p/16341179.html">src和href的区别</a></p><p><a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从掘金的一篇文章中摘下来的部分问题，这种级别的面试题，问问三年前的新人还好，问现在的新人多少有点过时了。&lt;/p&gt;
&lt;p&gt;而问我这种前端老登，如果不是为了找工作，放在以前我真会喷他。&lt;/p&gt;
&lt;p&gt;这里没什么好说的，谁叫现在是为了找工作呢，统一整理出来看看吧，我实在想不懂问这些阴间问题的到底是哪些面试官想出来的，这些面试题显得你很会搜集面试题吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue3相对于vue2的变化</title>
    <link href="https://crazystudent13.github.io/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>https://crazystudent13.github.io/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/</id>
    <published>2024-07-18T04:39:05.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>vue3与vue2的区别算是较为火热的面试题之一了，之前早就想整理一遍了，但是奈何没有太多时间去关注。</p><p>在两者的深度上，我个人一直觉得自己了解的较少，了解的越深就越不敢说自己深入了解。</p><p>经过两个月左右的整理，我应该可以勉强说自己算是略懂了。</p><p>这里放上自己的拙见，我尽可能的确认了自己理解的准确性，不过我仍然感觉自己似乎做的不到位，这就当是抛砖引玉，希望大家在评论区多多拍砖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这段时间看了很多相关的文档，自己也翻了很多遍<a href="https://cn.vuejs.org/">vue3的官网文档</a>，同时自己也在项目中重新按照自己的经验重新用了一遍Vue3的新写法。</p><p>在一段时间的使用之后，个人认为，Vue3与Vue2的区别，要从使用者和开发者的角度来看。</p><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><p>使用者，就是我们平时写业务的这些普通开发者。</p><p>大多数情况下，使用者不负责源码开发，仅仅只要知道有个新特性，然后按照新特性使用就行了。</p><p>就像是伐木工学会了用A型号的电锯，这时候电锯做了个升级，加入了一些特性，而我们只要知道如何用好这些新特性。</p><p>相对于Vue2，我认为Vue3的新特性如下。</p><ul><li>取消了根元素，每个组件不必再必须嵌套一个根元素标签了</li><li>响应式用法的改变，用reactive和ref取代了之前的data声明的变量的方式</li><li>新增了组合式写法，相对于传统的选项式更灵活，可读性更高，这种写法也支持</li><li>父子组件传参方式发生了些许改变，不过用法大致和Vue2的思路没差，<strong>defineProps</strong>，<strong>defineEmits</strong>，<strong>defineExpose</strong>这三个稍微看看用法就能很快上手</li><li>生命周期的写法和名称有些许改变，新增了setup，但是大致流程没有变化</li><li>v-if和v-for的优先级调整，以v-if的优先级更高，如果二者要在同一标签内使用，将v-for放在外边，不然v-if会直接覆盖掉v-for的效果</li><li>修饰符发生了一些改变，取消了.native，不过总的来说没有太大变化</li></ul><p>总之，Vue3相对于Vue2，虽然很多人说是有些破坏式更新，写法发生了巨大的改变，这是一次失败的更新。</p><p>但从使用者的角度来讲，我个人认为，这次更新并不算是一次破坏式更新，至少大部分写法和习惯都是保留好了。</p><p>这里浅谈一下争论最大的选项式与组合式。</p><h4 id="选项式？"><a href="#选项式？" class="headerlink" title="选项式？"></a>选项式？</h4><p>选项式就是V2的写法，选项式上手简单，且不容易出岔子，有这个架子的保证，新手只要不是特别离谱，写出来的代码至少具有一定的可读性。</p><p>但这种写法在代码量上去的时候，可读性就会变得差。</p><p>主要原因就是变量和函数分开，每次翻阅代码的时候就要上下翻看，要么就要拆开面板去分开看，很麻烦。</p><p>而且，所有的变量都是在data中申明，全部指向了this。</p><p>指向this固然好用，但是随着后续模块的增多，这些this声明出来的变量会让人不知道这到底是哪个模块的内容，容易造成混乱。</p><p>而组合式确实解决了这个痛点。</p><h4 id="组合式？"><a href="#组合式？" class="headerlink" title="组合式？"></a>组合式？</h4><p>组合式写法其实就是回归了传统的script标签写法，声明了变量，然后做就完事了。</p><p>相对于V2的写法，V3的写法太过自由，可能很多人第一时间拿到手之后会有些不知所措。</p><p>不过经过几个项目铺垫之后，大概就能明白组合式的优势了。</p><p>组合式相对于选项式，可以更模块化的拆业务，更有逻辑的去切割页面上的逻辑块，之后去找变量的时候，不会再全部指到this了，这样让我们更清楚这些变量是负责哪个代码块的。</p><h4 id="hooks？minxin？"><a href="#hooks？minxin？" class="headerlink" title="hooks？minxin？"></a>hooks？minxin？</h4><p>随着代码量的增加，还可以将多个页面的重复业务块拆出来，放入hooks中供全局使用（Vue2中也有minxin），但是二者实际使用后，就能明白二者的不同。</p><ul><li>hooks像是以前抽离出来的公用方法，抽离的是逻辑，我们将一段公用的逻辑方法封入Hooks中，这里可以封入一定的业务逻辑</li><li>minxin更像是抽离出一部分公用模板，抽离的是模板，我们将一些写烦了的公用方法封入minxin中，省的每次都写。</li></ul><p>当然，我这个说法还是有点怪，实际开发中，这二者的用法硬要用的话，可混为一谈的。</p><p>不过，我个人依旧推荐大家用hooks去封装逻辑，不要用来封装模板。</p><h3 id="开发者"><a href="#开发者" class="headerlink" title="开发者"></a>开发者</h3><p>开发者，就是指Vue框架的源码开发者啦。</p><p>这个层级大家平时其实很少接触到，不过部分使用者在常规业务开发到极度深入的时候，肯定会去了解相关内容。</p><p>尽管我们不去开发，但是时间久了，肯定多少会要了解一些的。</p><p>相对于Vue2，Vue3在源码层面的特性变动如下</p><ul><li>整个框架用TS重写，对Vue3对TS有了更好的支持</li><li>重写了响应式的数据劫持方式，用proxy取代了vue2的Object.defineProperty()</li><li>重写了虚拟Dom的实现，编译模板优化，更高效的组件初始化效果</li><li>diff算法重写</li></ul><p>通过这些，开发者做到让Vue3具有了哪些优势呢？</p><h4 id="更快的渲染性能"><a href="#更快的渲染性能" class="headerlink" title="更快的渲染性能"></a>更快的渲染性能</h4><ul><li>Vue3 相比 Vue2 来说，Vue3 重写了虚拟 <code>Dom</code> 实现，编译模板的优化，更高效的组件初始化。</li></ul><h4 id="更小的体积"><a href="#更小的体积" class="headerlink" title="更小的体积"></a>更小的体积</h4><ul><li>Vue 3 的运行时核心相比 Vue 2 更小，这意味着更小的打包体积，减少了前端加载时间。</li><li>Tree-shaking 支持：Vue 3 代码更容易被 Tree-shaking 优化，因此可以更好地剔除不需要的代码。</li></ul><h4 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h4><ul><li>Vue 3 的代码库已经全面采用 TypeScript 重写，提供了更好的类型推断和类型提示。</li><li>提供了更多的内置类型声明，使得开发时更容易发现代码错误和调试。</li></ul><h4 id="更灵活的组合式-API"><a href="#更灵活的组合式-API" class="headerlink" title="更灵活的组合式 API"></a>更灵活的组合式 API</h4><ul><li>Vue 3 引入了组合式 API，使得组件的逻辑可以更好地组织和复用。</li><li>组合式 API 提供了更直观、更灵活的方式来组织组件代码，使得代码更易读、易维护。</li></ul><h4 id="更好的响应式系统"><a href="#更好的响应式系统" class="headerlink" title="更好的响应式系统"></a>更好的响应式系统</h4><ul><li>Vue 3 使用了 Proxy 来重写响应式系统，相比 Vue 2 的 Object.defineProperty，更加直观和强大。</li><li>在 Vue 3 中，可以在更深的层次上追踪响应式变量的变化，使得开发者能够更准确地监听数据变化。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>个人虽然是个vue老登了，但是确实也是菜鸡，所以我整理的这些内容实在是过于浅薄，让大家见笑了。</p><p>关于Vue2与Vue3的选择，我个人并不排斥任何一种选择，这需要我们根据实际情况来进行选择，很多老项目如果能不动，最好还是别动。</p><p>当然，从长远的角度来讲，我还是期望用Vue3的，毕竟Vue2已经停止了更新，而Vue3继承了2的特性，并且还在持续更新，显然Vue3更有潜力。</p><p>而且，社区内似乎有不少人开始追随Vue3的更新，长远的来看，显然是Vue3的社区会更壮大。</p><p>未来的前景，就是最值得追逐技术的理由之一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340676808436563987?searchId=20240718123318E0F013B86F459BBDBB95">vue3和vue2的区别，你知道多少 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7030992475271495711">vue3保姆级教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vue3与vue2的区别算是较为火热的面试题之一了，之前早就想整理一遍了，但是奈何没有太多时间去关注。&lt;/p&gt;
&lt;p&gt;在两者的深度上，我个人一直觉得自己了解的较少，了解的越深就越不敢说自己深入了解。&lt;/p&gt;
&lt;p&gt;经过两个月左右的整理，我应该可以勉强说自己算是略懂了。&lt;/p&gt;
&lt;p&gt;这里放上自己的拙见，我尽可能的确认了自己理解的准确性，不过我仍然感觉自己似乎做的不到位，这就当是抛砖引玉，希望大家在评论区多多拍砖。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue2与3的数据劫持区别</title>
    <link href="https://crazystudent13.github.io/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-14T08:52:52.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>两年前在vue3在社区兴起之时，很多社区弄潮儿就在分析2与3源码区别，那时候很多人都以为是个新时代会到来。</p><p>可是两年过去了，vue3的新时代依旧在缓慢迭代。</p><p>对于大部分业务流选手，大家都不关心源码，大家更期望Vue3的相对于Vue2在工程上的亮点在哪，到底能否更爽快的开发，更好更稳定的替换当前工程。</p><p>除非是面试，这种源码级的改动几乎是一个必然的面试题。</p><p>很不巧，我现在刚好需要处理面试，于是这里整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文默认使用者都用过Vue2和Vue3的，如果您没有看过Vue2的响应式原理，推荐您最好先去了解Vue2的响应式原理，因为本文会直接略过很多内容，如果不清楚相关知识，看起来可能体验会很差。</p><p>好了，接下来就开始对V2与V3的数据劫持进行区分。</p><p>在正式进入对二者区别的分析前，我们需要先简单了解一下，什么是数据劫持。</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>在没有进入MVVM框架的时代时候，我们要操作DOM中的数据，就需要自己手动封装一套方法，获取对应节点的DOM，然后修改。</p><p>因为这样很麻烦，才诞生了前端时代的MVVM的各种响应式实现方式。</p><p>这里不展开细说其他框架的响应式原理，单说Vue这块的响应式，在实现响应式的第一步，就是要进行数据劫持。</p><p><strong>数据劫持是Vue数据响应式的核心和基础，通过添加代理来给属性的变化添加额外的操作的方式</strong></p><h4 id="Vue2方式"><a href="#Vue2方式" class="headerlink" title="Vue2方式"></a>Vue2方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Obejct</span>.<span class="title function_">defineProperty</span>(obj,prop,descriptor)</span><br></pre></td></tr></table></figure><p>这个方法可以精确修改对象的属性，decriptor有四个参数，分别是</p><ul><li>configurable：数据是否可删除，可配置，</li><li>enumerable：属性是否可枚举，</li><li>get:一个给属性提供 getter 的方法，如果没有 getter 则为 undefined，</li><li>set:一个给属性提供 setter 的方法，如果没有 setter 则为 undefined object.defineProperty()通过getter&#x2F;setter属性对数据进行监听，getter监听访问数据，setter监听修改数据，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置值&#x27;</span>)</span><br><span class="line">        value = qqq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">o.<span class="property">a</span> = <span class="string">&#x27;sss&#x27;</span> </span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>)</span><br><span class="line"><span class="comment">// 获取值</span></span><br></pre></td></tr></table></figure><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li><p><strong>只有getter&#x2F;setter属性无法监听属性的修改删除</strong>，在Vue 2.x赋值对象时，需要对对象进行初始化，否则需要使用$Set()进行设置</p></li><li><p>无法监听组数的数据变化，数组的长度发生变化的时候无法监听，这也是为什么我们直接根据下标改动数组内容时候会失效，vue2通过处理数组扩展方法（push、pop、shift、unshift、splice、sort、reverse这7个方法），通过这些方法，我们依然是可以对数组进行响应式的数组操作的。</p><p>这个核心原因就是在于遍历数组消耗的性能太大，Vue2如果要做数组的响应式，按照原有的实现方式实在是买椟还珠了。针对这点，Vue2也给出来了一些解决方案，比如$Set()方法解决数组内的数据改变无响应的问题</p></li><li><p>无法拦截对象属性的多层嵌套。vue 2.x表现，watch对多层对象的监听中会失效，也需要$forceupdate()来更新视图。</p></li></ul><h4 id="Vue3方式"><a href="#Vue3方式" class="headerlink" title="Vue3方式"></a>Vue3方式</h4><p>为了解决上面的缺陷，Vue3使用了ES6的proxy方法，直接对源数据进行代理操作。</p><p>通过建立一个新的实例对象，才操作原有对象，并且提供13种监听操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target,thisArg,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">construct</span>(target,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,name,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(target,name,value,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target,name,desc)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(target, prototype)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&quot;获取数组元素&quot; + key);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置数组&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1. 改变已存在索引的数据</span></span><br><span class="line">obj[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment">// result: 设置数组</span></span><br><span class="line"><span class="comment">// 2. push,unshift添加数据</span></span><br><span class="line">obj.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// result: 设置数组 * 2 (索引和length属性都会触发setter)</span></span><br><span class="line"><span class="comment">// // 3. 直接通过索引添加数组</span></span><br><span class="line">obj[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment">// result: 设置数组 * 2</span></span><br><span class="line"><span class="comment">// // 4. 删除数组元素</span></span><br><span class="line">obj.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>显然Proxy完美的解决了数组的监听检测问题，针对数组添加数据，删除数据的不同方法，代理都能很好的拦截处理。</p><p>另外Proxy也很好的解决了深层次嵌套对象的问题。</p><p>这里我们综合整理一下<code>proxy</code>的优势</p><ol><li><strong>性能提升</strong>：Proxy API 比 defineProperty API 在许多情况下具有更好的性能。Vue2使用 Object.defineProperty 方法来拦截对象属性的访问和修改，但它需要遍历每个属性进行拦截。而 Proxy API 允许拦截整个对象，可以更高效地捕获对对象的访问和修改。</li><li><strong>更全面的拦截能力</strong>：Proxy API 提供了更多的拦截方法，比 defineProperty API 更灵活、丰富。它支持拦截目标的各种操作，包括读取、设置、删除、枚举等，甚至还可以拦截函数调用和构造函数实例化。</li><li><strong>更好的数组变化检测</strong>：Vue 3.0 使用 Proxy API 改善了数组的变化检测机制。Proxy 可以直接拦截数组的索引访问和修改，使得对数组的变化更容易被监听到，从而提供了更可靠的响应式行为。</li><li><strong>更易于处理嵌套对象</strong>：Proxy API 能够递归地拦截对象的嵌套属性，而 defineProperty 无法自动递归处理嵌套对象。这使得在 Vue 3.0 中处理嵌套对象更加简单和方便。</li><li><strong>更好的错误提示</strong>：相比于 defineProperty，Proxy API 提供了更好的错误追踪和调试信息。当使用 Proxy API 时，如果访问或修改了一个不存在的属性，会直接抛出错误，从而更容易发现和修复问题。</li></ol><p>不过，如果硬要挑刺的话，总是能找到缺点的。</p><p>比如<code>proxy</code>属性毕竟是ES6的特性，如果有人要兼容低版本的IE10之类的说法，可能vue3这套响应式就不是很能玩得转了。</p><p>但是大多情况下，在现代浏览器环境中，V3的<code>proxy</code>代理确实是比V2的<code>Object.defineProperty()</code>实现方式更还好用</p><h5 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h5><p>我们在日常的工作中，估计已经非常熟悉二者的使用了，相对于Vue2中用data()声明之后即可简单实现响应式，Vue3提供的这两种方式对于Vue2的习惯用户来说简直是一种致命缺陷。</p><p>关于ref和reactive的使用方式优化，在前文<a href="https://crazystudent13.cn/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB/">浅析ref与reactvie的区别</a>一文中，我给出了一些相对好用的使用方案，至少能让开发者在开发项目的过程中有更好的开发体验。</p><p>不过，今天这次不再是简单的讲二者的使用，而是更深层的剖析他们的实现方式。</p><h5 id="reactive的缺陷"><a href="#reactive的缺陷" class="headerlink" title="reactive的缺陷"></a>reactive的缺陷</h5><ol><li>reactive只能用来处理引用类数据的响应式，不能处理基础类型的数据，这个是官方自己这么规定的且<code>proxy</code>也只适合代理对象罢了。</li><li>reactive声明的数据，解构赋值会导致响应式失效</li><li>引用式数据直接赋值会导致响应式失效，比如用reactive代理数组，代理对象，如果你直接赋值一个新数组或者新对象，都会导致响应式失效</li></ol><p>以上缺陷几乎是我们日常开发中经常遇到的问题，稍微有点经验的开发老手大概都能猜出来什么原因。</p><p>很简单，深拷贝改变了引用类型数据的位置，而引用类的数据都是要根据存储位置的指针去找源数据的存储地址的。</p><p>而引用类型数据直接赋值，会直接改变指存储地址，这个重新赋值的过程丢失了响应式自然不奇怪。</p><p>解构赋值也是同理，我们用解构赋值处理引用类型数据，也会改变数据存储位置，原理同上，所以这两种情况都会导致响应式失效。</p><h5 id="ref的本质"><a href="#ref的本质" class="headerlink" title="ref的本质"></a>ref的本质</h5><p>很多开发者在开发中都非常喜欢ref一把梭，虽然这都需要.value&#96;这个小尾巴去获取实际内容。</p><p>相对于reactive，ref不需要考虑数据类型，无论是引用类型和基础类型的数据都能用ref代理。</p><p>但，ref的本质实际上就是reactive。</p><p>很多新人朋友可能在这个过程可能会有点犯迷，为什么ref的本质是reactive？</p><p>ref不是比reactive多了一个基础数据类型代理吗？</p><p>既然ref既能处理基础数据类型，又能处理引用数据类型，为什么不用ref一把梭？</p><p>这里我们放一段在vue工程中随手声明的测试变量，看看这个输出结果吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="title function_">ref</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是基础类型test的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">_value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testObj  = <span class="title function_">ref</span>(&#123; <span class="attr">a</span>: test &#125;)</span><br><span class="line"><span class="comment">// 以下是引用类型数据testObj的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">dep</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">_value</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>) &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">value</span>: (...)</span><br><span class="line">    [[<span class="title class_">Prototype</span>]]: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个复杂对象会有__v_isRef，__v_isShallow等属性，引用类型。</p><p>而我们将reactive包裹的对象输出，就没有该属性。</p><p>再结合上述示例的输出结果我们就能明白，<code>ref</code>实际上在处理基础数据的时，就是用普通的处理，将基础类型数据转换为一个<code>.value</code>的对象来完成响应式的处理。</p><p>而<code>ref</code>在处理引用类型数据时，通过输出结果，我们发现了<code>proxy</code>代理的数据，这和reactive输出的结果一模一样的。</p><p>显然，ref在处理对象的时候，本质上还是调用reactive。</p><p>根据__v_isRef的值去判断，如果是简单的数据，就有ref去处理，如果是复杂的数据，本质还是用reactive去代理。</p><p>所以，在处理引用类型数据时候，本质上还是<code>reactive</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，本次简单的说完了V2与V3的数据劫持方式的不同，不过我水平浅薄，没敢放自己对源码的解读，所以显得有点low。</p><p>不过，我尽可能保证自己说的内容都是查证和实验过了，所以准确性还是有保证的。</p><p>后续会持续整理更新V2与V3之后，也算是对得起自己这多年前端的经验。</p><p>如果您有更好的见解，欢迎在评论区留言，我会参考修正自己的认知。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6968657795977576455">Vue 2.x和Vue 3.x 数据劫持的实现和优缺点</a></p><p><a href="https://www.bilibili.com/video/BV1Lm4y1v72m/?share_source=copy_web&vd_source=a848031cce5c755167a3d6aa6bd87859">【Vue中修改了数组数值，为什么界面没有更新？】</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两年前在vue3在社区兴起之时，很多社区弄潮儿就在分析2与3源码区别，那时候很多人都以为是个新时代会到来。&lt;/p&gt;
&lt;p&gt;可是两年过去了，vue3的新时代依旧在缓慢迭代。&lt;/p&gt;
&lt;p&gt;对于大部分业务流选手，大家都不关心源码，大家更期望Vue3的相对于Vue2在工程上的亮点在哪，到底能否更爽快的开发，更好更稳定的替换当前工程。&lt;/p&gt;
&lt;p&gt;除非是面试，这种源码级的改动几乎是一个必然的面试题。&lt;/p&gt;
&lt;p&gt;很不巧，我现在刚好需要处理面试，于是这里整理一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，规则的意义</title>
    <link href="https://crazystudent13.github.io/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://crazystudent13.github.io/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2024-07-11T11:33:43.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>为了让工程提速，我们制造了规则。</p><p>为了让工程提速，我们漠视了规则。</p><p>本文给新踏上开发之路的朋友，1~3年左右开发经验的朋友可以看看，虽然这不是实打实的开发技能，但这却是我这数年开发的实际心得，您看完了，或许会有所收获，也可能会莞尔一笑，不过无论如何，肯定都不算是耽误您人生中的些许时光。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在早期单打独斗的时候，从来没有在意规则，一个人想怎么写就怎么写。</p><p>不过为了让未来的自己读代码没那么累，于是我开始在代码中写入注释，并且开始了简单的语义化，不再简单使用<code>a,b,c,d</code>这种临时变量。</p><p>这是最开始的简单规则，一直到团队开发的时候，我开发人生中第一套规则才开始正式诞生。</p><p>而数年之后，我为公司打造了一套低代码工具，将工程化发挥到了极致。</p><p>遥遥回想过往，简直感觉一切简直是不可思议。</p><h3 id="开发规则"><a href="#开发规则" class="headerlink" title="开发规则"></a>开发规则</h3><p>在早年前后端分离的思潮刚刚诞生的时候，我入职的前端开发团队大约两人左右，那时后端也仅一人。</p><p>很多时候商量着来，就能完成。</p><p>而后来，随着业务量的增加，前后端数量开始增加，三人以上的前端团队，对接三人以上的后端，在没有统一规则的指导下，开发进度一言难尽。</p><p>大部分的时间，前后端为了对接接口而费劲了心思。</p><h4 id="情景复盘"><a href="#情景复盘" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>三个人的后端，写出了三种风格的接口，大小写不统一，中英文混写，接口传参方式混乱，传参方式不同，且接口变动频繁导致前端根本无法稳定对接。</p><p>大家可能不能想象，那我就说一点，增删改查这一套流程中，有人同样一个字段居然写出了四种命名，有的是拼音，有的是小驼峰的单词，有的是大驼峰的单词，有的还用下划线方式命名，传参的code甚至都能出现字符串和数字两种类型，判定接口成功的code：200，20000，且这个过程中还有两种类型。</p><p>后端一团乱麻，而前端也没好到哪里去。</p><p>样式写法混乱，不用公用样式，非要自己改权重，写入样式覆盖公用样式。</p><p>接口写入方式不同，明明有着开源框架的标准方式，却偏偏要自己手动引入<code>axios</code>写接口，导致<code>api</code>接口文件非常不便管理。</p><p>而且，当时那个时间大约是2019年，那时候，前后端分离方式的思潮还很新，部分前端依旧是习惯于<code>Jquery</code>操作<code>Dom</code>的写法，然后你可以在vue的项目中看到有人引入了<code>Jquery</code>的在线链接，然后在框架内写代码操作表格。</p><p>这种思潮时至今日我居然还能在部分新手代码中遇到，有些时候我甚至可以在vue3中看到Jquery操作表格的代码，我也是不得不感叹，世界真是太大了，大到会发生任何不可思议的事。</p><h4 id="整理问题"><a href="#整理问题" class="headerlink" title="整理问题"></a>整理问题</h4><p>毫无疑问，不规范的问题极大拖累了开发速度，我们两周后复盘了一下，近乎7成以上的事件浪费在这种毫无意义的调试上。</p><p>我们当时在做的是一个系统的翻新，之所以接口会出现频繁变动，是因为大多数后端对业务不熟悉，进而导致接口频繁变动，而我们需要快速翻新出成果。</p><p>为了追求快，我们放弃了规则，这是管理上的隐患。</p><p>公司当时用的是非常好上手的Vue2，写过Vue2的朋友大概率应该知道，这是一个非常好上手的新手框架，但是我们那时候简直能用出一坨屎。</p><p>我将这个开发过程中犯的毛病整理一下，权当一篇避雷指南了。</p><p>如果您现在的项目中中了以下几条，那您就必须要反思一下，您做项目到底将多少精力花在这些无意义的调试上了？</p><ul><li>管理上追求快，不做标准要求，按照要求的时间点开始倒排开发日期，导致开发无限期加班，精力极大程度的消耗在对接空耗上了</li><li>UI风格不统一确定，很多时候出成品，经常会有样式上的变动</li><li>前后端不做业务交流，双方都在一次会议之后，简单确认了任务，就毫无修正的朝着各自以为的目标推进</li><li>后端接口标准不统一，数种不同风格的接口导致前端难以适配，即便写统一处理字段的方法也没法讲中文字段转换成英文字段，这极大的拖累的开发进度</li><li>前后端未约定联调标准，导致传参方式适配难度极大，后端成功与失败的code都不统一，有的后端甚至不写接口报错捕获，所有的传参结果都是成功</li><li>前端未使用公用样式，导致样式管理极度混乱，无法统一修改部分公用样式</li><li>前端技术栈不统一，有人在项目中使用JQuery，加重了调试的心智负担</li><li>前端语义化命名不明显，在样式中多处使用<code>L1，R1，T1，B1</code>这类风格，scss样式嵌套加深之后，阅读极为困难，变量中更是重量级，基本上不用ES6，狂用ES5的写法，几乎不用ES6的新特性来处理数组，导致代码阅读极为困难</li><li>前端代码风格不同，导致不同格式化的代码风格经常冲突</li><li>前端不用VueX存储的公共数据来读取一些数据字典，反而每次都要请求一次接口去读数据，每次页面都要拉取很多接口</li><li>没有公共工具方法库，所有人判空，取整，时间格式化都是按照自己的想法来，八仙过海，各显神通</li></ul><p>综上，这是开发中问题，至于发布测试等方面的问题，这里先按住不表，因为后续更是重量级。</p><p>由于以上的问题，我们开发页面过程极度缓慢，翻新进度简直慢的发指。</p><p>四个简单的增删改查页面，前端后端6人，每天工作12小时以上，而且是时刻有交流条件的情况下，大家根本不交流。</p><p>然后，居然在一周内没有完成两个单表的增删改查。</p><p>而后续一个复杂的多字段表单，更是整整耗时一周，才勉强调通，且不能保证全流程完全走通。</p><p>是的，这就是我们的开发进度，6个人，做成这样，肉眼可见的丢人，但这就是那时的开发进度。</p><p>我们放弃了规矩，但是我们并未追求到进度。</p><p>在复数人员的开发情况下，一个混沌的开发体系，进度便是如此的可笑。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>幸亏管理也算是技术出身，且技术功底扎实，简单的商量之后，我们制定了以下的简单方案</p><ul><li>后端接口由管理负责，定好统一格式，后端全员按照接口格式开发</li><li>在正式确认业务之前，前后端都要过一遍业务，彼此确认业务的大致流程，同时后端在没有给定正式业务之前，要先给出确定字段的接口，便于双方确认（那时候我们还不会Mock数据）</li><li>制定统一风格，由管理人员确定一套风格，然后开发出最初的模板，之后尽可能使用<code>element-ui</code>框架来实现功能，避免前端使用自己手写的样式覆盖，如果一定要调整全局样式，那么需要报备，除非必须要求改动，否则就放弃修改</li><li>技术栈统一，放弃JQuery，全面拥抱Vue2的写法，每晚定期进行代码审查（草草检查，主要确认没有jquery）</li><li>公共接口抽离，将一些公用方法抽离出来，如上传，部分复杂的业务数据字典，</li><li>公共方法本地化封装，将一些判空之类的方法写在工具类中，省去每人手写工具方法的时间</li><li>命名语义化，尽可能减少无意义的变量命名</li><li>代码格式化插件统一，开发工具统一，保证所有人调试起来方便（笔者并不太会用webstorm的格式化，当时也没时间去研究，只能禁了那位组员的webstorm，让他用vscode）</li></ul><p>经过这些小手段，效果立竿见影。</p><p>开发进度确实有了些许提升，但是页面功能的稳定性显而易见的上升，同时每人的工作量大幅下降，勉强可以8点下班，至少不用彻夜彻夜的加班了（在这之前巅峰时间甚至能达到每天14小时以上的工作强度）。</p><p>可能大家会觉得，这并未提升多少，但是于那时的我们来说，在这之前，团队几乎是肉眼可见要崩塌，所有人都不觉得这样的团队能做成这个项目。</p><p>但是这些简单的规定做下来之后，虽然强度还在，但是工作目标至少可以量化了，同时任务终于可以拆解了，不再是将所有人都堆在任务中。</p><p>而团队工程化的路，就是从那时候开始的。</p><h3 id="运维发布"><a href="#运维发布" class="headerlink" title="运维发布"></a>运维发布</h3><p>因为团队一开始并不大，所以很多时候都是开发运维一把抓，然后在这个过程中，又诞生了一堆混乱至极的问题。</p><h4 id="情景复盘-1"><a href="#情景复盘-1" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>那时，我们用的仍然是SVN进行版本管理，相对于git的分布式版本管理，SVN的集中管理有个弱势点，那就是版本管控必须要将代码文件提交到中心服务器。</p><p>而这就有个隐患，如果有人没有将自己的逻辑走完，那么为了版本管控，他也只能将代码提交到SVN，而客户几乎每天都会过来看一下进度。</p><p>如果有经验的人，想必此时已经发现哪里有隐患了。</p><p>因为有人会将未完成的功能提交到线上，那么发布到线上的时候，碰到演示这种未完成的功能时候，免不了会被客户一顿痛批。</p><p>部分公司为了解决这种问题，会选择再买个服务器，做一个测试版本，但我们当时是内网开发，客户表示只有这一个服务器，然后结果就很尴尬了。</p><p>这个过程，开发流程管理也很混乱，客户会经常在我们开发过程中插入一些新的要求，导致我们项目需求翻新的进度极度拖延。</p><h4 id="整理问题-1"><a href="#整理问题-1" class="headerlink" title="整理问题"></a>整理问题</h4><p>在我们刚解决了开发上的规范问题之后，我们就遇到了这种运维及需求沟通的问题上的问题。</p><h5 id="需求混乱"><a href="#需求混乱" class="headerlink" title="需求混乱"></a>需求混乱</h5><ul><li>翻新需求不明确，做无用功，很多旧版本的功能，在旧版时候明确不用了，但是项目Leader没有细细筛过需要翻新的功能，导致经常做了无用功</li><li>客户需求不评审，因为客户可以直接到现场催稿，导致经常会插入一些客户优先的功能，延误了正常工期排序</li><li>对业务不熟悉，导致返工。这个是最常见的事情，很多时候，我们评审业务，项目Leader没有说明白业务，进而导致开发者对业务的理解南辕北辙，不停翻新做无用功。</li></ul><p>针对这些问题，我们项目Leader只能将自己从开发序列中抽离，自己去整理业务对接客户。</p><p>因为他最懂这块的业务，所以只有他自己可以去，他将需求承接完成后，顶住客户的需求压力，按照排期给我们捋顺业务和开发进度。</p><p>之后，由他来作为团队大核，指导对业务不熟悉的我们，由我们负责具体的开发内容。</p><p>这之后的效果，也算是立竿见影，虽然项目Leader不用实际开发了，但我们的进度却并未落下，甚至质量再次提升，做无用功的情况越来越少，随着大家对业务的逐渐熟悉，所有人甚至可以对业务中不合理的地方及时预警。</p><h5 id="混乱发布"><a href="#混乱发布" class="headerlink" title="混乱发布"></a>混乱发布</h5><p>这是在需求没有整理之前的情况，我们的发布突出一个随心所欲，几乎所有小团队中能犯的错，我们这里都犯过。</p><ul><li>版本不指定，我们没有既定的版本，只是按照大致的感觉和客户的催命程度来发布，这时候我们和上版本相比有了什么进步只有项目Leader知道</li><li>功能不自测，因为经常翻新，为了追求演示效果，我们经常赶时间发布，这导致演示的时候经常翻车</li><li>人员不指定，所有人都可以发布，然后我们经常在发布的时候撞车（趁没有测出BUG悄悄发布，小团队这种事想必很多）</li><li>项目现场不指定，当时翻新的这个项目部分源码涉及到另一个项目现场，手动发布必然会有失误，经常忘记改配置，导致项目现场读取的内容错乱</li><li>日期不指定，因为没有固定的发布时间，所以客户经常回来催我们（后来由项目Leader去抗这个压力了）</li></ul><p>综上，我们提出了一系列的解决方案。</p><ul><li>定好版本发布规则，确认需求后，固化发布日期。除非客户强烈要求，否则不会加入新功能排期，按照周为单位进行迭代。</li><li>指定专门的运维人员，其他人不能碰发布服务器</li><li>前端开发打包版本插件，让代码可以根据时间自动生成版本，并抽离配置，减少手动发包导致项目现场错配的问题</li><li>安排运维人员书写运维文档，保证客户和开发人员都能明白我们要改什么，接下来要做什么</li></ul><h3 id="提速方向"><a href="#提速方向" class="headerlink" title="提速方向"></a>提速方向</h3><p>讲到这里，时间基本上挺接近现在了，我这里没有接触过更高标准的团队，但是就我打听的情况来看，大厂似乎也将工程化的流程走到顶点了。</p><p>我在面试过程中，发现很多团队实际上基本就是前者的形态了，很少有进入到这一步的，以下提到的这些需求，几乎是只有大型团队才会出现的需求。</p><p>这一步几乎是工程化的高标准状态了，大多数草创的开发团队，甚至是一些较为成熟的团队，他们几乎没有到这一步的意识和需求。</p><p>到了这一步，公司业务几乎固定，因为业务线的固定，也逐渐衍生出产品化的概念，自然也就有了产品迭代的需求。</p><p>于是，工程提速的玩法再次发生了改变。</p><ul><li>自动化发布</li><li>代码管控，自动生成发布日志</li><li>组件库</li><li>工具包</li><li>脚手架</li><li>前后端约定统一，技术栈固化</li></ul><p>集成以上方式之后，便有了终极形态，低代码。</p><p>在那时，我们几乎可以将一个两月交付的项目在一周内迭代出原型，供客户参考，然后在那基础上修改。</p><p>同时极大程度节约人力，不过受限于篇幅，这里就不展开说了，后续会随着自己的要求，逐步解释我们项目中为什么进行这些操作。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>开发规则的诞生，是一个几乎必然的过程，人人都在骂这种制度化，但是一旦走向了大型团队化，我们又不可避免的制度化。</p><p>有些时候，人真是有趣，讨厌一件事，理解一件事，融入一件事，成为这件事。</p><p>制度化，团队化，似乎是人类群体的必然性，这种过程似乎是大型团队的必然答案，也是一种趋同进化的趋势。</p><p>当然，扯远了，我们仅仅说的是工程，一个工程想要做的正常，并非一定要上大型工程的规则。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7390319475525107764">工程提速，规则的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了让工程提速，我们制造了规则。&lt;/p&gt;
&lt;p&gt;为了让工程提速，我们漠视了规则。&lt;/p&gt;
&lt;p&gt;本文给新踏上开发之路的朋友，1~3年左右开发经验的朋友可以看看，虽然这不是实打实的开发技能，但这却是我这数年开发的实际心得，您看完了，或许会有所收获，也可能会莞尔一笑，不过无论如何，肯定都不算是耽误您人生中的些许时光。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解JS中的常用遍历</title>
    <link href="https://crazystudent13.github.io/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/"/>
    <id>https://crazystudent13.github.io/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/</id>
    <published>2024-07-09T04:48:10.000Z</published>
    <updated>2024-08-06T13:43:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>最近写代码频繁写map，以至于想写for…of的时候，都忘记这块的讲究了，索性整理下，以备面试。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>常规开发中我们可能已经习惯性的使用map了，但我们肯定不能只会map。</p><p>这里我们索性通盘整理下，把前端开发中遍历的熟面孔遍历一遍。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code>循环是一种常用的遍历方法，特别适用于已知遍历次数的情况。</p><p>它由三个部分组成：初始化表达式、循环条件和循环迭代器。</p><p>这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++ )&#123; <span class="comment">//(初始化表达式; 循环条件; 循环迭代器)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环非常灵活，你可以根据需要自定义循环变量的初始值、循环条件和迭代方式。它适用于各种遍历需求，包括遍历数组、对象的属性等。</p><ol><li>通过<strong>continue</strong>中断当次循环</li><li>通过<strong>break</strong>中断整个循环</li><li>通过<strong>retrun</strong>中断函数执行</li></ol><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法用于对数组的每个元素执行指定的操作，并返回一个新的数组，新数组的元素是原数组经过操作后的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> modifiedElement;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>map</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行操作，并返回经过操作后的新值<code>modifiedElement</code>。</p><p><code>map</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的结果组成一个新的数组。</p><p>下面是一个使用<code>map</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>map</code>方法对数组<code>array</code>的每个元素进行操作，将每个元素乘以2，并将操作后的结果组成一个新的数组<code>newArray</code>。</p><p><code>map</code>方法是一种非常有用的方法，它可以方便地对数组的每个元素进行操作，并生成一个新的数组。</p><p> 需要注意的是</p><ul><li><code>map</code>方法不会修改原始数组，而是返回一个新的数组</li><li><code>map</code>方法无法遍历对象，仅适用于数组的遍历</li><li><code>map</code>方法不会对空数组进行检测</li><li><code>map</code>循环只能通过return中断当次循环</li></ul><h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for..in 和 for..of 的区别"></a>for..in 和 for..of 的区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h4><p>for…in是为遍历对象属性而构建的，它以任意顺序遍历一个对象的除Symbol以外的可枚举属性，可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 name age</span></span><br></pre></td></tr></table></figure><p>在JavaScript中，数组也是对象的一种，所以数组也是可以使用for…in遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2</span></span><br></pre></td></tr></table></figure><h4 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h4><p>for…of语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句（包括Array，Map，Set，String，TypedArray，arguments等等，不包括Object），可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 obj is not iterable (obj不是可迭代的)</span></span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>无论是for…in还是for…of都是迭代一些东西。它们之间的主要区别在于它们的迭代方式</p><ul><li>for…in语句以任意顺序迭代对象的可枚举属性</li><li>for…of语句遍历可迭代对象定义要迭代的数据</li></ul><p>总之，for…in 循环主要是为了遍历对象而生，不适用于遍历数组</p><p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ufo</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2 ufo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br></pre></td></tr></table></figure><h3 id="使用for…-of遍历对象的方法"><a href="#使用for…-of遍历对象的方法" class="headerlink" title="使用for….of遍历对象的方法"></a>使用for….of遍历对象的方法</h3><h4 id="遍历类数组对象"><a href="#遍历类数组对象" class="headerlink" title="遍历类数组对象"></a>遍历类数组对象</h4><p>使用Array.from()方法将对象转换为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历普通对象"><a href="#遍历普通对象" class="headerlink" title="遍历普通对象"></a>遍历普通对象</h4><ul><li>给对象添加一个[symbol.iterator]属性，并指向一个迭代器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(count&lt;keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  onsole.<span class="title function_">log</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二（使用Generator函数生成迭代器）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*()&#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-和-forEach区别"><a href="#for-和-forEach区别" class="headerlink" title="for 和 forEach区别"></a>for 和 forEach区别</h3><ul><li>for循环可以使用break跳出循环，但forEach不能。</li><li>for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。</li><li>for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。</li></ul><h3 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h3><p><code>reduce</code>方法用于对数组的每个元素进行累积操作，并返回一个最终的累积结果。</p><p>以下是<code>reduce</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element, index, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulatedValue;</span><br><span class="line">&#125;, initialValue);</span><br></pre></td></tr></table></figure><p>在<code>reduce</code>方法中，我们传入一个回调函数作为参数。该回调函数接受四个参数：累积值<code>accumulator</code>、当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行累积操作，并将累积结果返回。<code>reduce</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的累积结果作为下一次迭代的累积值。</p><p>下面是一个使用<code>reduce</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element</span>) &#123; <span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line">    <span class="keyword">return</span> accumulator + element;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>reduce</code>方法对数组<code>array</code>的每个元素进行累积操作，将所有元素相加得到最终的累积结果。</p><p>需要注意的是:</p><ul><li><code>reduce</code>方法不会改变原数组。</li><li><code>reduce</code>方法可以接受一个可选的初始值<code>initialValue</code>作为第二个参数。如果提供了初始值，累积值<code>accumulator</code>的初始值将为该值；如果未提供初始值，则累积值将为数组的第一个元素，且从数组的第二个元素开始进行累积操作。</li><li>如果数组为空，且未提供初始值，则<code>reduce</code>方法会抛出一个<code>TypeError</code>。在处理可能为空的数组时，要确保提供了合适的初始值或进行适当的错误处理。</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于筛选数组中满足指定条件的元素，并返回一个新的数组。</p><p>以下是<code>filter</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element, index, array</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>filter</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否保留该元素。如果回调函数返回<code>true</code>，则该元素将被保留在新的数组中；如果返回<code>false</code>，则该元素将被过滤掉。</p><p>下面是一个使用<code>filter</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>filter</code>方法筛选数组<code>array</code>中的偶数元素，并将满足条件的元素组成一个新的数组<code>newArray</code>。</p><p><code>filter</code>方法非常灵活，可以根据不同的条件筛选数组中的元素。回调函数应该返回一个布尔值，表示是否保留该元素。返回<code>true</code>表示保留，返回<code>false</code>表示过滤掉。</p><p>需要注意的是：</p><ul><li><code>filter</code>方法会返回一个新的数组，该数组包含满足指定条件的元素。请确保在回调函数中返回一个布尔值，表示是否保留该元素。</li><li><code>filter</code>方法不会对空数组进行检测。</li></ul><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p><code>some</code>方法用于检测数组中是否至少有一个元素满足指定条件。</p><p>以下是<code>some</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>some</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。如果回调函数返回<code>true</code>，则表示至少有一个元素满足条件；如果所有元素都不满足条件，回调函数返回<code>false</code>。</p><p>下面是一个使用<code>some</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>some</code>方法检测数组<code>array</code>中是否存在大于3的元素。</p><p>由于数组中存在元素4和5满足条件，所以<code>some</code>方法返回<code>true</code>。</p><p><code>some</code>方法可以用于检测数组中是否满足某个条件的元素。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>some</code>方法在找到满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>some</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p><code>every</code>方法用于检测数组中的所有元素是否都满足指定条件。</p><p>以下是<code>every</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>every</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。</p><p>如果回调函数对数组中的所有元素都返回<code>true</code>，则<code>every</code>方法返回<code>true</code>；如果有任何一个元素返回<code>false</code>，则<code>every</code>方法返回<code>false</code>。</p><p>下面是一个使用<code>every</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>every</code>方法检测数组<code>array</code>中的所有元素是否都大于0。由于数组中的所有元素都大于0，所以<code>every</code>方法返回<code>true</code>。</p><p><code>every</code>方法可以用于检测数组中的所有元素是否满足某个条件。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>every</code>方法在找到不满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>every</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端遍历循环，最熟悉的陌生人。</p><p>平时开发的过程中，很多新人肯定会直接map或者for循环一把梭，这样固然简单有效，但是不够语义化，所以才有了这些api。</p><p>我们要尽可能的多用这些原生的API，减少日常开发中不够语义化的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://conistudy.club/interview/javascript.html#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB">JavaScript | Conistudy</a></p><p><a href="https://juejin.cn/post/7361809254044647465?searchId=20240710123929C9622D5B87737C588848">详解JavaScript遍历：掌握for、forEach、for in、for of和map等方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近写代码频繁写map，以至于想写for…of的时候，都忘记这块的讲究了，索性整理下，以备面试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，低代码的意义</title>
    <link href="https://crazystudent13.github.io/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://crazystudent13.github.io/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2024-07-07T11:29:59.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>低代码在22~23年左右的时候，这个概念是最火的，同时期，若依开源项目也在这期间加入了低代码的功能。</p><p>之后，在23年低代码的风潮达到了鼎盛，但是之后就陷入了 各种声音的质疑中，最后陷入的沉寂。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>低代码的没落并非是低代码本身的没落，而是需求本身的没落。</p><h3 id="低代码平替"><a href="#低代码平替" class="headerlink" title="低代码平替"></a>低代码平替</h3><p>低代码并非万能银弹，在开发者的世界里，是不可能存在万能的银弹的。</p><blockquote><p>银弹，即<a href="https://baike.baidu.com/item/%E7%BA%AF%E9%93%B6/0?fromModule=lemma_inlink">纯银</a>质或<a href="https://baike.baidu.com/item/%E9%95%80%E9%93%B6/9937426?fromModule=lemma_inlink">镀银</a>质的子弹。在古老的欧洲民间传说、鬼怪题材的小说和电影，尤其是19世纪以来<a href="https://baike.baidu.com/item/%E5%93%A5%E7%89%B9%E5%B0%8F%E8%AF%B4/0?fromModule=lemma_inlink">哥特小说</a>风潮影响下，银色子弹往往被描绘成是<a href="https://baike.baidu.com/item/%E7%8B%BC%E4%BA%BA/24621?fromModule=lemma_inlink">狼人</a>和<a href="https://baike.baidu.com/item/%E5%90%B8%E8%A1%80%E9%AC%BC/64596?fromModule=lemma_inlink">吸血鬼</a>、<a href="https://baike.baidu.com/item/%E5%A5%B3%E5%B7%AB/2007?fromModule=lemma_inlink">女巫</a>以及其他怪物的克星，一发即可致命，并具有驱魔的效力。</p><p>后来在开发中，有人比喻为万能解法，因为很多西部片和小说中的不死邪魔经常都被一发银弹解决，这种不讲道理的方式，就被戏称为银弹，在戏剧中也有类似的玩法，叫做机械降神，不过这个就不细展开说了。</p><p>无论是银弹还是机械降神，都是比喻一种万能解法，而在开发者的世界中，这种万能的银弹是不存在的。</p></blockquote><p>低代码的诞生和火爆，离不开早些年互联网的火爆，各种<code>ToB（面向公司老板）</code>，<code>ToC（面向客户）</code>，<code>ToG（面向政府）</code>等业务的不断上扬和增加，这时候，不可避免的出现了N多的管理系统。</p><p>一旦管理系统落成，那么不可避免的，就要对表的增删改查。</p><p>这时候，很多开发者不可避免的要一遍又一遍的陷入前端写表单列表，后端写<code>curd</code>的接口，在这种重复业务中不断耽误时间，加班赶进度，却十分枯燥的情况。</p><p>针对这种情况，于是才有了低代码。</p><p>但是低代码，却绝非是现代才有的概念，而是很早之前就有的概念，早在现代低代码概念爆火之前，就有类似的说法。</p><p>说穿了，低代码就是配置化系统的变种，但是生成出来的代码又需要一定开发技术去按照需求修改，相对于传统的工具系统，这种低代码平台肯定更好用。</p><p>譬如ERP，CMS及等工具系统，对已经固定的业务线，仅仅需要配置就可以配置好一个系统，供用户使用，这应该就是最早的低代码系统。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>低代码并非是小型公司可以玩转的东西，这东西的诞生是为了解决特定的场景内的需求。</p><p>个人曾在公司有幸接触过相关业务，所以这里分享一下低代码的具体的应用场景及基础要求。</p><h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><p>注意，需要满足以下绝大多数条件的，可以考虑在公司产品中加入低代码的功能，否则开发用来造轮子的工作时间会远大于使用低代码这个轮子的节约的时间。</p><ul><li>重复的业务场景，需要消耗大量人力时间去写重复的增删改查工作量</li><li>业务线路稳定，不会频繁变动，多数业务逻辑可以拆分成简单的增删改查实现</li><li>表单关系简单，相互之间交互关系不大</li><li>UI风格稳定，需求方对UI不做大规模的变动要求，并且基于这个稳定的UI库，形成一套属于公司自己的风格</li><li>稳定的组件库，能够极大程度减少代码生成文件的代码量，便于改动</li><li>如果有双端适配的要求，那移动端也要有稳定的组件库和设计风格，同时业务量不要统一</li><li>前端基建相对稳定，脚手架，工具包，组件库都统一，并基建代码和业务代码能够并行推进，相互干扰程度小</li><li>稳定的权限管理功能，从路由到按钮级别的管理，不是一个混沌的权限管理系统（在很多中小厂中至今没有一个像样的权限管理系统）</li><li>前端负责人需要对公司业务有较为深层的了解，能够把控和预测公司接下来的发展方向，不会完全受制于设计或者后端，不至于一点话语权也没有。</li></ul><p>综上，我们会发现，这并非是个小公司使用的工具。</p><p>低代码的诞生，是一个团队的工作成果。</p><blockquote><p>稳定的UI，业务线，产品化的前后端框架，成熟的运维人员，几乎缺一不可。</p></blockquote><p>低代码热门的场景，大概是中型公司或者大厂业务部门中常用的工具，通过这东西，应该可以快速生成一些增删改查的表单，快速完成项目任务。</p><p>而小厂接到的业务，多数个性化要求较高，甚至是外包业务，根本就不在乎你用什么技术，混乱的项目管理根本不适合低代码的的使用。</p><h3 id="低代码优劣"><a href="#低代码优劣" class="headerlink" title="低代码优劣"></a>低代码优劣</h3><p>开发者固然要追求更新潮，更有趣的技术，这是一个开发者固有的技术素养。</p><p>但工程不能，工程是一个公司，一个团队的心血，工程要以稳定为主，你可以小步迭代，决不能贸然使用不稳定的技术。</p><p>毕竟，所有的技术诞生，都是为了解决某种特殊的需求，不要为了技术追星，去强上看上去很酷炫的技术。</p><p>这里我列举一下低代码的优劣，各位可以根据自己的需求权衡，是否在公司内使用</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>大量节省人力，原本一个项目至少需要一个熟手前端，后端同时协同开发数月才能完成一个项目，而使用低代码之后，简单的项目完全可以由一个运维人员通过简单的配置，生成一个系统，个性化的页面申请给开发部调整，将数月级别的项目缩减到两周。</li><li>可以快速迭代项目，很多时候需求方不清楚自己需要什么，而我们通过对表单的和列表的配置，很容易就能让客户明白自己的缺陷和需求，这样便于快速迭代，但是注意，不要被客户套进去。</li><li>使用简单，基本上一个运维人员通过培训，只要稍微有点项目经验和些许的开发经验，就可以覆盖一个项目现场，一旦完成交付后，还可以快速迭代到下一个项目现场。</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>技术固化。随着项目的不断推进，低代码系统涉及到的组件库必须得稳定维护，组件库会随着项目的增多而不断臃肿，随着时间的增加，低代码的尽头必然是需要前端组长花很大的力量去维护和平衡各个项目现场的需求。</li><li>项目臃肿。很多人在使用低代码的时候，简单生成了代码，后续这里不用之后，就隐藏废弃，代码也不会删除，时间长了之后，这种废弃代码就堆在业务系统中，久而久之，这项目就会很臃肿。</li><li>依赖管理困难。各个前端项目没有版本锁，当时Pnpm也没有流行开来，现在相对来说应该好的多，但是随着时间的推移，这种组件库的适配早晚也会在依赖管理上出问题的。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多大厂的为了做业绩，在那两年几乎把这玩意吹成了万能银弹，这是不对的。</p><p>在它的固有领域内，低代码能极大节省人力，减少开发者的业务工作量，让开发者更专注于自身的开发优势，不过这也让开发者更远离业务，难以进入业务管理层了。</p><p>总之，有利又有弊，是否使用低代码，需要根据自身情况做决定。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7389077092136452148">工程提速，低代码的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;低代码在22~23年左右的时候，这个概念是最火的，同时期，若依开源项目也在这期间加入了低代码的功能。&lt;/p&gt;
&lt;p&gt;之后，在23年低代码的风潮达到了鼎盛，但是之后就陷入了 各种声音的质疑中，最后陷入的沉寂。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅析const声明的ref，reactive变量为什么可以修改</title>
    <link href="https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/"/>
    <id>https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/</id>
    <published>2024-07-06T04:33:39.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。</p><p>当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>const</code>关键字用于声明一个变量，该变量的值在其生命周期中不会被重新赋值。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>我们都知道const声明的常量不可改变，但是为什么Vue3中的ref和reactive声明的变量就可以修改？</p><p>这里我们先看几个例子，我们会发现，不止是ref和reactive，const声明的引用类数据，都是会被改变的。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>对于基本数据类型（如数字、字符串、布尔值），<code>const</code>确保变量的值不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// num = 43;  // 这会抛出错误</span></span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于对象，仍然可以修改对象的属性，但不能重新赋值整个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girlfriend = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小宝贝&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">girlfriend.<span class="property">name</span> = <span class="string">&quot;亲爱的&quot;</span>;  <span class="comment">// 这是允许的，因为你只是修改了对象的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// girlfriend = &#123; name: &quot;亲爱的&quot; &#125;;  // 这会抛出错误，因为你试图改变obj的引用</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>对于数组，你可以修改、添加或删除元素，但不能重新赋值整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>;  <span class="comment">// 这是允许的，因为你只是修改了数组的一个元素</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">5</span>);  <span class="comment">// 这也是允许的，因为你只是向数组添加了一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [6, 7, 8];  // 这会抛出一个错误，因为你试图改变arr的引用</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在JavaScript中，<code>const</code>并不是让变量的值变得不可变，而是让变量指向的<strong>内存地址</strong>不可变。</p><p>换句话说，使用<code>const</code>声明的变量不能被重新赋值，但是其所指向的内存中的数据是可以被修改的。</p><p>使用<code>const</code>后，实际上是确保该变量的引用地址不变，而不是其内容。</p><p>其实，这就是一次浅拷贝，只要地址指向的位置不发生改变，你做什么操作都可以，关于深浅拷贝不清楚的，可以参考一下我的：<a href="https://crazystudent13.cn/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">10分钟了解深浅拷贝</a>。</p><p>基础数据类型定死了内存地址，所以当你重新赋值的时候，自然就会报错。</p><p>而引用数据类型虽然也定死了内存地址，但是其中内容未完全定死，所以可以操作和修改，这就是为什么引用类的数据类型使用const修改不会报错，但是重新赋值就会报错的原因了。</p><p>当const<code>声明一个变量并赋值为一个对象或数组，这个变量实际上存储的是这个对象或数组在内存中的地址，形如</code>0x00ABCDEF&#96;（这只是一个示例地址，实际地址会有所不同），而不是它的内容。这就是为什么我们说变量“引用”了这个对象或数组。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>这种看似矛盾的特性实际上在开发中经常用到。</p><p>例如，在开发过程中，可能希望保持一个对象的引用不变，同时允许修改对象的属性。这可以通过使用<code>const</code>来实现。</p><p>考虑以下示例：</p><p>假设你正在开发一个应用，该应用允许用户自定义一些配置设置。当用户首次登录时，你可能会为他们提供一组默认的配置。但随着时间的推移，用户可能会更改某些配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">const</span> userSettings = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&quot;light&quot;</span>,  <span class="comment">// 主题颜色</span></span><br><span class="line">    <span class="attr">notifications</span>: <span class="literal">true</span>,  <span class="comment">// 是否开启通知</span></span><br><span class="line">    <span class="attr">language</span>: <span class="string">&quot;en&quot;</span>  <span class="comment">// 默认语言</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时间点，用户决定更改主题颜色和语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateUserSettings</span>(<span class="params">newTheme, newLanguage</span>) &#123;</span><br><span class="line">    userSettings.<span class="property">theme</span> = newTheme;</span><br><span class="line">    userSettings.<span class="property">language</span> = newLanguage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用函数，将主题更改为&quot;dark&quot;，语言更改为&quot;zh&quot;</span></span><br><span class="line"><span class="title function_">updateUserSettings</span>(<span class="string">&quot;dark&quot;</span>, <span class="string">&quot;zh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userSettings);  <span class="comment">// 输出：&#123; theme: &quot;dark&quot;, notifications: true, language: &quot;zh&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个<code>userSettings</code>对象，它包含了用户的默认配置。</p><p>尽管我们使用<code>const</code>来声明这个对象，但我们仍然可以随后更改其属性来反映用户的新配置。</p><p>这种模式在实际开发中很有用，因为它允许我们确保<code>userSettings</code>始终指向同一个对象（即我们不会意外地将其指向另一个对象），同时还能够灵活地更新该对象的内容以反映用户的选择。</p><h4 id="为什么不用let"><a href="#为什么不用let" class="headerlink" title="为什么不用let"></a>为什么不用let</h4><p>以上所以案例中，使用let都是可行，但它的语义和用途相对不同，主要从这几个方面进行考虑：</p><ol><li><strong>不变性</strong>：使用<code>const</code>声明的变量意味着你不打算重新为该变量赋值。这为其他开发人员提供了一个明确的信号，即该变量的引用不会改变。在上述例子中，我们不打算将<code>userSettings</code>重新赋值为另一个对象，我们只是修改其属性。因此，使用<code>const</code>可以更好地传达这一意图。</li><li><strong>错误预防</strong>：使用<code>const</code>可以防止意外地重新赋值给变量。如果你试图为<code>const</code>变量重新赋值，JavaScript会抛出错误。这可以帮助捕获潜在的错误，特别是在大型项目或团队合作中。</li><li><strong>代码清晰度</strong>：对于那些只读取和修改对象属性而不重新赋值的场景，使用<code>const</code>可以提高代码的清晰度，可以提醒看到这段代码的人：“这个变量的引用是不变的，但其内容可能会变。”</li></ol><p>一般我们默认使用<code>const</code>，除非确定需要重新赋值，这时再考虑使用<code>let</code>。这种方法旨在鼓励不变性，并使代码更加可预测和易于维护。</p><p>由此，我们应该也明白，ref和reactive使用const声明，而非使用let了。</p><h4 id="避免修改"><a href="#避免修改" class="headerlink" title="避免修改"></a>避免修改</h4><p>如果我们想要避免修改<code>const</code>声明的变量，当然也是可以的。</p><p>例如，我们可以使用浅拷贝来创建一个具有相同内容的新对象或数组，从而避免直接修改原始对象或数组。这可以通过以下方式实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">originalArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">const <span class="attr">newArray</span> = [...originalArray]<span class="comment">; // 创建一个原始数组的浅拷贝</span></span><br><span class="line">newArray.push(4)<span class="comment">; // 不会影响原始数组</span></span><br><span class="line">console.log(originalArray)<span class="comment">; // 输出: [1, 2, 3]</span></span><br><span class="line">console.log(newArray)<span class="comment">; // 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>const</code>声明的变量之所以看似可以被修改，是因为<code>const</code>限制的是变量指向的内存地址的改变，而不是内存中数据的改变。</p><p>这种特性在实际开发中有其应用场景，允许我们保持引用不变，同时修改数据内容。</p><p>然而，如果我们确实需要避免修改数据内容，可以采取适当的措施，如浅拷贝。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7268087637239463997">const声明的变量还能修改？原理都在这了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。&lt;/p&gt;
&lt;p&gt;当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解nginx</title>
    <link href="https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/"/>
    <id>https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/</id>
    <published>2024-07-02T12:53:32.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。</p><p>等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。</p><p>现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>nginx这东西，好用也不难学，学会了之后，对于前端来说，就可以自己操控服务器进行独立应用部署了。</p><p>学一学也好，简单又强大的东西，也是其成为新时代的开发宠儿的原因。</p><p>以前只是简单的用过，但是从来没有系统性的整理过，这次干脆花些时间简单整理一下。</p><h3 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h3><p><strong>第一部分 全局块</strong></p><p>主要设置一些影响 nginx 服务器整体运行的配置指令。</p><p>比如： worker_processes 1；worker_processes 值越大，可以支持的并发处理量就越多。</p><p><strong>第二部分 events块</strong></p><p>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。</p><p>比如： worker_connections 1024; 支持的最大连接数。</p><p><strong>第三部分 http块</strong></p><p>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p><ul><li><strong>server块</strong>：配置虚拟主机的相关参数。</li><li><strong>location块</strong>：配置请求路由，以及各种页面的处理情况。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attribute">error_log</span> log/<span class="literal">error</span>.log <span class="literal">debug</span>;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attribute">log_format</span> myFormat <span class="string">&#x27;<span class="variable">$remote_addr</span>–<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="variable">$request</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="variable">$http_referer</span> <span class="variable">$http_user_agent</span> <span class="variable">$http_x_forwarded_for</span>&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> mysvr &#123;   </span><br><span class="line">      <span class="attribute">server</span> <span class="number">127.0.0.1:7878</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">120</span>; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">4545</span>;   <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;   <span class="comment">#监听地址       </span></span><br><span class="line">        <span class="section">location</span>  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attribute">proxy_pass</span>  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attribute">deny</span> <span class="number">127.0.0.1</span>;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           <span class="attribute">allow</span> <span class="number">172.18.5.54</span>; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="nginx特性"><a href="#nginx特性" class="headerlink" title="nginx特性"></a>nginx特性</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理，就是代理服务器替客户端去访问目标服务器。</p><p>在用户去访问目标服务器的时，<code>nginx</code>所在的服务器通过正向代理，作为中介服务器，将用户的访问指到目标服务器。</p><p>正向代理，代理的对象是客户端。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理针对的是目标服务器。</p><p>反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。</p><p>客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。</p><p>反向代理，代理的对象是服务器。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>配合反向代理，将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p><p>这适合于一些大型应用，通过反向代理+负载均衡，我们可以将单个服务器的压力分散到多个服务器。</p><p>在这些被代理的服务器集群中，如果某个服务器上的后台应用挂了，那么这些被代理压力可以被转移到其他服务器，而这个过程中，用户不会有感知，这是目前大多数大型企业web应用面对多用户访问的标准解法之一。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来负责解析，加快解析速度，降低原来单个服务器的压力。</p><p>简单的来说，就是静态的页面，代理到专门的静态页面处理</p><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><h5 id="实战一"><a href="#实战一" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器输入 <em><a href="http://www.abc.com/">www.abc.com</a></em> , 从 nginx 服务器跳转到 linux 系统 tomcat 主页面。</p><h6 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#/html目录</span></span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;  <span class="comment">#请求转向</span></span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;      <span class="comment">#设置默认页       </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实战二"><a href="#实战二" class="headerlink" title="实战二"></a>实战二</h5><h6 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h6><p>根据在浏览器输入的路径不同，跳转到不同端口的服务中</p><h6 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9000</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址       </span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example1/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:5000;         </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example2/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;         </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>location</strong> 指令说明：</p><ul><li><strong>~ :</strong> 表���uri包含正则表达式，且区分大小写。</li><li><strong>~* :</strong> 表示uri包含正则表达式，且不区分大小写。</li><li><strong>&#x3D; :</strong> 表示uri不含正则表达式，要求严格匹配。</li></ul><h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="实战一-1"><a href="#实战一-1" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器地址栏输入 <em><a href="https://link.juejin.cn/?target=http://192.168.4.32/example/a.html">http://192.168.4.32/example/a.html</a></em> ，平均到 5000 和 8080 端口中，实现负载均衡效果。</p><h6 id="具体配置-2"><a href="#具体配置-2" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   <span class="comment">#监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#html目录</span></span><br><span class="line">       <span class="attribute">index</span> index.html index.htm;  <span class="comment">#设置默认页</span></span><br><span class="line">       <span class="attribute">proxy_pass</span>  http://myserver;  <span class="comment">#请求转向 myserver 定义的服务器列表      </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx 分配服务器策略</strong></p><ul><li><p><strong>轮询</strong>（默认）</p><p> 按请求的时间顺序依次逐一分配，如果服务器down掉，能自动剔除。</p></li><li><p><strong>权重</strong><br> weight 越高，被分配的客户端越多，默认为 1。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span> weight=<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ip</strong><br> 按请求 ip 的 hash 值分配，每个访客固定访问一个后端服务器。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    ip_hash;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fair</strong></p><p> 按后端服务器的响应时间来分配，响应时间短的优先分配到请求。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    fair;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>nginx是运维人员常用的工具，严格意义上不是前端负责的区域。</p><p>但是随着最近面试难度的不断提升，再加上有时候人手紧缺，需要前端部署应用的时候，也许我们需要掌握这些技能，所以，有备无患，我梳理一下以前不成体系的知识框架。</p><p>不过，nginx这东西么，其实更多的都是想起来再用，个人感觉有点像前端开发中的UI工具库，平时很少有人会记着怎么用，一直都是到了使用的时候现场翻书。</p><p>所以，我后续可能不会对nginx太过深入吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7267003603095879714">写给前端同学的Nginx配置指南</a></p><p><a href="https://juejin.cn/post/6844904041542221832">从原理到实战，彻底搞懂Nginx</a></p><p><a href="https://juejin.cn/post/6844904046789132301">从原理到实战，彻底搞懂Nginx（高级篇）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。&lt;/p&gt;
&lt;p&gt;等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。&lt;/p&gt;
&lt;p&gt;现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://crazystudent13.github.io/tags/nginx/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解cookie，sessionStorage，localStorage</title>
    <link href="https://crazystudent13.github.io/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/"/>
    <id>https://crazystudent13.github.io/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/</id>
    <published>2024-07-01T14:32:43.000Z</published>
    <updated>2024-08-06T13:43:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie、sessionStorage和localStorage这些都是面试中问烂的问题，这里统一整理一下，便于后续</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Cookie、sessionStorage和localStorage都是Web存储机制，用于在用户的浏览器中存储数据。</p><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><ul><li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><h4 id="cookie-重要的属性"><a href="#cookie-重要的属性" class="headerlink" title="cookie 重要的属性"></a>cookie 重要的属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name&#x3D;value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td>**指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘**。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table><h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</strong></li></ul><p><img src="https://s2.loli.net/2024/07/01/cMNzOIbCZAT63LD.png" alt="QQ截图20240701225448"></p><h3 id="什么是localStorage"><a href="#什么是localStorage" class="headerlink" title="什么是localStorage"></a>什么是localStorage</h3><p>localStorage（本地存储） 允许你访问一个Document 的远端(Origin)对象的Storage；</p><p>Storage:Web Storage API的接口，Storage提供了访问特定域名下的会话存储(session storage)或本地存储(local storage) 的功能，例如可以添加、修改或删除本地存储的数据项。</p><p>localStorage 类似于sessionStorage。</p><p>localStorage：没有时间限制的数据存储，</p><p>seesionStorage：针对一个 session的数据存储即当页面会话结束，也就是说当页面被关闭时，数据存储在seesionStorage会被清除。</p><p>tips：无论数据存储在localStorage 还是sessionStorage，它们都特定于页面的协议，对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>localStorage相对于cookie，存储量大，一般的浏览器大概在PC在4M左右，手机端在2M左右</li><li>存储数据是永久的</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h4 id="localStorage与sessionStorage的区别"><a href="#localStorage与sessionStorage的区别" class="headerlink" title="localStorage与sessionStorage的区别"></a>localStorage与sessionStorage的区别</h4><p>localStorage与sessionStorage的唯一区别就是localStorage属于永久性存储。</p><p>sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空</p><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><p>上边提了localStorage与sessionStorage的区别，这里干脆把三者的区别放在一起比较。</p><h4 id="存储位置与大小限制"><a href="#存储位置与大小限制" class="headerlink" title="存储位置与大小限制"></a>存储位置与大小限制</h4><p><code>Cookie</code>，存储在客户端，即用户的浏览器中。由于Cookie是通过HTTP请求头在服务器和浏览器之间传输的，因此它们的大小有限制，通常不超过 4KB。大多数浏览器限制在20个，有的可能50个。</p><p> <code>sessionStorage</code>，也是存储在客户端的，但它是一个临时会话存储对象。sessionStorage没有严格的大小限制，但它仅在当前浏览器窗口或标签页中有效，并且当窗口或标签页关闭时，存储的数据会被自动删除。 </p><p><code>localStorage</code>，同样存储在客户端，并且提供了比Cookie更大的存储空间。一般来说，浏览器对localStorage的支持可以达到 5MB，这使得它可以存储更多的数据。</p><h4 id="数据有效期与持久性"><a href="#数据有效期与持久性" class="headerlink" title="数据有效期与持久性"></a>数据有效期与持久性</h4><p><code>Cookie，</code>可以设置过期时间，从而决定其在浏览器中的有效期。一旦过期，Cookie将被删除。</p><p> <code>sessionStorage</code>，数据在页面会话期间保持有效，当页面会话结束（例如关闭浏览器窗口或标签页）时，数据会被清除。它提供了一种在单个会话中跟踪用户数据的方式。</p><p> <code>localStorage</code>，存储的数据没有过期时间，它们会一直保留在浏览器中，直到被手动删除或清除缓存。</p><h4 id="与服务端的通信"><a href="#与服务端的通信" class="headerlink" title="与服务端的通信"></a>与服务端的通信</h4><p><code>Cookie</code>，会在每次HTTP请求中发送到服务器，因此它们可以用于在客户端和服务器之间传递数据。这种特性使得Cookie成为处理用户身份验证和会话管理的常用机制。</p><p> <code>sessionStorage</code> 和 <code>localStorage</code>，不与服务器的通信。它们主要用于在客户端存储数据，以便在后续的页面请求或用户交互中使用。</p><h4 id="数据共享与独立性"><a href="#数据共享与独立性" class="headerlink" title="数据共享与独立性"></a>数据共享与独立性</h4><p><code>Cookie</code>，对于同一域名下的网站，可以共享Cookie数据。</p><p> <code>sessionStorage</code>，数据在不同的窗口或标签页之间不共享。 </p><p><code>localStorage</code>，在整个浏览器实例中共享数据，无论打开多少个窗口或标签页，都可以访问到相同的localStorage数据。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>Cookie</code>，适用于需要在客户端和服务器之间传递小量数据的场景，如身份验证和会话管理； </p><p><code>sessionStorage</code>，适用于在同一浏览器窗口或标签页中存储临时数据的场景；</p><p> <code>localStorage</code>，则适用于需要在客户端长期存储大量数据的场景。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次仅仅只是简单的按照面试题标准说了一下这三者之间的区别，后续会专门出一篇内容，详细整理cookie与session在项目开发中的实际作用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904034181070861?searchId=202407012223169FB3FBAFB1729A23E3CC">傻傻分不清之 Cookie、Session、Token、JWT</a></p><p><a href="https://juejin.cn/post/7350143110495518770?searchId=202407012223169FB3FBAFB1729A23E3CC">Cookie、sessionStorage和localStorage的区别详解</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cookie、sessionStorage和localStorage这些都是面试中问烂的问题，这里统一整理一下，便于后续&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何选择入职公司</title>
    <link href="https://crazystudent13.github.io/2024/07/01/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%A5%E8%81%8C%E5%85%AC%E5%8F%B8/"/>
    <id>https://crazystudent13.github.io/2024/07/01/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%A5%E8%81%8C%E5%85%AC%E5%8F%B8/</id>
    <published>2024-07-01T04:42:25.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>以前一家公司做到底，从来没考虑那么多事，现在出来找工作找了这么久，真是大开眼界。</p><p>我这种大专崽没法指望好公司了，因为学历卡着根本进不去，不过相对来说，我还是可以考虑避免垃圾公司的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我不知道什么是好公司，但是我在各地被毒打了这么久，我一定知道什么是垃圾公司。</p><p>目前在江浙沪区域内找工作找了很久，这里根据之前我自己和朋友的经历，我自己做了个汇总。</p><h3 id="危险标准"><a href="#危险标准" class="headerlink" title="危险标准"></a>危险标准</h3><p>如果你碰到大概情况如下，要谨慎考虑，也许你的工作可能就危险了。</p><ul><li>拖欠或克扣工资，这种基本上是小地方的，一般大城市不会有这种情况，但是如果您到了山穷水尽的地步，一定要小心这种情况了。</li><li>五险没有一金，这种小地方常用的计俩，不会给你交一金，不为你的长远做着想的公司，很常见</li><li>不超过试用期辞退，你各方面可能干的都很好，但是不超过试用期就会被辞退，这种情况在小地方也很常见</li><li>项目赶工，强制占用下班时间，不服从就开除。</li><li>人事变动频繁，如果你了解到一家公司人员变动频繁，大概率可能会有你意向不到的问题。</li><li>办公环境差，有的地方办公环境整个楼层没有厕所（厕所放在办公室内），要么是楼层高度只有2m1左右（我一抬头就能看到天花板，很压抑），又或者仅有一个办公室，没有任何会议室之类，开会时候，办公环境极为嘈杂。（这都是中小公司凑活办公环境的问题）</li></ul><h3 id="公司配置"><a href="#公司配置" class="headerlink" title="公司配置"></a>公司配置</h3><p>我这里默认大家都是常规水平的开发人员，所以大家找的基本上都是成熟稳定的中小公司，而非那种大公司或者巨型公司。</p><p>这里分享一下我的辨识标准。</p><h4 id="人员规模"><a href="#人员规模" class="headerlink" title="人员规模"></a>人员规模</h4><table><thead><tr><th>规模（人）</th><th>备注</th></tr></thead><tbody><tr><td>0-20</td><td>初创公司，如果注册资本较低，且团队内没有成熟的开发人员，不要去，因为外行指导内行，很痛苦。</td></tr><tr><td>20-99</td><td>初具规模的初创公司，团队配置初步齐全，应该有了一定的业务线。</td></tr><tr><td>100-499</td><td>较为成熟的中大型公司，在地区可能叫得上名字了，能进去最好，不过未来晋升有压力，很可能做到项目经理就到头了。</td></tr><tr><td>499-1000</td><td>外包，纯纯的外包，不然这类公司定然都是国内叫得上名字的龙头企业。</td></tr></tbody></table><h4 id="是否双休"><a href="#是否双休" class="headerlink" title="是否双休"></a>是否双休</h4><ul><li>双休，最好的选择，这种工作在如今的环境中值得极度珍惜，哪怕是工资稍微少一些，因为空余的事件你可以用来自我精进，社交，养家，只要你有了自己的时间，你就可以做很多事。</li><li>大小周，勉强可以接受，前提是日常加班要少，这样虽然稍微辛苦一些，但是至少时间上只要规划好，也不至于损失太多。</li><li>单休，那你要考虑你的身体是否年轻，这笔钱是否能补得上这段时间的身体损失，单休。</li><li>月休，这种我们称之为黑奴</li></ul><h4 id="五险一金"><a href="#五险一金" class="headerlink" title="五险一金"></a>五险一金</h4><ul><li>五险很重要，如果没有五险的长期工作，不要去。因为人难免保证自己的身体问题，五险中的医保最重要了，一旦出什么事，医保可以报销太多了。</li><li>一金就是公积金，这个较为重要，如果没有一金的公司，要么他的工资高于本地的平均水准，要么在其他方面的待遇能提上去。</li><li>缴费比例，如果按照当地最低工资缴，那也算是不失本分，如果按照满额缴费，那公司就是绝对的好公司了，一定要珍惜。</li></ul><h4 id="核心产品"><a href="#核心产品" class="headerlink" title="核心产品"></a>核心产品</h4><p>这里按照重要性进行排序，如果您有兴趣，可以按照自己的需求进行对比，看看自己进入的是哪条线。</p><ul><li>拳头产品，有数条盈利的项目线，为了同时兼顾这么多项目线，公司有自己的核心产品，这条线很少有外人进去</li><li>核心项目，活跃期的项目，特别挣钱，是领导最重视的一条线，甚至某种程度高于核心产品，尤其是在前中期，项目活跃，需要你维护项目的新特性和功能。</li><li>项目翻新，一些末期的项目因为技术栈的缘故，特别难以维护，于是公司想要进行翻新，这种项目如果你前期进入，成为核心的把控者，那么你未来说不定会进阶为这个项目的核心成员。一个项目从零开始的翻新，会有很多难以想象的经验，对于没经验的新手来说，这个项目经验很不错。</li><li>稳定项目，项目的稳定期，只是偶尔需要你维护处理一些BUG，虽然轻松，但是没什么晋升空间。</li></ul><p>以上，是个人和一些朋友闲聊之后，个人总览了所有人的项目经验得出的结论。</p><p>不过，这都是常规的公司项目，至于大厂的核心项目，那种一般都是凤毛麟角的天骄才会接触到，大多数普本大专，很难接触到那些大厂的核心项目。</p><h3 id="三不找"><a href="#三不找" class="headerlink" title="三不找"></a>三不找</h3><p>三不找，是我根据公司类型做的大致画像，如果你要进入以下类型的企业，请酌情考虑。</p><ul><li>临时工，纯恶心人的工作，没什么人权的工作。</li><li>外包，大多数没有什么团队主导权，主要去其他团队内做技术支持，项目做完会将人可能直接踢掉。</li><li>初创，比较赌运气，老板要是懂行的，就好做事，要是不懂行的，哪怕人好也不顶用。</li></ul><p>这三类工作基本上都是有坑的，不仅仅是因为工作性质的问题，更是因为待遇实在太过不人道。</p><p>当然，如果你当前真的是走投无路了，这三条路将会是你迫不得已的最后选择，没什么可挑的。</p><p>现在这个环境没什么好挑的，有个工作比什么都重要。</p><h4 id="外包"><a href="#外包" class="headerlink" title="外包"></a>外包</h4><p>是因为外包太过没有人权，前公司工作有些时候去其他公司做技术支持，待遇也就比外包好点，有时候看到一些纯正的外包连喝水都小心翼翼的。</p><p>说实话，这种感觉真是糟糕透顶，外包人员难道是劳改犯？连喝水都得小心？</p><p>这种不被当人的感觉，个中滋味我不好说，但是只要做过，懂的都懂。</p><p>不过现在大环境实在是烂，没有办法，可以先当一段时间黑奴，后续随着时间推移再看看吧。</p><h4 id="临时工"><a href="#临时工" class="headerlink" title="临时工"></a>临时工</h4><p>临时工其实就是外包的变种，只不过未必是专职的外包公司，公司明明白白的说着后续不会给你转正，就是让你干这三个月，就问你做不做。</p><p>之所以不找这种的，主要原因就是这些业务线太过赶工，在这个分秒必争的时间段里，过了几个月被裁员之后，说不定出来之后更难找，无异于饮鸩止渴。</p><h4 id="初创"><a href="#初创" class="headerlink" title="初创"></a>初创</h4><p>是指那些0-20人的团队规模，待遇看着像是画大饼，连稳定的业务线都没有的初创公司。</p><p>这里，我并非是指代所有的初创公司，如果注册资金水平高，或者公司的初创领导者具有相当的领导水准，可以尝试考虑加入，选择赌一把。</p><p>这种初创公司一旦起飞了，后续你就是功臣元老，一般不犯什么惊天大错，不会辞退你。</p><p>不过，大多初创公司的老板多数是脑子一热的外行突然进场耍耍，要么是有些人不甘心想创业翻身。</p><p>初创公司太过于草莽，如果薪资给高了，那么平时工时就很恶心了，如果工时不夸张，那么就是薪资跟不上，如果各方面都能跟得上，那你要小心了，一旦老板说要拖工资，立刻跑路。</p><p>总之，不够稳定，是初创公司的最大的问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多人都整理了技术类的文档，但是很少有人去整理这些基础的找工作教程。</p><p>不过，很多人大概一路很顺，从校招开始就没有变过，类似我这种疯狂的经历，怕是很少。</p><p>如果我中间没什么变动，想来也不会写出这篇文档，想想我这一路，有时候真有种造化弄人的感觉。</p><p>这两年环境是如此艰难，技术上的卷似乎很大程度已经无法再获得更高的成就。</p><p>人生路远，且行且珍惜。于此，我浅浅将自己的部分经历写出，希望能帮到一些初入职场的新人。</p><p>祝大家人生一路精彩，安好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前一家公司做到底，从来没考虑那么多事，现在出来找工作找了这么久，真是大开眼界。&lt;/p&gt;
&lt;p&gt;我这种大专崽没法指望好公司了，因为学历卡着根本进不去，不过相对来说，我还是可以考虑避免垃圾公司的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解前端各种像素，em，rem等概念</title>
    <link href="https://crazystudent13.github.io/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
    <id>https://crazystudent13.github.io/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/</id>
    <published>2024-06-30T13:43:26.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>前端经典的em,rem，还有像素概念的问题，我发现很多说法都不统一，怎么说的都有，搞得我都有点不好抄统一的面试回答了。</p><p>干脆这里结合自己的理解，统一整理下，以便防止面试时候混乱。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于像素问题，几乎提到移动端适配这方面，这些基础概念就是在面试中绕不开的。</p><p>看了很多面试中都提到相关的问题，各种说法混乱无比，索性自己这里一把梭，把所有的概念都整理一下。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>我们实际开发中常说分辨率，但开发中说的内容可能指向的是不一样的内容。</p><h4 id="物理分辨率"><a href="#物理分辨率" class="headerlink" title="物理分辨率"></a>物理分辨率</h4><p>指的是显示屏的最高分辨率，又称标准分辨率。</p><p>屏幕实际存在的像素行数乘以列数的数学表达方式，是显示屏固有的参数，不能调节，其含义是指<strong>显示屏最高可显示的像素数</strong>。</p><p>我们实际使用过程，分辨率是可以改变的，比如我们手动将1920 * 1080的屏幕换成1600 * 900的分辨率，屏幕会按照你调整的要求，重新将屏幕切割为1600 * 900的像素点阵，形成新的分辨率。</p><p>不过，此时屏幕实际的物理分辨率依然还是1920 * 1080，这是屏幕自己固有的设备像素大小，并非我们可以手动调整的。</p><p>我们平时说的时候习惯性的说的分辨率，多数情况下都是指代最高分辨率，没什么人提你当前屏幕的分辨率是多少。</p><h4 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h4><p>正常来说，像素越大肯定是越清楚，但是这前提是要加个限定条件，那就是屏幕实际的大小要一样。</p><p>不然，物理分辨率同样是1920 * 1080的屏幕，一个尺寸是32寸，一个屏幕是100寸，实际显示效果确实一样的话，这怎么可能呢？</p><p>这里，就要引入一个概念：<strong>像素密度，ppi（pixels per inch）</strong>。</p><p>像素密度，表示沿对角线每英寸长度的像素数目（单位是dpi），越大显示的越细腻。</p><p>通过上边的例子，我们应该很快就能明白，像素密度的含义。</p><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p><strong>物理像素</strong>(px:physical pixel)又可以称为<strong>设备像素</strong>(dp:device pixel)</p><p>我们以实际设备屏幕举例，我们说的1920 * 1080的屏幕，实际上就是在说：宽度方向有1920个像素点，长度方向有1080个像素点。</p><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><blockquote><p>设备尺寸 × 像素密度 &#x3D; 物理分辨率（设备像素）</p></blockquote><p>这里举个例子：</p><p>iphone6s 对角线长度为5.5 英寸，像素密度401 dpi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。</p><p>5.5 * 401 &#x3D; 2205.5</p><p>这里说明白了这三者的关系，我们才好说明白接下来CSS的像素概念，即逻辑像素。</p><h3 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h3><p>CSS 的像素单位，其尺寸大小是相对的，也有称其为独立像素的，这里为了避免大家混乱，下边统一称呼CSS的像素为逻辑像素。</p><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p>提到<strong>逻辑像素(logical pixel)<strong>，也可以称为</strong>设备独立像素(dip : device independent pixel）</strong>。</p><p>当然，这两个名词我们大多数开发者可能都会陌生，实际上这里就是我们平常用到的CSS样式的像素单位。</p><h4 id="物理像素与逻辑像素的关系"><a href="#物理像素与逻辑像素的关系" class="headerlink" title="物理像素与逻辑像素的关系"></a>物理像素与逻辑像素的关系</h4><p>很多人这时候估计平时没有遇到过相关概念，所以一时间会有些懵，难道物理像素和逻辑像素有什么不同吗？难道我写了个100 * 100 的box，在小屏幕上就不是100 * 100了？</p><p>答案是：不是的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比武我们这里写了一个100 * 100的box，假设在物理分辨率为100*100的屏幕上，它以100 * 100的方式展示，1个逻辑像素，用1 * 1个物理像素来表示。</p><p>而在 400 * 400 的屏幕上，我们同样让这个BOX达到充满屏幕的效果，那就需要4 * 4个物理像素来表示。</p><p>后者因为用更多的物理像素来展示，所以看起来更清晰，更精细。</p><h4 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h4><p>我上边这个例子说的有个问题，为什么在有点屏幕上要以物理像素：css逻辑像素 &#x3D; 1 ：1 的比例展示，有的要以 4： 1的概念展示呢？</p><p>这里要引入一个概念：<strong>设备像素比（dpr : device pixel ratio）</strong>。不过这个说法也很混乱，我看很多整理的说法，有的说缩放比，也有说缩放因子的。</p><p>实际上，这就是物理像素与逻辑像素的比例概念。</p><p>我们这里为了接下来不混淆概念，统一就叫设备像素比。</p><p>1个css的逻辑像素，用更多的物理像素表示，那当时是比例越高，越清晰喽，如下例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标清屏：dpr = 2 / 2 = 1</span><br><span class="line">高清屏：dpr = 4 / 2 = 2</span><br></pre></td></tr></table></figure><p>因此，设备像素比越高，我们看到的网页也就越清晰，这也是为什么有时候我们看到有些手机实际屏幕很小，但看到页面的效果却很清晰。</p><p>屏幕虽小，但是实际物理分辨率和大屏一样，因此同样的网页，在更高的设备像素比的设备上显然看着更清晰，更细腻。</p><p>我们经常在设计师手中拿到的UI稿件，肯定会看到@1X，@2X，@3X，实际上就是这个就是指设备像素比。</p><blockquote><p>tips：逻辑像素相对于设备像素的放大比例，可通过window.devicePixelRatio获得，pc上可以用个个性化来设置，但二者并不完全等同。</p></blockquote><h4 id="禁用缩放"><a href="#禁用缩放" class="headerlink" title="禁用缩放"></a>禁用缩放</h4><p>提到上边的设备像素比的概念，有人可能会有疑问，按照这么说，岂不是我把页面用手势捏一下，就能改动页面的设备像素比？</p><p>是的，用户在移动端可以随意通过手势缩放网页，为了防止用户随意控制，我们便有了如下的操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">width // 设置 viewport 的宽度，正整数/字符串 device-width</span><br><span class="line">height // 设置 viewport 的高度，正整数/字符串 device-height</span><br><span class="line">initial-scale // 设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数</span><br><span class="line">maximum-scale // 设置最大缩放系数，0.0-10.0之间的正数</span><br><span class="line">minimum-scale // 设置最小缩放系数，0.0-10.0之间的正数</span><br><span class="line">user-scalable // 如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no</span><br></pre></td></tr></table></figure><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>因为不同设备的的dpi不同，有时候PC上看上去非常正常的页面，放在手机端可能就显得不正常。</p><p>为了做各端的适配，于是前端衍生出了一种概念，相对单位。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>上面提到，想让我们的网页在不同分辨率的设备（移动端）上正常显示，最好我们的元素长宽，外边距，内边距等都是动态的。</p><p>上面说到，我们在移动端一般这样设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width;initial-scale=1&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这个时候我们1px的大小就已知，iPhone6上为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1px</span> = <span class="number">1</span>/<span class="number">750</span>（分辨率） * <span class="number">2</span>（设备像素比） = <span class="number">1</span>/ <span class="number">375</span>。</span><br></pre></td></tr></table></figure><p>既然1px的大小固定了，那么我们只能动态改变一个元素设置的px了，比如说在iPhone8上是120px；而在iPhone6上需要是100px。</p><p>这时候我们可以用js去动态计算，根据屏幕大小。</p><p>但是显然很麻烦，需要对每一个元素的长宽，内边距，外边距都需要调整，这显然是一个巨大的工程。</p><p>这时候我们就可以用到em这个单位了，em单位的名称为相对长度单位，是根据它父元素的字体大小来计算的。</p><p>一般默认情况下：16px &#x3D; 1em，这里要插一嘴，有的远古面试官经常会问：为什么1em要等于16px？</p><blockquote><p>因为浏览器默认的字体大小都是16px，所以没有重新设置浏览器默认字体大小的话1em就等于16px。</p><p>在页面里要用到em作为单位的话，默认的<code>1em=16px</code>会使得在计算他们转换的值时非常不方便，比如我要把一个块里面的内容字体大小设置成18px，但我只想用em做为单位，那么情况就会这样，<code>1em=16px，1px=0.0625em</code>，得<code>18px=1.125em（0.0625em*18）</code>。</p><p>这太麻烦，所以为了简化px和em之间的换算，需要在body里定义<code>font-size:62.5%</code>，即将浏览器初始化为即<code>1em=10px</code>，这样的话，上面的<code>font-size:18px</code>就等于<code>font-size:1.8em</code>。</p></blockquote><blockquote><p>计算公式：1&#x2F;父元素font-size值*需要转换的px&#x3D;em值    (PS:父元素font-size的单位没有关系，无论px还是em)</p></blockquote><p>这是早期的适应方式，当所有单位都采用em时，我们只需要改变body的 font-size，那么其他子元素宽度就能动态变化了，显然方便很多。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem是CSS3新增的一个相对长度单位，它的出现是为了解决em的缺点，em可以说是相对于父级元素的字体大小，当父级元素字体大小改变时，又得重新计算。</p><p>rem出现就可以解决这样的问题，rem只相对于根目录，即HTML元素。</p><p>有了rem这个单位，我们只需要通过JS调整根元素html的font-size就能达到所有元素的动态适配了，这里附上一段常用适配代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ================================================</span></span><br><span class="line"><span class="comment">    *   设置根元素font-size</span></span><br><span class="line"><span class="comment">    * 当设备宽度为375(iPhone6)时，根元素font-size=16px; </span></span><br><span class="line"><span class="comment">    × ================================================</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">doc, win</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = win.<span class="property">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="keyword">var</span> resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> refreshRem = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientWidth = win.<span class="property">innerWidth</span></span><br><span class="line">                      || doc.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">                      || doc.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clientWidth)</span><br><span class="line">    <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> fz;</span><br><span class="line">    <span class="keyword">var</span> width = clientWidth;</span><br><span class="line">    fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!doc.<span class="property">addEventListener</span>) <span class="keyword">return</span>;</span><br><span class="line">  win.<span class="title function_">addEventListener</span>(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">refreshRem</span>();</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">document</span>, <span class="variable language_">window</span>);</span><br></pre></td></tr></table></figure><h4 id="vh，vw"><a href="#vh，vw" class="headerlink" title="vh，vw"></a>vh，vw</h4><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。</p><p>vw 始终是针对窗口的宽，同理，<code>vh</code>则为窗口的高度。</p><p>这里的窗口分成两种情况</p><ul><li>在桌面端，指的是浏览器的可视区域</li><li>移动端指的就是布局视口</li></ul><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素，而<code>vw</code>、<code>vh</code>相对的是指代当前窗口。</p><h3 id="适配方案分析"><a href="#适配方案分析" class="headerlink" title="适配方案分析"></a>适配方案分析</h3><p>无论是哪种方案，本质上都是为了解决移动端适配的问题。</p><p>这里本来打算自己整理一下各种方案的优劣，没想到有人已经整理好了，而且非常详尽：<a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a>。</p><p>虽然是数据大屏的方案整理，但是已经够用了。</p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>vw vh</strong></td><td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td><td>1.可以动态计算图表的宽高，字体等，灵活性较高 2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td><td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td></tr><tr><td><strong>scale</strong></td><td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td><td>1.代码量少，适配简单 2.一次处理后不需要在各个图表中再去单独适配</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况  2.当缩放比例过大时候，字体会有一点点模糊，就一点点  3.当缩放比例过大时候，事件热区会偏移。</td></tr><tr><td><strong>rem + vw vh</strong></td><td>1.获得 rem 的基准值 2.动态的计算<code>html根元素的font-size</code> 3.图表中通过 vw vh 动态计算字体、间距、位移等</td><td>1.布局的自适应代码量少，适配简单</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些基础概念，如果不是深入研究移动端适配的人，应该不会去深入了解，毕竟这都算是以前的老古董知识了。</p><p>实际开发中，移动端大多数中小厂商为了节省成本，应该是用Uni-app一把梭，直接用rpx完成移动端单位的适配。</p><p>甚至有些项目为了图省事的，直接用px糊弄了事，很少有人去实际操心适配的问题，毕竟多数都是为了赶工期。</p><p>这里今天整理一下，也算是梳理以前有些混乱的知识体系，把以前脑海中各种混乱的名称做了个整合，心情也算是颇为舒畅。</p><p>不过，关于移动端的适配，我这里只是浅浅聊了一下，后续有时间会逐步整理相关的知识，防止面试官去面试这些乱七八糟的考验广度的面试题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="px/em/rem%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8">px&#x2F;em&#x2F;rem的区别与应用</a></p><p><a href="https://juejin.cn/post/7125603588084072455?searchId=2024063013543065534144521E4587DF9D">【CSS】一文搞懂 em、px、rem、vh、vw 的区别！</a></p><p><a href="https://blog.csdn.net/qq_30811721/article/details/106326253">px&#x2F;em&#x2F;rem的关系与区别_不同分辨率的设备上,1px的大小是不一样的-CSDN博客</a></p><p><a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端经典的em,rem，还有像素概念的问题，我发现很多说法都不统一，怎么说的都有，搞得我都有点不好抄统一的面试回答了。&lt;/p&gt;
&lt;p&gt;干脆这里结合自己的理解，统一整理下，以便防止面试时候混乱。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="css" scheme="https://crazystudent13.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，工具文档托管</title>
    <link href="https://crazystudent13.github.io/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/"/>
    <id>https://crazystudent13.github.io/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/</id>
    <published>2024-06-28T11:43:58.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，我们经常会整理一下业务文档或者工具文档供团队参考使用，这就是简单的前端基建工程。</p><p>以前是由公司运维来处理这活，现在脱离团队了，只能自己来了，正好这块不熟悉，统一整理一下吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次记录算是一个面向新手的简化版教程，这里默认大家都有一台服务器，一个简单的前端页面，都会用各自的SSH工具。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>为了保证大家都能顺利走完流程，这里先列一下需要用到的东西。</p><h4 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h4><ol><li>优先双核的服务器，虽然单核凑活也能用，但是如果同时访问人数一旦较多，单核的效率很容易产生卡顿，所以还是双核比较好</li><li>优先香港或者亚洲区服务器，不然域名绑定的时候，大陆服务器需要服务器备案，来回走流程会很麻烦</li><li>优先选择linux服务器，因为便宜，环境干净，而且相关的教程很多。当然，你也可以选择window服务器，不过同样的配置，window服务器更贵，且win系统因为自带图形界面，所以相对系统会吃掉更多的硬盘空间，所以，普遍推荐linux服务器。</li><li>优先选择腾讯云的服务器，控制台更简单更好操作，虽然安全配置不高，但是效果不错。如果经济条件允许，可选阿里云，会比腾讯云稍微贵一些。</li><li>新用户优先购买长期，所有的服务器供应商都喜欢新用户，优惠力度最大，如果你是新用户购买，能买多久就买多久，最好选个四核的，四核服务器甚至可以用来部署一些游戏的私服，并且体验相当不错。</li></ol><h4 id="SSH工具"><a href="#SSH工具" class="headerlink" title="SSH工具"></a>SSH工具</h4><p>SSH工具就是能够让你在本地电脑访问云服务器的工具。</p><p>因为linux不需要什么图形化界面，所以很多人都喜欢用SSH工具直连服务器，通过命令行操作。</p><p>我个人推荐<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，个人觉得它比FinalShell，Xshell，PUTTY这三个工具好用。</p><p>不过mobaxterm的免费版的连接数有上限，只能存10个服务器地址，如果一个人需要管理很多服务器，要么付费要么换一个吧。</p><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>一个有着<code>index.html</code>的前端页面，当然，名字并非是强制要求，只是大家都习惯了，于是约定俗成的以<code>index.html</code>为准。</p><h3 id="Nginx服务器安装"><a href="#Nginx服务器安装" class="headerlink" title="Nginx服务器安装"></a>Nginx服务器安装</h3><p>我们暂时先别管什么是Nginx，我们只要配置好Nginx，后续就可以将配置托管到服务器上。</p><p>服务器系统推荐centOS7.6，虽然这个版本的系统有点老，但是折腾的人最多，所以遇到什么问题都能找到对应的解决方案。</p><p>这里需要略懂一点linux的常规操作，如果不清楚的，推荐看文：<a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a>，这篇文章介绍的流程要比我目前的操作详细的多，我这里只是简洁版。</p><h4 id="vim编辑nginx-repo"><a href="#vim编辑nginx-repo" class="headerlink" title="vim编辑nginx.repo"></a>vim编辑nginx.repo</h4><p>输入以下指令，然后按回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>按<code>i</code>键进入编辑模式，底部出现“插入”则说明成功进入编辑模式</p><p>复制以下代码，粘贴进去（注意别用ctrl+v粘贴，在finalshell里点击鼠标右键，然后选择粘贴）</p><p>注意每行开头不能有空格，否则可能会报错（vim编辑器不适用左键改变光标位置，可以通过上下左右控制）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nginx-stable]</span></span><br><span class="line"><span class="attr">name</span>=nginx stable repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[nginx-mainline]</span></span><br><span class="line"><span class="attr">name</span>=nginx mainline repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 复制完确认没问题后，点击键盘上的esc退出编辑模式，然后输入:wq保存并退出 Vim 编辑器（注意输入法一定要是英文模式，不要因为<code>:</code>的中英文区别报错）</p><h4 id="输入指令安装nginx"><a href="#输入指令安装nginx" class="headerlink" title="输入指令安装nginx"></a>输入指令安装nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><h4 id="安装完之后查看nginx状态"><a href="#安装完之后查看nginx状态" class="headerlink" title="安装完之后查看nginx状态"></a>安装完之后查看nginx状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>如果控制台报的命令如下，这个说明nginx已经安装成功，但是未启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-centos#systemctl status nginx</span><br><span class="line">nginx.service -nginx-high performance web server</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">Active:inactive(dead)</span><br></pre></td></tr></table></figure><p>现在启动一下nginx，启动后再次查看nginx状态，出现active (running)说明启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p>查看80端口是否被nginx占用，然后在浏览器地址栏直接访问你的公网ip地址，如果出现nginx提示，则说明nginx已经配置OK。</p><blockquote><p>注意，80端口是http协议的默认端口，如果你没有配置好<code>https</code>，这里外部访问的时候，记得要用<code>http:// </code>开头访问，否则会访问无效。</p></blockquote><h3 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h3><p> 在你的电脑上新建一个文本文档，重命名为nginx.conf，用记事本打开，然后把以下内容粘贴进去</p><p>这里注意配置重点，下边这个配置是让你的目录设置，是为了让外部访问目录能指向你的服务器文件位置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/index.html</span><br></pre></td></tr></table></figure><p>就比如我上边用locahost本地的访问的<code>/index.html</code>，这个按照下方配置后，就是访问<code>/usr/local/dist/index.html</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /usr/local/dist<span class="comment">;</span></span><br><span class="line">    index index.html<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root配置根目录，index配置入口文件。</p><p>打包好的文件需要放到usr下的local文件夹内，我这边前端打包生成的文件是dist,所以root配置为&#x2F;usr&#x2F;local&#x2F;dist。</p><p>我这里需要配置两个文档托管，于是就采用了根据次级域名转换到不同文件目录的方式，根据次级域名（也有叫二级域名的）不同而指向不同的资源，从而访问不同的内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line">user nginx<span class="comment">;</span></span><br><span class="line">worker_processes auto<span class="comment">;</span></span><br><span class="line">error_log /var/log/nginx/error.log<span class="comment">;</span></span><br><span class="line">pid /run/nginx.pid<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user <span class="section">[$time_local]</span> &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    sendfile            on<span class="comment">;</span></span><br><span class="line">    tcp_nopush          on<span class="comment">;</span></span><br><span class="line">    tcp_nodelay         on<span class="comment">;</span></span><br><span class="line">    keepalive_timeout   65<span class="comment">;</span></span><br><span class="line">    types_hash_max_size 2048<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types<span class="comment">;</span></span><br><span class="line">    default_type        application/octet-stream<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  cattools.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/dist<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  lintdoc.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/lintdoc<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers PROFILE=SYSTEM;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入&#x2F;etc&#x2F;nginx目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br></pre></td></tr></table></figure><p>将目录下原有的nginx.conf拷贝一份（注意刷新一下才会显示）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> nginx.conf nginxCopy.conf</span><br></pre></td></tr></table></figure><p>备份旧配置（这一步不是必然，但是出于运维的好习惯，凡事留备份）</p><p>删除目录下的nginx.conf，然后将本地电脑上的nginx.conf上传到目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f nginx.conf</span><br></pre></td></tr></table></figure><h3 id="重启发布"><a href="#重启发布" class="headerlink" title="重启发布"></a>重启发布</h3><p>将静态文件发布到<code>/usr/local</code>目录下，因为我们直接配置的是dist文件夹，这里我们需要将dist整个文件夹发到<code>/usr/local</code>目录下。</p><p>发布完成之后，重启nginx，读取新的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>为了保险，我们可以查看一下发布之后的效果，有绿色的（active）代表发布成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>将下方的ip地址替换为自己的服务器地址，就可以访问到自己发布的前端页面了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip地址/index.html</span><br></pre></td></tr></table></figure><p>如果不想要用IP地址在外访问，我这里就用二级域名绑定了自己服务器IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://cattools.crazystudent13.cn</span><br><span class="line">http://lintdoc.crazystudent13.cn</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为前端基建的必然基石，像这种通用的工具文档部署是必然的需求。</p><p>团队化作战的过程中，我们肯定会在现代开发过程中遇到部署这些文档，这是一件绕不开的事。</p><p>这次是一次简单的部署，后续会持续集成，完成自动化部署的流程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发过程中，我们经常会整理一下业务文档或者工具文档供团队参考使用，这就是简单的前端基建工程。&lt;/p&gt;
&lt;p&gt;以前是由公司运维来处理这活，现在脱离团队了，只能自己来了，正好这块不熟悉，统一整理一下吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://crazystudent13.github.io/tags/nginx/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解link与import的区别</title>
    <link href="https://crazystudent13.github.io/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-06-27T11:21:12.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>朋友：最近听说你在整理面试题？那我考考你，css样式的引入，link和import有什么区别？</p><p>我：你他妈疯了？这哪怕是五年前也是很少有人问到的，现在都是直接打包压进去的，你问我这个？</p><p>朋友：这关系到你的基础牢不牢靠，万一面试官问了呢。</p><p>我：你他妈就是一个大傻逼。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>尽管这道面试题是五年前的老古董了，这个问题放在五年前都是冷门问题。</p><p>在当初已经盛行前端工程化的时代了，这种问题实在是没有必要放在嘴边，样式都拆到项目里边了，谁管你最后是怎么引入的呢。</p><p>但是，问都问了，索性看看整理一下吧。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>二者毫无问都是引入CSS样式，我们没必要找什么共性，直接看看区别吧。</p><h4 id="从属关系"><a href="#从属关系" class="headerlink" title="从属关系"></a>从属关系</h4><ul><li>link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 </li><li>@import是 CSS 提供的语法规则，只有导入样式表的作用；</li></ul><h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><ul><li>link标签引入的 CSS 被同时加载；</li><li>@import引入的 CSS 将在页面加载完毕后被加载。</li></ul><h4 id="兼容性区别"><a href="#兼容性区别" class="headerlink" title="兼容性区别"></a>兼容性区别</h4><ul><li>link标签作为 HTML 元素，不存在兼容性问题。 </li><li>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；</li></ul><h4 id="DOM可控性区别"><a href="#DOM可控性区别" class="headerlink" title="DOM可控性区别"></a>DOM可控性区别</h4><ul><li>可以通过 JS 操作 DOM ，插入link标签来改变样式；</li><li>由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</li></ul><h4 id="权重区别"><a href="#权重区别" class="headerlink" title="权重区别"></a>权重区别</h4><p>link引入的样式权重大于@import引入的样式。（相同的类名或者标签名，而不是含有!important之类的才生效）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>尽管现在我们不怎么需要关注了，但有时候项目工程化打包会遇到二者优先度或其他问题，这里备注下。</p><blockquote><p>@import一定要写在除@charset外的其他任何 CSS 规则之前，如果置于其它位置将会被浏览器忽略。</p><p>而且，在@import之后如果存在其它样式，则@import之后的分号是必须书写，不可省略的</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>2024年了，还问这种问题的面试官就是纯纯的大傻逼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903890832326664?searchId=2024062719174374BA1A8A291721F074D7">link和@import的区别 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朋友：最近听说你在整理面试题？那我考考你，css样式的引入，link和import有什么区别？&lt;/p&gt;
&lt;p&gt;我：你他妈疯了？这哪怕是五年前也是很少有人问到的，现在都是直接打包压进去的，你问我这个？&lt;/p&gt;
&lt;p&gt;朋友：这关系到你的基础牢不牢靠，万一面试官问了呢。&lt;/p&gt;
&lt;p&gt;我：你他妈就是一个大傻逼。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="css" scheme="https://crazystudent13.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解域名等级</title>
    <link href="https://crazystudent13.github.io/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/"/>
    <id>https://crazystudent13.github.io/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/</id>
    <published>2024-06-24T15:37:09.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>我：买了个新服务器，又得买个域名挂靠了，有点太费钱，有没有什么好办法？</p><p>朋友：为什么要买新域名？用二级域名处理一下就可以了。</p><p>我：什么是二级域名？</p><p>朋友：远川同学，你这块的知识有点水啊，你要不去补一下，以后面试可有点够呛。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近刚买了一个服务器，本想买新域名挂在服务器上，然后和朋友说了一下，他说你可以用二级域名。</p><p>关于二级域名这种说法，以前工作中偶尔听到，当时都是由运维的朋友来处理，我很少操心这些事。</p><p>自考有关计算机网络原理的部分，并未提及相关内容，于是我自考中也没了解过相关知识。</p><p>幸亏被朋友点了我一下，不然要是被面试官问到了，那还是真是愧对我这五年经验。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><h4 id="什么是DNS解析"><a href="#什么是DNS解析" class="headerlink" title="什么是DNS解析"></a>什么是DNS解析</h4><p>先说DNS解析，我们浏览器输入域名，就可以直接渲染出我们需要的页面。</p><p>做前端的都是知道，这其中有一个很重要的步骤：域名解析，又叫DNS解析，域名解析就是由域名查找到 IP 的过程。</p><p>域名解析的工作由DNS服务器完成。</p><p>简单了来说，域名实际上就是一个IP的昵称，我们通过DNS服务器去打听这个昵称是哪个IP，最后锁定IP，然后访问对应的机器。</p><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>已知一个域名，先会访问根域的DNS服务器，全球一共有13台根域名服务器，根域名服务器储存了负责每个顶级域（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>拿到顶级域名服务器地址后，访问得到二级域名的域名服务器地址信息，以此类推，直到最终确定某个 IP 地址。</p><p>常见的解析方式有三种：A记录解析、CNAME记录解析、MX记录解析。</p><p>如果我们新增、减少了 DNS 解析记录，正常情况下的 TTL 是10 min。</p><h3 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h3><p>前边我们提到了域名的根服务器，这里详细解释下根域名的定义。</p><blockquote><p>根域是指整个互联网的最高层级，位于所有的顶级域名之上。</p></blockquote><p>它没有任何域名前缀，只有一个点号。</p><p>例如，在某些场合，<code>www.baidu.com</code>被写成<code>www.baidu.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p>根域由互联网的根服务器组成，这些服务器负责解析所有的顶级域名（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>理论上，所有<a href="https://cloud.tencent.com/act/pro/domain-sales?from_column=20065&from=20065">域名查询</a>都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p><p><strong>根域名服务器</strong>是 13个 固定 <strong>ip</strong> 所组成服务器群的简称，它保存的只是所有<strong>一级域名服务器</strong>的 <strong>ip</strong> 地址信息。</p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>顶级域名，也叫一级域名。</p><p>域名最后面的那一部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 .com 就是顶级域名，又叫一级域名。</p><p>顶级域名分为国际顶级域名、国家顶级域名。</p><h4 id="国际顶级域名（gTLD）"><a href="#国际顶级域名（gTLD）" class="headerlink" title="国际顶级域名（gTLD）"></a>国际顶级域名（gTLD）</h4><p>这里列举一下我们常见的域名，如下这种指向各种机构的域名，共有700多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.com</td><td>工商企业</td></tr><tr><td>.net</td><td>网络提供商</td></tr><tr><td>.org</td><td>非盈利组织</td></tr><tr><td>.gov</td><td>政府网站</td></tr><tr><td>.edu</td><td>教育机构</td></tr></tbody></table><p>为了解决域名紧张的问题，后来也引入了一些其他的顶域</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.firm</td><td>公司企业</td></tr><tr><td>.store</td><td>销售公司或企业</td></tr><tr><td>.web</td><td>突出WWW活动的单位</td></tr><tr><td>.arts</td><td>突出文化、娱乐活动的单位</td></tr><tr><td>.rec</td><td>突出消遣、娱乐活动的单位</td></tr><tr><td>.info</td><td>提供信息服务的单位</td></tr><tr><td>.nom</td><td>个人</td></tr></tbody></table><h4 id="国家顶级域名（ccTLD）"><a href="#国家顶级域名（ccTLD）" class="headerlink" title="国家顶级域名（ccTLD）"></a>国家顶级域名（ccTLD）</h4><p>另一类是国别顶级域名（ccTLD），这种指向国家地域的域名，总共有300多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.cn</td><td>中国</td></tr><tr><td>.us</td><td>美国</td></tr><tr><td>.jp</td><td>日本</td></tr><tr><td>.cc</td><td>科科斯群岛</td></tr></tbody></table><h3 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h3><p>一级域名左侧的部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 baidu 就是二级域名。</p><p>国际顶级域名下二级域名，一般是指域名注册人选择使用的网上名称，如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 中的 baidu 。</p><p>国家顶级域名下二级域名，一般是指类似于国际顶级域名的表示注册人类别和功能的标志，例如com，edu，gov，net等如：<a href="https://link.juejin.cn/?target=https://www.moe.gov.cn">www.moe.gov.cn</a> 中的 gov，其实可以发现 <a href="https://link.juejin.cn/?target=https://www.baidu.com.cn">www.baidu.com.cn</a> 也是可以访问到的，这个时候的二级域名就是 .com ，但是会被重定向到 <a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 。</p><p>这里的二级域名并不是朋友说的二级域名，这里的二级域名，实际上是我们买的域名，譬如我个人的博客域名：<a href="https://crazystudent13.cn/">crazystudent13.cn</a>，这里的crazystudent13就是二级域名。</p><h3 id="三级域名"><a href="#三级域名" class="headerlink" title="三级域名"></a>三级域名</h3><p>三级域名可以当做是二级域名的子域名，比如：<a href="https://link.juejin.cn/?target=https://naotu.baidu.com">naotu.baidu.com</a> ，对于使用者而言，三级域名都是二级域名的附属物而无需单独费用，四级域名等依次类推即可。</p><p>又如：<a href="https://link.juejin.cn/?target=http://www.neea.edu.cn/">www.neea.edu.cn</a> 中的 neea (教育考试网)。</p><p>所以严格意义上，朋友说的二级域名的说法是不对的，正常的来说，应该是三级域名了，也有说法叫次级域名。</p><h3 id="域名风险"><a href="#域名风险" class="headerlink" title="域名风险"></a>域名风险</h3><p>这个知识属于拓展了，因为我们偶尔访问一些页面失效的时候，经常会听网上传言说是DNS污染或者DNS劫持。</p><p>那这里干脆顺便讲一下，就当是相关知识拓展。</p><h4 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h4><p>DNS又称<strong>域名服务器缓存投毒</strong>，是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。</p><p>简单的来说，就是域名服务器内IP和域名的指向被其他人投了错误的数据包，导致指向错误了，就像一个人的昵称和本人对不上，这样自然会导致访问错误。</p><p>一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><p>这种污染基本上是大范围的，批量的，并不是针对某个网站，而是某片网域的污染。</p><p>通常对于DNS污染，一般除了使用代理服务器和VPN之类的软件之外，我们并没有什么还办法，大多数人只能干等域名供应商将污染的数据恢复。</p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>了解了域名的一些知识，我们经常听到的一个名词：域名劫持（DNS 劫持）。</p><p>正常的流程应该是我们根据域名，访问正确的 DNS 解析服务器来获取我们最终的 IP。但如果让用户访问到的错误的 DNS 解析服务器上，返回错误的 IP，让用户展示攻击者指定的页面，这就是域名劫持了。</p><p>经典案例就是有的年久不用的网站，被他人恶意劫持，指向了某个黄色网站，这类事情发生的很多，尤其是国内很多政府网站，早年没有什么网安，也没人关注这类门面网站，发生这种事很常见。</p><p>相对于DNS污染那种大范围破坏来说，DNS劫持目标更单一，就是针对某个网站的恶意行为。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个不算面试题，只是个普通知识拓展，后续随着计算机网络知识的了解，会不断丰富相关知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904192868352007">域名等级、DNS域名解析</a></p><p><a href="https://cloud.tencent.com/developer/article/1147777">根域名的知识</a></p><p><a href="https://developer.baidu.com/article/detail.html?id=2594936">域名解析：顶级域名、根域&#x2F;二级域名、一级域名&#x2F;子域名解析</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我：买了个新服务器，又得买个域名挂靠了，有点太费钱，有没有什么好办法？&lt;/p&gt;
&lt;p&gt;朋友：为什么要买新域名？用二级域名处理一下就可以了。&lt;/p&gt;
&lt;p&gt;我：什么是二级域名？&lt;/p&gt;
&lt;p&gt;朋友：远川同学，你这块的知识有点水啊，你要不去补一下，以后面试可有点够呛。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="网络原理" scheme="https://crazystudent13.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>解决git SSL certificate problem</title>
    <link href="https://crazystudent13.github.io/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/"/>
    <id>https://crazystudent13.github.io/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/</id>
    <published>2024-06-24T04:38:07.000Z</published>
    <updated>2024-08-06T13:43:32.868Z</updated>
    
    <content type="html"><![CDATA[<p>提交项目代码到github上的时候，突然就报了这个问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实是个很简单的问题，只是以前没遇到过，所以不知道怎么处理。</p><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>这个错误表明Git在尝试通过HTTPS进行通信时，遇到了SSL证书验证问题。</p><p>具体来说，Git客户端无法获取到用于验证本地颁发者证书的信息。</p><p>这通常发生在Git客户端没有正确配置或者没有本地证书文件的情况下，尤其是在自签名的证书或者是过期的证书文件缺失的情况下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git SSL certificate problem: unable to get local issuer certificate</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一：忽略验证"><a href="#方案一：忽略验证" class="headerlink" title="方案一：忽略验证"></a>方案一：忽略验证</h4><p>使用Git的配置选项来忽略SSL证书验证（不推荐，因为这会降低通信的安全性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><h4 id="方案二：更新CA证书库"><a href="#方案二：更新CA证书库" class="headerlink" title="方案二：更新CA证书库"></a>方案二：更新CA证书库</h4><p>确保系统中安装了正确的CA证书。</p><p>在Linux系统中，你可以通过更新CA证书库来解决问题。</p><p>如果是自签名的证书，你可以将服务器的证书添加到Git的信任列表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslCAInfo /path/to/certificate.pem</span><br></pre></td></tr></table></figure><p>如果你使用的是代理服务器，请确保代理服务器的SSL证书是有效的，或者配置Git以跳过代理的SSL验证。</p><p>更新Git到最新版本，以确保包含最新的证书信息。</p><p>如果问题仍然存在，可以考虑使用SSH方式克隆或者拉取远程仓库，从而绕过HTTPS的SSL验证问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个常规的CA证书验证问题，但是平时很少遇到，所以这里记录一下，如果后续遇到，方便排查。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_44014995/article/details/109900149">解决：git SSL certificate problem: unable to get local issuer certificate</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提交项目代码到github上的时候，突然就报了这个问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://crazystudent13.github.io/tags/github/"/>
    
    <category term="疑难杂症" scheme="https://crazystudent13.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>2024年，第一回在徐州破防了</title>
    <link href="https://crazystudent13.github.io/2024/06/23/2024%E5%B9%B4%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%9C%A8%E5%BE%90%E5%B7%9E%E7%A0%B4%E9%98%B2%E4%BA%86/"/>
    <id>https://crazystudent13.github.io/2024/06/23/2024%E5%B9%B4%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%9C%A8%E5%BE%90%E5%B7%9E%E7%A0%B4%E9%98%B2%E4%BA%86/</id>
    <published>2024-06-23T10:21:28.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>在徐州呆了快三个月，基本可以确定徐州就是一个根本不能待的垃圾城市。</p><p>自行车被偷只是我爆发的一个诱因，总的来说，破防的原因是多方面的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说实话，以前很多觉得无所谓的事情，在徐州这边真的是被成倍的放大。</p><p>我做梦都没想到徐州已经烂成这个样子了。</p><h3 id="中介套路深"><a href="#中介套路深" class="headerlink" title="中介套路深"></a>中介套路深</h3><p>到一个地方肯定要租房，因为对地方不熟，所以还是得找中介。</p><p>安居客上边的中介，放着好看的房照，然后实际带你过去，那地方烂的要死，这也是常态，没什么可说的。</p><p>按照套路，中介人又会带你看几个缺陷比较明显的房子，要么很贵，要么地方很偏，要么周围住宿人员素质低。</p><p>这时候肯定你会打听有没有性价比更高的房子，然后他会说平台上的房子已经没了，但他手里有一些房子，你有没有兴趣。</p><p>这也是熟悉的套路了，没啥好说的，然后跟着去看了一下。</p><p>说实话，他手里的这些房源一个比一个烂不说，他要价还特别不老实，和我目前住的地方差不多的水平，要价800，在徐州，这个水平多少有点坑人了。</p><p>然后连续看了几个，我感觉他介绍的房子都不行，然后我打算走了。</p><p>这时候，我没料到的套路来了，中介说他带我看了这么久，多少要有点辛苦费吧？不多，给个500就行。</p><p>我：？？？？不是，哥们儿这就是你的工作啊？我没看上你手里的房源，你还问我要幸苦费？你多少有点过了吧？</p><p>他还不是那种油腻中年人，就是普通的00后小年轻，这个态度几乎让我以为自己碰到了哪来的油腻中年人了。</p><p>我感觉自己遇到讹人的了，然后就打算报警，然后他又改口说自己这不算是辛苦费，就是一个推荐费，后续有好的房源还是回通知我的。</p><p>呵呵，多少有点不讲理了，为此差点和他掐了起来，说实话这是头一回在外边遭遇这种中介。</p><h3 id="城市基建极度不合理"><a href="#城市基建极度不合理" class="headerlink" title="城市基建极度不合理"></a>城市基建极度不合理</h3><p>从老城区到工作地方并不远，差不多近4公里，开车和骑车差不多要半小时才能到。</p><p>在人流量最大的地方，车道居然是双车道（火车站老城区大马路），这种环境，这样的通勤状态可想而知。</p><p>不仅如此，很多大型CBD根本没有合理的安排，周围的停车位，不说供机动车停了，电动车的停留位置都不够。</p><p>那肉眼可见的稀少车位，我都不知道设计者一开始是怎么想的。</p><p>每回上下班，看着停车位上一排排的电动车，简直难蚌。就这，密度还是小了，一栋楼近40层的楼到底能容纳多少人，这当时做规划估计也没人去算，现在周围就放这么点停车位，不知道的还以为是供苍蝇趴窝呢。</p><p>车道，停车位，还有之前提到的不合理的小吃街，更糟心的就是那稀少的公厕，河道两岸那些不明排泄物，到底是人还是狗排，懂的都懂。</p><p>新城区我还没去逛，本来打算骑自行车去的，这下自行车也丢了，简直把我整笑了。</p><h3 id="人流太杂"><a href="#人流太杂" class="headerlink" title="人流太杂"></a>人流太杂</h3><p>平均几步路一个足浴店，足浴店里边的姑娘挺年轻，这种还有二楼的，一眼看着就不是什么正经地儿我就不说了。</p><p>还有周围喧闹嘈杂的环境，老城区毕竟还是落寞了，我没什么好说的。</p><p>但是再怎么落寞，这街上还有打架的，还有那种撒泼的疯子（真的是神经不正常的那种疯）。</p><p>不过，也不全是这种人，也有很多漂亮的妹子，年轻的正经小哥。</p><p>大马路附近，大规模的待业工人在街上像是需要被挑选的牲口（可能我有些极端化了，但是说实话，当你看到这些人在阴凉地等工作的时候，真的就是这么个感觉）。</p><p>这种混杂的人员，给我一种莫名的荒诞感，徐州就是这么个朋克的城市吧。</p><h3 id="平均工资低"><a href="#平均工资低" class="headerlink" title="平均工资低"></a>平均工资低</h3><p>基本上大多数人的工资基本只能勉强够活。</p><p>根据目前的观察，3-4k是大多数人的常规工资，基本上只是是服务生一类的工作就可以做到。</p><p>如果高于4000，那么偶尔可以改善生活，如果高于5000，那么相对滋润一些。</p><p>高于6000，大概是人，勉强可以有一些娱乐的资本。</p><p>如果高于7000，大概就是T1，人上人的入门水准。</p><p>如果高于8000，那就是正经的人上人了。</p><p>虽然徐州整体物价低，但是我这个技术水平放在徐州居然只能值这个价格，真的挺浪费的。</p><h3 id="自行车被偷"><a href="#自行车被偷" class="headerlink" title="自行车被偷"></a>自行车被偷</h3><p>妈的，老子从老家骑车107公里，好不容易骑到徐州的车！！</p><p>这年头了居然还有人偷自行车，真他吗的神经病！</p><p>我就他妈的一天没锁车，车就丢了！！</p><p>奶奶的，以后再也不再徐州骑车了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以前还想着在外地钱差不多挣够了，就回老家买个差不多的房子，然后日子就定在这里，也不是不行。</p><p>这一猛子给我锤醒了，我这边再也不考虑在徐州这个地方落户了，这地方，狗都不呆。</p><p>从小到大的经历豁然间苏醒，我真是瞎了眼，对老家有这种滤镜。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在徐州呆了快三个月，基本可以确定徐州就是一个根本不能待的垃圾城市。&lt;/p&gt;
&lt;p&gt;自行车被偷只是我爆发的一个诱因，总的来说，破防的原因是多方面的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解spa,ssr,seo</title>
    <link href="https://crazystudent13.github.io/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/"/>
    <id>https://crazystudent13.github.io/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/</id>
    <published>2024-06-23T04:56:01.000Z</published>
    <updated>2024-08-06T13:43:32.864Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近被一个新人模拟面试折腾的高血压又犯了，以前我是碰都不会碰这类基础面试题的，这种常识还有人不会？</p><p>结果还真有人不会，为了给新手开开眼，于是特意整理了这篇文档。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近有个刚入行的新手问我什么是SPA，我说就是单页面应用。</p><p>他又问什么是单页面应用，我寻思这是来考我了？</p><p>然后我就认真回了一下：就是一次加载前端所有资源，然后由前端的JS脚本来控制用户的交互行为。这样做的好处是可以在客户端处理掉所有的交互，减小服务器的压力，但是坏处是服务器做SEO时候，不好做数据抓取，相对于传统的SSR不太好。</p><p>然后，新人又问：什么是SEO?SSR不是抽卡吗，和这个有什么关系？</p><p>我：。。。你他妈的就是来找茬的？新生代的前端都这么没常识的吗？</p><h3 id="单页面应用（SPA）"><a href="#单页面应用（SPA）" class="headerlink" title="单页面应用（SPA）"></a><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">单页面应用（SPA）</a></h3><p>单页面应用这个面试题从我入行的时候就在问，因为那时候还是jquery刚刚倾倒的时刻，vue，ng，react三大框架刚刚兴起，对于那时候的人来说，这个概念很新鲜。</p><p>如今都他妈快5到6年了，还在问这个问题，我只能说社会进步还是挺缓慢的。</p><p>我这里懒得自己写定义了，引用一下vue官方的说法。</p><blockquote><p>一些应用在前端需要具有丰富的交互性、较深的会话和复杂的状态逻辑。</p><p>构建这类应用的最佳方法是使用这样一种架构：Vue 不仅控制整个页面，还负责处理抓取新数据，并在无需重新加载的前提下处理页面切换。</p><p>这种类型的应用通常称为单页应用 (Single-Page application，缩写为 SPA)。</p></blockquote><p>说的简单点，就是以前页面切换等操作，每次都需要向服务器发送请求，抓取新的页面资源，到了本地重新解析资源，压力都在服务器端。</p><p>为了缓解服务器的渲染压力，也为了开发提速，于是就有了单页面应用（SPA）的处理方式。</p><p>这样避免每次切换页面对服务端造成压力，也不需要前端页面在服务器渲染，进一步削弱了服务器的压力。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>减小了后端开发心智负担，使后端更专注业务开发，前端来处理交互逻辑。SPA必然伴随着前后端解耦，传统开发需要后端调试前端的写的页面逻辑，比如JSP交互，如今将交互逻辑分离出来，页面及跳转之类的交互逻辑全部由前端开发，使后端更专注于业务逻辑的开发。</li><li>增加开发速度，因为前后端逻辑解耦，各自负责自己的部分，可以并行安排开发任务，双方通过接口进行联调，相对于传统的开发模式，不需要后期全部由后端挑大梁。</li><li>减小对服务器的压力，SPA是一次性加载所有资源到本地，由用户本地的浏览器来处理交互逻辑，在后续的人机交互过程中，除了需要请求接口数据，几乎不需要请求大量的页面资源，也不需要再服务端渲染，故而极大程度的减小的服务器的压力。</li><li>页面之间的切换非常快，用户体验好。因为全部由前端处理交互，不需要过服务器的渲染，不会受限于服务器的性能造成处理问题，所以相对传统的服务器端渲染页面，SPA能够更快的完成前端页面交互效果。</li></ol><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，由此衍生出了很多首屏优化的要求。</li><li>不方便SEO。SEO是根据每个页面的固定内容进行抓取，而SPA是一次性加载所有资源，故而这种方式不利于SEO抓取。</li></ol><h3 id="搜索引擎优化（SEO）"><a href="#搜索引擎优化（SEO）" class="headerlink" title="搜索引擎优化（SEO）"></a>搜索引擎优化（SEO）</h3><p>既然提到了SEO，这里就先讲SEO。</p><p>这里引用一下百度百科给的定义，虽然百科不怎么正规，但是它这部分说的还是相对来说较为严谨的。</p><blockquote><p>SEO（Search Engine Optimization）：汉译为搜索引擎优化。</p><p>是一种利用<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>的规则提高网站在有关搜索引擎内的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%8E%92%E5%90%8D/2092669?fromModule=lemma_inlink">自然排名</a>的方式。目的是让其在行业内占据领先地位，获得<a href="https://baike.baidu.com/item/%E5%93%81%E7%89%8C/235720?fromModule=lemma_inlink">品牌</a>收益。</p><p>很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。</p></blockquote><h4 id="搜索引擎工作原理"><a href="#搜索引擎工作原理" class="headerlink" title="搜索引擎工作原理"></a>搜索引擎工作原理</h4><p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。</p><p>随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。</p><p>反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。</p><p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。</p><p>在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。</p><p>这样一个过程我们称之为SEO。</p><h4 id="SEO与SEM的区别"><a href="#SEO与SEM的区别" class="headerlink" title="SEO与SEM的区别"></a>SEO与SEM的区别</h4><p>讲到两者的区别时候，先放一下SEM的定义，我看了一下百科的定义，个人感觉不够直白，这里自己干脆重写一下。</p><blockquote><p>SEM一般指竞价推广，在搜索引擎后台账户投钱，使广告获取相关的排名，一般搜索页面上会展现“广告”的标签。</p></blockquote><p>这里我们从不同维度去比较一下两者的区别。</p><table><thead><tr><th>维度</th><th>SEO</th><th>SEM</th></tr></thead><tbody><tr><td>关键词前置条件</td><td>需要网站有权重基础，小站无法做热词，不能随时增减关键词</td><td>不需要网站基础，任何关键词都可以投放</td></tr><tr><td>关键词收费</td><td>相对较低，随着SEO优化好，收费会降低</td><td>关键词越多，收费越高，随着同类站点竞争激烈，收费越高</td></tr><tr><td>见效时长</td><td>3-5月以上</td><td>立刻见效</td></tr><tr><td>持续性</td><td>停止SEO，效果可以持续很久</td><td>停止SEM，立刻失效</td></tr></tbody></table><p>如果你们老板实际开发官网，希望你能优化一下官网的SEO排名，我个人建议，在国内的话，直接找个靠谱的厂商去买关键字竞价吧。</p><p>现在搜索排名靠前的全部都是广告，搜不出什么正经的东西，你各种花里胡哨的操作，都不如直接去买关键字权重。</p><p>我之前呆的一家公司，甚至没做SSR的优化，直接用vue弄了个单页面应用，硬是靠着关键字排名砸到了前排，SEO总归是商业行为，技术角度总归只是辅助，了解一下就行。</p><p>当然，也并非说国内完全没有做seo的价值，详情可以参考这篇文：<a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a>，讲的很不错。</p><p>另外，在国内的网站最好还是备案一下，虽然<strong>备案不影响SEO的优化</strong>，但在国内有备案的网站终归更具有可信度。</p><h4 id="白帽SEO与黑帽SEO"><a href="#白帽SEO与黑帽SEO" class="headerlink" title="白帽SEO与黑帽SEO"></a>白帽SEO与黑帽SEO</h4><p>在市面上，按照各种操作行为，大致可以分为白帽SEO和黑帽SEO。</p><p><strong>白帽SEO</strong>：起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。</p><p><strong>黑帽SEO</strong>：利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。</p><p>我们常规的技术手段，大概就是白帽SEO，具体手段参考：<a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a>，实际开发过程中，我们主要做如下操作。</p><ol><li>SSR服务器渲染</li><li>预渲染prerender-spa-plugin</li><li>对网站的的title、description、keywords精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</li><li>网站内容优化：内容与关键字的对应，合理增加关键字的密度；</li><li>饰性图片必须加alt</li><li>在网站上合理设置Robots.txt文件；</li><li>语义化化的HTML代码，符合W3C规范</li><li>增加外部链接，到各个网站上宣传；</li><li>向各大搜索引擎提交收录自己的站点</li><li>少用iframe：iframe中的内容是不会被抓取到的</li></ol><p>详细的操作手段这里就不说了，我后续会专门整理一篇文档，毕竟从零开始弄一个网站，然后通过SEO优化打到前排这种操作我也没做过，公司都是直接用钱砸关键字权重的，只能说钱多任性。</p><p>后续我会尝试做个简单的玩具网站，试试能不能通过白帽SEO把排名打上去，如果打不上去，我这里介绍的再怎么花哨也没什么用。</p><h3 id="服务器端渲染（SSR）"><a href="#服务器端渲染（SSR）" class="headerlink" title="服务器端渲染（SSR）"></a>服务器端渲染（SSR）</h3><p>这里依旧放一下百度百科的定义。</p><blockquote><p>服务器端渲染（Server-Side Rendering）是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p></blockquote><p>SSR没什么好说的，就是传统的服务端页面，因为页面的接口都是在服务端完成拼接处理，当浏览器的请求资源的时候，已经是完整的DOM结构。</p><p>故而，SSR相对于传统的SPA更适合搜索引擎抓取关键字，所以SEO效果会更好。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了</li><li>更好的SEO，将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li><li>一些常用的浏览器API可能无法正常使用，比如<code>window</code>、<code>docment</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致</li></ol><h4 id="SSR常用框架"><a href="#SSR常用框架" class="headerlink" title="SSR常用框架"></a>SSR常用框架</h4><ul><li>React 的 <a href="https://link.juejin.cn/?target=https://nextjs.org/">Next</a></li><li>Vue.js 的 <a href="https://nuxt.com/">Nuxt3</a></li></ul><h4 id="Nuxt静态化"><a href="#Nuxt静态化" class="headerlink" title="Nuxt静态化"></a>Nuxt静态化</h4><p>因为个人之前是用Nuxt来做官网的，而且本人的技术栈主要也是vue全家桶，所以这里主要也就讲一下Nuxt3。</p><p>静态化是Nuxt.js打包的另一种方式，算是Nuxt.js的一个创新点，部署到服务器上之后，这种页面加载速度很快。</p><p>这里再次放一下Nuxt3官网的关于服务端渲染的说法。</p><h5 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title=" 服务器端渲染"></a><a href="https://nuxt.com/docs/getting-started/introduction#server-side-rendering"> 服务器端渲染</a></h5><p>默认情况下，Nuxt具有内置的服务器端渲染（SSR）功能，无需自己配置服务器，这对Web应用程序有很多好处</p><ul><li><strong>更快的初始页面加载时间：</strong>Nuxt将完全呈现的HTML页面发送到浏览器，该页面可以立即显示。这可以提供更快的感知页面加载时间和更好的用户体验 （UX），尤其是在速度较慢的网络或设备上。</li><li><strong>改进的 SEO：</strong>搜索引擎可以更好地索引 SSR 页面，因为 HTML 内容可以立即使用，而不需要 JavaScript 在客户端呈现内容。</li><li><strong>在低功耗设备上具有更好的性能：</strong>它减少了需要在客户端下载和执行的 JavaScript 数量，这对于可能难以处理繁重的 JavaScript 应用程序的低功耗设备非常有益。</li><li><strong>更好的辅助功能：</strong>内容在初始页面加载时立即可用，从而提高了依赖屏幕阅读器或其他辅助技术的用户的可访问性。</li><li><strong>更轻松的缓存：</strong>页面可以缓存在服务器端，这可以通过减少生成内容并将其发送到客户端所需的时间来进一步提高性能。</li></ul><p>总体而言，服务器端渲染可以提供更快、更高效的用户体验，并改善搜索引擎的优化和可访问性。</p><blockquote><p>注意：在Nuxt.js执行 generate静态化打包时，动态路由会被忽略。</p></blockquote><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>纯静态文件，访问速度超快</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>动态路由（params传参），参数多的时候，Nuxt不适用</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些常识类的东西，虽然对开发没什么作用，但是作为见识拓展一下比较好。</p><p>这些问题也不是什么新鲜问题，基本上都是老古董的问题了，这里整备一下，省的哪天被别人面试挖了犄角旮旯的问题拉出来拷打。</p><p>假如上级布置了一个SSR开发任务，不会闹出来SSR抽卡用的词的笑话，多了解一点，总归是没什么错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a></p><p><a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a></p><p><a href="https://juejin.cn/post/7230303948925665341?searchId=20240623132441364A0B270D1932943462">挑战15分钟了解SEO、SMO、SPA、SSR可以吗？</a></p><p><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">使用 Vue 的多种方式 | Vue.js (vuejs.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为最近被一个新人模拟面试折腾的高血压又犯了，以前我是碰都不会碰这类基础面试题的，这种常识还有人不会？&lt;/p&gt;
&lt;p&gt;结果还真有人不会，为了给新手开开眼，于是特意整理了这篇文档。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
