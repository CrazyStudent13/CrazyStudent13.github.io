<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远川的个人博客</title>
  
  <subtitle>CrazyStudent13的个人日志</subtitle>
  <link href="https://crazystudent13.github.io/atom.xml" rel="self"/>
  
  <link href="https://crazystudent13.github.io/"/>
  <updated>2024-05-26T08:44:07.372Z</updated>
  <id>https://crazystudent13.github.io/</id>
  
  <author>
    <name>CrazyStudent13</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10分钟了解跨域</title>
    <link href="https://crazystudent13.github.io/2024/05/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/"/>
    <id>https://crazystudent13.github.io/2024/05/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/</id>
    <published>2024-05-23T14:52:31.000Z</published>
    <updated>2024-05-26T08:44:07.372Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：请问您能说一下跨域的解决办法吗？</p><p>我：这种事儿为什么要前端来做？难道不是后端设置一下就行了吗？</p><p>面试官：和您聊得很开心，请您回去等通知吧。</p><span id="more"></span><p><img src="C:\Users\crazystudent13\Pictures\微信截图_20221125141314.png" alt="微信截图_20221125141314"></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在很早以前还是JSONP的解决方案里，跨域问题算是很经典的面试题。</p><p>但那是前端环境还处于蛮荒时代的解决手法，如今再问跨域，多少有点过期的感觉了。</p><p>不过，作为开发人员，跨域这个问题是必须要了解的。</p><p>在正式讲解跨域之前，先简单了解几个概念。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>协议（Protocol）</td><td><code>URL</code>的开头部分通常包含<code>协议</code>名称，例如“http:&#x2F;&#x2F;”、“https:&#x2F;&#x2F;”等，也有ftp等协议，这里不展开细说</td></tr><tr><td>主机名（Host Name）</td><td>指定了资源所在的主机（服务器）的<code>域名</code>或<code>IP地址</code></td></tr><tr><td>端口号（Port Number）</td><td>可选部分，用于指定<code>服务器</code>上接收请求的<code>端口号</code>。如果未指定，默认使用协议的<code>默认端口</code>（如80或443）</td></tr><tr><td>路径（Path）</td><td>指定了<code>服务器</code>上资源的<code>位置</code>，表示<code>资源</code>在服务器文件系统中的<code>路径</code>。</td></tr><tr><td>查询参数（Query Parameters）</td><td>可选部分，用于向<code>服务器</code>传递额外的<code>参数</code>，通常以<code>键值对</code>的形式出现，例如“?key1&#x3D;value1&amp;key2&#x3D;value2”</td></tr><tr><td>锚点（Fragment）</td><td>可选部分，用于指定资源内的<code>特定位置</code>（如页面内的锚点）</td></tr></tbody></table><p>以<code>http://192.168.0.1:8080/index.html</code> 为例子，我们可以得出如下结论。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http是协议，192.168.0.1是主机名，8080端口号，index.html是路径</span><br></pre></td></tr></table></figure><p>如果<code>http://www.test.com/index.html</code>这样的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http是协议，www.test.com是主机名，index.html是路径</span><br></pre></td></tr></table></figure><p>这里我们会发现，这里只有主机名而没有端口的构成。</p><p>这是因为，这种域名的形式的端口往往默认以80或者443的形式绑定在域名上，所以我们平时在正式的网址上，很少看到有域名加端口的形式。</p><p>关于URL我们这里就简单说一些，这里就不详细展开说。</p><p>如果想要深入了解URL的构成，可以参考<a href="https://www.runoob.com/html/html-url.html">菜鸟教程的HTML 统一资源定位器(Uniform Resource Locators)篇</a></p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>正式了解之前，我们先记住一点：<strong>同源策略是浏览器的策略，而非服务端的策略</strong>。</p><p>在记住这点之后，我们再正式了解同源策略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同源策略，它是由Netscape提出的一个著名的安全策略。</span><br><span class="line">现在所有支持JavaScript 的浏览器都会使用这个策略。</span><br><span class="line">所谓同源是指，域名，协议，端口相同。</span><br><span class="line">当一个浏览器的两个tab页中分别打开百度和谷歌的页面，当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的</span><br><span class="line">即检查是否同源，只有和百度同源的脚本才会被执行。</span><br></pre></td></tr></table></figure><p>总结，同源策略，是浏览器为了解决两个页面数据安全问题而提出的一种手段。</p><p>我们已经了解了URL的构成，所以这里我们很明显的就能看明白，资源文件同源到底是哪些地方要对应的。</p><p>同源策略，说到底，是<strong>浏览器</strong>为了隔离不同页面的获取资源的一种手段。</p><p>如果两个页面的<code>协议</code>，<code>域名</code>和<code>端口</code>都相同，则两个页面具有<strong>相同的源</strong>。</p><p>这里，我们以<code>http://www.test.com/index.html</code> 为例子，看一下。</p><table><thead><tr><th>URL</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/other.html">http://www.test.com/other.html</a></td><td>是</td><td>同源(协议、域名、端口相同)</td></tr><tr><td><a href="https://www.test.com/about.html">https://www.test.com/about.html</a></td><td>否</td><td>协议不同(http 与 https)</td></tr><tr><td><a href="http://blog.test.com/movie.html">http://blog.test.com/movie.html</a></td><td>否</td><td>域名不同(<a href="http://www.test.com与/">www.test.com与</a> blog.test.com)</td></tr><tr><td><a href="http://www.test.com:7001/home.html">http://www.test.com:7001/home.html</a></td><td>否</td><td>端口不同(默认的 80 端口与 7001 端口)</td></tr><tr><td><a href="http://www.test.com/main.html">http://www.test.com:80/main.html</a></td><td>否</td><td>同源(协议、域名、端口相同)</td></tr></tbody></table><p>由以上例子，我们应该大致明白了同源策略是怎么一回事儿了。</p><p>而不同源的请求去访问，就一种跨域，如下图所示。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdce35faa4194c63952d7a2f6e56a451~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto.webp"></p><p>总结的来说，由于浏览器安全限制，数据是不可以直接请求不同源的资源，包括不同的根域名、二级域名、或不同的端口，除非目标域名授权你可以访问。</p><p>那么，想要解决同源策略下的不同源文件访问，就需要<strong>跨域</strong>。</p><p>我这里只是介绍我工作中经历过的三种方式，详细教程参考阮一峰老师的文章：<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a>。</p><p><a href="https://imgse.com/i/pkl1yFI"><img src="https://s21.ax1x.com/2024/05/26/pkl1yFI.md.png" alt="pkl1yFI.md.png"></a></p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>由上述的过程，我们已经讲明白了什么是同源策略，及同源策略造成的影响，这里就主要说一下我工作中的常用的四种跨域解决方式。</p><ol><li>JSONP跨域</li><li>nginx配置</li><li>webpack Server配置</li><li>后端接口请求头设置</li></ol><h4 id="JSONP是什么"><a href="#JSONP是什么" class="headerlink" title="JSONP是什么"></a>JSONP是什么</h4><p>JSONP本质是一种讨巧的解决方式。</p><p>早些年的时候，前端开发人员发现Web页面上调用js文件时则不受是否跨域的影响，不仅如此，有人还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<script/>、<img/>、<iframe/>。</p><p>而有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，并被原生js支持。</p><p>所以实现跨域的方案就出现了。我们可以调用跨域服务器上动态生成的js格式文件,也就是调用JSON文件，获取自己需要的数据。</p><p>后来逐渐形成了一种非正式的传输协议，也就是JSONP。</p><p>该协议允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，客户端接收到响应后执行回调并且可以对数据进行各种需要的处理。</p><p>说到这里，我们来总结一下<strong>什么是JSONP</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过动态创建script标签，其scr指向非同源的url，并传递一个callback参数给服务端，服务器返回一个以callback参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。</span><br></pre></td></tr></table></figure><p>这里说起来不够明显， 我们直接看一下示例。</p><h5 id="实现JSONP"><a href="#实现JSONP" class="headerlink" title="实现JSONP"></a>实现JSONP</h5><p>首先，我们要有一个请求方和响应方。</p><p>请求方是一个网页的前端，也就是浏览器，响应方是另一个网页的后台，也就是服务器，两个网页是不同源的。</p><p>这里我们假设浏览器页面显示着一个数字100和一个<code>打钱</code>的按钮，服务器储存着页面显示的那个数字，要求在每按下<code>打钱</code>按钮的时候，浏览器显示的数字减一，并且服务端储存这个减后的数字，在下一次打开的时候显示减后的数字。这是一个跨域向非同源网站的服务器发送请求和接收响应的过程。<br> 请求方：<code>http://fang.com:8001</code><br> 响应方：<code>http://zeng.com:8002</code></p><p>先写好html：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/20/16f2263965d9fc7c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="image"></p><p>接着就是写前端部分代码main.js，实现点击之后发送请求改变数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">    let script = document.createElement(&#x27;script&#x27;)// 创建script标签</span><br><span class="line">    let functionName = &#x27;fang&#x27; + parseInt(Math.random()*10000000,10)// 设置调用函数名</span><br><span class="line">    window[functionName] = function(result)&#123;</span><br><span class="line">      if(result === &#x27;success&#x27;)&#123;</span><br><span class="line">        amount.innerText = amount.innerText - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `http://zeng.com:8002/pay?callback$&#123;functionName&#125; `</span><br><span class="line">    document.body.appendChild(script)// 将能实现发送跨域请求的script标签插入html</span><br><span class="line">    script.onload = function(e)&#123;</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName]</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = function()&#123;</span><br><span class="line">      alert(&#x27;fail&#x27;)</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName]</span><br><span class="line">    &#125;</span><br><span class="line">    // 完成传输后删除script标签</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>搭建好服务器，就可以实现功能了。这个就是一个利用JSONP发送跨域和响应的过程。</p><p>如果觉得不够详细，这里可以参考<a href="https://space.bilibili.com/383062034">零寂前端</a>的视频：<a href="https://www.bilibili.com/video/BV1KH4y1v7a9/?spm_id_from=333.1296.header_right.history_list.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">从HTTP与Restfull到Ajax全方位掌握-前端开发-JavaScript</a>，大佬在视频中很完美的演示了JSONP的跨域请求方式。</p><h5 id="JSONP的优点与缺点"><a href="#JSONP的优点与缺点" class="headerlink" title="JSONP的优点与缺点"></a>JSONP的优点与缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>JSONP可以实现跨域传输，不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制</li><li>JSONP兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持</li><li>在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>它只支持GET请求而不支持POST等其它类型的HTTP请求，因为script标签的scr只能进行GET请求</li><li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li><li>JSONP在调用失败的时候不会返回各种HTTP状态码。</li><li>缺乏安全性。假如提供JSONP的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的,那么所有调用这个JSONP的网站都会存在漏洞,这样的话危险就不止在一个域名下。</li><li>JSONP仍然需要改动服务端代码，写好回调函数，工作量较大，本质上是一种从客户端获取服务端回调函数的东西</li></ul><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx代理是指使用Nginx作为反向代理服务器，接收客户端发来的请求，然后将这些请求转发到其他服务器上进行处理，并将处理结果返回给客户端。</p><p>Nginx是一种高性能的Web服务器和反向代理服务器，因其性能优异、配置简单而被广泛应用于互联网领域。</p><p>这在工作中，也是较为常用的方式，往往开发服务器会配置这个来做好本地的接口联调。</p><p><strong>实现</strong></p><p>编辑 Nginx 的配置文件（<code>nginx.conf</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       2222;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api &#123;</span><br><span class="line">        proxy_pass  http://127.0.0.1:3000;</span><br><span class="line">        add_header  Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>localhost:2222/api</code> 路径下的请求转发到<code>http://127.0.0.1:3000</code>来代理，并且添加响应头 <code>Access-Control-Allow-Origin *</code>，设置白名单，允许跨域请求，这里类似 Cors 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data =&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;Hello nginx-proxy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端提供数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(<span class="string">&#x27;http://localhost:2222/api&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>res.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端向 <code>http://localhost:2222/api</code> 发请求，将被 Nginx 反向代理到 <code>http://127.0.0.1:3000</code></p><p>所有工作准备完毕，点击按钮，拿到数据，成功解决跨域。</p><h4 id="Webpack-Server配置"><a href="#Webpack-Server配置" class="headerlink" title="Webpack Server配置"></a>Webpack Server配置</h4><p>这种方式不常见，但是偶尔有团队会在本地联调中用到，所以这里提一嘴。</p><p>大多数Vue项目的脚手架中，应该将webpack的配置集成到了vueConfig.js文件中，所以，大概的配置模式也是类似的。</p><p>譬如，只要按照如下配置，便可将路径为<code>/api</code>的接口代理到<code>http://localhost:3001</code>中，这样我们也能简单的实现一个本地的接口跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  output: &#123;...&#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: 3000,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &quot;/api&quot;: &#123;</span><br><span class="line">        target: &quot;http://localhost:3001&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="呼叫后端修改"><a href="#呼叫后端修改" class="headerlink" title="呼叫后端修改"></a>呼叫后端修改</h4><p>这个是工作中的现在常用解决方式，难度低，工作量小，且没什么后遗症。</p><p>毕竟大多数工作中常用的后端框架都是springboot搭建的，所以往往只需要后端配置一下<code>javax.servlet.Filter</code>即可。</p><p>当然，这里不清楚大家的工作框架，所以只是一家之言，如果有更好的解决方式还请细说，毕竟我不是专业的后端。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为面试八股文的经典问答，这个问题几乎是很多新手前端的必问题目，但是在实际开发的过程中，往往是后端只要设置一下就行了。</p><p>但是很多面试官还是拿着经典面试答案来套话，说实话，有种刻舟求剑的美。</p><p>总的来说，跨域的经典问题，前端开发工程师可以了解但不必强求，实际开发过程中，前端和跨域处理的距离已经相当之遥远。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904024924225544">JSONP原理详解——弄懂JSONP及其实现方法</a></p><p><a href="https://juejin.cn/post/7106180372047593503#heading-18">JSONP 跨域原理及实现</a></p><p><a href="https://juejin.cn/post/7348275757800882191#heading-7">面试官：你是如何解决跨域的？</a></p><p><a href="https://juejin.cn/post/7253367284873461818?searchId=202405250030111B33BC21282A963FD75F">实现跨域请求：Spring Boot后端的解决方案</a></p><p><a href="https://juejin.cn/post/6999042691698786311?searchId=202405250030111B33BC21282A963FD75F">一篇文章让你搞懂如何通过Nginx来解决跨域问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：请问您能说一下跨域的解决办法吗？&lt;/p&gt;
&lt;p&gt;我：这种事儿为什么要前端来做？难道不是后端设置一下就行了吗？&lt;/p&gt;
&lt;p&gt;面试官：和您聊得很开心，请您回去等通知吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解浏览器的进程</title>
    <link href="https://crazystudent13.github.io/2024/05/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>https://crazystudent13.github.io/2024/05/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-05-15T18:16:36.000Z</published>
    <updated>2024-05-19T16:59:02.983Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：难道您没有了解过浏览器到底有哪些线程吗？</p><p>我：工作中用到的不多，没了解。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于进程与线程的事情说完了，但是浏览器到底有什么进程，这里我也比较好奇，所以也了解了一下。</p><p>虽然平时不怎么会用到，但也算是开拓眼界了。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是一个多进程架构设计，<strong>每打开一个标签页就会创建一个进程</strong>。当然浏览器内部也有着自己的优化，比如：当浏览器同时打开多个空白标签页的时候，会合并成一个进程。</p><p>浏览器到关闭到启动，至少开启四个进程：</p><ol><li><code>1个 browser进程</code></li><li><code>1个GPU进程</code></li><li><code>1个网络进程</code></li><li><code>1个渲染进程</code></li></ol><p>当新增其他标签页时，前面三个进程是可以共用的，不用重启。</p><p>默认情况下，每打开一个标签页，就会开启一个渲染进程。但是也会存在特殊的情况，就是如果打开的标签页在同一个站点下，会共享同一个渲染进程。</p><p>最新的浏览器进程主要包含：</p><ul><li>1个浏览器主进程</li><li>1个GPU进程（也可能存在多个，每个标签页都需要一个进程，用于绘制图形）</li><li>1个网络进程</li><li>多个插件进程（每个插件都会开启一个进程，因为防止一个插件崩溃，造成整个浏览器崩溃）</li><li>多个渲染进程（标签页需要独立的进程）</li></ul><h3 id="browser-进程（主进程）"><a href="#browser-进程（主进程）" class="headerlink" title="browser 进程（主进程）"></a>browser 进程（主进程）</h3><p>负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</p><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a>GPU 进程</h3><p>负责处理与图形渲染相关的任务。（着重在于<strong>图像</strong>）</p><ul><li>图形渲染</li><li>动画和过渡</li><li>3D 和 WebGL 渲染</li><li>视频播放和解码等</li></ul><h3 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h3><p>负责处理与网络相关的任务。它主要负责管理和维护网络连接，以及处理所有的网络请求和响应。</p><ul><li>管理网络连接</li><li>处理网络请求和响应</li><li>处理DNS解析</li><li>处理缓存</li><li>处理安全问题</li></ul><blockquote><p><strong>浏览器的网络进程和渲染进程的异步HTTP线程之间存在通信吗？</strong></p><p>在浏览器中，<strong>当用户在页面上发起一个网络请求时，该请求首先由渲染进程中的异步 HTTP 线程发起，异步 HTTP 线程会将该请求通过 IPC 传递给网络进程</strong>。网络进程收到请求后，负责管理和维护网络连接，发送请求并接收响应，最后<strong>将响应数据再通过 IPC 传递给渲染进程中的异步 HTTP 线程处理</strong>。</p><p>在这个过程中，网络进程和渲染进程之间需要频繁地进行通信，以协同完成网络请求和响应的处理。</p><p>例如，当请求被发送出去后，网络进程需要不断地监控连接状态和接收数据，并及时将收到的数据通过 IPC 传递给渲染进程中的异步 HTTP 线程，同时异步 HTTP 线程也需要不断地向网络进程查询请求状态和响应数据。 </p><p>浏览器通过 IPC（进程间通信）机制来实现这种进程间通信，IPC 是浏览器中进程间交换数据的标准方法，其通信方式包括消息传递、共享内存、管道等。</p><p>通过 IPC 机制，网络进程和渲染进程之间可以高效地传递数据和信息，保证了浏览器的正常工作和性能表现。</p></blockquote><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><p>用于处理浏览器插件的进程（每个插件，就会创建一个进程）</p><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>负责将 HTML、CSS 和 JavaScript 转换为可视化的页面。默认情况下，浏览器的tab就会创建一个渲染进程。</p><blockquote><p>针对前端，需要着重了解该进程。</p></blockquote><p>该进程包含：<code>GUI 渲染线程</code>、<code>JS 引擎线程</code>、<code>定时触发线程</code>、<code>异步 HTTP 线程</code>、<code>事件触发线程</code></p><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><p>负责页面的渲染和绘制；解析 HTML和CSS，构建 DOM树、CSSOM树 、 渲染树（Render 树） ，布局和绘制等。重绘和重排也是发生在该线程中。</p><p>GUI 更新会被保存在一个队列之中，等到 JS 引擎线程空闲时，GUI 线程就会立即执行。</p><p><strong>「GUI 线程和JS引擎线程是互斥的」</strong></p><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><p>也称为 JS 内核，负责处理 JavaScript 脚本程序。</p><p>再次注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong> ，所以，如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><p>指的是计时函数：setInterval 和 setTimeout 两个函数。</p><p>由于 JS 引擎是单线程的，如果该线程处于堵塞状态，那么就会造成计时不准确，那么就需要单独一个线程来进行计时。</p><p>当计时完成之后，就会把事件回调（任务）添加事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="异步-HTTP-线程"><a href="#异步-HTTP-线程" class="headerlink" title="异步 HTTP 线程"></a>异步 HTTP 线程</h4><p>XMLHttpRequest 在连接后是通过浏览器新开的一个线程请求。</p><p>检测到状态发生变化之后，就会事件回调（任务）添加到事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>用来控制事件循环的（Event Loop）。</p><p>就比如上面的，</p><ul><li>定时器的任务通过事件触发线程添加到事件队列中，</li><li>异步请求的任务是通过事件触发线程添加到事件队列中</li><li>。。。（收集任务）</li></ul><p>事件触发线程还会周期性地检查事件队列中是否存在任务。当JS引擎线程空闲了，就会将其中的任务顺序交给 JS 引擎线程执行。</p><blockquote><p>这里的解释可能存在错误。</p><p>事件触发线程是连接事件的发生和任务执行的桥梁。它负责接收事件，并将对应的任务添加到事件队列中，然后主动触发 JavaScript 引擎线程来执行任务。</p></blockquote><h4 id="存储线程"><a href="#存储线程" class="headerlink" title="存储线程"></a>存储线程</h4><p>负责处理浏览器的各种存储机制，包括 cookie、localStorage、indexedDB 等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然面试时候感觉完全不太可能会提到，但是作为拓充知识涉猎一下也是不错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7287914116286201891">浏览器原理：进程与线程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：难道您没有了解过浏览器到底有哪些线程吗？&lt;/p&gt;
&lt;p&gt;我：工作中用到的不多，没了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解JS的线程与进程</title>
    <link href="https://crazystudent13.github.io/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>https://crazystudent13.github.io/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-05-15T13:56:45.000Z</published>
    <updated>2024-05-19T16:59:02.981Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：你能说一下线程和进程吗？我：工作中用不到，我没了解过。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>大多数前端都知道前端的JS是单线程语言，但是JS为什么是单线程语言大多数人可能还是不清楚的。</p><p>线程与进程这个东西，虽然不影响日常开发，但这是程序员必会的基础知识，我没能完整的说出来，确实不太好。</p><p>因此，我这里整理一下相关的知识点。</p><h3 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h3><ol><li>查看人管理器，每个应用程序至少会启动一个进程，有的会启动多个进程</li><li>一个进程会占有一片独立的内存空间。</li><li>各个进程的内存空间相互独立，不能互相访问。</li></ol><h3 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h3><ol><li>是进程内一个独立执行的单元。</li><li>是进程内的一个独立的执行单元</li><li>是CPU的最小调度单元</li></ol><p>单线程与多线程的概念，是针对一个进程内的概念。</p><ul><li>一个进程内有多个线程，那这个进程对应的程序就是多线程的程序。</li><li>一个进程内只有一个线程，那么这个程序就是单线程的程序，并且，一个程序，如果只有一个主线程，那就是单线程。</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li>某个独立的模块(浏览器的JS引擎)必须运行在某个进程的某个线程上，不能直接运行在进程上。</li><li>一个进程中必须至少有一个线程，就是所谓的主线程。主线程是进程启动后自动创建的，要运行代码必须要创建线程。</li><li>一个进程可以同时运行多个线程，叫做多线程。</li><li>一个进程内的数据可心供其中多个线程直接共享使用</li><li>多进程之间的数据不能直接共享使用</li></ol><h4 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h4><p>单线程和多线程之间并无优劣之分，只是根据使用场景而确定的方案，譬如JS一开始之所以确定为单线程，就是为了提高执行效率。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:能有效提升CPU的利用率</span><br><span class="line">缺点:创建多线程开销，线程间切换开销，锁进制与状态同步问题</span><br></pre></td></tr></table></figure><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:代码顺序执行，编码更加简单</span><br><span class="line">缺点:效率低</span><br></pre></td></tr></table></figure><h4 id="关于cpu利用率"><a href="#关于cpu利用率" class="headerlink" title="关于cpu利用率"></a>关于cpu利用率</h4><p>单核cpu，某一个时刻肯定只能有一个线程在执行。但是却也能创建多线程，多线程是交替执行的，只是比较快，看着好像是同时执行的。<br>双核cpu，某一个时刻可以有两个线程在执行。单线程的就浪费了双核的能力了，另外一个核闲置了。</p><h4 id="异步与多线程的区别"><a href="#异步与多线程的区别" class="headerlink" title="异步与多线程的区别"></a>异步与多线程的区别</h4><p>异步和多线程都是处理并发任务的方式，但它们本质上是不同的。</p><p>多线程和异步编程之间的一个关键区别是，多线程涉及在一个进程内创建多个线程，而异步编程涉及以非阻塞方式执行任务。</p><p>另一个区别是，多线程需要显式地管理线程同步和通信，而异步编程可以使用编程构造（例如回调或承诺）来处理异步操作。</p><p>多线程和异步编程都可以用于实现计算机系统的并发和并行，但使用哪种取决于程序的具体要求以及底层硬件和软件基础设施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 执行方式：多线程是并行执行任务，即多个线程同时执行任务，而异步是串行执行任务，即一个任务执行完成后再执行下一个任务。</span><br><span class="line">2. 内存使用：每个线程都有自己的栈和内存，因此多线程会占用更多的内存。而异步则可以在一个线程中共享内存。</span><br><span class="line">3. 调度机制：多线程需要操作系统提供的线程调度器来进行线程之间的切换，而异步则是通过事件循环和任务队列的机制完成任务的调度。</span><br><span class="line">4. 错误处理：多线程中一个线程抛出异常时，其他线程不受影响，但异步中一个任务出错可能会影响后续的任务执行。</span><br></pre></td></tr></table></figure><p>总的来说，多线程适用于CPU密集型的任务（如计算），而异步则适用于IO密集型的任务（如网络请求），它们都有自己的优缺点，在选择使用时需要根据具体的场景进行判断。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>谈到异步多线程了，多少就顺手讲一下并行与并发的概念，这都算是计算机相关的基础名词，多少要做一个了解。</p><p><strong>并发</strong>是一个人同时吃三个馒头（时间点是相互独立的，在一个时间点只能吃其中馒头的一口）</p><p><strong>并行</strong>是三个人同时吃三个馒头（时间是重合的，三个人可以在同一时间吃馒头）</p><h4 id="并行-parallel"><a href="#并行-parallel" class="headerlink" title="并行(parallel)"></a>并行(parallel)</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><h4 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发(concurrency)"></a>并发(concurrency)</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p>这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><h4 id="关于CPU与二者的关系"><a href="#关于CPU与二者的关系" class="headerlink" title="关于CPU与二者的关系"></a>关于CPU与二者的关系</h4><p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p><p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端的基础知识，仅做内功修炼的一条，可以涉猎了解，但是没必要深入了解。</p><p>除非，是真正纯正的技术MAN。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1iw4m1R7Xr/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">JS进程与线程全解析-前端开发-JavaScript_哔哩哔哩_bilibili</a></p><p><a href="https://juejin.cn/post/7231391129945047096">异步和多线程的区别</a></p><p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/scarificed/article/details/114645082">并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂_咋么又饿了的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：你能说一下线程和进程吗？我：工作中用不到，我没了解过。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试题" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解JS异步与同步</title>
    <link href="https://crazystudent13.github.io/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://crazystudent13.github.io/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2024-05-13T11:37:31.000Z</published>
    <updated>2024-05-19T16:59:02.981Z</updated>
    
    <content type="html"><![CDATA[<p>模拟面试，感觉自己JS异步同步自己回答的不够精彩，重新整理下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文仅算入门浅析，如有说错的部分，还请轻喷。</p><p>在正式了解Promise之前，我们需要先了解一些基础知识。</p><p>我们知道JavaScript的单线程的，这与它的用途有关。</p><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</p><p>这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所谓”单线程”，就是指一次只能完成一件任务。</p><p>如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p><p>这种模式好处坏处都很明显。</p><p>好处是实现起来比较简单，执行环境相对单纯；</p><p>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。</p><p>常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><p>ajax的同步请求就会导致浏览器产生假死，因为它会锁定浏览器的UI（按钮，菜单，滚动条等），并阻塞所有用户的交互，jquery中的ajax有这样一个同步请求的功能，一定要慎用，尤其是在请求的数据量很大的时候，要避免使用同步请求。</p><p>举几个栗子感受一下异步</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>javascript异步<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> myData = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//ajax请求</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>(<span class="string">&#x27;https://easy-mock.com/mock/5b0525349ae34e7a89352191/example/mock&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回成功&quot;</span>);<span class="comment">// handle success</span></span></span><br><span class="line"><span class="language-javascript">            myData = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(error); // handle error</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h3><p>JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为<strong>JS引擎线程</strong>，但是浏览器的渲染进程是提供多个线程的</p><ul><li>JS引擎线程</li><li>事件触发线程</li><li>定时触发器线程</li><li>异步http请求线程</li><li>GUI渲染线程</li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,应该没什么悬念</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 定时器d</span></span><br></pre></td></tr></table></figure><p>我们看一下执行顺序</p><ol><li>console.log(myData)</li><li>定时器，将定时器挂起（就是暂停了这个定时器）</li><li>继续执行第二个 console.log(myData);</li><li>没有可以执行的js代码，回头把挂起的任务继续执行下去</li></ol><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;(这是接口返回的数据，我们不必关心返回的具体内容，只要知道返回了就好，陌上寒注)</span></span><br></pre></td></tr></table></figure><h4 id="定时器与AJAX"><a href="#定时器与AJAX" class="headerlink" title="定时器与AJAX"></a>定时器与AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">//定时器</span></span><br></pre></td></tr></table></figure><p>两个异步函数相遇了，先执行谁？谁跑的快就先执行谁？</p><p>当遇到计时器、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程去处。</p><p>如定时器线程为setTimeout计时、异步http请求线程处理网络请求，而JS引擎线程继续后面的其他任务，这样便实现了 <strong>异步非阻塞</strong>。</p><p>定时器触发线程也只是为 <code>setTimeout(..., 1000)</code> 定时而已，时间一到，还会把它对应的回调函数(callback)交给 <strong>任务队列</strong> 去维护，JS引擎线程会在适当的时候去<strong>任务队列</strong>取出任务并执行。</p><p>JS引擎线程什么时候去处理呢？消息队列又是什么？</p><p>为了解决这个异步执行顺序的问题，JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制来解决这个问题。</p><h3 id="事件循环和任务队列"><a href="#事件循环和任务队列" class="headerlink" title="事件循环和任务队列"></a>事件循环和任务队列</h3><p>两个console.log(myData)是同步执行的，他们都在js的主线程上执行</p><p>在主线程之外还存在一个任务队列，任务队列中存放着需要异步执行的内容</p><p>当主线程运行完毕之后，就会去执行任务队列中的任务（不断的重复扫描）直到任务队列清空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,这没什么可解释的</span></span><br><span class="line"><span class="comment">// 1，3，2</span></span><br></pre></td></tr></table></figure><p>再看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出,但是后者次序依旧在上</span></span><br><span class="line"><span class="comment">// 2，1，</span></span><br></pre></td></tr></table></figure><p>console.log(2)在主线程中，先执行，</p><p>setTimeout(function(){console.log(1);}, 0)放在了任务队列中，只有在主线程执行完了才会去执行任务列队中的内容</p><p>只有主线程的任务执行完成才会执行</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>为什么主线程的任务执行完了后需要不断的扫描任务列队中的内容呢？</p><p>看这段代码，有助于你的理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// (10次输出)点击了</span></span><br><span class="line"><span class="comment">// ajax返回成功</span></span><br><span class="line"><span class="comment">// &#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="comment">// 点击了</span></span><br></pre></td></tr></table></figure><p>我们为button按钮添加了点击事件，在浏览器刷新的同时不停地对按钮进行点击操作（当然是手动点击）</p><p>这样是不是可以理解为什么主线程要去循环扫描任务列队了？</p><p>事件循环的每一轮称为一个tick（有没有联想到vue中的nextTick？）</p><p>当产生用户交互（鼠标点击事件，页面滚动事件，窗口大小变化事件等等），ajax，定时器，计时器等，会向事件循环中的任务队列添加事件，然后等待执行</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>在查找相关文档的时候，我发现有的笔者混淆了任务队列与消息队列，这两个名词虽然相近，但本质上并非是可以混为一谈的事儿，这次我们本次不做深入讨论。</p><blockquote><p>任务队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">2. 主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">3. 一但&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">4. 主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复，这种机制就被称为事件循环（event loop）机制。</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-595fdd0e4697bed589dc4b30f2c60aeb_r.jpg" alt="img"></p><p>JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制解决了异步时间执行顺序排序的问题。</p><p><strong>事件循环</strong> 机制和 <strong>任务队列</strong> 的维护是由事件触发线程控制的。</p><p><strong>事件触发线程</strong> 同样是浏览器渲染引擎提供的，它会维护一个 <strong>任务队列</strong>。</p><p>JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等…），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 <strong>事件触发线程</strong> 将异步对应挂起的 <strong>回调函数</strong> 重新加入到任务队列中，消息队列中的回调函数等待被执行。</p><p>同时，JS引擎线程会维护一个 <strong>执行栈</strong>，同步代码会依次加入执行栈然后执行，结束会退出执行栈。</p><p>如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从任务队列取出一个任务（即异步的回调函数）放入执行栈中执行。</p><p>这里关于线程的进程的说法比较模糊，后续我会单开一文着重复述一下<code>线程</code>与<code>进程</code>。</p><h3 id="前端异步场景分析"><a href="#前端异步场景分析" class="headerlink" title="前端异步场景分析"></a>前端异步场景分析</h3><ol><li>定时任务：setTimeout,setInverval</li><li>网络请求：ajax请求，img图片的动态加载</li><li>ES6中的Promise</li><li>事件绑定或者叫DOM事件。比如一个点击事件，我不知道它什么时候点，但是在它点击之前，我该干什么还是干什么。用addEventListener注册一个类型的事件的时候，浏览器会有一个单独的模块去接收这个东西，当事件被触发的时候，浏览器的某个模块，会把相应的函数扔到任务队列中，如果现在任务列队中是空的，就会直接执行这个函数。</li></ol><h3 id="需要异步的场景分析"><a href="#需要异步的场景分析" class="headerlink" title="需要异步的场景分析"></a>需要异步的场景分析</h3><p>到底什么时候需要异步呢？这里我们稍微分析一下平时的业务场景。</p><ol><li>在可能发生等待的情况</li><li>等待过程中不能像alert一样阻塞程序的时候</li><li>因此，所有的“等待的情况”都需要异步</li></ol><p>一句话总结就是需要等待但是又不能阻塞程序的时候需要使用异步</p><h3 id="异步和并行"><a href="#异步和并行" class="headerlink" title="异步和并行"></a>异步和并行</h3><p>千万不要把异步和并行搞混了</p><p>异步：单线程的,主线程的任务以同步的方式执行完毕，才会去依次执行任务列队中的异步任务</p><p>并行：两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>主题是JS异步，话题有点歪到JS的执行顺序机制里边了，而且自己似乎还没顺明白，这里有点差了。</p><p>温故而知新，今天扫了很多文档才知道，消息队列和任务队列原来是同一回事儿，早些年就没怎么关注这些东西。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/139967525">一篇搞定（Js异步、事件循环与消息队列、微任务与宏任务）</a></p><p><a href="https://www.cnblogs.com/c3gen/p/6170504.html">关于js中的同步和异步</a></p><p><a href="http://blog.sina.com.cn/s/blog_c112a2980102xlrh.html">异步和单线程——什么时候需要异步，前端使用异步的场景</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟面试，感觉自己JS异步同步自己回答的不够精彩，重新整理下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试题" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解常用的git命令</title>
    <link href="https://crazystudent13.github.io/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/"/>
    <id>https://crazystudent13.github.io/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/</id>
    <published>2024-05-12T04:07:56.000Z</published>
    <updated>2024-05-19T16:58:54.597Z</updated>
    
    <content type="html"><![CDATA[<p>git命令还是在刚毕业时为了面试学的，工作时常用图形化的工具处理。</p><p>如今新入职的公司又要手敲命令，简直有种重返猿人时代的美。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git clone <url></td><td>clone远程版本库到本地</td></tr><tr><td>git init</td><td>初始化本地版本库</td></tr></tbody></table><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git diff</td><td>查看变更内容</td></tr><tr><td>git add .</td><td>添加所有改动文件到暂存区</td></tr><tr><td>git add <file></td><td>添加指定文件或目录到暂存区</td></tr><tr><td>git mv <old> <new></td><td>文件改名</td></tr><tr><td>git rm <file></td><td>删除指定文件或文件夹</td></tr><tr><td>git rm –cached <file></td><td>删除暂存区的文件追踪，不删除源文件</td></tr><tr><td>git commit -m “提交描述”</td><td>提交更新文件，并附带提交信息</td></tr><tr><td>git commit –amend -m “本次提交的描述”</td><td>将本次提交，加入到上次的提交中，并重写提交信息</td></tr></tbody></table><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/git/git-status.html">git status</a></td><td>查看状态（分支名称，与远程分支的关系，未暂存，未跟踪的文件）</td></tr><tr><td>git log</td><td>查看提交历史</td></tr><tr><td>git log -p <file></td><td>查看指定文件的提交历史</td></tr><tr><td>git blame  <file></td><td>以列表方式查看指定文件的提交历史</td></tr></tbody></table><h3 id="代码检出"><a href="#代码检出" class="headerlink" title="代码检出"></a>代码检出</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git checkout</td><td>核查工作区相对于版本库修改过的文件</td></tr><tr><td>git checkout  分支名</td><td>切换到对应的分支</td></tr><tr><td>git checkout -b 分支名</td><td>以当前分支的当前状态创建新分支并切换到新分支  -b 表示创建新分支</td></tr><tr><td>git pull <remote> <branch></td><td>将远程分支的代码拉取到本地分支</td></tr></tbody></table><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git branch</td><td>显示本地所有分支</td></tr><tr><td>git branch -r</td><td>查看本地仓库的远程分支</td></tr><tr><td>git checkout &lt;branch&#x2F;tag&gt;</td><td>切换到指定分支或标签</td></tr><tr><td>git branch <new-branch></td><td>创建新分支</td></tr><tr><td>git branch -d <branch></td><td>删除本地分支</td></tr><tr><td>git tag</td><td>显示本地所有标签</td></tr><tr><td>git tag <tagname></td><td>基于最新提交创建标签</td></tr><tr><td>git tag -d <tagname></td><td>删除标签</td></tr></tbody></table><h3 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git merge <branch></td><td>合并指定分支到当前分支</td></tr><tr><td>git rebase <branch></td><td>衍合指定分支到当前分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git fetch <remote></td><td>从远程库获取代码</td></tr><tr><td>git pull <remote> <branch></td><td>指定的远程仓库（<code>&lt;remote&gt;</code>）拉取指定分支（<code>&lt;branch&gt;</code>）的最新更改，并尝试合并到当前分支</td></tr><tr><td>git push <remote> <branch></td><td>把当前分支的更改推送到指定的远程仓库（<code>&lt;remote&gt;</code>）的指定分支（<code>&lt;branch&gt;</code>），并快速合并</td></tr><tr><td>git push <remote>  :&lt;branch&#x2F;tag-name&gt;</td><td>删除远程分支或标签</td></tr><tr><td>git push –tags</td><td>上传所有标签</td></tr><tr><td>git remote -v</td><td>列出当前仓库中已配置的远程仓库，并显示它们的 URL</td></tr><tr><td>git remote add <remote_name> <remote_url></td><td>添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中。</td></tr><tr><td>git remote rename <old_name> <new_name></td><td>将已配置的远程仓库重命名。</td></tr><tr><td>git remote remove <remote_name></td><td>从当前仓库中删除指定的远程仓库。</td></tr><tr><td>git remote set-url <remote_name> <new_url></td><td>修改指定远程仓库的 URL。</td></tr><tr><td>git remote show <remote_name></td><td>显示指定远程仓库的详细信息，包括 URL 和跟踪分支。</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时就先整理这么多，至于代码的冲突解决，暂时先不做了解。</p><p>毕竟，在大多数业务开发过程中，很难遇到代码冲突的情况。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7359833391192031273?searchId=20240512115740A18BB0AFCF72FB30AEA6">常用的Git命令指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;git命令还是在刚毕业时为了面试学的，工作时常用图形化的工具处理。&lt;/p&gt;
&lt;p&gt;如今新入职的公司又要手敲命令，简直有种重返猿人时代的美。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="git" scheme="https://crazystudent13.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解fetch</title>
    <link href="https://crazystudent13.github.io/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/"/>
    <id>https://crazystudent13.github.io/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/</id>
    <published>2024-05-09T12:12:42.000Z</published>
    <updated>2024-05-19T16:58:54.596Z</updated>
    
    <content type="html"><![CDATA[<p>朋友：也许面试官是问你什么是fetch呢？我：什么是fetch？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果不是刷面试题，我真的不知道有fetch这个东西。</p><h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><h4 id="基本历史"><a href="#基本历史" class="headerlink" title="基本历史"></a>基本历史</h4><p>远古时期，XMLHttpRequest对象的出现，JavaScript调用它就可以让浏览器异步地发http请求，然后这项异步技术就被称为Ajax。</p><p>之后jQuery封装了它，让异步结果更清晰的表现在一个对象的回调函数属性上，编写方式更简单，但出现了新的问题，回调地狱。</p><p>Promise为了解决异步编程的回调地狱问题诞生了。</p><p>随后有人把XHR对象用Promise封装了起来，它就是axios库(浏览器端)，axios在node.js环境是http模块的封装。</p><p>后来又出现了一个可以异步地发http请求的api，就是fetch()。</p><p>Fetch它并非是封装xhr对象的库，而是全新的JavaScript的接口。</p><p>而且Fetch的api天生就是自带Promise的，现在的Ajax就有了两种方式: XHR对象和Fetch()。</p><h4 id="Ajax，Axios，Fetch三者关系"><a href="#Ajax，Axios，Fetch三者关系" class="headerlink" title="Ajax，Axios，Fetch三者关系"></a>Ajax，Axios，Fetch三者关系</h4><ol><li>Ajax 是一种代表异步 JavaScript + XML 的模型（技术合集），所以 Fetch 也是 Ajax 的一个子集</li><li>在之前，我们常说的 Ajax 默认是指以 XHR 为核心的技术合集，而在有了 Fetch 之后，Ajax 不再单单指 XHR 了，我们将以 XHR 为核心的 Ajax 技术称作<strong>传统 Ajax</strong>。</li><li>Axios 属于传统 Ajax（XHR）的子集，因为它是基于 XHR 进行的封装。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代AJAX包含XHR和Fetch两种类型的常见接口请求方式，AJAX和AXIOS都是基于XHR做的封装。</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象</p><p>基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询参数直接通过 ?、&amp; 拼接</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err))</span><br></pre></td></tr></table></figure><p><code>fetch()</code>接收到的<code>response</code>是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Stream 对象</a>，<code>response.json()</code>是一个<strong>异步操作</strong>，取出所有内容，并将其转为 JSON 对象</p><p>使用 await 语法改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;http://example.com/movies.json&#x27;</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求</p><ul><li><code>fetch(url, options)</code></li><li>post、put、patch 用法类似</li><li>HTTP 请求的方法、标头、数据体都在<code>options</code>这个对象里面设置</li></ul><p>下面是一些示例：</p><p><strong>（1）POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br></pre></td></tr></table></figure><blockquote><p>此处的<code>body</code>指的是POST 请求的数据体</p></blockquote><p><strong>（2）提交 JSON 数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user =  &#123; <span class="attr">name</span>:  <span class="string">&#x27;John&#x27;</span>, <span class="attr">surname</span>:  <span class="string">&#x27;Smith&#x27;</span>  &#125;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type`的默认值是`&#x27;text/plain;charset=UTF-8&#x27;</span><br></pre></td></tr></table></figure></blockquote><p><strong>（3）提交表单</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>（5）直接上传二进制数据</strong></p><p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> canvasElem.<span class="title function_">toBlob</span>(resolve,  <span class="string">&#x27;image/png&#x27;</span>))</span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/image&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:  <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: blob</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="完整配置项"><a href="#完整配置项" class="headerlink" title="完整配置项"></a>完整配置项</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="comment">// 指定请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定请求体数据</span></span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="comment">// 指定 fetch() 请求的 referer 标头</span></span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 Referer 标头的规则</span></span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求的模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>, </span><br><span class="line">  <span class="comment">// 指定是否发送 Cookie</span></span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定如何处理缓存</span></span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 HTTP 跳转的处理方法</span></span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值</span></span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据</span></span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 指定一个 AbortSignal 实例，用于取消fetch()请求</span></span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于官网对于部分配置项没有中文翻译，以下列出全部配置项具体值及其说明</p><p><code>cache</code>：指定如何处理缓存，可能的取值如下：</p><blockquote><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误</li></ul></blockquote><p><code>mode</code>：指定请求的模式，可能的取值如下：</p><blockquote><ul><li><code>cors</code>：默认值，允许跨域请求</li><li><code>same-origin</code>：只允许同源请求</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求</li></ul></blockquote><p><code>credentials</code>：指定是否发送 Cookie，可能的取值如下：</p><blockquote><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送</li><li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie</li><li><code>omit</code>：一律不发送</li></ul></blockquote><p><code>redirect</code>：指定 HTTP 跳转的处理方法，可能的取值如下：</p><blockquote><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转</li></ul></blockquote><p><code>referrerPolicy</code>：用于设定<code>Referer</code>标头的规则，可能的取值如下：</p><blockquote><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名</li><li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头</li></ul></blockquote><h3 id="取消Fetch请求"><a href="#取消Fetch请求" class="headerlink" title="取消Fetch请求"></a>取消Fetch请求</h3><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象，流程如下：</p><ul><li>创建<code>AbortController</code>实例</li><li>配置对象的<code>signal</code>属性指定接收<code>AbortController</code>实例发送的信号<code>controller.signal</code></li><li>使用<code>controller.abort()</code>方法发出取消信号</li><li>发出取消信号后，会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>()</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: signal</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>))</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>()<span class="comment">// 取消fetch请求</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p><code>fetch()</code>请求成功以后，得到的是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Response">Response 对象</a>。它对应服务器的 HTTP 响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br></pre></td></tr></table></figure><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>Response 实例属性如下表：</p><table><thead><tr><th>属性</th><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><strong>ok</strong></td><td>布尔值</td><td>表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码</td></tr><tr><td><strong>status</strong></td><td>数字</td><td>表示 HTTP 回应的状态码（如：200，表示成功请求）</td></tr><tr><td><strong>statusText</strong></td><td>字符串</td><td>表示 HTTP 回应的状态信息（如：请求成功以后，服务器返回”OK”）</td></tr><tr><td><strong>url</strong></td><td>请求的 URL</td><td>如果 URL 存在跳转，该属性返回的是最终 URL</td></tr><tr><td><strong>type</strong></td><td>请求的类型</td><td><code>basic</code>：普通请求，即同源请求  <code>cors</code>：跨域请求  <code>error</code>：网络错误，主要用于 Service Worker  <code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值。表示发出的是简单的跨域请求 <code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值</td></tr><tr><td><strong>redirected</strong></td><td>布尔值</td><td>表示请求是否发生过跳转</td></tr><tr><td><strong>body</strong></td><td>ReadableStream 对象</td><td>暴露响应体内容</td></tr><tr><td><strong>headers</strong></td><td>与响应关联的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">Headers</a>对象</td><td>通过访问与响应关联的 Headers 对象，来操作 HTTP 响应头</td></tr></tbody></table><p><code>fetch()</code>发出请求以后，<strong>只有网络错误，或者无法连接时</strong>，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。这意味着服务器返回的状态码是<code>4xx</code>或<code>5xx</code>时，不会报错（Promise 不会变为 <code>rejected</code>状态）</p><p>以下两种方法可以判断是否发生错误：</p><ul><li>通过<code>status</code>属性，得到 HTTP 回应的真实状态码，判断请求是否成功</li><li>判断<code>ok</code>属性是否为<code>true</code></li></ul><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>()</span><br><span class="line">  <span class="keyword">if</span> (done) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块，其中：</p><ul><li><code>done</code>属性是一个布尔值，用来判断有没有读完</li><li><code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容</li><li><code>value.length</code>属性是当前块的大小</li></ul><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers 对象</a>，对应 HTTP 回应的所有标头</p><p>Headers 对象提供了以下方法，用来操作标头：</p><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加</li><li><code>Headers.append()</code>：添加标头</li><li><code>Headers.delete()</code>：删除标头</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数</li></ul><blockquote><p>方法具体用法请参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;…</a></p></blockquote><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法</p><ul><li><code>response.text()</code>：得到文本字符串</li><li><code>response.json()</code>：得到 JSON 对象</li><li><code>response.blob()</code>：得到二进制 Blob 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取图片文件flower.jpg，显示在网页上</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">myImage.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob)</span><br></pre></td></tr></table></figure><ul><li><code>response.formData()</code>：得到 FormData 表单对象</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>Stream 对象只能读取一次，这意味着，前五个读取方法，只能使用一个，否则会报错。Response 对象提供了克隆方法</p><ul><li><code>response.clone()</code>：创建<code>Response</code>对象的副本，实现多次读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flowers.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response2 = response1.<span class="title function_">clone</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBlob1 = <span class="keyword">await</span> response1.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myBlob2 = <span class="keyword">await</span> response2.<span class="title function_">blob</span>()</span><br><span class="line"><span class="comment">// 将同一张图片读取了两次</span></span><br><span class="line">image1.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob1)</span><br><span class="line">image2.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob2)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>fetch这种方法虽然才了解，但是感觉好像还行，看了很多文章介绍，感觉在文件读取这里似乎有不错的应用。</p><p>但是说到底，这终归不是工作中常用的，连面试题问到的似乎都很少，如果不是这里刷到，似乎都没什么人讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-30">一文熟悉Ajax</a></p><p><a href="https://juejin.cn/post/6997784981816737800">有同学问我：Fetch 和 Ajax 有什么区别？ - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朋友：也许面试官是问你什么是fetch呢？我：什么是fetch？&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解axios</title>
    <link href="https://crazystudent13.github.io/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/"/>
    <id>https://crazystudent13.github.io/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/</id>
    <published>2024-05-09T11:43:42.000Z</published>
    <updated>2024-05-19T16:58:54.595Z</updated>
    
    <content type="html"><![CDATA[<p>承接昨天的日志，问到ajax，怎么可能不问axios呢。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这虽然是一次模拟面试，但当模拟真的开始的时候，我开始汗流浃背了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官：能详细说说axios吗？</span><br><span class="line"></span><br><span class="line">我：项目中常用的一个工具库，封装接口请求的工具方法。</span><br><span class="line"></span><br><span class="line">面试官：很高兴面试您，如果后续有结果了，我们会通知您的。</span><br></pre></td></tr></table></figure><p>虽然知道今年很卷，但是比想象中要卷的多。</p><blockquote><p>本节为 Axios 常规使用，更多方法请看<a href="https://link.juejin.cn/?target=https://www.kancloud.cn/yunye/axios/234845/">Axios中文文档</a>、<a href="https://link.juejin.cn/?target=https://www.axios-http.cn/docs/intro">Axios中文文档(官方)</a>、开源API库：<a href="https://link.juejin.cn/?target=https://www.bootcdn.cn/index.html">BootCDN</a></p></blockquote><h3 id="Axios概念"><a href="#Axios概念" class="headerlink" title="Axios概念"></a>Axios概念</h3><p>Axios 是一个基于 promise 的网络请求库，作用于 node.js 和浏览器中，它是 isomorphic 的 (即同一套代码可以运行在浏览器和 node.js 中)。</p><p>在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequest</p><ul><li><strong>Axios 本质上是对原生 XMLHttpRequest 的封装</strong>，只不过它是 Promise 的实现版本，符合最新的 ES6 规范</li></ul><blockquote><p>Promise教程请参考：<a href="https://juejin.cn/post/7321996765977198611">juejin.cn&#x2F;post&#x2F;732199…</a></p></blockquote><p>主要特点：</p><ul><li>从浏览器创建 XMLHttpRequests、从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>超时处理</li><li>自动将请求体序列化</li><li>自动转换 JSON 数据</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>使用 npm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ul><li>使用 CDN</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>可以向 <code>axios</code> 传递相关配置来创建请求</p><ul><li><code>axios(config)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起一个get请求, 参数名和值会自动拼接到url</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起一个post请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>常用请求方法：</p><table><thead><tr><th>请求方法</th><th>操作</th></tr></thead><tbody><tr><td>GET</td><td>获取数据</td></tr><tr><td>POST</td><td>提交数据</td></tr><tr><td>PUT</td><td>修改数据（全部）</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>PATCH</td><td>修改数据（部分）</td></tr></tbody></table><p>为方便起见，为所有支持的请求方法提供了别名：</p><p>无 data 属性：</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[, config])</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.options(url[, config])</code></li></ul><p>有 data 属性：</p><ul><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config]])</code></li><li><code>axios.postForm(url[, data[, config]])</code></li><li><code>axios.putForm(url[, data[, config]])</code></li><li><code>axios.patchForm(url[, data[, config]])</code></li></ul><blockquote><p>别名中的data属性无需显式给出，只需传入一个对象即可</p></blockquote><p>下面是使用方法别名的示例：</p><ul><li>GET 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// data属性直接为一个对象, 无需显式给出</span></span><br><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>,</span><br><span class="line">    <span class="attr">orders</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="attr">photo</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#fileInput&#x27;</span>).<span class="property">files</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>Axios 支持以 fetch API 方式—— <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a> 取消请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/foo/bar&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">controller.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>以下是创建请求时可以用的配置选项只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>GET</code> 方法</p><blockquote><p>配置源于官网，已将常用配置移到最前</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// baseURL 自动加在url前，除非url是一个绝对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// params 是与请求一起发送的 URL 参数, 与 get 方法搭配使用</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data 是作为请求体被发送的数据 (PUT、POST、DELETE、PATCH)</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属: Stream, Buffer</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定请求超时的毫秒数, 超时则请求会被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 默认值是 0 (永不超时)</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// responseType 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// auth 示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 Authorization ，覆写掉现有的任意使用 headers 置的自定义 Authorization </span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span></span><br><span class="line">  <span class="comment">// 你可以修改请求头。</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span></span><br><span class="line">  <span class="comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span></span><br><span class="line">  <span class="comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span></span><br><span class="line">  <span class="comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span></span><br><span class="line">  <span class="comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// see https://axios-http.com/zh/docs/cancellation</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed </span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> <span class="comment">// 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>一个请求的响应包含以下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务器响应头, 所有的 header 名称都是小写, 而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: response.headers[&#x27;content-type&#x27;]</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// axios 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Axios默认配置"><a href="#Axios默认配置" class="headerlink" title="Axios默认配置"></a>Axios默认配置</h3><p>常规开源项目中的常见封装方式。</p><h4 id="全局默认配置"><a href="#全局默认配置" class="headerlink" title="全局默认配置"></a>全局默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="自定义实例"><a href="#自定义实例" class="headerlink" title="自定义实例"></a>自定义实例</h4><p>可以使用自定义配置新建一个实例：<code>axios.create([config])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例时配置默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例后修改默认值</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br></pre></td></tr></table></figure><h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p>配置将会按优先级进行合并</p><ul><li>优先级：<a href="https://link.juejin.cn/?target=https://github.com/axios/axios/blob/master/lib/defaults.js%23L28">lib&#x2F;defaults.js</a>默认值 &lt; 实例 <code>defaults</code> 属性 &lt; 请求 <code>config</code> 参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 使用库提供的默认配置创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 0</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写库的超时默认值 </span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写此请求的超时时间，因为该请求需要很长时间</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拦截器完整使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 创建一个单独的axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://xxx.xxx.xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">6000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">user</span>?.<span class="property">token</span>) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;store.user?.token&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="comment">// 数据脱壳、业务成功、业务失败、401 token失效的处理</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面判断用户请求的业务成功</span></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">data</span>?.<span class="property">code</span> === <span class="number">10000</span>) &#123;</span><br><span class="line">      <span class="comment">// 数据脱壳</span></span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 业务失败, 提示错误</span></span><br><span class="line">      <span class="title function_">showToast</span>(res.<span class="property">data</span>?.<span class="property">message</span> || <span class="string">&#x27;请求失败&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面这里的函数是请求失败，http状态码是 4xx 5xx</span></span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>?.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理401错误</span></span><br><span class="line">      <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">      store.<span class="title function_">delUser</span>()</span><br><span class="line">      router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><p>如果需要移除拦截器，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>面向面试开发的感觉，这些东西平日用的太顺手，整理出来甚至也不算细究，只是调用别人的工具方法。</p><p>但是在面试时候问出来，真是有一种。。。。无趣的感觉。</p><p>累了，这次单纯是为了面试整理了一下知识点，后续大概不会持续关注这种工具方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-17">一文熟悉Ajax</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;承接昨天的日志，问到ajax，怎么可能不问axios呢。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解ajax</title>
    <link href="https://crazystudent13.github.io/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/"/>
    <id>https://crazystudent13.github.io/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/</id>
    <published>2024-05-08T13:24:40.000Z</published>
    <updated>2024-05-19T16:58:54.594Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：ajax是什么？我：啥？这不是JQuery封装的工具方法吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，模拟面试那时候，什么刁钻的问题几乎都接触过，用这种远古问题拷打我，真是。。。绝了。</p><p>我还没答上来，真是，绝妙。</p><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX 代表异步的 JavaScript 和 XML（<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML）。</p><p>简单点说，就是使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象与服务器通信。它可以使用 JSON、XML (Extensible Markup Language)、HTML 和文本文件等格式发送和接收数据</p><p>AJAX 最吸引人的就是它的<code>异步</code>特性，也就是说它可以在<strong>不重新刷新页面</strong>的情况下与服务器通信、交换数据或更新页面</p><p>整个流程很简单，如下</p><ol><li>创建一个XMLHttpRequest对象，发送异步请求HttpRequest</li><li>服务器通过网络，接收HttpRequest请求，返回请求数据</li><li>浏览器通过网络，接收服务器返回的数据，用JS操作DOM更新页面</li></ol><p>为避免混淆，这里重新梳理一下 Ajax 概念：</p><ol><li>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</li><li>AJAX <strong>不是编程语言</strong>，而是一种基于现有标准的新方法</li><li>AJAX 最大的优点是在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并更新部分网页内容</li><li>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。</li><li><strong>XMLHttpRequest 只是实现 Ajax 的一种方式</strong></li></ol><p><strong>总的来说，AJAX是浏览器与服务器进行数据通信的技术</strong></p><h3 id="AJAX实现"><a href="#AJAX实现" class="headerlink" title="AJAX实现"></a>AJAX实现</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL (Uniform Resource Locator) 统一资源定位符（统一资源定位器、定位地址、URL地址）俗称地址，是因特网上标准的资源的地址，如同在网络上的门牌，用于访问网络上的资源</p><p>URL组成：URL 由<strong>协议</strong>、<strong>域名</strong>、<strong>资源路径</strong>组成</p><ul><li>协议：URL 使用 http 协议（超文本传输协议），规定浏览器与服务器之间传输数据的格式</li><li>域名：标记服务器在互联网中的方位</li><li>资源路径：标记资源在浏览器下的具体位置</li></ul><p>比如，我们这里架假设要去访问百度网站上的一份文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/test/helloworld.txt</span><br></pre></td></tr></table></figure><p>这里我们将上述url拆分一下，结果如下</p><table><thead><tr><th>访问协议</th><th>服务器名称：域名</th><th>目录名</th><th>文件名</th></tr></thead><tbody><tr><td>http:</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td><td>test</td><td>helloworld.txt</td></tr></tbody></table><p>域名这里如果细说，还要提到IP和端口，这里暂时先跳过，下期再说。</p><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><h5 id="XHR概念"><a href="#XHR概念" class="headerlink" title="XHR概念"></a>XHR概念</h5><p><code>XMLHttpRequest</code>（XHR）对象<strong>用于与服务器交互</strong>。</p><p>通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL 来获取数据。</p><p>这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p><p><code>XMLHttpRequest</code> 在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX">AJAX</a> 编程中被大量使用，所有现代浏览器均支持 XMLHttpRequest 对象</p><p><code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML，它甚至支持 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:&#x2F;&#x2F; 和 FTP），尽管可能受到更多出于安全等原因的限制</p><h5 id="XHR使用"><a href="#XHR使用" class="headerlink" title="XHR使用"></a>XHR使用</h5><p>实现 <code>Ajax</code>异步交互需要完成以下步骤：</p><ul><li>创建 <code>XMLHttpRequest</code> 对象</li><li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li><li>构建请求所需的数据内容，并通过<code> XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li><li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>readystatechange、loadend</code> 事件监听服务器端的通信状态</li><li>接受并处理服务端向客户端响应的数据结果</li><li>将处理结果更新到 <code>HTML</code>页面中</li></ul><h5 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h5><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法</p><p><strong>open()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务器建立连接</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>method</td><td>表示当前的请求方式，常见的有 <em>GET</em>、<em>POST</em></td></tr><tr><td>url</td><td>服务端地址</td></tr><tr><td>async</td><td>布尔值，表示是否异步执行操作，默认为 <em>true</em>(异步)</td></tr><tr><td>user</td><td>可选的用户名用于认证用途；默认为 <em>null</em></td></tr><tr><td>password</td><td>可选的密码用于认证用途，默认为 <em>null</em></td></tr></tbody></table></li></ul><p><strong>send()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body为 XHR 请求中要发送的数据体(string)，如果不传递数据则为 null</span></span><br><span class="line">xhr.<span class="title function_">send</span>([body])</span><br></pre></td></tr></table></figure></li></ul><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p><p>每当 readyState 改变时（存有 XMLHttpRequest 状态信息）就会触发 readystatechange 事件</p><p>以下是 XMLHttpRequest 对象的三个重要的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</td></tr><tr><td>readyState</td><td>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200：”OK”，404：未找到页面</td></tr></tbody></table><blockquote><p>readystatechange 事件被触发四次，分别是：0-1、1-2、2-3、3-4，对应着 readyState 的每个变化</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span> ) &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>获取 XMLHttpRequest 响应体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readBody</span>(<span class="params">xhr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!xhr.<span class="property">responseType</span> || xhr.<span class="property">responseType</span> === <span class="string">&quot;text&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseText</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">responseType</span> === <span class="string">&quot;document&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseXML</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">response</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XHR使用示例"><a href="#XHR使用示例" class="headerlink" title="XHR使用示例"></a>XHR使用示例</h5><ul><li>GET 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://xxxx.com/xxx/xxx?参数名1=值1&amp;参数名2=值2&#x27;</span>) </span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POST请求，要设置请求头，请求体携带JSON字符串</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://xxx/api/register&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><h3 id="相关概念拓展"><a href="#相关概念拓展" class="headerlink" title="相关概念拓展"></a>相关概念拓展</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>但在以下情况中，请使用 POST 请求：</p><ul><li>不愿使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><p>常见 GET 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/try/ajax/demo.php?fname=Henry&amp;lname=Ford&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><p>常见 POST 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo.php&quot;</span>,<span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>POST 方式发送数据，需要设置请求头，并且使用<code>send</code>方法传递参数</p></blockquote><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><code>Content-Type</code>是 HTTP 头部字段之一，用于指示请求或响应消息的媒体类型</p><p>以下是常见的<code>Content-Type</code>格式：</p><ul><li><code>application/json</code>：用于传输 JSON 格式的数据</li><li><code>application/xml</code>：用于传输 XML 格式的数据</li><li><code>text/plain</code>：纯文本格式，通常用于普通文本文件</li><li><code>text/html</code>：用于传输 HTML 格式的数据</li><li><code>image/jpeg, image/png, image/gif</code>：用于传输图像数据</li><li><code>multipart/form-data</code>：通常用于上传文件，表单数据会被编码成一系列的部分</li><li><code>application/x-www-form-urlencoded</code>：通常用于发送表单数据，数据会被编码为键值对的形式（表单默认的提交数据的格式）</li></ul><p>在 HTTP 协议中，如果未明确指定 <code>Content-Type</code> 头部字段，默认值取决于请求或响应的具体情况：</p><ul><li><strong>对于请求（Request）</strong><ul><li>对于常见的表单提交，即 <code>application/x-www-form-urlencoded</code></li><li>对于通过表单上传文件的情况，即 <code>multipart/form-data</code></li></ul></li><li><strong>对于响应（Response）</strong><ul><li>如果服务器响应包含实际的数据，而不仅仅是一条状态码和头部字段，则常见的默认值为 <code>application/octet-stream</code>，表示二进制流，没有指定具体的数据类型</li></ul></li></ul><p>HTTP 协议规范允许在请求和响应中都不设置 <code>Content-Type</code> 头部字段。</p><p>在这种情况下，接收方可能需要根据上下文来猜测数据的类型，这可能引入一些不确定性。</p><p>推荐在请求和响应中显式地设置 <code>Content-Type</code> 头部字段</p><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>Ajax 操作往往用来传递表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单，特别适用于发送包含文件上传等复杂数据的请求</p><p>使用 FormData 可以执行以下步骤：</p><ul><li>创建一个 FormData 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br></pre></td></tr></table></figure><ul><li>向 FormData 对象中添加字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>添加文件类型的字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件输入框中获取选中的文件, 可以根据实际情况选择获取文件的方式</span></span><br><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>将 FormData 对象作为请求的 body 或附加到 XMLHttpRequest 或 fetch 等发送请求的方法中：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/api/endpoint&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(formData)</span><br></pre></td></tr></table></figure><p>以上就将 FormData 数据作为请求的一部分发送给服务器端了</p><p>注意事项：</p><ul><li>当使用 FormData 时，浏览器会自动设置适当的 <code>Content-Type</code> 头部，无需手动设置</li><li>FormData 也支持删除字段和追加相同字段名的多个值等操作，请根据需求使用相应的方法</li></ul><blockquote><p>FormData 对象其他方法参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">MDN-FormData</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说实话，早年就以为这东西是jquery封装的，结果上次模拟面试被狠狠拷打了一波。</p><p>虽然这种远古问题不应该算是关注范围以内的东西了，但是有备无患，这里记录一下。</p><p>2024年了，我居然又翻到ajax了，真是。。绝了。</p><p>这两天把ajax，axios，fetch相关的请求方式全整理一遍，不然面试还真有点发憷。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817?searchId=2024050820515495FC5659A1B7863EB72F">一文熟悉Ajax</a></p><p><a href="https://developer.mozilla.org/zh-CN/">MDN-CN</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：ajax是什么？我：啥？这不是JQuery封装的工具方法吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>解决github提交代码端口报错的问题</title>
    <link href="https://crazystudent13.github.io/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://crazystudent13.github.io/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-07T15:25:19.000Z</published>
    <updated>2024-05-13T11:35:42.336Z</updated>
    
    <content type="html"><![CDATA[<p>癞蛤蟆趴脚上，不咬人膈应人，这事能出问题，国内这个网络环境全责，这狗屎一样的网络环境真是一言难尽。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天写完博客，提交代码的时候正好遇到这个问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><p>这里简单翻译一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh:连接到主机github.com端口22:连接超时</span><br></pre></td></tr></table></figure><p>常规的做法无非就是挂加速器或一些梯子，但是好巧不巧，今天梯子到期了。</p><p>于是只能连夜翻CSDN，结果屎里淘金找了半个小时也没有几个靠谱的解法，好在掘金论坛翻到了一个不错的解决方案。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>出现这个问题，很可能是你的网络供应商（比如广电网）在出口防火墙上屏蔽了22端口（本地使用vpn等代理服务），这意味着你将无法访问其他主机的22端口。</p><p>github提供了一种解决方案，允许你使用<strong>443端口进行ssh连接</strong>。</p><p>因为443端口是访问<strong>https网站</strong>所必须的，大部分防火墙都会允许通过，但如果使用<strong>代理服务器</strong>可能产生干扰。</p><h3 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h3><p>我这里使用gitbash命令行工具，不推荐使用powershell和cmd，因为win的权限和创建文件的命令太难背。</p><p>这里我的电脑是win11，默认大家存放的公钥的文件都在ssh文件夹下。</p><p>首先，我们切换到ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>然后，若是没有文件config，我们这里新建一个config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure><p>config文件需要手动添加如下内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port <span class="number">443</span></span><br><span class="line"><span class="keyword">User</span> git</span><br></pre></td></tr></table></figure><p>之后，继续在gitbash中，写入如下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>命令行在这里会提示你确定是不是要这么做，你选yes就行。</p><p>因为这是为了让每次ssh连接github都通过443端口，指明ssh连接<code>git@github.com</code>或<code>git@ssh.github.com</code>走443端口</p><p>最后，重新执行，检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果命令行中有success等字样，那就代表修改成功了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这虽然是个简单的修改方式，但是没想到国内传统的技术论坛就没几个靠谱的解法。</p><p>为了防止下一次再次翻车，这里必须得写一下了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7325627349080424457?searchId=20240507230033784D20BC75A8A6B6BB11">解决git push提交超时问题ssh: Connection timed out</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;癞蛤蟆趴脚上，不咬人膈应人，这事能出问题，国内这个网络环境全责，这狗屎一样的网络环境真是一言难尽。&lt;/p&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://crazystudent13.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解6种接口请求的方式</title>
    <link href="https://crazystudent13.github.io/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>https://crazystudent13.github.io/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</id>
    <published>2024-05-07T14:06:34.000Z</published>
    <updated>2024-05-19T16:59:02.981Z</updated>
    
    <content type="html"><![CDATA[<p>模拟面试题，今天刷到了，我除了知道传参方式略有不同之外，什么也回答不上来。</p><p>干了这么多年的前端，不知道这个，说实话，有点汗颜。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作。</p><h3 id="六种方式"><a href="#六种方式" class="headerlink" title="六种方式"></a>六种方式</h3><ol><li>Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）</li><li>Post 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改</li><li>Put 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）</li><li>Delete 请求服务器删除request-URL所标示的资源（请求服务器删除页面）</li><li>Head 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的响应中没有具体内容，用于获取报头）</li><li>opions 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许客户端查看服务器性能）</li></ol><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET一般用于获取&#x2F;查询资源信息。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>post向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改。</p><p>post请求一般通过body传递参数。</p><p>包括一些文件上传什么的，常用这种请求类型。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>这个方法比较少见,HTML表单也不支持这个，常见的工作任务中，多数后端都更远已使用post来取代put。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><p>就是说，put是更在更新服务器上已经存在的数据。</p><p>举个例子：如一个用于提交博文的URL，&#x2F;addBlog。如果用PUT，则提交的URL会是像这样的”&#x2F;addBlog&#x2F;abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。</p><p>目前大部分博客都是这样的，显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除某一个资源。</p><p>因为目前大多数公司业务删除都是伪删除，所以这种类型的请求很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。</p><p>有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。</p><p>若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一度以为接口常见的请求方式就四种，如果不是今天刷面试题，还真不清楚这个冷知识，也是颇为长见识了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6899465311712935949?from=search-suggest">接口请求的六种常见方式详解（get、post、head等）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟面试题，今天刷到了，我除了知道传参方式略有不同之外，什么也回答不上来。&lt;/p&gt;
&lt;p&gt;干了这么多年的前端，不知道这个，说实话，有点汗颜。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2024年生活规划</title>
    <link href="https://crazystudent13.github.io/2024/04/28/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/"/>
    <id>https://crazystudent13.github.io/2024/04/28/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/</id>
    <published>2024-04-27T16:03:24.000Z</published>
    <updated>2024-05-19T16:58:54.599Z</updated>
    
    <content type="html"><![CDATA[<p>完成2023年没搞定的任务，并继续人生新目标。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>2023年规定的事，只完成了一半，有点尴尬。</p><p>不过，好在也是折腾出来打了一些东西，所以不算太过尴尬，这里继续去年的计划，开始新一轮的新年计划。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>前几年工作的积蓄算是被清的差不多了，又赶上市场暴死，幸亏还有点技术底子，不然现在真是不知道做什么好。</p><p>如今找到了一份勉强糊口的清闲工作，于是打算趁这段时间好好规划，这是30之前的最后一年了，如果规划好，35之前的卖身日子应该还是有救的。</p><ol><li><strong>简单掌握nodejs，并简单写两个项目作为自己可以展示的私人项目来做护城河。</strong></li><li><strong>简单掌握JAVA，完成一个像样的后台管理系统</strong></li><li><strong>维护自己的开源工具cat-tools，完成去年未做完的事情</strong></li></ol><h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>去年减重太过反复，虽然中间削低谷时期削弱到了90KG级左右，但是之后因为冬季，运动量骤减，最终体重快速反弹。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><strong>本年目标恢复75KG级体重</strong></li><li>作息稳态化，不要像去年那样容易被打乱</li><li>身体内分泌常规化，尽量摆脱药物，将高血压高血脂控制再常规水平之下</li><li>调理腰椎和皮肤</li></ol><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ol><li><strong>严格控制摄入量，每天不要摄入大量碳水，每月最多一餐油炸类食物。</strong></li><li><strong>控制饮料，减少碳酸类等饮料的摄入</strong></li><li><strong>作息从轮班换成常规作息，晚上11点之前能不依赖药物睡着</strong></li><li><strong>能够进行5公里快速长途骑行，时速能拉到18左右最好</strong></li><li>能够进行<strong>简单的游泳</strong>（冬季）</li><li>经常进行腰椎和皮肤的调理，并长期使用工学椅</li></ol><h3 id="学历"><a href="#学历" class="headerlink" title="学历"></a>学历</h3><p>由于去年各种糟心事太多，自考这点除了去年一开始还在正轨，后来完全脱轨，生活的种种琐事硬是冲断了自己的计划。</p><p>因为种种缘故，原定的八门课程，去年拢共就考了一门，真是太过操蛋。</p><p>而今年也因为找工作的缘故，4月份的自考也没能花时间去准备，一切真是糟糕。</p><p>今年如果再次被打断，我就不考虑走大自考路线了，直接放弃证道，选择最low的成人高考模式，毕竟这些东西本质上就是弄个证书。</p><ol><li><strong>高数，原定的计划</strong></li><li><strong>离散数学，相对较为简单一门</strong></li><li><strong>数据结构，工作中要接触的科目</strong></li><li><strong>计算机网络原理，工作中必然要接触的科目</strong></li></ol><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>去年接触了nas之后，知识体系走的有点偏，今年为了工作，重新矫正一下知识体系。</p><ol><li><strong>补全前端的更底层知识体系，有时候还真是架不住面试官问的太深层。</strong></li><li><strong>较为纯熟的掌握nodejs，自主开发一套小型的类博客平台</strong></li><li>今年主要掌握视频直播的相关技术</li><li>次要掌握地图相关的技术</li><li>考虑掌握网络安全相关的技术</li><li>考虑掌握无人机飞行证书（视工作情况而定）</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong>写一本小说，先存稿60万字，将去年想到的一些思路进行整合</strong>，10月份过后，试试水。</li><li>在身体恢复正常后，尝试相亲或者恋爱，太久没和女人接触了，感觉人有点不正常</li><li>每月拜一拜关二爷。</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>读一些已经读过的书，以如今的心境，会有一些不一样的感觉。</p><ol><li>《南明史》</li><li>《三体》</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>去年规划的太过满了，再加上平日琐事太多，规划的任务大部分未能完成（尴尬，吹牛吹爆了）。</p><p>但是，至少留下了一些可供参考的路径，今年努把力，把去年没做完的地方补全，尤其是身体和学历这方面。</p><p>希望今年一切顺利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;完成2023年没搞定的任务，并继续人生新目标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="年计划" scheme="https://crazystudent13.github.io/tags/%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2024年的第一份offer</title>
    <link href="https://crazystudent13.github.io/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/"/>
    <id>https://crazystudent13.github.io/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/</id>
    <published>2024-04-26T14:01:32.000Z</published>
    <updated>2024-05-07T15:17:58.215Z</updated>
    
    <content type="html"><![CDATA[<p>终于找到工作了，但只是暂时安全了，种种巧合让我有种无力的宿命感，我不信命，但是不得不承认世事的无常。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，相对于整个前端的技术栈来说，我这点水平，属实有点鸭子睁眼，大可不必了。</p><p>找了这么久，什么样的技术栈都见过了，但是头一回遇到把我手里的技术栈近乎清零的公司了。</p><p>我会的是vue全家桶，这家公司的招人要求，除了是vue全家桶之外，别的几乎和我没什么交集，简直他妈的离谱。</p><p>我从来不注重性能，全面专注业务领域的，所以深层代码实现了解的较浅，但他们问的还都挺深，看上去和我有点犯冲。</p><p>不过，这几天面试下来，我也习惯从拷打面试官变成被拷打的一方了。</p><p>前端现在太广了，谁都不敢说自己事事精通。</p><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>在正式接面试的时候，看公司规模，0-20人，以为又是一家垃圾小公司，结果到地方一看就被镇住了。</p><p>妈的，是正儿八经的玩无人机的，而且型号还挺多，看着不像是胡闹的。</p><p>不仅有各式各样的无人机，开发人员也很年轻，很有年轻人的朝气，和我这种时代中浪迹的老油条完全是两个画风，不的不感叹，年轻真好。</p><p>现在想来，开在闹市区的CBD里边，注册资金1000万的级别，稍微想了一下，这感觉怎么也不像是普通公司，能在徐州招人用vue3+ts的公司，想来也是一朵奇葩（褒义）。</p><p>毕竟，我都在徐州面试使用jquery的岗位了（丢人的是还没面过），那我还能说什么呢。</p><p>跑了数家公司，见识了各种光怪陆离的情况，现在这家公司的情况，反而算是正常甚至有些优秀的画风了。</p><p>不得不说，我的认知滤镜第一时间给出了错误的判断，在到了现场之后，就表面看上去，这家公司看着确实是挺有实力的。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>这次基本上是我被拷打了。</p><p>说实话，我vue的底层原理除了早些年为了跳槽准备的时候仔细准备过，现在几乎都很难捡起来了。</p><p>然后传统的网络原理及网络安全这块，我几乎就没戏唱了，因为我只能说浅层次的涉猎，但是深入的问我的话，我几乎都不能准确而全面的回答上来。以前都是做的TOB或者TOG的项目，谁有胆子去入侵别人内网搞事情？</p><p>网络安全这块的认知，我几乎就是憨憨，我连SQL注入的手法都玩不明白。</p><p>你不能指望一个平时连放置个人网站都用傻瓜教程的家伙去深层次探秘。</p><p>之后是视频直播这块，我这里就更尴尬了，我对视频直播的了解，仅限于nas相关的那些东西，上传带宽+硬解码暴打一切不服，别的几乎没有任何方案了，就这么个认知，我也没法回答上来啥。</p><p>然后是地图，早些年确实基于百度开发的vueAmap做过一些浅层的标识放置，现在告诉我，他们这里觉得地图麻烦，打算自己整地图引擎。</p><p>嘶。。。。</p><p>一种油然而生的不妙感。</p><p>业务，是我不熟悉的领域，以前的业务经验基本上就算是打了折扣了。</p><p>技术，视频直播，地图开发，网站安全，这三相之力几乎全部都是软肋，任何其中一项技能都是一个肉眼可见的天坑。</p><p>这次的面试，基本上是我单方面被暴打。</p><p>不过，好在也算是快人快语，事情当场就给了结果，我周日就可以先去试岗，先试一周看看。</p><p>虽然面试被拷打，然后感觉上自己可能撑不过试岗，但是无人机真的很酷炫，能靠过去凑凑热闹也不错。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>如果未来能顺利通过试用期，入职的话，倒是会深入考虑深入看看视频相关的技术手段，网络安全这块应该也会考虑一下，至于3D这块，不太敢考虑。</p><p>毕竟，那玩意是出了名的投入大，回报少，我如今青春的时间不是很多了，不是很乐意去研究相关的技术。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新公司虽然给的薪资不算太多，但是总算是有点意思了，确实比长久不变的业务线有趣的多，就是不知道自己能不能扛下来。</p><p>本来都打算脱下长衫去送外卖了，但是偏偏命运垂青，给了一点点足够转机，我愿意试试看。</p><p>如果不成，那我大概率是真不适合这行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于找到工作了，但只是暂时安全了，种种巧合让我有种无力的宿命感，我不信命，但是不得不承认世事的无常。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解重绘和重排(回流)</title>
    <link href="https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81/"/>
    <id>https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81/</id>
    <published>2024-04-22T09:07:23.000Z</published>
    <updated>2024-05-07T15:17:58.208Z</updated>
    
    <content type="html"><![CDATA[<p>这是上海某次面试中的问题，说实话，我这个VueBoy还真不清楚这块的基础，这里整合一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文主要面向面试，所以先挑干的说，然后再细讲原理。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="重排或回流（Reflow）"><a href="#重排或回流（Reflow）" class="headerlink" title="重排或回流（Reflow）"></a>重排或回流（Reflow）</h4><p>当render树中的一部分或者全部因为大小边距等问题发生改变而<strong>需要DOM树重新计算</strong>的过程</p><h5 id="产生重排的场景"><a href="#产生重排的场景" class="headerlink" title="产生重排的场景"></a>产生重排的场景</h5><ul><li>页面渲染初始化，这是开销最大的一次重排</li><li>添加或者删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变，边距、填充、边框、宽度和高度</li><li>元素内容改变，如文本改变或者图片大小改变而引起的计算值宽度和高度改变</li><li>元素字体大小 改变</li><li>浏览器窗口尺寸改变，resize事件发生时</li><li>CSS伪类激活，如hover</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><h5 id="重排影响的范围"><a href="#重排影响的范围" class="headerlink" title="重排影响的范围"></a>重排影响的范围</h5><p>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h4 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a>重绘（Repaint）</h4><p>元素的一部分属性发生改变，如外观、背景、颜色等<code>不会引起布局变化</code>，只需要浏览器根据元素的新属性<strong>重新绘制</strong>，使元素呈现新的外观叫做重绘。</p><h5 id="产生重绘的场景"><a href="#产生重绘的场景" class="headerlink" title="产生重绘的场景"></a>产生重绘的场景</h5><ul><li><code>设置背景图片</code></li><li><code>修改字体颜色及样式</code></li><li><code>改变 visibility 属性值</code></li><li><code>设置box盒子阴影</code></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="页面生成"><a href="#页面生成" class="headerlink" title="页面生成"></a>页面生成</h4><ol><li>HTML 被 HTML 解析器解析成 DOM 树</li><li>CSS  被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制(paint)在屏幕上，显示出整个页面</li></ol><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h4 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h4><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h4 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h4><h5 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h5><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">left</span> = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">cssText</span> += <span class="string">&quot;; left: &quot;</span> + left + <span class="string">&quot;px; top: &quot;</span> + top + <span class="string">&quot;px;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.<span class="property">className</span> += <span class="string">&quot; className&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h5><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h5 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h5><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h5 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h5><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h5 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h5><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 根据上面的结论</span></span><br><span class="line"><span class="comment">  * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">  * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">  * 提高动画性能</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  div &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate3d</span>(10px, 10px, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在浏览器中查看页面渲染时间"><a href="#在浏览器中查看页面渲染时间" class="headerlink" title="在浏览器中查看页面渲染时间"></a>在浏览器中查看页面渲染时间</h3><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。</p><ul><li>loading: 网络通信和HTML解析</li><li>scripting: JavaScript执行</li><li>Rendering: 样式计算和布局，即重排</li><li>Painting: 重绘</li></ul><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。</p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</p><p>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>太久远的知识了，回顾了一下大佬的总结，感觉真是一种难得的有趣体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904083212468238?searchId=20240422171513D3B4751FC9432336560C">重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6938376882005999646?searchId=20240422171235DF23177183B7AA3806A2#heading-1">CSS 重绘（Repaint）、重排（回流）(reflow) - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是上海某次面试中的问题，说实话，我这个VueBoy还真不清楚这块的基础，这里整合一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解http常用状态码</title>
    <link href="https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2024-04-22T08:58:30.000Z</published>
    <updated>2024-05-07T15:17:58.207Z</updated>
    
    <content type="html"><![CDATA[<p>工作中不常用，而面试题常考。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1XX（临时响应）"><a href="#1XX（临时响应）" class="headerlink" title="1XX（临时响应）"></a>1XX（临时响应）</h3><ul><li>100 <code>Continue </code>继续。客户端应继续其请求</li><li>101  <code>Switching Protocols </code>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul><hr><h3 id="2XX（成功）"><a href="#2XX（成功）" class="headerlink" title="2XX（成功）"></a>2XX（成功）</h3><ul><li>200 <code>OK</code> 请求成功。一般用于<code> GET</code> 与 <code>POST</code> 请求</li><li>201 <code>Created</code> 已创建。成功请求并创建了新的资源</li><li>202 <code>Accepted</code> 已接受。已经接受请求，但未处理完成</li><li>203 <code>Non-Authoritative Information</code> 非授权信息。请求成功。但返回的 <code>meta </code>信息不在原始的服务器，而是一个副本</li><li>204 <code>No Content </code>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 <code>Reset Content </code>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 <code>Partial Content </code>部分内容。服务器成功处理了部分 <code>GET</code> 请求</li></ul><hr><h3 id="3XX（重定向）"><a href="#3XX（重定向）" class="headerlink" title="3XX（重定向）"></a>3XX（重定向）</h3><ul><li>300 <code>Multiple Choices </code>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 <code>Moved Permanently</code> 永久移动。请求的资源已被永久的移动到新 <code>URI</code>，返回信息会包括新的 <code>URI</code>，浏览器会自动定向到新 <code>URI</code>。今后任何新的请求都应使用新的<code>URI</code>代替</li><li>302 <code>Found </code>临时移动。与 <code>301 </code>类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 <code>See Other</code> 查看其它地址。与<code> 301</code> 类似。使用 <code>GET</code> 和<code>POST</code>请求查看</li><li>304 <code>Not Modified</code> 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>305 <code>Use Proxy</code> 使用代理。所请求的资源必须通过代理访问</li><li>306 <code>Unused </code>已经被废弃的<code> HTTP</code> 状态码</li><li>307 <code>Temporary Redirect</code> 临时重定向。与 <code>302</code> 类似。使用 <code>GET </code>请求重定向</li></ul><hr><h3 id="4XX（请求错误）"><a href="#4XX（请求错误）" class="headerlink" title="4XX（请求错误）"></a>4XX（请求错误）</h3><ul><li>400 <code>Bad Request</code> 客户端请求的语法错误，服务器无法理解</li><li>401 <code>Unauthorized</code> 请求要求用户的身份认证</li><li>402 <code>Payment Required </code>保留，将来使用</li><li>403 <code>Forbidden</code> 服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404 <code>Not Found </code>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>405 <code>Method Not Allowed</code> 客户端请求中的方法被禁止</li><li>406 <code>Not Acceptable</code> 服务器无法根据客户端请求的内容特性完成请求</li><li>407 <code>Proxy Authentication Required</code> 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权</li><li>408 <code>Request Time-out</code> 服务器等待客户端发送的请求时间过长，超时</li><li>409 <code>Conflict</code> 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</li><li>410 <code>Gone </code>客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</li><li>411 <code>Length Required</code> 服务器无法处理客户端发送的不带<code> Content-Length</code> 的请求信息</li><li>412 <code>Precondition Failed</code> 客户端请求信息的先决条件错误</li><li>413 <code>Request Entity Too Large</code> 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个<code> Retry-After</code> 的响应信息</li><li>414 <code>Request-URI Too Large </code>请求的 <code>URI</code> 过长（<code>URI</code> 通常为网址），服务器无法处理</li><li>415 <code>Unsupported Media Type</code> 服务器无法处理请求附带的媒体格式</li><li>416 <code>Requested range not satisfiable</code> 客户端请求的范围无效</li><li>417 <code>Expectation Failed</code> 服务器无法满足<code>Expect </code>的请求头信息</li><li>429  <code>Too Many Requests</code> 请勿频繁操作</li></ul><hr><h3 id="5XX（服务器错误）"><a href="#5XX（服务器错误）" class="headerlink" title="5XX（服务器错误）"></a>5XX（服务器错误）</h3><ul><li>500 <code>Internal Server Error</code> 服务器内部错误，无法完成请求</li><li>501 <code>Not Implemented </code>服务器不支持请求的功能，无法完成请求</li><li>502 <code>Bad Gateway</code> 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 <code>Service Unavailable</code> 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 <code>Retry-After </code>头信息中</li><li>504 <code>Gateway Time-out </code>充当网关或代理的服务器，未及时从远端服务器获取请求</li><li>505 <code>HTTP Version not supported</code> 服务器不支持请求的 <code>HTTP </code>协议的版本，无法完成处理</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基本上属于面试题不考的类型，但是经常会遇到，所以这里整理一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7030428038953173029?searchId=202404221657433AF2988FD33492318F90">一篇梳理http返回的状态码 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作中不常用，而面试题常考。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解http与https的区别</title>
    <link href="https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-04-22T07:56:51.000Z</published>
    <updated>2024-05-10T16:29:23.514Z</updated>
    
    <content type="html"><![CDATA[<p>http与https的区别是什么，今天看到群里有回答是复数的，一时间有点没绷住。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>早些年做个人网站，简单了解了相关知识，但是不够深入，这里整理一下。</p><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><h4 id="HTTP-定义"><a href="#HTTP-定义" class="headerlink" title="HTTP 定义"></a>HTTP 定义</h4><p>超文本传输协议（HTTP）是万维网使用的底层协议，它规定了消息如何被格式化和传输，以及网络服务器和浏览器应当如何回应各种命令。</p><h4 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h4><p>通常，HTTP的工作流程如下：</p><ol><li><strong>发起请求</strong>：在浏览器中输入URL或点击链接后，浏览器向对应的服务器发起资源请求。</li><li><strong>服务器响应</strong>：服务器处理接受到的请求并返回资源和HTTP头。</li><li><strong>建立连接</strong>：在HTTP老版本中，每次请求需要建立一个新的连接，造成了延迟。为了解决这个问题，在新的版本中提出了持久连接。</li><li><strong>资源渲染</strong>：浏览器接收到资源后开始解析并展示。</li></ol><h4 id="HTTP-的局限性"><a href="#HTTP-的局限性" class="headerlink" title="HTTP 的局限性"></a>HTTP 的局限性</h4><p>HTTP在状态无关、安全性、性能、数据传输大小等方面存在局限性。</p><h3 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h3><h4 id="了解-HTTPS"><a href="#了解-HTTPS" class="headerlink" title="了解 HTTPS"></a>了解 HTTPS</h4><p>安全超文本传输协议（HTTPS），即HTTP的安全版本，使用类似TLS或SSL的加密协议，加固客户端和服务器之间的连接。</p><h4 id="HTTPS-与-HTTP-的对比"><a href="#HTTPS-与-HTTP-的对比" class="headerlink" title="HTTPS 与 HTTP 的对比"></a>HTTPS 与 HTTP 的对比</h4><p>与HTTP以明文传送数据不同，HTTPS通过加密保护传输的数据，确保通讯过程的安全与数据在传递过程中不被篡改。</p><h4 id="HTTP-与-HTTPS-的六大不同"><a href="#HTTP-与-HTTPS-的六大不同" class="headerlink" title="HTTP 与 HTTPS 的六大不同"></a>HTTP 与 HTTPS 的六大不同</h4><ol><li>加密：HTTPS对数据进行加密，确保沟通的保密性。</li><li>数据完整性：HTTPS检验数据传输中未被修改。</li><li>身份验证：通过SSL证书，HTTPS可以验证服务器身份，防中间人攻击。</li><li>安全水平：与HTTP相比，HTTPS提供了更高的安全性。</li><li>端口定义：HTTPS默认使用443端口，而HTTP使用80端口。</li><li>URL模式：HTTPS的URL以 <code>https://</code> 开头，而HTTP则是 <code>http://</code>。</li></ol><table><thead><tr><th>特性</th><th>http</th><th>https</th></tr></thead><tbody><tr><td>加密</td><td>无</td><td>使用TLS&#x2F;SSL协议加密数据包</td></tr><tr><td>安全性</td><td>不安全，数据以铭文形式传输，容易被第三方截取和查看</td><td>安全，使用TLS&#x2F;SSL协议加密的数据包，防止拦截和篡改</td></tr><tr><td>证书</td><td>无</td><td>需要SSL证书，由可信任的证书办法机构（CA）颁发，用于验证服务器的身份</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>url标识</td><td>http:&#x2F;&#x2F;开头</td><td>https:&#x2F;&#x2F;开头</td></tr><tr><td>性能</td><td>通常较高</td><td>可能略低，犹豫加密解密带来的一些 计算开销，但随着技术进步，差异会逐渐缩小</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>连续翻看了几个介绍，发觉都差不多，这里就选了一篇最清楚的文档做了个整合。</p><p>当初弄个人网站的时候，简单了解了这二者的区别，并不深入，如今梳理之后，倒也颇为明晰，也算是小有收获了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7329772404645806099?searchId=2024042215523434CA7F568FA739283956">理解 Web 安全：HTTP 和 HTTPS 的关键区别 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;http与https的区别是什么，今天看到群里有回答是复数的，一时间有点没绷住。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解URL到页面加载的过程</title>
    <link href="https://crazystudent13.github.io/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://crazystudent13.github.io/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2024-04-21T13:12:41.000Z</published>
    <updated>2024-05-07T15:17:58.205Z</updated>
    
    <content type="html"><![CDATA[<p>好早之前的面试题，最近猛的一问，居然答不上来了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>在页面加载到最终渲染显示大致是这样的：</p><ol><li>用户在浏览器输入URL回车后，浏览器为了将URL解析成IP地址，会向DNS服务器发起DNS查询，获取IP地址。</li><li>在建立连接后，浏览器就可以发起HTTP请求，而服务器接受请求后进行响应，浏览器从响应结果中拿到数据，并进行解析和渲染，</li><li>最后在用户面前就出现了一个网页。</li></ol><p>简而言之就是三个阶段：</p><ul><li>客户端发起请求阶段</li><li>服务端数据处理请求阶段</li><li>客户端页面渲染阶段</li></ul><p>如果想起</p><ol><li>缓存解析地址，判断是否</li><li>DNS解析，（输入的是域名）</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回需要的数据</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>输入了一个域名,域名要通过DNS解析找到这个域名对应的服务器地址(ip),通过TCP请求链接服务,通过WEB服务器(apache)返回数据,浏览器根据返回数据构建DOM树,通过css渲染引擎及js解析引擎将页面渲染出来,关闭<a href="https://www.zhihu.com/search?q=tcp%E8%BF%9E%E6%8E%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2603050043%7D">tcp连接</a></p><h3 id="正常分析"><a href="#正常分析" class="headerlink" title="正常分析"></a>正常分析</h3><h4 id="首先在浏览器中输入URL-，缓存解析"><a href="#首先在浏览器中输入URL-，缓存解析" class="headerlink" title="首先在浏览器中输入URL ，缓存解析"></a>首先在浏览器中输入URL ，缓存解析</h4><p>浏览器先在缓存里找资源，浏览器缓存-系统缓存-路由缓存（如CDN缓存）中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><p>浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</p><h5 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h5><p>如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</p><h5 id="路由器缓存"><a href="#路由器缓存" class="headerlink" title="路由器缓存"></a>路由器缓存</h5><p>如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</p><h5 id="ISP（互联网提供服务商）缓存"><a href="#ISP（互联网提供服务商）缓存" class="headerlink" title="ISP（互联网提供服务商）缓存"></a>ISP（互联网提供服务商）缓存</h5><p>若上述均失败，继续向ISP搜索。</p><h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><p>浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。</p><p>DNS服务器是基于UDP的，因此会用到UDP协议。</p><ul><li>DNS(Domain Name System, 域名系统)，是域名和IP地址相互映射的一个分布式数据库</li><li>DNS 解析就是从域名映射到IP地址的过程</li><li>如果有些网站已经访问过了，下次访问时浏览器会依次从浏览器缓存、系统缓存、路由器缓存、ISP缓存、根域名服务器、顶级域名服务器、主域名服务器里面找IP地址，所以下次访问速度更快</li></ul><h4 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h4><p>解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。</p><h5 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a><strong>三次握手过程</strong></h5><p>建立tcp连接就是三次握手，三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号</p><p>第一次，客户端&#x3D;&gt;服务端 客户端向服务器端发送SYN&#x3D;1,代表请求建立连接；还发送seq&#x3D;n是客户端的序列号。</p><p>第二次，服务端&#x3D;&gt;客户端，服务端表名收到请求，发给客户端SYN&#x3D;1,代表同意建立连接，ack&#x3D;n+1，返回客户端序列号加1，代表确认收到信息，同时发送一个自己的序列号，seq&#x3D;x代表服务端序列号。</p><p> 第三次，客户端&#x3D;&gt;服务端 客户端发送SYN&#x3D;0表明开始发送信息，并返回ack &#x3D; x+1确认收到服务端序列号，并发送seq &#x3D; n+1</p><h4 id="发起HTTP请求"><a href="#发起HTTP请求" class="headerlink" title="发起HTTP请求"></a>发起HTTP请求</h4><p>浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器</p><h4 id="服务器响应请求并返回结果"><a href="#服务器响应请求并返回结果" class="headerlink" title="服务器响应请求并返回结果"></a>服务器响应请求并返回结果</h4><p>服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p><h5 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h5><p>通过四次挥手释放TCP连接； 前两次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道。</p><h5 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a><strong>四次挥手过程</strong></h5><p>​    客户端向服务器发送FIN控制报文段（首部中的 FIN 比特被置位）；</p><p>​    服务端收到FIN，回复ACK。服务器进入关闭等待状态，发送FIN;</p><p>​    客户端收到FIN，给服务器回复ACK，客户端进入等待状态（进入“等待”，以确保服务器收到ACK真正关闭连接）;</p><p>​    服务端收到ACK，链接关闭。</p><p><strong>四次挥手原因</strong></p><p> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p><p>TCP是全双工模式，这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；</p><p>但是，这个时候客户端还是可以接受来自服务端的数据；</p><p>当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；</p><p>当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><p>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</p><p> 构建CSS规则树：生成CSS规则树（CSS Rule Tree）</p><p> 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</p><p> 布局（Layout）：计算出每个节点在屏幕中的位置</p><p> 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</p><h5 id="浏览器渲染详细过程"><a href="#浏览器渲染详细过程" class="headerlink" title="浏览器渲染详细过程"></a>浏览器渲染详细过程</h5><p><strong>浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。</strong></p><p>最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，这个内部结构就是 DOM，DOM 提供了对 HTML 文档的结构化表述。渲染进程通过分词器将html字节流成功成一个个 token，包括 Tag token 和文本 token。HTML 解析器维护了一个 token 栈结构，token 会按照对应顺序入栈出栈，然后将 token 解析成 DOM 节点，并将 DOM 节点添加进 DOM 树中。</p><p><strong>异步下载资源文件</strong></p><p>解析过程中，如果遇到&lt; link href &#x3D;＂..＂＞和&lt; script src &#x3D;＂..＂＞这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p><p><strong>渲染样式</strong></p><p>渲染引擎在接受到 CSS 文本时，会将 CSS 生成 CSS对象模型CSSOM(即CSS Object Model) ，通过document.styleSheets可获取所有CSS样式表，然后将 styleSheet 中的属性值进行标准化操作。最后将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 进行渲染。</p><p>最后，渲染过程中，如果遇到＜ script ＞就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待＜ script ＞内容执行完之后，浏览器继续渲染。</p><p>—— <strong>为何要将 CSS 放在 HTML 头部？</strong> —— </p><p>这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM ，然后在解析 HTML 之后可一次性生成最终的RenderTree ，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p><p>—— <strong>为何要将 JS 放在 HTML 底部？</strong> —— </p><p>JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外， JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行， JS 放在底部执行时， HTML 肯定都解析成了 DOM 结构。 </p><p>JS 如果放在 HTML 顶部， JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p><h5 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h5><p>调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><h6 id="创建window对象"><a href="#创建window对象" class="headerlink" title="创建window对象"></a>创建window对象</h6><p>window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</p><h6 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h6><p>完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</p><h6 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h6><p>在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</p><h6 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h6><p>执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个基础知识我能回答，但是细节我答不上太多，稍微显得有点丢人。</p><p>当初面试时候都记得，如今居然都记不得了。</p><p>现在趁着梳理知识体系时候，好好学习一下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7154306280868282381?searchId=20240421211440950468993CA81FC881AA">从输入URL到页面加载的全过程 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好早之前的面试题，最近猛的一问，居然答不上来了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2024年第一次被骗</title>
    <link href="https://crazystudent13.github.io/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/"/>
    <id>https://crazystudent13.github.io/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/</id>
    <published>2024-04-20T12:45:38.000Z</published>
    <updated>2024-05-07T15:17:58.215Z</updated>
    
    <content type="html"><![CDATA[<p>这次好歹是没什么损失，问题不大，只是有种恶心的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>经过上次被骗的事，对于这类问题，我已经非常敏感了。</p><p>感觉自己化身烙印战士了，在最糟糕的时候，被骗子群体标记了，一旦我有所松懈，就会被这些小鬼缠上，真是麻烦。</p><p>妈的，等以后有钱了，一定要想办法干死这帮搞诈骗的。</p><p>终归是修行不够，贪了，想要个工作的贪欲占了上分，要是不贪，就不会有这么多屁事。</p><p>另外，2024了，连骗子都能对前端面试题说道说道，我真是麻了。</p><p>前端已死真不是随便说说啊。</p><h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><h4 id="陌生人"><a href="#陌生人" class="headerlink" title="陌生人"></a>陌生人</h4><p>昨夜凌晨3-4点，接到一个QQ添加的好友，说是同行，看到我简历不错，想和我私聊。</p><p>昨天夜里是周五，技术下班，第二天有休息，所以有技术人熬夜，这事儿常见。</p><p>稍稍思考一下，我没多想就同意了。</p><p>正好最近找工作找的火大尿黄，于是就先问了这个陌生人的几个前端面试题，没毛病，都能答上来，应该是同行，看样子问题不大。</p><p>毕竟最近面试机会不多，难得有个线上懂行的模拟面试，这怎么想就是一个好事儿。</p><p>现在想想，这个过程真是处处透着诡异，单纯就是自己纯纯上头了。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>首先是发了我一个面试题库软件呢。</p><p>这个我也知道，就是灵题库嘛，类似这种面试题集合的软件工具，我是不排斥的，我个人也喜欢用软件刷前端面试题。</p><p>但是，一直登录不上去，挺烦的，然后他给了我一串账号，说用自己的账号试试。</p><p>顺利登录了，之后点不开，不得已就转QQ视频，说是直接面试。</p><p>这里我还是排斥，如果不是工作找不到，我是真不考虑这些破事。</p><p>然后这时候又谈了一下最近的工作情况，他说自己是湖南人，然后在上海工作，然后和这个陌生人相谈甚欢，这里我放松戒备了。</p><p>然后，他说软件不好用，干脆他就模拟面试，不过需要开视频。</p><p>开视频这点是我很排斥的，毕竟半夜，开视频总有种不对劲的感觉，陌生人突然开视频怎么想都感觉不对劲啊。</p><p>可我真是太想进步了，难得的面试机会，就算是模拟面试我也想把握一下。</p><p>想了好一会儿，还是同意视频模拟面试。</p><h4 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h4><p>然后我就和他开了视频，对方是个男生，这更没什么不妥了，不是女人就意味着视频怎么也不会伪造，这让我还挺开心的。</p><p>简单的自我介绍和技术问答之后，三分钟左右，他说他要上厕所，先关闭视频。</p><p>然后差不多十多分钟后，劲爆的就来了。</p><p>这畜生拉老子进了一个小群，里面就我和他，然后发了我的裸照和裸聊视频，这还没完，通讯录和周围熟人的联系方式全给我盒出来了，包括我的个人身份信息。</p><p>这一手直接把我干懵了。</p><p>妈的，裸聊你好歹给我看个女人啊，我连女人都没看到，怎么就裸聊了，操你妈的！</p><p>但我毕竟是被骗过一次的人了，这套路我可太熟了。</p><p>提钱，免谈。</p><p>而且我属于社会独立的边缘人，你要发我裸照，我只会说，这图里边的不够大，麻烦P的大一点。</p><p>主要是，他妈个逼，我他妈的根本没裸聊过，居然就整了一套视频加图片，真行。</p><p>然后就是电话威胁+发彩信威胁，勒索说要八千。</p><p>他妈的，笑死人了，我怕你这个？</p><p>下次记得给我换个肥一点的，我现在的身体比之前更垃圾，照片上的人还是瘦了，不像我，还有，他下边太小了。</p><p>总之，接下来就是互喷，然后我当场报警，存了他的QQ。</p><p>本来还想存下来那个换脸视频研究下的，QQ把视频给拦截了，然后我自己都下不下来。</p><p>还有图，类似的情况。</p><p>再之后，我又骂了几句，本来还打算等一波电话轰炸来着，之后就没信了，骗子QQ注销了。</p><h3 id="技术思路"><a href="#技术思路" class="headerlink" title="技术思路"></a>技术思路</h3><p>虽然这事儿很恶心，但稍微盘点一下思路，倒也不是不可以理解。</p><p>这里不盘他的话术，单纯盘点一下他的技术手段。</p><ol><li>我的QQ应该是最近海投简历泄露出去的，因为简历中，我的邮箱就是常用的QQ邮箱，而且我已近海投了简历，对方猜出来我最近是在找工作的人，所以抓住了我的求职心理，妈的，信息裸奔是真烦。</li><li>面试软件是木马工具，猜测应该是先用超量授权的应用读取用户的通讯录，不然对方应该是盒不到我手里那么多信息的。</li><li>其次，视频换源应该是用克隆语音加AI换脸搞定的，我模拟面试时候穿着衣服，但是对面让我看一下全身装，之后发给我的视频里边，封面上我是没有穿衣服的，虽然没点开视频，但是估计是全裸了。猜测这里用了类似的AI脱衣手法，这个我自己也玩过。</li><li>最后，批量给亲友发彩信，目前没有朋友电话我，猜测应该是没发，这太怪了，群发彩信应该是成本不贵的，猜测应该是时间成本不值当，寻找下一个怨种了。</li></ol><h3 id="事情结果"><a href="#事情结果" class="headerlink" title="事情结果"></a>事情结果</h3><ol><li>报警，但是没正式立案，因为警察也比较同情我，说这要是立案，用人单位一查，有这事儿就难受了，干脆就别立案。</li><li>无事发生，没啥亲友找我，估计彩信没发出去，要么就是被当做骚扰电话拦截了，不过，那个辣眼睛的裸照，我自己都想戳瞎自己的双眼，妈的，造裸照就能造好看点吗。</li><li>骗子QQ主动注销，那家伙的QQ空间还蛮正常的，一个太阳号就这么被注销了，真可惜。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>估计自己已经在骗子那边挂号了，从第一次信息泄露之后，我就像是剑风传奇中，被蚀刻的鹰之团战士，就算逃了第一次估计后续也是一辈子被挂号了。</p><p>他妈的，联想早年的事儿，真是感觉缘分到了。</p><p>最近找工作太忙，没时间收拾这帮家伙。</p><p>妈的，后续我要有钱了，我先想办法干死这帮畜生。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次好歹是没什么损失，问题不大，只是有种恶心的感觉。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2024年前端求职经历</title>
    <link href="https://crazystudent13.github.io/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
    <id>https://crazystudent13.github.io/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/</id>
    <published>2024-04-14T07:21:39.000Z</published>
    <updated>2024-05-07T15:17:58.213Z</updated>
    
    <content type="html"><![CDATA[<p>大劫将至，前端已死。</p><p>我们都是技术上的妓女，当青春的肉体不再，年老之时，我们将不再有任何价值。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在正式开始说话前，先将我个人的暴论放在前边。</p><p>如果还是现在这个行情，两年内，前端和后端都会有一场近乎踩踏式的失业潮。</p><p>前端已死，2023的小型裁员潮只是第一年，2024的内卷求职潮才是真正的开始。</p><p>以往火烧到了应届生身上，现在火烧到了应届本科生和三到五年的大专生身上，未来不好说。</p><p>当然，重本那群怪物不在考虑范围之内，如果连他们工作都不好找，那只有一种可能，世界大战的火烧到本土了。</p><p>2024，不仅仅是前端，是所有的互联网职业 ，都要为自己的过去的高收入付账了。</p><h3 id="招聘软件"><a href="#招聘软件" class="headerlink" title="招聘软件"></a>招聘软件</h3><p><strong>推荐使用BOSS直聘</strong>，也只有boss直聘反馈快点，其他的几个软件都是一坨屎。</p><p>智联等于失联，拉钩连个像样的发贴请求都没有，猎聘和51根本不是程序员用的。</p><p>如果没有内推，推荐使用BOSS直聘求职。</p><h3 id="求职经历"><a href="#求职经历" class="headerlink" title="求职经历"></a>求职经历</h3><p>在2024的4月里，本着金三银四的求职时间，我这个臭带专毕业的，选择在四月份来赶一下这个晚集。</p><p>然后，我就发现今年的就业环境不是一般的冷，我的项目履历如果放在一年前，出去也算是暴打一批人，但是今年的就业环只让我感觉到一阵心凉。</p><p>我之前的工作地点大约都在苏州，所以，本来想在苏州继续找份工作，但今年到了苏州之后才发现，这里的就业环境几乎是大专绝地。</p><p>从4月8号开始正式，我大约面试了8家左右，这里林林总总包括一些线上面试。</p><p><strong>我的项目履历不差。</strong></p><p>三到五年的工作经验，项目履历涉及到低代码，bpmnJS流程图，涉及过OA系统，小程序，大型资产管理系统，数据大屏+地图可视化，做过npm的包，带过团队，在项目现场救过火。</p><p>这些我都写到简历里边，但这么多东西，没有换到任何一家苏州的面试邀约。</p><p><strong>大专，在这个时候是犯天条了。</strong></p><p>当初，没能花时间完成自考真是可惜，不过当初一直在加班，根本没时间，而现在的空窗期只有一年，一年时间，就算我再怎么努力，恐怕也没办法把剩余的十二门考试全弄考完，因为一年只能报八门。</p><p>学历就算上去了也没用，要求里边全是统招本科，后续提升上去的，大概率没戏。</p><p>此时，苏州大部分工作，待遇依然没有下降，但是招聘要求抬了好几个档次，简历过不了人事那关，就只能上其他城市了。</p><p>扫了一眼，上海还行。</p><p>虽然上海房租贵，物价高，外地人被歧视的严重，交通恶心，而且疫情期间那种封闭到现在让我感觉到畏惧，我有个同事真的在上海被关在房里饿了一天。</p><p>但，人要过日子的。</p><p>不得已，只能将目光转到上海，去魔窟卖身了，好在上海没给大专上天条，至少我还能看到有很多家招收大专的，3-5年，正经的态度。</p><p>然后，在一周的时间里，我看到BOSS直聘的招聘要求，逐渐从1-3年，转到3-5年，最后从大专升到本科，然后工资压到实习生的水准。</p><p>麻了，今年的就业环境真是彻底凉透了。</p><h3 id="招聘要求"><a href="#招聘要求" class="headerlink" title="招聘要求"></a>招聘要求</h3><p>投了大概500多家，环江苏找了一圈工作之后，最后只能停留在上海附近。</p><p>苏州这种新一线城市，要求提的虽然高，但是技术栈挺新潮，工作待遇大多较好，大环境虽然烂，但是待遇这块没的说。</p><p>上海那边超一线城市，要求相对不高，而且技术栈较新，待遇参差，上下差距极大，但至少有的选。</p><p>其他地方大多垃圾，要么技术栈直接拉胯到爆炸，要么薪资待遇就是在养黑奴，综合下来，找了半天，整个江苏居然只有苏州和上海勉强能看。</p><p>所有公司的招聘意向，我大致梳理了一下，有如下几个套路，我个人按照心里的综合评分，从高到底逐次介绍。</p><ol><li>优中选优的正常向纯前端，要求本科学历，3-5年工作经验，项目履历丰富，能加班，有大厂项目经历最好，在上海薪资11k-15k（考虑到3000左右的房租，这个薪资勉强算是能活，毕竟3-5年不年轻了，再有两年，可能就做不了事情了，这个工资水平是最后的晚餐）</li><li>全干工程师，要求大专及以上，3-5年工作经验，前端要掌握一门后端语言，后端要掌握一门前端框架，能加班，在上海薪资15K-20K（看着正常，但这种全干工程师，绝对是要一个人干两个人的事情，而且项目管理大多不正规，各种死线周期瞎改需求是常有的事，在这种地方做久了，会折寿）</li><li>设计型前端，，但是倾向于设计，自带审美（这话的意思是你要做设计的活），工资水平大约12k-15k左右。（这种工资水平虽然低了一些，但只要稍微懂点设计应该能糊弄，但一个没有设计的公司，大概率还在蛮荒时期，这个技术栈难以想象，平庸但是安稳。）</li><li>短期外包型，要求大专起步，1-3年或3-5年，纯前端或者纯后端都可以，但是要你签短期合同，而且承诺无偿加班，待遇有些偏黑奴，不过。（外包，在技术行业里基本上和黑奴没差别，在外边做技术支持的时候，甚至不能喝那些人饮水机里边的水，如果要形容的话，和黑奴比，唯一的优势大概就是至少有一定的人权，不是纯纯的农具）</li><li>纯农具型外包，学历大专起步，1-3年工作经验，纯前端，有的要求短期不结账，等项目完成后再结账，有的要求在上海月薪约莫2-4K（妈了个逼的，2-4k这种连吃饭的钱都够呛，上海一碗牛肉面就得18，他妈的莫不是让人不吃牛肉？能开出这种要求，我只能说没钱你装你妈比的boss，资本家是那么好当的？）</li></ol><p>以上五种，大致是我这边整理出来的所有需求，仅供参考。</p><h3 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h3><p>时隔这么多年，再次拿起这些八股文，我只感觉一股悲凉。</p><p>毕业的时候，背面试题，被卡本科学历，然后低价招到公司。</p><p>干了快五年了，我还在背面试题，被卡本科学历，然后又会被低价招到了公司。</p><p>工作经验，属于屁用没有了，反而因为年轻的肉体已经不在，因为年龄大而遭到了就业的歧视。</p><p>重新看了很多，VUE的常规问题，es6的基础，promise的部分内容，computed和watch监听的实现，https和http，TCP和UDP，url输入之后发生什么之类的基础八股文看了一堆。</p><p>有用，也有些感悟，但是感觉心凉。</p><p>他奶奶的，这种问题平日谁看啊？业务上一堆逼事不做，来看这个？</p><p>好在，面试官大多给了我这个求职者最后的尊严，简单问了一些小的技术点之后，他们露怯了，不敢细问，因为我的回答可能比他们手里的答案要深，如果要是胡搅蛮缠的让我去写算法，写二叉树，手写promise，那我只能说，太悲凉了。</p><p>之后，他们没有问那些假大空的八股文，反而问了我很多技术实现的细节，我讲了项目怎么优化翻新，怎么重构项目中不合理的地方，团队前端工具的统一管理，前公司的业务流程和技术实现。</p><p>我没有特地去记这些事情，只是随便讲了些许之前的内容，可只是一开口，我就停不下来了，每次讲到这些，我好像又回到了那些时候。</p><p>每当我讲到这些项目经历时，我居然有种怀念青春的可笑感。</p><p>他妈的，我真是贱人啊。</p><p>高三天天熬夜，因为小高考残废考不上本科，我认了。</p><p>工作后天天加班熬夜，把身体搞垮，调养一年重新就业之后，我再次竞争失利，因为我是大专，哈哈哈哈，他妈了个逼的。</p><p>我认了，大专，就是犯了天条的罪人。</p><p>现在想来，我非常讨厌高三，但是却非常怀念加班的日子。</p><p>这两个于我而言同样都是苦日子，但我却更怀念那段加班的日子，不是因为我贱，而是我上班之后，终于能挣钱了，钱给了我尊严。</p><p>我并不怀念青春，我只是渴求金钱，我不想再忍受贫穷的苦楚。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不买房，不结婚，不疯魔，老老实实等着，挣够了钱，我就给自己赎身回家。</p><p>这个时代，是最好的时代，也是最烂的时代。</p><p>在这个喧闹的时代里，技术人就像是十里洋场的舞女，将自己那不值一提的年轻肉体和精神化作洋场之上的霓虹灯，他们的血汗和尊严点缀了这个疯狂的时代，让这个时代有了病态的繁荣。</p><p>但是，宴会终有散会时，今年的失业潮终于要击碎这摇摇欲坠的黄粱一梦了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大劫将至，前端已死。&lt;/p&gt;
&lt;p&gt;我们都是技术上的妓女，当青春的肉体不再，年老之时，我们将不再有任何价值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>vue2生命周期</title>
    <link href="https://crazystudent13.github.io/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://crazystudent13.github.io/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2024-03-28T01:09:36.000Z</published>
    <updated>2024-05-07T15:17:58.218Z</updated>
    
    <content type="html"><![CDATA[<p>工作时候用的特别熟悉的内容，如今竟然有一种生疏的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>重新整理一下，免得面试时候露怯。</p><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><p><strong>定义：组件从 创建 到 销毁 的整个过程就是生命周期</strong></p><p><strong>作用：特定的时间点，执行特定的操作</strong></p><p><strong>场景：组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据</strong></p><p><strong>分类: 4大阶段8个方法</strong></p><ul><li>初始化</li><li>挂载</li><li>更新</li><li>销毁</li></ul><table><thead><tr><th><strong>钩子函数</strong></th><th><strong>触发的行为</strong></th><th><strong>在此阶段可以做的事情</strong></th></tr></thead><tbody><tr><td>beforeCreadted</td><td>vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。</td><td>加loading事件</td></tr><tr><td>created</td><td>vue实例的数据对象data有了，$el还没有</td><td>结束loading、请求数据为mounted渲染做准备</td></tr><tr><td>beforeMount</td><td>vue实例的$el和data都初始化了，但还是虚拟的dom节点，具体的data.filter还未替换。</td><td></td></tr><tr><td>mounted</td><td>vue实例挂载完成，data.filter成功渲染</td><td>配合路由钩子使用</td></tr><tr><td>beforeUpdate</td><td>data更新时触发</td><td></td></tr><tr><td>updated</td><td>data更新时触发</td><td>数据更新时，做一些处理（此处也可以用watch进行观测）</td></tr><tr><td>beforeDestroy</td><td>组件销毁时触发</td><td></td></tr><tr><td>destroyed</td><td>组件销毁时触发，vue实例解除了事件监听以及和dom的绑定（无响应了），但DOM节点依旧存在</td><td>组件销毁时进行提示</td></tr></tbody></table><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="创建期间的生命周期函数"><a href="#创建期间的生命周期函数" class="headerlink" title="创建期间的生命周期函数"></a>创建期间的生命周期函数</h4><h5 id="beforeCreate（初始化界面前）"><a href="#beforeCreate（初始化界面前）" class="headerlink" title="beforeCreate（初始化界面前）"></a>beforeCreate（初始化界面前）</h5><p>实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</p><h5 id="created（初始化界面后）"><a href="#created（初始化界面后）" class="headerlink" title="created（初始化界面后）"></a>created（初始化界面后）</h5><p>实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</p><h4 id="挂载期间的生命周期函数"><a href="#挂载期间的生命周期函数" class="headerlink" title="挂载期间的生命周期函数"></a>挂载期间的生命周期函数</h4><h5 id="beforeMount（渲染DOM前）"><a href="#beforeMount（渲染DOM前）" class="headerlink" title="beforeMount（渲染DOM前）"></a>beforeMount（渲染DOM前）</h5><p>此时已经完成了模板的编译，但是还没有挂载到页面中</p><h5 id="mounted（渲染DOM后）"><a href="#mounted（渲染DOM后）" class="headerlink" title="mounted（渲染DOM后）"></a>mounted（渲染DOM后）</h5><p>此时，已经将编译好的模板，挂载到了页面指定的容器中显示</p><h4 id="运行期间的生命周期函数"><a href="#运行期间的生命周期函数" class="headerlink" title="运行期间的生命周期函数"></a>运行期间的生命周期函数</h4><h5 id="beforeUpdate（更新数据前）"><a href="#beforeUpdate（更新数据前）" class="headerlink" title="beforeUpdate（更新数据前）"></a>beforeUpdate（更新数据前）</h5><p>状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</p><h5 id="updated（更新数据后）"><a href="#updated（更新数据后）" class="headerlink" title="updated（更新数据后）"></a>updated（更新数据后）</h5><p>实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</p><h4 id="销毁期间的生命周期函数"><a href="#销毁期间的生命周期函数" class="headerlink" title="销毁期间的生命周期函数"></a>销毁期间的生命周期函数</h4><h5 id="beforeDestroy（卸载组件前）"><a href="#beforeDestroy（卸载组件前）" class="headerlink" title="beforeDestroy（卸载组件前）"></a>beforeDestroy（卸载组件前）</h5><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><h5 id="destroyed（卸载组建后）"><a href="#destroyed（卸载组建后）" class="headerlink" title="destroyed（卸载组建后）"></a>destroyed（卸载组建后）</h5><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>组件模板自己试着写就好，此处贴js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Vue的生命周期&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeCreate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeCreate创建前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span> , <span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//undefined </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------created创建完毕状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeMount挂载前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + (<span class="variable language_">this</span>.<span class="property">$el</span>)); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------mounted 挂载结束状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeUpdate</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);   </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updated</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeDestroy</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">destroyed</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="激活与未激活的生命周期"><a href="#激活与未激活的生命周期" class="headerlink" title="激活与未激活的生命周期"></a>激活与未激活的生命周期</h3><h4 id="activated（）"><a href="#activated（）" class="headerlink" title="activated（）"></a>activated（）</h4><p>被 keep-alive 缓存的组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="deactivated（）"><a href="#deactivated（）" class="headerlink" title="deactivated（）"></a>deactivated（）</h4><p>被 keep-alive 缓存的组件停用时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><blockquote><p>2.5.0+ 新增</p></blockquote><h4 id="errorCaptured（）"><a href="#errorCaptured（）" class="headerlink" title="errorCaptured（）"></a>errorCaptured（）</h4><p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p><h3 id="钩子函数的理解"><a href="#钩子函数的理解" class="headerlink" title="钩子函数的理解"></a>钩子函数的理解</h3><p>所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong>(例如created: () &#x3D;&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此this与你期待的 Vue 实例不同，this.fetchTodos的行为未定义。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也算是温故而知新了，太久没看的vue2相关的内容了，捕获错误这个之前一直没有，如今也算是新发现了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>原帖：<a href="https://juejin.cn/post/7024074527420203044">Vue生命周期（简单易懂,超详细）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作时候用的特别熟悉的内容，如今竟然有一种生疏的感觉。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解原型链</title>
    <link href="https://crazystudent13.github.io/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://crazystudent13.github.io/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2024-03-26T02:04:56.000Z</published>
    <updated>2024-05-07T15:17:58.207Z</updated>
    
    <content type="html"><![CDATA[<p>原型链，从来都没去理解过，为了面试特意查了一下，发现早就是在工作里边用的熟悉了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工作中常常遇到输出对象的内容，</p><p><strong>暂时未完成施工，等手里的私活忙完我再继续写</strong></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>用来声明对象的函数</p><p>构造函数和普通函数本质上没什么区别，只不过使用了<code>new</code>关键字创建对象的函数，被叫做了构造函数。构造函数命名通常采用首字母大写的方式，以便与普通函数和变量进行区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">    this.species = &#x27;人类&#x27;;</span><br><span class="line">    this.say = function () &#123;</span><br><span class="line">        console.log(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let per1 = new Person(&#x27;xiaoming&#x27;, 20);</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>将函数作为参数传递的函数</p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型链的顶层是null</p><h4 id="显示原型"><a href="#显示原型" class="headerlink" title="显示原型"></a>显示原型</h4><ol><li>Prototype是<strong>函数</strong>的一个属性</li><li>是个对象</li><li>创建函数的时候时候，自带该属性</li></ol><h4 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h4><p>_<em>proto</em>_</p><ol><li><strong>对象</strong>的属性</li><li>指向构造函数Prototype</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b435c6ed064418969d80abcddb44e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>感觉这玩意除非涉及到基础框架开发，否则感觉真是用不上啊。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7255605810453217335?searchId=20240326154528B151AB415507AF9D5722">原型和原型链–图解</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原型链，从来都没去理解过，为了面试特意查了一下，发现早就是在工作里边用的熟悉了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
