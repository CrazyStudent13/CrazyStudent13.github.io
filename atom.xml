<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远川的个人博客</title>
  
  <subtitle>CrazyStudent13的个人日志</subtitle>
  <link href="https://crazystudent13.github.io/atom.xml" rel="self"/>
  
  <link href="https://crazystudent13.github.io/"/>
  <updated>2024-09-08T15:57:30.337Z</updated>
  <id>https://crazystudent13.github.io/</id>
  
  <author>
    <name>CrazyStudent13</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转】10分钟了解redis应用</title>
    <link href="https://crazystudent13.github.io/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%9110%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3redis%E5%BA%94%E7%94%A8/"/>
    <id>https://crazystudent13.github.io/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%9110%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3redis%E5%BA%94%E7%94%A8/</id>
    <published>2024-09-08T12:00:33.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是从<a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a>这篇文章中切出来的部分。</p><p>不过算是redis的基础知识和应用篇，目前还未完全了解，仅仅只是学习记录一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><p>默认连接：IP 127.0.0.1 端口 6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>指定IP端口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli –h <span class="number">127.0</span>.<span class="number">0.1</span> –<span class="selector-tag">p</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>Redis提供了PING-PONG机制，测试与客户端和服务器链接是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>正常回复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;SET <span class="built_in">test</span> 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>错误回复（以error开头，后面跟着错误信息）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;TEST</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;TEST&#x27;</span></span><br></pre></td></tr></table></figure><p>整数回复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;INCR test_incr</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>字符串回复（最长久的一种回复，双引号包裹）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;get test</span><br><span class="line">“<span class="number">123</span>”</span><br></pre></td></tr></table></figure><p>多行字符串回复</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">127.0.0.1:6379&gt;KEYS *</span></span><br><span class="line">1) <span class="string">&quot;test_incr&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><p>字符串类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。可以存储JSON化的对象、字节数组等。一个字符串类型键允许存储的数据最大容量是512MB。</p><p>赋值与取值：</p><p>SET key value</p><p>GET key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> test1 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> test2 ab</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test2</span><br><span class="line"><span class="string">&quot;ab&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="keys通配符"><a href="#keys通配符" class="headerlink" title="keys通配符"></a>keys通配符</h4><p>获取符合规则的建名列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br><span class="line">keys <span class="built_in">test</span>[_]* </span><br><span class="line">keys t[a-d]</span><br></pre></td></tr></table></figure><p>说明：</p><p>？ 匹配一个字符，例如 keys ?est1</p><p>*  匹配任意个（包括0个）字符</p><p>[] 匹配括号间的任一字符，例如 keys test[12]。还可以使用“-“表示范围。</p><p>例如test[1-3]匹配test1&#x2F;test2&#x2F;test3</p><p>\x 匹配字符x，用于转义符合，如果要匹配“？“就需要使用?</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>redis默认支持16个数据库，对外都是以一个从0开始的递增数字命名，可以通过参数database来修改默认数据库个数。客户端连接redis服务后会自动选择0号数据库，可以通过select命令更换数据库，例如选择1号数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;GET <span class="built_in">test</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>说明：</p><p>Redis不支持自定义数据库名称。</p><p>Redis不支持为每个数据库设置访问密码。</p><p>Redis的多个数据库之间不是安全隔离的，FLUSHALL命令会清空所有数据库的数据。</p><p>清除屏幕内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><p>判断一个键是否存在。</p><p>如果键存在则返回整数类型1，否则返回0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test_incr&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists test1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists test3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><p>删除键，可以删除一个或者多个键，多个键用空格隔开，返回值是删除的键的个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del test1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del test1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; del test1 test_incr</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>获得键值的数据类型，返回值可能是string（字符串）、hash（散列类型）、list（列表类型）、set（集合类型）、zset（有序集合类型）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> test1</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> test2</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span></span><br><span class="line">redis-cli 2.8.19</span><br><span class="line">Type: <span class="string">&quot;help @&lt;group&gt;&quot;</span> to get a list of commands <span class="keyword">in</span> &lt;group&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;command&gt;&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span> on &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;tab&gt;&quot;</span> to get a list of possible <span class="built_in">help</span> topics</span><br><span class="line">      <span class="string">&quot;quit&quot;</span> to <span class="built_in">exit</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">  TYPE key</span><br><span class="line">  summary: Determine the <span class="built_in">type</span> stored at key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br></pre></td></tr></table></figure><p>官网：<a href="https://link.juejin.cn/?target=http://www.redis.io%E5%B8%AE%E5%8A%A9">www.redis.io帮助</a></p><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><p>清空所有数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="Redis数据类型之字符串"><a href="#Redis数据类型之字符串" class="headerlink" title="Redis数据类型之字符串"></a><strong>Redis数据类型之字符串</strong></h3><p>存放的字符串为二进制是安全的。字符串长度支持到512M。</p><h4 id="incry-x2F-incyby"><a href="#incry-x2F-incyby" class="headerlink" title="incry&#x2F;incyby"></a>incry&#x2F;incyby</h4><p>递增数字INCR key当存储的字符串是整数时，redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;num&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">3) <span class="string">&quot;test&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>从上面例子可以看出，如果num不存在，则自动会创建，如果存在自动+1。</p><p>指定增长系数</p><p>语法：INCRBY key increment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="decr-x2F-decrby"><a href="#decr-x2F-decrby" class="headerlink" title="decr&#x2F;decrby"></a>decr&#x2F;decrby</h4><p>减少指定的整数</p><p>DECR key  按照默认步长(默认为1)进行递减</p><p>DECRBY key decrement 按照指定步长进行递减</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; decrby num 3</span><br></pre></td></tr></table></figure><h4 id="incrbyfloat"><a href="#incrbyfloat" class="headerlink" title="incrbyfloat"></a>incrbyfloat</h4><p>整数时，第一次加可以得到正确结果，浮点数后再加浮点就会出现精度问题。</p><p>原来下面的例子2.8.7注意在新版本中已经修正了这个浮点精度问题。3.0.7</p><p>INCRBYFLOAT key decrement</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> num 131</span><br><span class="line">(<span class="built_in">integer</span>) 131</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat num 0.7</span><br><span class="line">“131.7”</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat num 0.7</span><br><span class="line">“132.3999999999999999”</span><br></pre></td></tr></table></figure><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>向尾部追加值。如果键不存在则创建该键，其值为写的value，即相当于SET key value。返回值是追加后字符串的总长度。</p><p>语法：APPEND key value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;num&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">3) <span class="string">&quot;test&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append <span class="built_in">test</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><p>字符串长度，返回数据的长度，如果键不存在则返回0。注意，如果键值为空串，返回也是0。</p><p>语法：STRLEN key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen <span class="built_in">test</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; strlen tnt</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> tnt <span class="string">&quot;&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen tnt</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; exists tnt</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="mset-x2F-mget"><a href="#mset-x2F-mget" class="headerlink" title="mset&#x2F;mget"></a>mset&#x2F;mget</h4><p>同时设置&#x2F;获取多个键值</p><p>语法：MSET key value [key value …]</p><p>MGET key [key …]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget a b c</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis有效时间"><a href="#Redis有效时间" class="headerlink" title="Redis有效时间"></a><strong>Redis有效时间</strong></h3><h4 id="Expire-设置生效时长-单位秒"><a href="#Expire-设置生效时长-单位秒" class="headerlink" title="Expire (设置生效时长-单位秒)"></a>Expire (设置生效时长-单位秒)</h4><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置有效时间的(缓存内存是有限的，不可能无限制增加)，即到期后数据自动销毁。</p><p>语法：EXPIRE key seconds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire bomb 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>TTL查看key的剩余时间，当返回值为-2时，表示键被删除。</p><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以毫秒为单位，返回 key 的剩余生存时间。</p><p>注意：在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="Persist-取消时长设置"><a href="#Persist-取消时长设置" class="headerlink" title="Persist(取消时长设置)"></a>Persist(取消时长设置)</h4><p>通过persist让对特定key设置的生效时长失效。</p><p>语法：PERSIST key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire bomb 60</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 49</span><br><span class="line">127.0.0.1:6379&gt; persist bomb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>设置新的数据时需要重新设置该key的生存时间，重新设置值也会清除生存时间。</p><h4 id="pexpire-单位毫秒"><a href="#pexpire-单位毫秒" class="headerlink" title="pexpire(单位毫秒)"></a>pexpire(单位毫秒)</h4><p>pexpire 让key的生效时长以毫秒作为计量单位，可应用于秒杀场景。</p><p>语法：PEXPIRE key milliseconds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpire bomb 10000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>设置生存时间为毫秒，可以做到更精确的控制。</p><h3 id="Redis高级中的hash结构"><a href="#Redis高级中的hash结构" class="headerlink" title="Redis高级中的hash结构"></a>Redis高级中的hash结构</h3><p>在redis中用的最多的就是hash和string类型。</p><h4 id="（1）问题"><a href="#（1）问题" class="headerlink" title="（1）问题"></a>（1）问题</h4><p>假设有User对象以JSON序列化的形式存储到redis中，User对象有id、username、password、age、name等属性，存储的过程如下：</p><p>保存、更新：</p><p>User对象-&gt;json(string)-&gt;redis</p><p>如果在业务上只是更新age属性，其他的属性并不做更新应该怎么做呢？</p><p>Redis数据类型之散列类型hash</p><p>散列类型存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他类型，也就是说，散列类型不能嵌套其他的数据类型。一个散列类型可以包含最多232-1个字段。</p><h4 id="（2）hset-x2F-hget"><a href="#（2）hset-x2F-hget" class="headerlink" title="（2）hset&#x2F;hget"></a>（2）hset&#x2F;hget</h4><p>相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line">HGET key field</span><br><span class="line">HMSET key field value [field value…]</span><br><span class="line">HMGET key field [field]</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>HSET和HGET赋值和取值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user username chenchen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user username</span><br><span class="line"><span class="string">&quot;chenchen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user username chen</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys user</span><br><span class="line">1) <span class="string">&quot;user&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; hset user age 18</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user address <span class="string">&quot;xi&#x27;an&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">3) <span class="string">&quot;address&quot;</span></span><br><span class="line">4) <span class="string">&quot;xi&#x27;an&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p><h4 id="（3）hincrby"><a href="#（3）hincrby" class="headerlink" title="（3）hincrby"></a>（3）hincrby</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdecrby article total 1<span class="comment">#执行会出错</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby article total -1<span class="comment">#没有hdecrby自减命令</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget article total<span class="comment">#获取值</span></span><br></pre></td></tr></table></figure><h4 id="（4）hmset-x2F-hmget"><a href="#（4）hmset-x2F-hmget" class="headerlink" title="（4）hmset&#x2F;hmget"></a>（4）hmset&#x2F;hmget</h4><p>HMSET和HMGET设置和获取对象属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset person username tony age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget person age username</span><br><span class="line">1) <span class="string">&quot;18&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>注意：上面HMGET字段顺序可以自行定义</p><h4 id="（5）hexists"><a href="#（5）hexists" class="headerlink" title="（5）hexists"></a>（5）hexists</h4><p>属性是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists killer</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;hexists&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; hexists killer a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hexists user username</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists person age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（6）-hdel"><a href="#（6）-hdel" class="headerlink" title="（6） hdel"></a>（6） hdel</h4><p>删除属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（7）hkeys-x2F-hvals"><a href="#（7）hkeys-x2F-hvals" class="headerlink" title="（7）hkeys&#x2F;hvals"></a>（7）hkeys&#x2F;hvals</h4><p>只获取字段名HKEYS或字段值HVALS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals person</span><br><span class="line">1) <span class="string">&quot;tony&quot;</span></span><br><span class="line">2) <span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（8）hlen"><a href="#（8）hlen" class="headerlink" title="（8）hlen"></a>（8）hlen</h4><p>元素个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen person</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis高级中的list结构"><a href="#Redis高级中的list结构" class="headerlink" title="Redis高级中的list结构"></a>Redis高级中的list结构</h3><h4 id="（1）问题-1"><a href="#（1）问题-1" class="headerlink" title="（1）问题"></a>（1）问题</h4><p>Redis高级中的list结构</p><p>Redis的list类型其实就是一个每个子元素都是string类型的双向链表。可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。</p><p>有意思的是list的pop操作还有阻塞版本的，当我们[lr]pop一个list对象时，如果list是空，或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop可以则可以阻塞，当然可以加超时时间，超时后也会返回nil。为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。</p><h4 id="（2）lpush"><a href="#（2）lpush" class="headerlink" title="（2）lpush"></a>（2）lpush</h4><p>在key对应list的头部添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>其中，Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><h4 id="（3）rpush"><a href="#（3）rpush" class="headerlink" title="（3）rpush"></a>（3）rpush</h4><p>在key对应list的尾部添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist2 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist2 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（4）查看list"><a href="#（4）查看list" class="headerlink" title="（4）查看list"></a>（4）查看list</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lrange mylist3 0 -1</span><br></pre></td></tr></table></figure><h4 id="（5）del"><a href="#（5）del" class="headerlink" title="（5）del"></a>（5）del</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mylist</span><br></pre></td></tr></table></figure><h4 id="（6）linsert"><a href="#（6）linsert" class="headerlink" title="（6）linsert"></a>（6）linsert</h4><p>在key对应list的特定位置之前或之后添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist3 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist3 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mylist3 before <span class="string">&quot;world&quot;</span> <span class="string">&quot;there&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist3 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;there&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（7）lset"><a href="#（7）lset" class="headerlink" title="（7）lset"></a>（7）lset</h4><p>设置list中指定下标的元素值(一般用于修改操作)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mylist4 0 <span class="string">&quot;four&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mylist4 -2 <span class="string">&quot;five&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist4 0 -1</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;five&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（8）lrem"><a href="#（8）lrem" class="headerlink" title="（8）lrem"></a>（8）lrem</h4><p>从key对应list中删除count个和value相同的元素，count&gt;0时，按从头到尾的顺序删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist5 2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist5 0 -1</span><br><span class="line">1) <span class="string">&quot;foo&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>count&lt;0时，按从尾到头的顺序删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist6 -2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist6 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>count&#x3D;0时，删除全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist7 0 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist7 0 -1</span><br><span class="line">1) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（9）ltrim"><a href="#（9）ltrim" class="headerlink" title="（9）ltrim"></a>（9）ltrim</h4><p>保留指定key 的值范围内的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;four&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; ltrim mylist8 1 -1</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist8 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（10）lpop"><a href="#（10）lpop" class="headerlink" title="（10）lpop"></a>（10）lpop</h4><p>从list的头部删除元素，并返回删除元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="（11）rpop"><a href="#（11）rpop" class="headerlink" title="（11）rpop"></a>（11）rpop</h4><p>从list的尾部删除元素，并返回删除元素：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop mylist2</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="（12）llen"><a href="#（12）llen" class="headerlink" title="（12）llen"></a>（12）llen</h4><p>返回key对应list的长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; llen mylist5</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（13）index"><a href="#（13）index" class="headerlink" title="（13）index"></a>（13）index</h4><p>返回名称为key的list中index位置的元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lrange mylist5 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mylist5 0</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mylist5 1</span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（14）rpoplpush"><a href="#（14）rpoplpush" class="headerlink" title="（14）rpoplpush"></a>（14）rpoplpush</h4><p>从第一个list的尾部移除元素并添加到第二个list的头部,最后返回被移除的元素值，整个操作是原子的.如果第一个list是空或者不存在返回nil：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush lst1 lst1</span><br><span class="line">rpoplpush lst1 lst2</span><br></pre></td></tr></table></figure><h3 id="Redis高机中的set结构"><a href="#Redis高机中的set结构" class="headerlink" title="Redis高机中的set结构"></a>Redis高机中的set结构</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为232 - 1 (4294967295每个集合可存储40多亿个成员)。</p><h4 id="（1）sadd"><a href="#（1）sadd" class="headerlink" title="（1）sadd"></a>（1）sadd</h4><p>添加元素，重复元素添加失败，返回0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd name tony</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name hellen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name rose</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name rose</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h4 id="（2）smembers"><a href="#（2）smembers" class="headerlink" title="（2）smembers"></a>（2）smembers</h4><p>获取内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers name</span><br><span class="line">1) <span class="string">&quot;hellen&quot;</span></span><br><span class="line">2) <span class="string">&quot;rose&quot;</span></span><br><span class="line">3) <span class="string">&quot;tony&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）spop"><a href="#（3）spop" class="headerlink" title="（3）spop"></a>（3）spop</h4><p>移除并返回集合中的一个随机元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop internet</span><br><span class="line"><span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop internet</span><br><span class="line"><span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（4）scard"><a href="#（4）scard" class="headerlink" title="（4）scard"></a>（4）scard</h4><p>获取成员个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h4 id="（5）smove"><a href="#（5）smove" class="headerlink" title="（5）smove"></a>（5）smove</h4><p>移动一个元素到另外一个集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd internet amoeba nginx redis</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd bigdata hadopp spark rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers bigdata</span><br><span class="line">1) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">2) <span class="string">&quot;spark&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove bigdata internet rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers bigdata</span><br><span class="line">1) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">2) <span class="string">&quot;spark&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（6）sunion"><a href="#（6）sunion" class="headerlink" title="（6）sunion"></a>（6）sunion</h4><p>并集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sunion internet bigdata</span><br><span class="line">1) <span class="string">&quot;redis&quot;</span></span><br><span class="line">2) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">5) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">6) <span class="string">&quot;spark&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Redis数据持久化的两种模式-重点"><a href="#Redis数据持久化的两种模式-重点" class="headerlink" title="Redis数据持久化的两种模式(重点)"></a>Redis数据持久化的两种模式(重点)</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>Redis中为了保证在系统宕机(类似进程被杀死)情况下，能更快的进行故障恢复，设计了两种数据持久化方案，分别为rdb和aof。</p><p>Rdb方式是通过手动(save-阻塞式或bgsave-异步)或周期性方式保存redis中key&#x2F;value的一种机制,Rdb方式一般为redis的默认数据持久化方式.</p><p>Aof方式是通过记录写操作日志的方式,记录redis数据的一种持久化机制,这个机制默认是没有开启的.</p><h4 id="（2）rdb和aof比较"><a href="#（2）rdb和aof比较" class="headerlink" title="（2）rdb和aof比较"></a>（2）rdb和aof比较</h4><table><thead><tr><th><strong>rdb</strong></th><th><strong>aof</strong></th></tr></thead><tbody><tr><td>fork一个进程，遍历hash table，利用copy on write，把整个db dump保存下来。  save,bgsave,shutdown, slave 命令会触发这个操作。粒度比较大，如果save, shutdown, slave 之前crash了，则中间的操作没办法恢复。</td><td>把写操作指令，持续的写到一个类似日志文件里。（类似于从postgresql等数据库导出sql一样，只记录写操作）  粒度较小，crash（宕机）之后，只有crash之前没有来得及做日志的操作,这些数据是没办法恢复。</td></tr></tbody></table><p>两种区别就是，一个是持续的用日志记录写操作，crash（崩溃）后利用日志恢复；一个是平时写操作的时候不触发写，只有手动提交save命令，或者是shutdown关闭命令时，才触发备份操作。</p><p>选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 最终一致性（eventually consistent）的意思了。</p><h3 id="Redis事务管理（重点）"><a href="#Redis事务管理（重点）" class="headerlink" title="Redis事务管理（重点）"></a>Redis事务管理（重点）</h3><h4 id="（1）背景"><a href="#（1）背景" class="headerlink" title="（1）背景"></a>（1）背景</h4><p>大多数数据库的事务控制，假如是乐观锁的方式，一般都是基于数据版本（version）的记录机制实现的。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据。</p><p>Redis也采用类似的机制，使用watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败。也可以调用watch多次监视多个key。这样就可以对指定的key加乐观锁了。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。当然exec，discard，unwatch命令都会清除连接中的所有监视。</p><h4 id="（2）基本概念"><a href="#（2）基本概念" class="headerlink" title="（2）基本概念"></a>（2）基本概念</h4><p>redis是单线程(但是在6.0中真正引用多线程的应用)，提交命令时，其它命令无法插入其中，轻松利用单线程实现了事务的原子性。那如果执行多个redis命令呢？自然就没有事务保证，于是redis有下列相关的redis命令来实现事务管理。</p><p>multi   开启事务</p><p>exec    提交事务</p><p>discard  取消事务</p><p>watch   监控，如果监控的值发生变化，则提交事务时会失败</p><p>unwatch  去掉监控</p><p>Redis保证一个事务中的所有命令要么都执行，要么都不执行(原子性)。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p><h4 id="（3）exec提交事务"><a href="#（3）exec提交事务" class="headerlink" title="（3）exec提交事务"></a>（3）exec提交事务</h4><p>例如：模拟转账，王有200，张有700，张给王转100。过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w 200</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> z 700</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;200&quot;</span></span><br><span class="line">2) <span class="string">&quot;700&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby z 100</span><br><span class="line">QUEUED<span class="comment">#注意此命令根本没有执行，而是把其放在一个队列中</span></span><br><span class="line">127.0.0.1:6379&gt; incrby w 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get w<span class="comment">#同时，这些相关的变量也不能再读取</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get z</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 600</span><br><span class="line">2) (<span class="built_in">integer</span>) 300</span><br><span class="line">3) 1) <span class="string">&quot;300&quot;</span></span><br><span class="line">   2) <span class="string">&quot;600&quot;</span></span><br><span class="line">4) <span class="string">&quot;300&quot;</span></span><br><span class="line">5) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（4）如果有错误指令，自动取消"><a href="#（4）如果有错误指令，自动取消" class="headerlink" title="（4）如果有错误指令，自动取消"></a>（4）如果有错误指令，自动取消</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get w</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; abc</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; mget w z<span class="comment">#可以看出数据并未变化</span></span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（5）discard取消事务"><a href="#（5）discard取消事务" class="headerlink" title="（5）discard取消事务"></a>（5）discard取消事务</h4><p>注意redis事务太简单，没有回滚，而只有取消。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget z w</span><br><span class="line">1) <span class="string">&quot;600&quot;</span></span><br><span class="line">2) <span class="string">&quot;300&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incrby z 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get z</span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br></pre></td></tr></table></figure><h4 id="（6）秒杀抢票事务处理"><a href="#（6）秒杀抢票事务处理" class="headerlink" title="（6）秒杀抢票事务处理"></a>（6）秒杀抢票事务处理</h4><p>客户端1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> ticket 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch ticket<span class="comment">#乐观锁，对值进行观察，改变则事务失败</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decr ticket</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby money 100</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>客户端2：还没等客户端1提交事务，此时客户端2把票买到了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get ticket</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr ticket</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>客户端1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)<span class="comment">#执行事务，失败</span></span><br><span class="line">127.0.0.1:6379&gt; get ticket</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch<span class="comment">#取消监控</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于redis的基础知识及应用，是上篇分离出来的。</p><p>因为我个人不怎么用JAVA，所以把java的相关内容移除了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇是从&lt;a href=&quot;https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08&quot;&gt;Redis在docker下的的安装和基本使用&lt;/a&gt;这篇文章中切出来的部分。&lt;/p&gt;
&lt;p&gt;不过算是redis的基础知识和应用篇，目前还未完全了解，仅仅只是学习记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="https://crazystudent13.github.io/tags/redis/"/>
    
    <category term="运维" scheme="https://crazystudent13.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>【转】linux安装redis</title>
    <link href="https://crazystudent13.github.io/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85redis/"/>
    <id>https://crazystudent13.github.io/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85redis/</id>
    <published>2024-09-08T11:33:57.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>完成了Docker和MySQL的安装，因为项目需要，这里需要安装redis。</p><p>redis是为了防止MySQL的连接被太多请求击穿做的防火墙（可以这么理解），是前后端连接的中间件。</p><p>所以，redis是大型项目必须要学习的必然知识，所以这里整理一下线上部署的知识，便于后续后端的学习。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这里并不用传动的方式进行redis在Linux服务器上的安装，全程都用docker进行安装。</p><p>在正式配置服务器之前，请参考我之前的<a href="https://crazystudent13.cn/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/">docker安装流程</a>，先把服务器上的Docker部署一下。</p><h3 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h3><p>在linux虚拟机中启动docker,从docker中将redis从网络上pull下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><h3 id="创建redis实例并启动"><a href="#创建redis实例并启动" class="headerlink" title="创建redis实例并启动"></a>创建redis实例并启动</h3><p>创建redis配置文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/docker/redis/conf</span><br></pre></td></tr></table></figure><p>在配置文件录下创建redis.conf配置文件(因为redis镜像中这个redis.conf是一个目录所以要先创建一个这个配置文件，否在我们本地挂载点也会变成一个目录)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /usr/local/docker/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>在linux上挂载redis并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /usr/local/docker/redis/data:/data \</span><br><span class="line">-v /usr/local/docker/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf </span><br></pre></td></tr></table></figure><h3 id="查看正在运行的进程"><a href="#查看正在运行的进程" class="headerlink" title="查看正在运行的进程"></a>查看正在运行的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="控制台直接连接redis测试"><a href="#控制台直接连接redis测试" class="headerlink" title="控制台直接连接redis测试"></a>控制台直接连接redis测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br></pre></td></tr></table></figure><h3 id="检测redisb版本"><a href="#检测redisb版本" class="headerlink" title="检测redisb版本"></a>检测redisb版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-server –v</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -v</span><br></pre></td></tr></table></figure><p>不过，这里更推荐直接将上面的两个步骤合为一个步骤，不容易出问题，指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-cli</span><br></pre></td></tr></table></figure><h3 id="停止redis服务"><a href="#停止redis服务" class="headerlink" title="停止redis服务"></a>停止redis服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop redis</span><br></pre></td></tr></table></figure><h3 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h3><p>在docker中，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start redis</span><br></pre></td></tr></table></figure><p>传统方式启动（非docker环境）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server <span class="comment">#默认找redis.conf配置文件</span></span><br><span class="line">redis-server &amp;<span class="comment">#上面ctrl+c中断reis会退出，这个不会</span></span><br><span class="line">redis-server redis6380.conf      <span class="comment">#指定配置文件，这样可以启动多个实例</span></span><br></pre></td></tr></table></figure><h3 id="重启redis服务"><a href="#重启redis服务" class="headerlink" title="重启redis服务"></a>重启redis服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><h3 id="查看redis服务版本"><a href="#查看redis服务版本" class="headerlink" title="查看redis服务版本"></a>查看redis服务版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-server -v</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><p>默认没有密码，可以随意访问。</p><p>redis速度相当快，在一个较好的服务器下，外部用户每秒可以进行15w次的密码尝试，这意味着必须指定非常强大的密码来防止暴力破解。</p><p>如果要使用密码，打开redis.conf配置文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 123456    <span class="comment">#480行，设置请求密码，这样访问时都需要先登录</span></span><br></pre></td></tr></table></figure><p>修改完配置文件以后，要重启redis服务。（docker start redis）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456<span class="comment">#客户端访问方式</span></span><br><span class="line">jedis.auth(“123456”);<span class="comment">#jedis访问方式(学了以后用)</span></span><br></pre></td></tr></table></figure><p>部署到这里，基本上流程都差不多了，如果有什么具体的配置需求，可以参考下文中的内容，进行config的配置。</p><h3 id="Redis-conf配置文件"><a href="#Redis-conf配置文件" class="headerlink" title="Redis.conf配置文件"></a>Redis.conf配置文件</h3><p>Redis 支持很多的参数，但都有默认值。</p><h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a><strong>daemonize</strong></h4><p>默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes。</p><h4 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a><strong>pidfile</strong></h4><p>当 Redis 在后台运行的时候， Redis 默认会把 pid 文件放在&#x2F;var&#x2F;run&#x2F;redis.pid，你可以配置到其他地址。当运行多个 redis 服务时，需要指定不同的 pid 文件和端口</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a><strong>bind</strong></h4><p>指定 Redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中最好设置该项</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a><strong>port</strong></h4><p>监听端口，默认为 6379</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><strong>timeout</strong></h4><p>设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</p><h4 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a><strong>loglevel</strong></h4><p>log 等级分为 4 级， debug, verbose, notice, 和 warning。生产环境下一般开启 notice</p><h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a><strong>logfile</strong></h4><p>配置 log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上</p><h4 id="databases"><a href="#databases" class="headerlink" title="databases"></a><strong>databases</strong></h4><p>设置数据库的个数，可以使用 SELECT 命令来切换数据库。默认使用的数据库是 0</p><h4 id="save"><a href="#save" class="headerlink" title="save"></a><strong>save</strong></h4><p>设置 Redis 进行数据库镜像的频率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(在 60 秒之内有 10000 个 keys 发生变化时)&#123;</span><br><span class="line">进行镜像备份 （redis/data/）</span><br><span class="line">&#125;else if(在 300 秒之内有 10 个 keys 发生了变化)&#123;</span><br><span class="line">进行镜像备份</span><br><span class="line">&#125;else if(在 900 秒之内有 1 个 keys 发生了变化)&#123;</span><br><span class="line">进行镜像备份</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a><strong>rdbcompression</strong></h4><p>在进行镜像备份时，是否进行压缩</p><h4 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a><strong>dbfilename</strong></h4><p>镜像备份文件的文件名</p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a><strong>dir</strong></h4><p>数据库镜像备份的文件放置的路径。</p><p>这里的路径跟文件名要分开配置是因为 Redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中</p><p>等备份完成时，再把该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中</p><h4 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a><strong>slaveof</strong></h4><p>设置该数据库为其他数据库的从数据库</p><h4 id="masterauth"><a href="#masterauth" class="headerlink" title="masterauth"></a><strong>masterauth</strong></h4><p>当主数据库连接需要密码验证时，在这里指定</p><h4 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a><strong>requirepass</strong></h4><p>设置客户端连接后进行任何其他指定前需要使用的密码。</p><p>警告：因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解。</p><p><strong>maxclients</strong></p><p>限制同时连接的客户数量。当连接数超过这个值时， redis 将不再接收其他连接请求，</p><p>客户端尝试连接时将收到 error 信息。</p><h4 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a><strong>maxmemory</strong></h4><p>设置 redis 能够使用的最大内存。</p><h4 id="appendonly"><a href="#appendonly" class="headerlink" title="appendonly"></a><strong>appendonly</strong></h4><p>默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。</p><p>所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。</p><p>但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对appendonly.aof 进行重新整理。</p><p>所以我认为推荐生产环境下的做法为关闭镜像，开启appendonly.aof，同时可以选择在访问较少的时间每天对 appendonly.aof 进行重写一次。</p><h4 id="appendfsync"><a href="#appendfsync" class="headerlink" title="appendfsync"></a>appendfsync</h4><p>设置对 appendonly.aof 文件进行同步的频率。 always 表示每次有写操作都进行同步，</p><p>everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置</p><h4 id="vm-enabled"><a href="#vm-enabled" class="headerlink" title="vm-enabled"></a><strong>vm-enabled</strong></h4><p>是否开启虚拟内存支持。因为 redis 是一个内存数据库，而且当内存满的时候，无法接收新的写请求，所以在 redis 2.0 中，提供了虚拟内存的支持。</p><p>但是需要注意的是， redis中，所有的 key 都会放在内存中，在内存不够时，只会把 value 值放入交换区。这样保证了虽然使用虚拟内存，但性能基本不受影响</p><p>同时，你需要注意的是你要把vm-max-memory 设置到足够来放下你的所有的 key</p><h4 id="vm-swap-file"><a href="#vm-swap-file" class="headerlink" title="vm-swap-file"></a><strong>vm-swap-file</strong></h4><p>设置虚拟内存的交换文件路径</p><h4 id="vm-max-memory"><a href="#vm-max-memory" class="headerlink" title="vm-max-memory"></a><strong>vm-max-memory</strong></h4><p>这里设置开启虚拟内存之后， redis 将使用的最大物理内存的大小。默认为 0， redis 将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。</p><p>在生产环境下，需要根据实际情况设置该值，最好不要使用默认的 0</p><h4 id="vm-page-size"><a href="#vm-page-size" class="headerlink" title="vm-page-size"></a><strong>vm-page-size</strong></h4><p>设置虚拟内存的页大小，如果你的 value 值比较大，比如说你要在 value 中放置博客、新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。</p><h4 id="vm-pages"><a href="#vm-pages" class="headerlink" title="vm-pages"></a><strong>vm-pages</strong></h4><p>设置交换文件的总的 page 数量， 需要注意的是， page table 信息会放在物理内存中，每8 个 page 就会占据 RAM 中的 1 个 byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages</p><h4 id="vm-max-threads"><a href="#vm-max-threads" class="headerlink" title="vm-max-threads"></a><strong>vm-max-threads</strong></h4><p>设置 VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过程，所以尽管 IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存的 vlaue 值比较大，将该值设大一些，还是能够提升性能的</p><p><strong>glueoutputbuf</strong></p><p>把小的输出缓存放在一起，以便能够在一个 TCP packet 中为客户端发送多个响应，具体原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成 yes</p><h4 id="hash-max-zipmap-entries"><a href="#hash-max-zipmap-entries" class="headerlink" title="hash-max-zipmap-entries"></a><strong>hash-max-zipmap-entries</strong></h4><p>在 redis 2.0 中引入了 hash 数据结构。当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时， hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</p><h4 id="activerehashing"><a href="#activerehashing" class="headerlink" title="activerehashing"></a><strong>activerehashing</strong></h4><p>开启之后， redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。</p><p>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。</p><p>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇文章一开始只是想简单整理一个好用的线上redis部署流程。</p><p>但是在掘金上翻了一阵子之后，没想到找了一篇配置流程全面且准确的教程。</p><p>因为文档实在太长，这里仅截取了部署的部分，部署流程简单易懂，亲测可用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;完成了Docker和MySQL的安装，因为项目需要，这里需要安装redis。&lt;/p&gt;
&lt;p&gt;redis是为了防止MySQL的连接被太多请求击穿做的防火墙（可以这么理解），是前后端连接的中间件。&lt;/p&gt;
&lt;p&gt;所以，redis是大型项目必须要学习的必然知识，所以这里整理一下线上部署的知识，便于后续后端的学习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="https://crazystudent13.github.io/tags/redis/"/>
    
    <category term="运维" scheme="https://crazystudent13.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>【转】linux安装MySQL</title>
    <link href="https://crazystudent13.github.io/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85MySQL/"/>
    <id>https://crazystudent13.github.io/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85MySQL/</id>
    <published>2024-09-06T14:46:42.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>关于在linux安装MySQL，我个人推荐使用Dcoker安装，流程比用原生手段安装更简单。</p><p>使用Docker之后，安装流程被简化了很多，简单易操作，节省时间也更问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果之前没有安装Docker的，推荐完整流程参考：<a href="https://juejin.cn/post/7406144322834382899?searchId=202409061945048DCECD6B5FCF23BDCB0D">从安装Docker到打包迁移MySQL的完整指南</a>这篇文档。</p><p>先安装一下Docker，这篇文章记录的比较详细。</p><p>本文仅截取部署MySQL的部分，主要是用Docker在服务器上部署MySQL的流程。</p><h3 id="用Docker部署MySQL"><a href="#用Docker部署MySQL" class="headerlink" title="用Docker部署MySQL"></a>用Docker部署MySQL</h3><p>MySQL是一种流行的开源关系数据库管理系统。</p><p>在Docker中部署MySQL非常简单。</p><p>以下步骤将引导你如何在Docker中运行MySQL容器。</p><h4 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取MySQL镜像</h4><p>为了加速镜像的下载速度，建议使用国内的镜像源。以下是从DaoCloud镜像源拉取MySQL官方镜像的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull daocloud.io/library/mysql:8.0</span><br></pre></td></tr></table></figure><p>千万千万不要使用下面命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:8.0</span><br></pre></td></tr></table></figure><p>因为有些服务器禁止连接外网，所以导致你不能从hub拿到镜像下载地址，导致pull失败。</p><p>比如政务内网环境，那么此时就只能是如此操作。</p><h4 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h4><p>使用拉取的MySQL镜像启动一个容器，并将MySQL的3306端口映射到主机的3306端口，以便外部访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name mysql-container -e MYSQL_ROOT_PASSWORD=my-secret-pw -p 3306:3306 -d mysql:8.0</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><ul><li><code>--name mysql-container</code>：指定容器名称为<code>mysql-container</code>。</li><li><code>-e MYSQL_ROOT_PASSWORD=my-secret-pw</code>：设置MySQL的<code>root</code>用户密码为<code>my-secret-pw</code>。</li><li><code>-p 3306:3306</code>：将容器内的3306端口映射到主机的3306端口。</li><li><code>-d mysql:8.0</code>：在后台运行MySQL 8.0镜像。</li></ul><h4 id="配置MySQL允许远程访问"><a href="#配置MySQL允许远程访问" class="headerlink" title="配置MySQL允许远程访问"></a>配置MySQL允许远程访问</h4><p>进入MySQL容器，允许<code>root</code>用户从任意主机访问数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it mysql-container mysql -uroot -p</span><br></pre></td></tr></table></figure><p>在MySQL命令行中，运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;my-secret-pw&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>如果你希望创建一个新用户以用于远程访问，可以运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;userpassword&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="配置my-cnf"><a href="#配置my-cnf" class="headerlink" title="配置my.cnf"></a>配置<code>my.cnf</code></h3><p>记得在目录<code>/var/lib/docker/volumes/mysql-data/_data/</code>中，添加一个<code>my.cnf</code></p><p><code>my.cnf</code>的文件，输入如下内容即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">bind-address = 自己服务器的ip地址</span><br></pre></td></tr></table></figure><h4 id="防火墙配置（如适用）"><a href="#防火墙配置（如适用）" class="headerlink" title="防火墙配置（如适用）"></a>防火墙配置（如适用）</h4><p>如果你的服务器有防火墙，需要确保3306端口对外开放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>当然，这是用命令的方式，如果你使用的是腾讯云或者阿里云这种云服务器，是有端口配置的协议的。</p><p>有这种云服务器，这种事情就简单很多了。</p><p>你可以直接在防火墙的配置中，打开端口配置，把3306的端口打开就可以。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个流程还不完整，我可能测试的还不够完整，所以文档中应该有所缺漏。</p><p>不过，只要学习独立开发，后续必然还会再其他云服务器上部署项目，这个流程应该会被持续完善。</p><p>后续持续完善该部署流程，也欢迎大家提意见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7406144322834382899?searchId=202409061945048DCECD6B5FCF23BDCB0D">从安装Docker到打包迁移MySQL的完整指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于在linux安装MySQL，我个人推荐使用Dcoker安装，流程比用原生手段安装更简单。&lt;/p&gt;
&lt;p&gt;使用Docker之后，安装流程被简化了很多，简单易操作，节省时间也更问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://crazystudent13.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="MySQL" scheme="https://crazystudent13.github.io/tags/MySQL/"/>
    
    <category term="docker" scheme="https://crazystudent13.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【转】linux安装docker</title>
    <link href="https://crazystudent13.github.io/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/"/>
    <id>https://crazystudent13.github.io/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/</id>
    <published>2024-09-06T11:01:59.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>因为需要安装MySQL，但是现在大多数主流的安装流程都要用到docker，所以在正式安装MySQL之前，先装Docker。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我看了一下这个流程，基本上<a href="https://link.juejin.cn/?target=https://docs.docker.com/engine/install/centos/">docker官方网站</a>是有介绍的，不过是英文，不太方便看，</p><p>而文档搬运的很好，个人亲测有效，推荐使用。</p><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><p>个人是linux服务器，纯命令行，请勿在windows上安装。</p><h4 id="删除docker信息"><a href="#删除docker信息" class="headerlink" title="删除docker信息"></a>删除docker信息</h4><p>原有安装信息清理，可跳过。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; yum remove docker \</span><br><span class="line">&gt; docker-client \</span><br><span class="line">&gt; docker-client-latest \</span><br><span class="line">&gt; docker-common \</span><br><span class="line">&gt; docker-latest \</span><br><span class="line">&gt; docker-latest-logrotate \</span><br><span class="line">&gt; docker-logrotate \</span><br><span class="line">&gt; docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装yum工具"><a href="#安装yum工具" class="headerlink" title="安装yum工具"></a>安装yum工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><h4 id="配置资源地址"><a href="#配置资源地址" class="headerlink" title="配置资源地址"></a>配置资源地址</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:<span class="comment">//download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.<span class="built_in">io</span> docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> docker</span><br></pre></td></tr></table></figure><h4 id="若安装docker报错"><a href="#若安装docker报错" class="headerlink" title="若安装docker报错"></a>若安装docker报错</h4><p>problem with installed package podman-1.6.4-10.module_el8.2.0+305+5e198a41.x86_64</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install <span class="attr">--allowerasing</span> docker-ce</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h4 id="阿里镜像加速配置"><a href="#阿里镜像加速配置" class="headerlink" title="阿里镜像加速配置"></a>阿里镜像加速配置</h4><p>阿里云：控制台-&gt;左上角菜单-&gt;产品与服务-&gt;容器-&gt;容器镜像服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;加速镜像地址&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h3><ul><li><strong>推荐一个前后端脚手架 <a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/MQoachhzJMGGdryo_VPeYg">lg-soar：助力开发者腾飞的利器</a></strong></li><li><strong>微信公众号</strong>：六哥是全栈</li><li>掘金主页：<a href="https://juejin.cn/user/3650034336021736/posts">六哥是全栈 的个人主页 - 文章 - 掘金 (juejin.cn)</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很好的安装流程，之前也找过不少流程，要么太老，要么太繁琐。</p><p>一篇好的指引教程很重要，所有这里特地记录一下，便于后续使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7410989416867364891">linux安装docker</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为需要安装MySQL，但是现在大多数主流的安装流程都要用到docker，所以在正式安装MySQL之前，先装Docker。&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://crazystudent13.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="docker" scheme="https://crazystudent13.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>解决el-tag等代码自动转成了图标的问题</title>
    <link href="https://crazystudent13.github.io/2024/08/24/%E8%A7%A3%E5%86%B3el-tag%E7%AD%89%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90%E4%BA%86%E5%9B%BE%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://crazystudent13.github.io/2024/08/24/%E8%A7%A3%E5%86%B3el-tag%E7%AD%89%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90%E4%BA%86%E5%9B%BE%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-24T16:26:51.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>某天打开新项目，意外的发现不对，<code>&lt;el-tag&gt;</code>这类标签居然变成图标了。</p><p>而且一开始还稍微费了些时间才搜到结果，这种配置问题我以为会很常见，但结果看来并不常见。</p><p>考虑到这是一个比较偏门的问题，所以特地转载记录一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次情况是vscode中开发前端项目中发现的。</p><h3 id="问题情况"><a href="#问题情况" class="headerlink" title="问题情况"></a>问题情况</h3><p>使用element框架，<code>&lt;el-tag&gt;</code>这类标签居然变成图标，我记得还有其他标签变成了图标。</p><p>具体情况如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a218e487bfad169059d5e523aac66352.png"></p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>打开vscode，首选项 -&gt; 设置 -&gt; 搜索iconify，然后把下面这个√去掉就OK了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enabled lconify inline annotations</span><br></pre></td></tr></table></figure><p>这不是插件的问题，是个配置的问题，这里稍微改一下。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来不太想记录这个问题的，但是当时搜的时候稍微费了一会儿功夫才查到，感觉还是记一下，稍微强化一下印象比较好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/this_zq/article/details/139961066">vscode代码片段自动转图标禁用（el-tag代码自动转成了图标问题排查）_el-tag 变成图标了-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;某天打开新项目，意外的发现不对，&lt;code&gt;&amp;lt;el-tag&amp;gt;&lt;/code&gt;这类标签居然变成图标了。&lt;/p&gt;
&lt;p&gt;而且一开始还稍微费了些时间才搜到结果，这种配置问题我以为会很常见，但结果看来并不常见。&lt;/p&gt;
&lt;p&gt;考虑到这是一个比较偏门的问题，所以特地转载记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="疑难杂症" scheme="https://crazystudent13.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>解决前端项目中npm包管理的常见问题</title>
    <link href="https://crazystudent13.github.io/2024/08/22/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://crazystudent13.github.io/2024/08/22/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2024-08-22T12:22:04.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>最近新入职了新公司，然后要走熟悉的流程，安装npm包，启动项目。</p><p>只是，公司有些项目版本实在太老，且最近似乎又有新项目升级项目的考量，所以项目的包管理肯定是个问题。</p><p>所以，这里整合一些常见的命令，用来处理有问题的地方。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇文档主要是整理一些我在开发过程中常常遇到的npm问题，过程中顺便分享一些自己的理解和心得。</p><p>本文主要面对刚上路的前端新手，如果高手路过，还请评论区轻喷并指导一二。</p><h3 id="node环境管理"><a href="#node环境管理" class="headerlink" title="node环境管理"></a>node环境管理</h3><p>如果你的手里有数个周期达到3年以上的老项目需要维护，那么大抵会有一些包只有低版本的node环境才能适配。</p><p>早些年有人会用nvm来进行版本管理，但是新生代的有了很多平替产品，个人推荐volta，当然也有朋友推荐fnm。</p><p>这两者都是新生代的产品，随便选哪个都好，相对于nvm，volta和fnm的操作更简单方便。</p><h3 id="npm与pnpm"><a href="#npm与pnpm" class="headerlink" title="npm与pnpm"></a>npm与pnpm</h3><p>虽然我依然还在使用npm，但那是因为低版本项目不支持pnpm，如果你手里的项目平均超过18，可以尝试使用pnpm。</p><p>pnpm比起npm更能节约空间，大多数开发者手里的电脑都是1T容量的开发本，这种容量基本上遇到几个黑洞项目容量就开始捉襟见肘。</p><p>如果你需要再本地跑一些后端项目，再加上一些大型的文档，或者是一些设计图什么的，很难说自己的电脑那1T的可怜容量是否能够保证。</p><p>而pnpm可以把各个项目中的相同包放在一个地方管理，通过软连接的形式，各个项目包就只要下载一次即可。</p><p>比起传统的npm，这种方式更节省磁盘，也更节省下载时间。</p><h3 id="npm相关操作"><a href="#npm相关操作" class="headerlink" title="npm相关操作"></a>npm相关操作</h3><p>这里的常规操作，如果不清楚，各个推荐使用gpt或者其他AI来在线去问。</p><p>现在AI对于这种通用的操作的解释准确度，很多时候甚至比人整理的文档更准。</p><h4 id="切换镜像"><a href="#切换镜像" class="headerlink" title="切换镜像"></a>切换镜像</h4><p>很多开发中，会遇到下载依赖包迟迟下载不下来的问题，这个问题估计新手会很懵。</p><p>其实，只要冲浪强度稍微高一点的朋友，大概都猜到是国内网络环境的问题了，只要遇到类似于环境配置下载的问题，大概都是网络问题。</p><p>目前能解决的方案，一种是翻墙，另一种就是常见的切换镜像下载了。</p><p>而npm的包下载问题，常用的就是切换镜像下载。</p><h5 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h5><p>前面我们说了，国内因为环境特殊的问题，往往会遇到环境配置难搞的问题。</p><p>而国内的大公司为了下载方便，于是就做了一个服务器用来同步这些主流的环境和包。</p><p>比如，淘宝镜像环境往往每隔10分钟同步一次外网的npm库，将npm线上的包同步到国内的服务器，便于开发者下载。</p><p>因为这些内容是同步npm库的东西，像镜子一样，于是这种服务器就被称作镜像。</p><p>要在npm中切换镜像源，你可以使用<code>npm config set registry</code>命令来设置你想要的npm注册表镜像。</p><p>以下是一些常用的npm镜像源以及如何切换到它们的示例操作。</p><h5 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmmirror.com </span><br></pre></td></tr></table></figure><h5 id="切换回官方npm镜像"><a href="#切换回官方npm镜像" class="headerlink" title="切换回官方npm镜像"></a>切换回官方npm镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h5 id="查看当前配置的镜像"><a href="#查看当前配置的镜像" class="headerlink" title="查看当前配置的镜像"></a>查看当前配置的镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">pnpm config get registry</span><br></pre></td></tr></table></figure><h5 id="npmrc文件配置"><a href="#npmrc文件配置" class="headerlink" title=".npmrc文件配置"></a><code>.npmrc</code>文件配置</h5><p>（位于用户的主目录，负责管理npm包安装的一些偏好），添加或修改下面的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>以上这些命令可以在命令行中直接运行，无需进入项目目录。</p><p>运行这些命令后，你将使用指定的镜像源来安装npm包。</p><p>切换镜像类的命令，<code>pnpm</code>和<code>npm</code>是通用的。</p><h4 id="包安装及查看"><a href="#包安装及查看" class="headerlink" title="包安装及查看"></a>包安装及查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install 包 -g //全局安装</span><br><span class="line">npm install 包 -s -d  //安装到devDependencies </span><br><span class="line">npm install mockjs@1.0.0 //安装指定版本的包</span><br><span class="line"></span><br><span class="line">包 -v //检查版本</span><br><span class="line">npm root //查看包的安装路径</span><br></pre></td></tr></table></figure><h4 id="包卸载"><a href="#包卸载" class="headerlink" title="包卸载"></a>包卸载</h4><p>有些时候，我们卸载包重装，会遇到一些奇怪的问题。</p><p>我们可以先卸载包，然后再清除npm本地缓存，再安装，效果会好很多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 包   // 卸载</span><br><span class="line">npm cache clean // 清除npm本地缓存</span><br><span class="line">npm update // 更新模块</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来一开始只是想简单记录一些npm的相关操作，后来想了想，反正做都做了，干脆索性做个新手级的科普文档。</p><p>为了做这期文档，特意去了解了很多东西，没想到这次简单的整理让我了解了不少npm的相关知识。</p><p>不过，本篇文档是主要还是以整理工作中常用问题为主，所以对于太过基本的问题就不去科普了，推荐看我参考整理的几篇参考文档。</p><p>他们对npm的解释较为深刻，如果你有时间将这些看完，对于npm包管理这块，应该会有一个较为深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7245201923506094140?searchId=20240822221329B4A35E92588CB1A6DB98">彻底了解npm——架构、进化史及原理解析</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近新入职了新公司，然后要走熟悉的流程，安装npm包，启动项目。&lt;/p&gt;
&lt;p&gt;只是，公司有些项目版本实在太老，且最近似乎又有新项目升级项目的考量，所以项目的包管理肯定是个问题。&lt;/p&gt;
&lt;p&gt;所以，这里整合一些常见的命令，用来处理有问题的地方。&lt;/p&gt;</summary>
    
    
    
    
    <category term="npm" scheme="https://crazystudent13.github.io/tags/npm/"/>
    
    <category term="疑难杂症" scheme="https://crazystudent13.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解defer与async</title>
    <link href="https://crazystudent13.github.io/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/"/>
    <id>https://crazystudent13.github.io/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/</id>
    <published>2024-08-05T08:02:19.000Z</published>
    <updated>2024-09-08T15:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>defer与async不怎么常用，而且这个涉及到<code>&lt;scrpit/&gt;</code>的基础使用方式，都是一些远古常识题，</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>async</code> 和 <code>defer</code> 是两种不同的JavaScript特性，它们的主要区别在于它们的执行顺序和时间点。</p><p>在正式进入二者的区别之前，我们需要先了解所有scprit的脚本对页面执行的阻塞的影响。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p> <strong>async</strong>属性是 HTML5 中的新属性</p></blockquote><ul><li><strong>async</strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li><li><strong>charset</strong>：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><strong>defer</strong>：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。</li><li><strong>language</strong>： 已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript 、 JavaScript1.2 或 VBScript ）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li><li><strong>src</strong>：可选。表示包含要执行代码的外部文件。</li><li><strong>type</strong>：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text&#x2F;javascript<br>和 text&#x2F;ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text&#x2F;javascript 。实际上，服务器在传送 JavaScript 文件时使用的<br>MIME 类型通常是 application&#x2F;x–javascript ，但在 type 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：<br>application&#x2F;javascript 和 application&#x2F;ecmascript 。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是<br>text&#x2F;javascript 。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text&#x2F;javascript 。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="内联形式"><a href="#内联形式" class="headerlink" title="内联形式"></a>内联形式</h4><p>这种方式指的是在 <code>html </code>文件中，添加一个<code>&lt;script&gt;&lt;/scritp&gt;</code>标签，然后将 <code>JavaScript</code>代码直接写在里面，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内联 JavaScript&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外置形式"><a href="#外置形式" class="headerlink" title="外置形式"></a>外置形式</h4><p>外置形式是将 <code>JavaScript</code> 代码写在外部的一个文件里面，在 <code>html</code> 文件中通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性引入,如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两种引入形式的比较"><a href="#两种引入形式的比较" class="headerlink" title="两种引入形式的比较"></a>两种引入形式的比较</h4><p>对于这两种方式，毫无疑问，外置形式明显好于内联形式，主要表现为以下方面:</p><ul><li><strong>可维护性</strong>：外置 Javascript 文件可以被多个页面调用而不用在每个页面上反复地书写.如果有需要改变的部分,你只需要在一处修改即可.所以外置JavaScript 导致代码工作量减少,进而使得维护手续也更加方便。</li><li><strong>可缓存</strong>：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li><li><strong>关注点分离</strong>：将 JavaScript 封装在外部的.js文件遵循了关注点分离的法则.总体来说,分离 HTML,CSS 和 JavaScript 从而让我们更容易操纵他们.而且如果是多名开发者同步工作的话,这样也更方便。</li></ul><p>因此，在今后的开发中尽量使用外置方式的形式引入<code>JavaScript</code>。</p><h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><p>如果要谈<code>&lt;script&gt;</code> 标签加载顺序问题，首先要谈的就是标签的位置。</p><p>标签的位置对于<code>JavaScript</code>加载顺序来说有着很重要的影响。</p><p>很早之前，有个经典面试题，<code>&lt;script&gt;</code> 标签放在html头部和尾部，是否有区别？会不会有不同执行结果？</p><p>显然，是有区别的。</p><h4 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h4><p>标签的位置有两种，一种是方式<code>&lt;head&gt;</code>元素里面，另外一种就是放在<code>&lt;body&gt; </code>元素中页面内容的后面（就是页面内容结尾部分）。</p><h4 id="在-lt-head-gt-内"><a href="#在-lt-head-gt-内" class="headerlink" title="在&lt;head&gt;内"></a>在<code>&lt;head&gt;</code>内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一种比较传统的做法，目的就是把所有外部文件（包括 <code>CSS</code> 文件和 <code>JavaScript</code> 文件）的引用都放在相同的地方。</p><p>可是，在文档的<code>&lt;head&gt;</code>元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。</p><p>对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。</p><p>在早年前端体系不成熟的时候，有些开发者会喜欢把<code>&lt;script/&gt;</code>标签放在<code>&lt;head&gt;</code>标签中，造成页面白屏时间极长，显得极为卡顿。</p><p>很明显，这种做法有着很明显的缺点，特别是针对于现在的移动端来说，如果超过 1s 还没有内容呈现的话将是一种很差的用户体验。</p><p>为了避免这个问题，就有了下面这种加载方式。</p><h4 id="在-lt-body-gt-内"><a href="#在-lt-body-gt-内" class="headerlink" title="在&lt;body&gt; 内"></a>在<code>&lt;body&gt;</code> 内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种方式，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。</p><p>而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p><code>&lt;script&gt;</code>的每个属性设计来肯定都是有用的，下面我们就来说一说 defer 属性。</p><p>HTML 4.01 为 <code>&lt;script&gt;</code> 标签定义了 defer 属性。</p><p>这个属性的用途是表明脚本在执行时不会影响页面的构造。</p><p>也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</p><p>因此，在<code>&lt;script&gt;</code>元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/02.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/03.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，虽然我们把 <code>&lt;script&gt;</code> 元素放在了文档的 <code>&lt;head&gt;</code> 元素中，但其中包含的脚本将延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签后再执行。</p><p>HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 <code>DOMContentLoaded</code> 事件执行。</p><p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p><blockquote><p><strong>“在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。”</strong> </p><p>这段话是《JavaScript 高级程序设计（第三版）》中的一句话，纠结了很久。自己也尝试写了一些例子，但反馈的结果都是：如果引入的 <code>&lt;script&gt;</code>标签 都使用了 <code>defer</code> 属性，他们的执行顺序都是按照他们引入的顺序来的。</p><p>那么作者为什么会写上这一句话呢，个人感觉原因是：即使在 <code>HTML5</code> 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，但支持 <code>defer</code> 属性，那么就会出现作者所描述的那种情况，所以为了安全起见，在开发中使用一个 <code>defer</code> 是非常有必要的。</p></blockquote><blockquote><p>还有一点需要注意的是，defer 属性只适用于外部脚本文件。</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>意味着函数或代码块会被异步执行。</p><p>当浏览器遇到带有 <code>async</code> 属性的资源时，它会立即开始下载该资源，同时继续加载页面。</p><p>这样可以避免由于同步执行而导致的页面加载阻塞问题。</p><p>然而，由于 <code>async</code> 并不保证具体的执行时间，所以如果在 <code>async</code> 代码中修改了 DOM（文档对象模型），可能会出现错误，特别是在依赖外部资源的场景下。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p><code>defer</code> 则是一种用于推迟执行的特性，这个属性在一些页面模板中会常见，在很多项目工程化的内容中，不常见。</p><p>它允许将脚本放置到页面的最后部分，直到其他所有资源都已加载完毕。</p><p>这样确保了在执行 <code>defer</code> 代码之前，页面已经完全准备好，从而减少了潜在的错误风险。</p><p>特别是对于那些依赖于外部资源的第三方脚本来说，使用 <code>defer</code> 可以提高应用的稳定性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>async</code> 更适合于不需要等待页面完整加载即可运行的第三方脚本，因为它提供了更高的灵活性，但可能伴随着一定的执行时机的不确定性。</p><p> <code>defer</code> 则是为了确保页面加载完成后才执行脚本，减少因页面未加载完全而引发的错误。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里算是直接搬运了其他的内容，稍微学习了一下，这是旁枝末节的内容，如果不是面试，我确实不怎么会看。</p><p><code>async</code>与<code>defer</code>的使用，算是旧时代的余声了，如有需要，按需自取。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000013615988">谈谈  标签以及其加载顺序问题，包含 defer &amp; async</a></p><p><a href="https://www.cnblogs.com/ltwlh/p/18003735">async与defer的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;defer与async不怎么常用，而且这个涉及到&lt;code&gt;&amp;lt;scrpit/&amp;gt;&lt;/code&gt;的基础使用方式，都是一些远古常识题，&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>如何准备非大厂面试</title>
    <link href="https://crazystudent13.github.io/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/"/>
    <id>https://crazystudent13.github.io/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/</id>
    <published>2024-08-02T17:41:53.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>个人没有经历大厂的面试，毕竟个人学历不够，且项目经历，技术可能都不太不符合大厂的要求。</p><p>而且，我的年龄已经打了，按照目前的经历，技术还有就业大环境来看，我这辈子估计也无缘大厂了。</p><p>不过，人总是要生活的，进不了大公司，我们也尽可能的要在中小公司拿到高一些的工资。</p><p>毕竟，没有什么东西比金钱更令人安心了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从2024年4月，一直在面试，不断刷面试题，从4月到同年8月，期间，我不间断的整理自己的项目经历，技术体系，面试常考面试题等。</p><p>通过大量的面试经历，我大概整理出中小公司常规的面试流程。</p><p>这里将自己的大量面试经历流程进行整合，以供大家参考，大家按照自己的需求酌情准备面试吧。</p><h3 id="线上交谈"><a href="#线上交谈" class="headerlink" title="线上交谈"></a>线上交谈</h3><p>大多社招，首先是和HR线上交谈，这期间主要是让HR大概了解你的概况，同时你也要了解日常作息待遇，五险一金和薪资等。</p><p>我们线上交谈的流程，无外乎就两种结果：</p><ul><li>HR主动搭话，不断的追问你的意向，主动了解你的居住地和工作经历，同时可能也会看你的。</li><li>HR迟迟不回话，或者说话有一搭没一搭，大概是这家公司的暂时不缺人，又或者对方没有看上你。</li></ul><p>如果是第一种情况，我们尽可能的按照实话将自己有利的一面展示出来就可以了，哪怕对方是外包，需要你展示自己的学信网截图，就正常发就可以。</p><p>如果对方没有看上，也没什么可急的，确认好之后，换下一家就可以。</p><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>技术老大对你的印象与能力的认可，直接决定你是否能拿到offer,所以在技术老大面前多聊技术，别谈工作时间薪资待遇那些，那是人事面的流程。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>很多时候我们自我介绍的时候，总是简单的说一下个人信息就结束了。</p><p>实际上，这时候我们最好可以将自己的长处，技术栈，个人优势在开场这个时间都说一下，便于双方交换信息，省的面试官后续再问。</p><p>这是一种高效的沟通方式，不要问一句说一句，这样会让双方都很尴尬。</p><h5 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h5><p>包括你的姓名、籍贯、年龄、专业、毕业学校（这里如果哪一项是弱势，介绍的时候可以略过）</p><ol><li>技术能力，简单介绍自己的技术栈，告诉对方你会什么?并且最擅长的技术是什么?这可以让面试官对你的技术体系大概有个数，便于后续双方互动。所以，可以针对对方公司招聘岗位的岗位职责去重点突出自己的能力。</li><li>职业经验，说清楚自己往期的工作经验，待过哪些公司，具体做过什么，如果是应届毕业生，有实习经验说实习经验，没有的话也可以重点说自己在学校内接触过的项目经验。</li><li>当前状况，居住地，是否离职，这样便于面试官判断你是什么时候可以入职。</li><li>自我评价，个人评价这点比较鸡肋，如果技术和项目经历可以说的不多，那可以用这项进行补充。如果要说，记得主要说优势，别说缺陷，因为你是在推销自己。从沟通能力、学习能力、逻辑性等方面吹自己的优势，不过不要吹的太离谱。</li></ol><p>以我个人为例，这里我以个人为例，简单的写个模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫远川，江苏**人，XX年的，有五年左右的前端开发经验，之前都在XX公司任职。</span><br><span class="line">我的技术栈主要是Vue2/3的全家桶，对源码略有了解，也做过Uni-app相关，主要以微信小程序为主。</span><br><span class="line">之前在公司早期负责公司产品开发，封装通用的业务组件，通用的工具类方法，如PC和小程序的动态表单，动态表格，包括一些需要远程查询的数据字典选项。</span><br><span class="line">后续公司产品化之后，主导低代码平台开发，实现低代码流程+流程表单生成的流程，可以同步生成小程序和PC端的单表，后续拓展了主子表的生成，通过该平台极大程度缩减了代码的人力和时间。</span><br><span class="line">目前已离职，人在苏州。</span><br></pre></td></tr></table></figure><p><strong>当你做完自我介绍后，面试官正式开始提问，做好准备!</strong></p><h4 id="项目方面"><a href="#项目方面" class="headerlink" title="项目方面"></a>项目方面</h4><p>在进入项目问题这个阶段，大概是你已经通过了面试官的八股文的阶段。</p><p>毕竟，八股文都是为了试试基础水平而提问的，只要大概试一下，面试官大概就能猜出来你的水平。</p><p>大多数有经验的面试官，在面完八股文之后，如果看到你项目履历足够的丰富之后，肯定是会问一下相关的解决方案，确认你的经历是否真实。</p><p>另外，不要去想着伪装经历，项目经历这种东西是实打实的，简单的几个问题和稍微深入，都能让你没法回应。</p><p>如果面试官开始问你项目，这个问题很重要，建议从以下角度介绍。</p><ol><li><p>项目背景，让对方知道这个项目是做什么的</p></li><li><p>你在项目中的角色，在项目中，你负责了哪些工作?</p></li><li><p>项目难点与解决方案，能说出来，说明你善于总结，同时也有自己的一套解决方案。</p></li><li><p>项目成果，你负责的部分，你的解决方案有什么亮点，主要解决了什么方案。</p></li></ol><p>这里我就不放例子了，每个人可以按照在自己的项目经历，展开写一份面试备案。</p><h4 id="反问阶段"><a href="#反问阶段" class="headerlink" title="反问阶段"></a>反问阶段</h4><p>在八股文和项目经历大概都说明白了之后，面试官大概率会问问你有什么想想问的。</p><p>不要觉得没什么想问的，这是你了解这个团队和未来工作的唯一渠道，你可以从以下角度去反问面试官。</p><ol><li>主营业务，公司的主营业务是什么？是稳定期还是开荒期？你们招我来主要的方向是想做什么？</li><li>团队配置，公司是否有测试，设计，前后端团队，整体开发基建到了什么水准？后续团队的基建方向如何？</li><li>开发流程，平时如何实现一个新需求的开发？平时是否需要做需求评审？</li></ol><p>如果面试你的技术leader层级较高，你也可以侧面确认一下公司的待遇，五险一金，公积金缴费比例，平日加班是否频繁。</p><p>通过这方面的反问，大概率可以确认一个公司的工作内容，团队水平，平日待遇等。</p><p>这些内容，足够用来判断这份工作是否合适自己，以哪方面为准，这个可以按照自己的需求来判断。</p><h3 id="HR二面"><a href="#HR二面" class="headerlink" title="HR二面"></a>HR二面</h3><p>许多公司的面试环节，可能是HR先面，而后是技术组长，之后是技术leader再面试。</p><p>如果技术面结束之后，又是HR二面要你，那就要恭喜了，说明你很大程度是进入了HR定薪阶段。</p><p>HR面试，往往是对你的综合素质进行评判，通常会有以下提问:</p><p><strong>您对自己的未来职业规划是什么?</strong></p><ol><li>想做技术大佬：主要从两个方面出发，一个实近期规划(比如深入的学习前端面向对象)</li><li>想做项目leader：还有一-个是长远规划(未来5年都在前端技术方向，如何可以转产品或者管理等)</li></ol><p><strong>您的期望薪资是多少?</strong></p><p>答:这个可以根据当前岗位给定的范围，选择自己心仪的价格+1k左右。</p><p><strong>您当前的住址在哪？</strong></p><p>这个实际上是希望你离公司很近，便于上下班。</p><p>如果你住的特别远，你也可以表示自己很快就可以搬过来。</p><p><strong>你还有其他公司offer吗?什么时候可以入职?</strong></p><p>HR这样问是想知道能不能百分百拿下你，回答这个问题的尺度一定要把握好:</p><ol><li><p>不能吹嘘，说自己已经有很多offer，否则给HR造成你入职可能性不大的错觉。</p></li><li><p>也不要说一个也没有。更不要表现出对这家公司“迫切入职”，要学会欲擒故纵。</p></li></ol><p>不过，这种套路稍微用用用就可以，实际上没必要玩这种小把戏。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我本来是懒得去整理这些内容，但是早期面试总觉得自己准备的不够充分，明明自己的技术不差，但是就是表达的不够完美。</p><p>现在大环境太烂，我手牌太少，不得不精打细算，于此，便有整理了这篇文档。</p><p>夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也。多算胜，少算不胜，而况于无算乎！——《孙子兵法》</p><p>不打无准备之仗，不打无把握之仗，目前，也只能准备好每一次面试了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7163849862599933983">web前端面试技巧-如何自我介绍？如何应对hr？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人没有经历大厂的面试，毕竟个人学历不够，且项目经历，技术可能都不太不符合大厂的要求。&lt;/p&gt;
&lt;p&gt;而且，我的年龄已经打了，按照目前的经历，技术还有就业大环境来看，我这辈子估计也无缘大厂了。&lt;/p&gt;
&lt;p&gt;不过，人总是要生活的，进不了大公司，我们也尽可能的要在中小公司拿到高一些的工资。&lt;/p&gt;
&lt;p&gt;毕竟，没有什么东西比金钱更令人安心了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>浅析Vue2与Vue3的diff算法的区别</title>
    <link href="https://crazystudent13.github.io/2024/07/29/%E6%B5%85%E6%9E%90Vue2%E4%B8%8EVue3%E7%9A%84diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/07/29/%E6%B5%85%E6%9E%90Vue2%E4%B8%8EVue3%E7%9A%84diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-29T16:28:52.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>关于vue2与vue3的区别，应该是今年最热门的面试题，如果问深了，diff算法的问题肯定会被问到。</p><p>Vue2的diff算法，市面上基本上算是说的烂大街了，而Vue3的diff算法，市面上并没有较为的解读。</p><p>本来都打算自己去手撕源码了，后来正好翻到了别人团队已经整理好的<a href="https://segmentfault.com/a/1190000042586883">文档</a>，这里特地转载过来。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇不算是全部转载，算是自己对原文的笔记，所以偏重会根据个人需求调整。</p><p>Vue2的diff算法我个人很熟悉，所以下文中可能提到的会少一些，大多数的倾向于解释Vue3的diff算法优化在哪。</p><h3 id="vue3的diff优化"><a href="#vue3的diff优化" class="headerlink" title="vue3的diff优化"></a>vue3的diff优化</h3><p>很多人都会提到Vue3的diff优化，这里很少有人提到具体优化在哪里，所以这里先统一整理下，让我们对优化的方向大致有个概念。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于Diff算法的优化，这里并非是必要的问题。</p><p>不过，我们要想构建一套自己的体系，那么这种边缘的问题最好还是了解一下比较好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000042586883">Vue2、Vue3的diff对比</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于vue2与vue3的区别，应该是今年最热门的面试题，如果问深了，diff算法的问题肯定会被问到。&lt;/p&gt;
&lt;p&gt;Vue2的diff算法，市面上基本上算是说的烂大街了，而Vue3的diff算法，市面上并没有较为的解读。&lt;/p&gt;
&lt;p&gt;本来都打算自己去手撕源码了，后来正好翻到了别人团队已经整理好的&lt;a href=&quot;https://segmentfault.com/a/1190000042586883&quot;&gt;文档&lt;/a&gt;，这里特地转载过来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>浅析pina与vuex的区别</title>
    <link href="https://crazystudent13.github.io/2024/07/29/%E6%B5%85%E6%9E%90pina%E4%B8%8Evuex%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/07/29/%E6%B5%85%E6%9E%90pina%E4%B8%8Evuex%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-29T10:47:37.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>无论是<code>vuex</code>还是<code>pina</code>，本质上都是为了解决项目中的全局数据存储的问题，没有什么更优或者更劣的说法。</p><p>不过，<code>vuex</code>主要是应用在vue2的项目，<code>pina</code>则是随着Vue3升级产生的社区产物。</p><p>pina由原vuex团队，为了配合vue3的升级，特意写的新工具，所以二者在使用上会有一定相似性。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在正式开始写这篇文档之前，稍微科普一下，<a href="https://vuex.vuejs.org/zh/guide/">vuex</a>和<a href="https://pinia.vuejs.org/zh/introduction.html">pina</a>都是一个团队开发的，所以这二者在使用上会有不少类似的地方。</p><p>随着vue3的推广，pina也逐渐开始在社区中推广，成了vue3的开源项目新宠儿。</p><p>早期也有很多开发者在vue2的项目中用pina，或在vue3的项目中用vuex。</p><p>不过，随着时间推移，vue2中使用vuex，vue3中pina，这成了社区约定的常规习惯，大多vue开源项目你都能看到他们这么用。</p><p>如果要问为什么，只是社区逐渐应用产生的习惯罢了，并没有什么特殊的讲究。</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><code>Vuex</code>设计为一个全局状态管理的单例模式，有一个中心化的存储来管理应用的所有状态。</p><p>它基于Vue 2的Options API，强调状态的集中管理和严格的规则，包括State、Getters、Mutations（用于同步更改状态）和Actions（可以处理异步逻辑）。</p><p>其使用与pinia的CompositionAPI 的写法还是略有不同的。 </p><h4 id="action和mutation的区别"><a href="#action和mutation的区别" class="headerlink" title="action和mutation的区别"></a>action和mutation的区别</h4><p>很多人早期在使用vuex的时候，可能有些分不清<code>action</code>和<code>mutation</code>的区别。</p><p>所以，在正式介绍<code>vuex</code>之前，我们先在简单介绍一下二者的区别。</p><ul><li><code>mutation</code>更专注于修改<code>state</code>，必须是同步执行（无法在mutation中使用异步方法）。</li><li><code>action</code>提交的是<code>mutation</code>，而不是直接更新数据，可以是异步的，如业务代码，异步请求。</li><li><code>action</code>可以包含多个<code>mutation</code></li></ul><h4 id="main-js文件"><a href="#main-js文件" class="headerlink" title="main.js文件"></a><code>main.js</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span> <span class="comment">// vuex是导入状态仓库,pinia是创建实例对象createPinia</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(store)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="store文件"><a href="#store文件" class="headerlink" title="store文件"></a><code>store</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">0</span>,<span class="comment">//计数状态</span></span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">//修改状态的方法</span></span><br><span class="line">  <span class="attr">increment</span>: <span class="function">(<span class="params">&#123; commit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// commit 提交一项修改 提交给mutations</span></span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有的状态修改都要经过mutations,只有mutations 可以修改状态</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getter</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="attr">doubleCount</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">counter</span> * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除了读操作，对写操作十分严格</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;state,actions,mutations,getters&#125;) <span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a><code>App.vue</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>App.vue:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    count: &#123;&#123; store.state.counter &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   doubleCount: &#123;&#123;store.getters.doubleCount&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AppHeader</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">AppHeader</span> <span class="keyword">from</span> <span class="string">&#x27;./components/app-header.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> store=<span class="title function_">useStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//使用dispatch派出increment  action的方法</span></span></span><br><span class="line"><span class="language-javascript">  store.<span class="title function_">dispatch</span>(<span class="string">&#x27;increment&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>Pinia针对Vue 3设计，充分利用Composition API，提倡更简洁和直观的状态管理方式。</p><p>每个store在Pinia中都是独立的，同时为了兼容Vuex的写法Pinia仍然支持使用选项式API,也是现在主流的状态管理库。</p><h4 id="main-js文件-1"><a href="#main-js文件-1" class="headerlink" title="main.js文件"></a><code>main.js</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia=<span class="title function_">createPinia</span>()  <span class="comment">//创建pinia实例对象</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">.<span class="title function_">use</span>(pinia)   <span class="comment">// use这个实例对象</span></span><br><span class="line">.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="store文件-1"><a href="#store文件-1" class="headerlink" title="store文件"></a><code>store</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>--;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123; count, increment, decrement, reset, doubleCount &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;store&#x27;</span>, </span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> someState=<span class="title function_">ref</span>(<span class="string">&#x27;hello Pinia&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">incrementSomeState</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      someState.<span class="property">value</span> += <span class="string">&#x27;!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; someState , incrementSomeState &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a><code>App.vue</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Counter: &#123;&#123; store.count &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Double:&#123;&#123; store.doubleCount &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.decrement&quot;</span>&gt;</span>decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.reset&quot;</span>&gt;</span>reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>String: &#123;&#123; hel.someState &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;hel.incrementSomeState&quot;</span>&gt;</span>+ ! <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;useCounterStore,useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/Pinia/counter.js&#x27;</span> <span class="comment">//引入定义好的状态库</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span>  <span class="title class_">Child</span> <span class="keyword">from</span>  <span class="string">&#x27;@/components/child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> store=<span class="title function_">useCounterStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> hel=<span class="title function_">useStore</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ol><li>相对于<code>vuex</code>,<code>pina</code>是用<code>tyepscript</code>完成的，所以，代码提示效果更好。</li><li>在<code>main.js</code>文件中，vuex使用的是导出的store仓库，而pinia是使用实例化对象。</li><li><code>pina</code>弃用了<code>mutation</code>,如果想要完成数据修改，可以直接用action操作就可以了。</li><li><code>pina</code>中不再使用modules，而是直接声明的对应的对象调用即可。</li></ol><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>如果项目比较大，使用单一状态库，项目的状态库就会集中到一个大对象上，显得十分臃肿难以维护。</p><p>所以Vuex就允许我们将其分割成模块（modules），每个模块都拥有自己state，mutations，action等。</p><h5 id="pina"><a href="#pina" class="headerlink" title="pina"></a>pina</h5><p>而Pinia每个状态库本身就是一个模块，<code>pinia</code>没有modules，如果想使用多个store，直接定义多个store传入不同的id即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeA = <span class="title function_">defineStore</span>(<span class="string">&quot;storeA&quot;</span>, &#123;...&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeB = <span class="title function_">defineStore</span>(<span class="string">&quot;storeB&quot;</span>, &#123;...&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeC = <span class="title function_">defineStore</span>(<span class="string">&quot;storeB&quot;</span>, &#123;...&#125;);</span><br></pre></td></tr></table></figure><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>一般来说每个module都会新建一个文件，然后再引入这个总的入口index.js中，这里为了方便就写在了一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; </span><br><span class="line">    <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">   &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="params">state, data</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> = data;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">getuser</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//全局state，类似于vue种的data</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">vuexmsg</span>: <span class="string">&quot;hello vuex&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;xiaoyue&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    moduleA,</span><br><span class="line">    moduleB</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用moduleA</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">let</span> vuexStore = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vuexStore.<span class="property">state</span>.<span class="property">moduleA</span>.<span class="property">count</span>) <span class="comment">//1</span></span><br><span class="line">vuexStore.<span class="title function_">commit</span>(<span class="string">&#x27;setCount&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vuexStore.<span class="property">state</span>.<span class="property">moduleA</span>.<span class="property">count</span>) <span class="comment">//2</span></span><br><span class="line">vuexStore.<span class="title function_">dispatch</span>(<span class="string">&#x27;getuser&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一般我们为了防止提交一些mutation或者actions中的方法重名，modules一般会采用命名空间的方式 <strong>namespaced: true</strong> 如moduleA：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="params">state, data</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> = data;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">getuser</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果我们再调用setCount或者getuser</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vuexStore.<span class="title function_">commit</span>(<span class="string">&#x27;moduleA/setCount&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">vuexStore.<span class="title function_">dispatch</span>(<span class="string">&#x27;moduleA/getuser&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li><code>store</code>仓库中的<code>actions</code>是提交修改方法名，而真正修改是通过<code>mutations</code>，<code>actions</code>就像是秘书，而<code>mutation</code>像是boss,你不能直接找到boss修改属性，而必须通过<code>dispatch</code>派出<code>increment  action</code>的方法,让<code>mutation</code>去修改这个值。</li><li>vuex中的<code>getter</code>是不需要引入computed这个方法的，他会自动一直监听内部的状态是否发生改变。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>pina和vuex的区别，算是vue3的常规面试题之一，我之前虽然大致整理过，但是没有系统性的梳理。</p><p>如今借着别人的文档仔细梳理了一遍，心里对二者的使用心得也是更上一层楼。</p><p>不过，随着vue3的逐渐推广，未来<code>pina</code>一定会在社区中提高占用比。</p><p>如果要是手里有新项目的朋友，最好还是在项目中使用<code>pina</code>，这也是对社区不断发展的一种适应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://pinia.vuejs.org/zh/introduction.html">简介 | Pinia (vuejs.org)</a></p><p><a href="https://vuex.vuejs.org/zh/guide/">开始 | Vuex (vuejs.org)</a></p><p><a href="https://juejin.cn/post/7397285224379957298?searchId=20240804003348CBA7977A1276A0D3C285">vue3通信大全（三）—— 全局状态管理库pinia,vuex</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;无论是&lt;code&gt;vuex&lt;/code&gt;还是&lt;code&gt;pina&lt;/code&gt;，本质上都是为了解决项目中的全局数据存储的问题，没有什么更优或者更劣的说法。&lt;/p&gt;
&lt;p&gt;不过，&lt;code&gt;vuex&lt;/code&gt;主要是应用在vue2的项目，&lt;code&gt;pina&lt;/code&gt;则是随着Vue3升级产生的社区产物。&lt;/p&gt;
&lt;p&gt;pina由原vuex团队，为了配合vue3的升级，特意写的新工具，所以二者在使用上会有一定相似性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解Vue的深度选择器</title>
    <link href="https://crazystudent13.github.io/2024/07/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Vue%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://crazystudent13.github.io/2024/07/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Vue%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2024-07-25T04:59:45.000Z</published>
    <updated>2024-09-08T15:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>本文算是转载文章，本来打算自己写的，但是发现别人写的比自己号多了，还很完成。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>毕竟是转载他人的文章，这里留一下他的微信公众号：前端历险记。</p><p>整理了很多面试相关的文章，很不错。</p><h3 id="深度选择器"><a href="#深度选择器" class="headerlink" title="深度选择器"></a>深度选择器</h3><p>在Vue.js项目中，尤其是在使用组件化开发时，我们时常需要修改组件内部的样式，但Vue的样式封装特性（如<code>&lt;style scoped&gt;</code>）会阻止外部样式直接作用于组件内部。为了应对这一挑战，Vue社区引入了深度选择器（也称为穿透选择器或阴影穿透选择器），让我们能够跨越组件的封装边界，对内部元素进行样式定制。</p><p>本文将详细探讨<code>/deep/</code>、<code>&gt;&gt;&gt;</code>、<code>::v-deep</code>以及Vue 3 Composition API中的<code>v-deep()</code>的区别与使用方法。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>深度选择器允许我们从父组件中穿透到子组件内部，直接修改子组件的样式。这在需要定制第三方UI库组件样式时尤为有用。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="deep"><a href="#deep" class="headerlink" title="/deep/"></a><code>/deep/</code></h5><ul><li><strong>Vue 2.x中的用法</strong>：<code>/deep/</code>是Vue 2.x中用于穿透组件样式封装的一种方式，类似于Sass的<code>/deep/</code>或<code>/deep/</code>的别名<code>::v-deep</code>（但Vue 2.x官方文档中并未直接提及<code>::v-deep</code>）。</li><li><strong>兼容性</strong>：支持CSS预处理器（如Sass、Less）和CSS原生样式。</li><li><strong>注意</strong>：在Vue 3.x中，<code>/deep/</code>不再被官方直接支持，虽然一些构建工具或库可能仍然兼容，但推荐使用<code>::v-deep</code>。</li></ul><h5 id="gt-gt-gt"><a href="#gt-gt-gt" class="headerlink" title="&gt;&gt;&gt;"></a><code>&gt;&gt;&gt;</code></h5><ul><li><strong>CSS原生语法</strong>：<code>&gt;&gt;&gt;</code>是CSS原生中的深度选择器语法，用于穿透样式封装。但在Vue单文件组件（.vue）中，它并不总是被直接支持，因为Vue会将其视为普通CSS选择器的一部分。</li><li><strong>兼容性</strong>：仅在某些特定环境（如Webpack的css-loader配置中）和原生CSS中有效，Vue单文件组件中通常需要特定配置才能使用。</li><li><strong>注意</strong>：在Vue 3.x中，<code>&gt;&gt;&gt;</code>同样不再被推荐使用，应使用<code>::v-deep</code>。</li></ul><h5 id="v-deep"><a href="#v-deep" class="headerlink" title="::v-deep"></a><code>::v-deep</code></h5><ul><li><strong>Vue 3.x中的推荐用法</strong>：<code>::v-deep</code>是Vue 3.x中引入的官方深度选择器，用于替代Vue 2.x中的<code>/deep/</code>和原生CSS中的<code>&gt;&gt;&gt;</code>。</li><li><strong>兼容性</strong>：支持CSS预处理器和CSS原生样式，是Vue 3.x中推荐使用的深度选择器。</li><li><strong>优点</strong>：与Vue 3的其他新特性相兼容，提供了更好的开发体验。</li></ul><p><code>v-deep()</code></p><p>（Vue 3 Composition API）</p><ul><li><p><strong>特殊用法</strong>：在Vue 3的Composition API中，可以通过<code>v-deep()</code>函数在<code>&lt;style&gt;</code>标签中动态应用深度选择器。这不是CSS语法的一部分，而是Vue 3特有的模板编译特性。</p></li><li><p><strong>用法</strong>：通常在<code>&lt;style&gt;</code>标签的<code>scoped</code>属性下，结合<code>v-bind:class</code>或<code>v-bind:style</code>在模板中动态绑定样式时使用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123;&#x27;custom-class&#x27;: true&#125;&quot;&gt;</span><br><span class="line">    &lt;ChildComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// Composition API 逻辑</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.custom-class::v-deep(.child-class) &#123;</span><br><span class="line">  /* 样式规则 */</span><br><span class="line">&#125;</span><br><span class="line">/* 或者使用v-deep()函数（虽然不直接在&lt;style&gt;中，但说明其概念） */</span><br><span class="line">/* 注意：实际中v-deep()不直接用于&lt;style&gt;标签内，而是可能通过其他方式结合Composition API使用 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面的<code>v-deep()</code>示例主要是为了说明概念，实际上在<code>&lt;style&gt;</code>标签内直接使用<code>v-deep()</code>函数是不支持的。在Composition API中，<code>v-deep()</code>通常与动态样式绑定结合使用，但这更多是在JavaScript层面而非CSS层面。</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="Vue-2-x"><a href="#Vue-2-x" class="headerlink" title="Vue 2.x"></a>Vue 2.x</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span> /deep/ <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>或者使用<code>&gt;&gt;&gt;</code>（需要配置支持）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span> &gt;&gt;&gt; <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="Vue-3-x"><a href="#Vue-3-x" class="headerlink" title="Vue 3.x"></a>Vue 3.x</h5><p>在Vue 3.x中，推荐使用<code>::v-deep</code>作为深度选择器，因为它既清晰又符合Vue的官方规范。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;ChildComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// Composition API 逻辑</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span>::v-deep <span class="selector-class">.child-class</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则，这些规则将穿透到ChildComponent内部，并应用于具有.child-class类的元素 */</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>.parent::v-deep .child-class</code>选择器将确保<code>.child-class</code>的样式被应用到<code>&lt;ChildComponent /&gt;</code>内部的任何匹配元素上，即使这些元素被<code>&lt;ChildComponent /&gt;</code>的<code>&lt;style scoped&gt;</code>封装所包围。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>关于<code>v-deep()</code>在Composition API中的特殊说明:</p><p>需要注意的是，<code>v-deep()</code>并不是一个在<code>&lt;style&gt;</code>标签内直接使用的CSS选择器或函数。相反，它的概念更多地与Vue 3的Composition API和动态样式绑定相关。</p><p>然而，Vue官方并没有直接提供一个名为<code>v-deep()</code>的函数用于在Composition API中处理样式穿透。</p><p>在Composition API中处理样式穿透时，你通常会继续使用<code>::v-deep</code>选择器，但可能会通过JavaScript逻辑来动态绑定类名或样式，而不是直接使用一个名为<code>v-deep()</code>的函数。</p><p>例如，你可以使用<code>v-bind:class</code>或<code>v-bind:style</code>来根据组件的状态动态地添加或移除样式类。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><ul><li><code>/deep/</code>和<code>&gt;&gt;&gt;</code>在Vue 2.x中用于穿透样式封装，但在Vue 3.x中不再推荐使用。</li><li><code>::v-deep</code>是Vue 3.x中推荐的深度选择器，用于穿透组件的样式封装。</li><li><code>v-deep()</code>并不是Vue官方提供的一个函数，用于在<code>&lt;style&gt;</code>标签内或Composition API中直接处理样式穿透。相反，你应该使用<code>::v-deep</code>选择器，并结合Vue的模板和Composition API功能来实现动态样式绑定。</li></ul><p>通过正确理解和使用这些深度选择器，你可以更有效地在Vue项目中定制组件样式，而无需修改第三方组件的源代码。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来想自己整理一下Vue的深度选择器这块的内容，没想到有人整理的如此详细。</p><p>我对比了官网文档大致看了一下，整理的很好，于是这里就直接收录（化身懒狗）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/erBnyyuka5c6BI7ZbIe8VA">深度选择器探秘：&#x2F;deep&#x2F;、&gt;&gt;&gt;、::v-deep 与 v-deep() 的区别与用法 (qq.com)</a></p><p><a href="https://cn.vuejs.org/api/sfc-css-features.html#deep-selectors">单文件组件 CSS 功能 | Vue.js (vuejs.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文算是转载文章，本来打算自己写的，但是发现别人写的比自己号多了，还很完成。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解前端的图片格式</title>
    <link href="https://crazystudent13.github.io/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    <id>https://crazystudent13.github.io/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-07-21T10:00:10.000Z</published>
    <updated>2024-09-08T15:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客转载：<a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a>。</p><p>关于图片，算是前端性能优化的一个核心，所以这里就不自己整理，而是尽可能的采用其他大佬整理好的标准答案了。</p><p>文中的内容我根据自己的经验确认了一下，基本没什么问题，可以放心食用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>前端开发中经常和图片打交道，那么熟悉各种图片格式的应用场景以及优劣势对于我们尤为重要。</p><p>基础的那些老古董问题让人心生烦躁，相比那些问题，图片这个问题虽然基础且老旧，但是在前端开发中确实频繁出现。</p><p>时至今日，在性能优化这里，图片的压缩依旧是一个避不开的问题。</p><p>关于网页中对图片的性能优化，后续会单独出一张内容，本次只是简单整理这些图片的格式，做个基础的了解。</p><h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul><li><strong>无损压缩</strong>：对文件的数据存储方式进行优化，采用某种算法表示重复的数据信息，能在保证图片的质量的同时降低图片的尺寸，png是其中的代表，但尺寸相比原图减少不多。<code>可以还原</code></li><li><strong>有损压缩</strong>：在压缩的时候，去除了人眼无法识别的图片细节，图片质量会下降，图片尺寸能得到很大程度的压缩。<code>不可还原</code></li><li><strong>无压缩</strong>：不会对图片进行任何压缩处理，能够精准的呈现原图片，例如：BMP。开发中我们考虑到加载性能问题，几乎不会考虑这种图片</li></ul><h3 id="GIF图"><a href="#GIF图" class="headerlink" title="GIF图"></a>GIF图</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>Gif图采用<code>LZW</code>压缩算法进行编码，采用<code>无损压缩</code>，这意味着图片在压缩后<code>质量不会受损</code>。</li><li>Gif图1987年提出的，距今发展了几十年了，<code>兼容性好</code>。</li><li><code>支持透明度</code>，GIF允许图像中的像素具有不透明和透明属性，这使得它在创建带有透明背景的图像时非常有用。</li><li><code>支持动画</code>，GIF支持简单的动画，可以用来创建循环播放的短动画，这在网页设计和用户界面方面非常有用。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>只能存储8位颜色索引，<code>色彩复杂、细节丰富的图片不适合</code>。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>适合简单的动画或者图标，例如：Logo、Icon、动图。</li><li>上报埋点时采用1 * 1像素的透明Gif图。<ul><li><code>避免跨域</code>，用图片上报而不是采用fetch或ajax去上报，用Image的src不会存在跨域行为并且也会触发请求</li><li><code>兼容性好</code>，所有浏览器都支持Image对象，即便浏览器不支持XMLHttpRequest(例如古董级的IE)，也能进行上报。相比与<code>navigator.sendBeacon</code>兼容性更好。</li><li><code>体积最小</code>，1*1的透明PNG是67字节，而Gif只需要43个字节。同样的性能比PNG图片减少35%的流量。</li><li><code>支持透明</code>，用Gif上报埋点最好是透明的，一是避免影响页面展示，而是可以不用存储颜色索引，减少图片大小。</li><li><code>避免请求取消</code>，ajax请求过程中离开页面会导致请求中断，最终导致上报失败。然而Image的src不会中断。</li></ul></li></ul><h3 id="PNG图"><a href="#PNG图" class="headerlink" title="PNG图"></a>PNG图</h3><p>PNG默认是PNG-24格式</p><h4 id="png-8"><a href="#png-8" class="headerlink" title="png-8"></a>png-8</h4><ul><li>png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。</li><li>非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。</li><li>这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。</li></ul><h4 id="png-24、png-32"><a href="#png-24、png-32" class="headerlink" title="png-24、png-32"></a>png-24、png-32</h4><ul><li>图片质量和bmp差不多，在尺寸是比bmp更小。</li><li>尺寸上比JPG、GIF更大，当然质量更高。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><code>支持透明度</code>：PNG支持透明通道，允许创建带有透明背景的图像。</li><li><code>无损压缩</code>：可以保持图片质量不损失细节。</li><li><code>广泛支持</code>：PNG是一种通用格式，计算机或移动设备都支持。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>复杂、色彩丰富图片尺寸大</li><li>不支持动画</li></ul><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><ul><li>适合图形设计，可以保存文本、线条图案等高质量、透明图像。</li><li>相机设备，适合后期对图片进行处理。</li></ul><h3 id="JPG图"><a href="#JPG图" class="headerlink" title="JPG图"></a>JPG图</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><code>有损压缩</code>:JPG格式具备出色的压缩性能，可以显著的减少图像文件的大小。这使得它在Web上显示一些质量要求不高的图像非常有用，减少加载时间</li><li><code>广泛支持</code>：是一种通用格式，在计算机以及手机设备上都广泛支持。</li><li><code>色彩丰富</code>：JPG支持24位颜色深度，因此可以显示百万种颜色。</li><li><code>可调质量</code>：用户可根据使用场景来调图片质量，较高的图片质量，会导致图片尺寸较大。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>不支持透明</code>：不能够创建带有透明背景的图像，PNG或GIF更适合这种情况。</li><li><code>损失性压缩</code>：JPG是有损压缩，而且一旦压缩无法还原，会丢失一些细节。</li><li><code>不适合带有文本或线条的图片</code>： JPG压缩在处理文本和线条方面不如其他格式好，可能会导致图像出现锯齿或模糊情况。</li><li><code>不适合Icon或者Logo</code>：相对于PNG或GIF图，在尺寸上没有优势</li></ul><h3 id="WEBP图"><a href="#WEBP图" class="headerlink" title="WEBP图"></a>WEBP图</h3><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>关于兼容性查询，想必大家或多或少都看过，这里我就不像他们那样放图浪费资源了。</p><p>想要查询图片的兼容性问题，直接访问：  <a href="https://link.zhihu.com/?target=https://caniuse.com/">Caniuse.com</a>，或者直接点击：<a href="https://caniuse.com/?search=webp">“webp” | Can I use… Support tables for HTML5, CSS3, etc</a>。</p><p>总之，IE11依然不支持Webp，需要额外引入一些JS工具来进行解决，如果你的项目需要兼容IE11，那么就要注意这个问题了。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当Web要求图片加载速度和图片显示质量时，可以适当的降低下图片质量减少图片尺寸来满足场景。</li><li>是用于要求<code>色彩丰富</code>的场景。</li></ul><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>WebP（Web Picture）是一种现代的图像格式，由Google开发，旨在提供高质量的图像压缩和更快的加载速度。WebP<code>支持有损和无损压缩</code>，以及<code>透明度</code>，是一种<code>灵活的图像格式</code>，适用于Web和移动应用程序。</p><p>对于前端来说，该图片格式常用于一种<code>优化网页加载速度</code>的手段之一。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><code>高压缩率</code>：WebP 图像通常具有更小的文件大小，相对于传统格式如JPEG和PNG，可以减少带宽使用和加速页面加载速度</li><li><code>高质量</code>：即使在较高的压缩率下，WebP 图像通常能够保持较高的图像质量，减少了压缩损失。</li><li><code>透明度</code>：WebP支持透明通道，可以用于创建带有透明背景的图像，类似于PNG格式。</li><li><code>动画</code>：WebP还支持动画图像，允许创建小型、高质量的动画。</li><li><code>广泛支持</code>：大多数浏览器都已经支持，但是目前低版本的Safri以及IE还不支持。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>兼容性</code>：考虑到目前还不能完全放弃IE以及旧版本Safri，所以还不能完全切到该图片格式。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>WebP 格式适用于网页开发，特别是那些需要快速加载的网站和移动应用程序。</li><li>它适合用于图像库、图标、按钮、背景图像、动画以及需要高质量和小文件大小的图像。</li><li>WebP 的无损压缩特性使它适用于医学图像、卫星图像、地图和其他需要高质量和完整性的图像应用。</li></ul><h4 id="开发兼容"><a href="#开发兼容" class="headerlink" title="开发兼容"></a>开发兼容</h4><p>考虑到Webp格式还存在兼容性问题，开发中如何应用Webp图片格式？</p><ul><li>如果图片资源存储在服务端，可以设计一套通用方案，在<strong>服务端根据Accept请求头判断是否支持Webp格式，如果支持返回Webp格式，否则返回PNG格式</strong>。</li><li>如果你无法说服后端去实现上述方案还想采用Webp图片优化页面加载，可以考虑维护两个格式的图片，然后使用<strong>picture标签</strong>去实现</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> srcset=<span class="string">&quot;flower.webp&quot;</span>&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> srcset=<span class="string">&quot;flower.jpg&quot;</span>&gt;</span><br><span class="line">  &lt;img <span class="attr">src</span>=<span class="string">&quot;flower.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>整理图片格式这个面试题相对来说我倒不是那么抗拒，这个问题虽然基础但是在开发中，如果专注性能优化的朋友可能会很熟悉。</p><p>早年我在优化小程序的时候，曾经在处理图片问题上废了不少功夫，那时候对图片相关的知识了解了很多，但是不成体系。</p><p>如今花了些时间整理了一下，心理倒也颇为感慨。</p><p>只是时间不够，不然我大概率还会整理一下矢量图和像素图的区别，还有一些性能优化的点。</p><p>后续在整理性能优化的相关文章的时候，我会着重整理相关内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客转载：&lt;a href=&quot;https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5&quot;&gt;聊聊几种常见的图片格式Webp、GIF、PNG、JPG&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于图片，算是前端性能优化的一个核心，所以这里就不自己整理，而是尽可能的采用其他大佬整理好的标准答案了。&lt;/p&gt;
&lt;p&gt;文中的内容我根据自己的经验确认了一下，基本没什么问题，可以放心食用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解一些HTML的知识</title>
    <link href="https://crazystudent13.github.io/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://crazystudent13.github.io/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/</id>
    <published>2024-07-19T04:49:45.000Z</published>
    <updated>2024-09-08T15:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>从掘金的一篇文章中摘下来的部分问题，这种级别的面试题，问问三年前的新人还好，问现在的新人多少有点过时了。</p><p>而问我这种前端老登，如果不是为了找工作，放在以前我真会喷他。</p><p>这里没什么好说的，谁叫现在是为了找工作呢，统一整理出来看看吧，我实在想不懂问这些阴间问题的到底是哪些面试官想出来的，这些面试题显得你很会搜集面试题吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇基本上都是HTML5的冷门问题，HTML的知识，真的。。。我都麻了，在掘金上刷到还有面试官来问这种问题？</p><p>呵呵，放在两年前，问这种问题只会让我感觉到这个面试官水平不行。</p><p>这些问题中不乏一些偏到犄角旮旯的垃圾问题，有些甚至是我这个前端老登都感觉真他妈离谱，真想把一些问题拍在面试官的脸上。</p><p>你这些狗日的问题，你要不查文档，你自己能答的出来吗？你到底是从哪个题库中扒出来的？你弄这些东西到底对你自己的项目有什么促进作用？这些基础问题，要是你自己不花点时间准备，你到底能回答出来多少？</p><p>这些问题对业务上的促进作用是什么？你问这些问题你要不给个为什么，我真他吗的。。。。算了，人在屋檐下。</p><p>罢了，就当是听孔乙己说茴香豆的四种写法了，真你妈的离谱。</p><h3 id="DOCUTYPE作用"><a href="#DOCUTYPE作用" class="headerlink" title="DOCUTYPE作用"></a>DOCUTYPE作用</h3><p>DOCTYPE（‌文档类型声明）‌是HTML文档中的一个重要组成部分，‌它位于HTML文档的第一行，‌位于<code>&lt;html&gt;</code>标签之前。‌</p><p>这个声明用于指定当前文档所采用的HTML版本。‌</p><p>DOCTYPE不是HTML标签，‌而是一个指令，‌告诉浏览器当前页面采用了哪个HTML版本，‌以便浏览器按照相应版本的规范来解析和渲染页面。‌</p><p><code>&lt;!DOCTYPE html&gt;</code>声明的主要作用是规范浏览器行为，‌确保HTML文档的正确解析和渲染。</p><p>这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat。</p><ul><li>document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面、（默认）。</li><li>document.compatMode： CSS1Compat：标准模式、浏览器使用W3C标准解析渲染页面。</li></ul><p>如果你的页面添加了<code>&lt;!DOCTYPE html&gt;</code>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。</p><p>这就是<code>&lt;!DOCTYPE html&gt;</code>的作用。</p><p>如果你不加，浏览器如果按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式、很可能出现兼容问题。</p><p>这个问题基本上是最初那一代的前端开发者才会知道的问题，因为最初浏览器还没有定下W3C标准，各家浏览器都按照自家的标准做事，所以那时候才有了那么多恶心的兼容问题。</p><p>在W3C标准出现之前，彼时不同浏览器的内核是不统一，割裂极度严重，IE浏览器，火狐，还有谷歌，三家浏览器各搞各的，直到后续各家浏览器出来统一制定了W3C规则之后，统一进行页面的解析。</p><p>当然，在那之后，IE浏览器依旧不老实，还是坚持要搞自己的一些小动作，所以在18年~22年左右，依然有很多政府项目要求兼容IE。</p><p>不过随着时代的发展，这种项目估计除了银行之类的ToG的政府项目才会关心，实际上都不在关注这种问题了，毕竟现在都在使用W3C标准，而坚持自己个性标准的IE浏览器，在IE11之后就进了历史垃圾堆。</p><p>在这之后，微软也宣布推出了Edge，摆脱了原有的历史包袱，使用W3C标准。</p><p>所以，到现在<code>&lt;!DOCTYPE html&gt;</code>成了前端标准的兼容行为，这个操作太过基石，以至于没什么人会去关注。</p><p>这里稍微总结一下<code>&lt;!DOCTYPE html&gt;</code>的作用</p><ul><li><strong>规范浏览器行为</strong>：‌通过指定正确的DOCTYPE，‌可以确保浏览器按照相应版本的HTML规范来解析和渲染页面，‌从而避免出现兼容性问题。‌</li><li><strong>避免混杂模式</strong>：‌早期的HTML标准中，‌如果没有提供DOCTYPE声明或者提供了错误的声明，‌浏览器会进入混杂模式（‌Quirks Mode）‌，‌这可能导致页面显示不一致或出现兼容性问题。‌通过明确指定正确的DOCTYPE，‌可以避免进入混杂模式。‌</li><li><strong>支持新特性</strong>：‌随着HTML标准的不断更新和演进，‌新版本中引入了许多新特性和语法规则。‌使用适当的DOCTYPE声明，‌可以告诉浏览器当前页面采用了哪个HTML版本，‌并使其能够理解并支持该版本中新增加的功能和语法。‌</li><li><strong>提示验证工具</strong>：‌DOCTYPE声明还对验证工具起到提示作用。‌验证工具（‌如W3C的HTML验证器）‌可以根据DOCTYPE声明来判断文档是否符合相应版本的HTML规范，‌从而帮助开发者发现和修复代码中的错误。‌</li></ul><h3 id="META的作用"><a href="#META的作用" class="headerlink" title="META的作用"></a>META的作用</h3><p>这里放一段W3C的示例，结合实例稍微说一下作用，实际开发过程中，最多可能常用到控制缩放。</p><p>至于常规keywords，description，基本上都是SEO常用到的配置，而后台管理类项目，平常基本上没人在乎这个的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;免费的 Web 教程&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, JavaScript&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Bill Gates&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>meta 元素可以使用名&#x2F;值对定义元数据，为此需要用到其 name 和 content 属性。</p><table><thead><tr><th>name</th><th>content</th><th>描述</th></tr></thead><tbody><tr><td>charset</td><td>UTF-8</td><td>声明当前页面使用的字符集</td></tr><tr><td>keywords</td><td>HTML, CSS, JavaScript</td><td>搜索引擎关键字</td></tr><tr><td>description</td><td>Free Web tutorials for HTML and CSS</td><td>网页描述</td></tr><tr><td>author</td><td>John Doe</td><td>页面作者</td></tr><tr><td>viewport</td><td>width&#x3D;device-width, initial-scale&#x3D;1.0</td><td>控制设备上缩放效果</td></tr><tr><td>http-equiv&#x3D;”refresh”</td><td>30</td><td>每 30 秒刷新一次文档</td></tr></tbody></table><p>这里大概列举了一下，至于详情，这里就不列举了。</p><p>详情这里实在不想细说，有兴趣可以自行去看<a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a>。</p><h3 id="HTML5语义化"><a href="#HTML5语义化" class="headerlink" title="HTML5语义化"></a>HTML5语义化</h3><blockquote><p>语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。</p><p>不仅对自己来说，容易阅读，书写。</p><p>别人，甚至是网络爬虫机器看你的代码和结构也容易理解。</p></blockquote><p><strong>语义化简单讲就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</strong></p><p>在解释这个概念之前，应该先解释下“结构-表现-行为”。</p><p>如果说解耦合是代码的高境界，那么“结构-表现-行为”的原则就是前台的标杆。</p><p>前端代码是有HTML + CSS + JS来实现的。他们对应的就是负责“结构-表现-行为”。</p><p>不过，现在兴起的前端技术大多要求是用来处理后台，这时候把很多以前的PC应用搬到了浏览器上。</p><p>而应用就不怎么在乎浏览器器的语义化了，秉承着能用就行的原则，大多数后台应用类的网站的语义化要求被淡化，大多数都是div一把梭。</p><p>除了页面SEO，或者是静态新闻网站之外，大多数网页开发都不再在乎应用，感兴趣的可以看看这篇博客园的博客：<a href="https://www.cnblogs.com/iamspecialone/p/11178486.html">Html的语义化</a>。</p><h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p>2024年了，还是那些个新特性，这些东西没有什么可聊的，从H5标准出来到现在，作为浏览器的基石，这些规则基本都没有什么改变。</p><p>后续会稍微整理这些新特性的详情玩法，每个特性都很基础，但是深挖之后，都是深坑，我们这里就简单的了解一下概念，应对面试就可以。</p><ol><li>语义化标签，（hrader、footer等），使得页面的内容结构化，见名知义</li><li>增强型表单，拥有多个新的表单input输入类型，可提供更好的输入控制和验证</li><li>video和audio元素，提供了播放视频和音频文件的标准方法</li><li>canvas绘图， 画布功能，通过 JavaScript 来绘制 2D 图形。</li><li>svg绘图，SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>地理定位，Geolocation（地理定位）用于定位用户的位置</li><li>拖放API，在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放</li><li>web worker，web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。</li><li>web storage，使用HTML5可以在本地存储用户的浏览数据，cookie，local storage，sessionStorage。</li><li>WebSocket，WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</li></ol><p>以上十个新特性在现代开发中衍生出了很多内容，譬如websocket的聊天室，基于canvas画布实现的流程图和很多酷炫的图表。</p><p>哪怕是最基础的语义化形成的SEO，还有表单的提交增强，都是很强力的增强，这里后续我们会基于每个特性进行深入的了解。</p><h3 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h3><p>二者的区别，这里要从请求资源类型，解析方式，权重角度来分析。</p><h4 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h4><h5 id="href（Hypertext-Reference）"><a href="#href（Hypertext-Reference）" class="headerlink" title="href（Hypertext Reference）"></a>href（Hypertext Reference）</h5><p>作用指定超链接目标的URL，主要用来建立当前元素和href引用元素的链接关系。</p><p>href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。</p><p>常用link，a标签。</p><h5 id="Src（Source）"><a href="#Src（Source）" class="headerlink" title="Src（Source）"></a>Src（Source）</h5><p>作用是指向物件的来源地址，主要指向需下载的资源。</p><p>src将其指向的资源下载并应用到当前document中，并且替换当前元素。</p><p>常用标签script，img，iframe等。</p><h4 id="浏览器解析方式和权重的不同"><a href="#浏览器解析方式和权重的不同" class="headerlink" title="浏览器解析方式和权重的不同"></a>浏览器解析方式和权重的不同</h4><p>用 href时，加载到对应位置的时，不会暂停其他资源的下载或行为。</p><ul><li>权重思想： href链接的的是当前页面的一部分附属资源。</li><li>注意点：所以CSS样式可以放在html结构的头部优先加载（因为不影响页面的核心加载，只是HTML标签的对应样式表）</li></ul><p>用src时候，会暂停其他资源的下载，直到当前资源加载，编译，执行完成了，并且把当前资源替换到src引用处了。</p><ul><li>权重思想： src加载的是当前页面的一部分。</li><li>注意点：这就是为何js脚本一般回放到document底部加载而不是头部。</li></ul><h3 id="BFC-及其应用"><a href="#BFC-及其应用" class="headerlink" title="BFC 及其应用"></a><strong>BFC 及其应用</strong></h3><p>说了半天，这个算是一个比较正常的面试题，值得重点看看。</p><p>BFC(Blcok formatting context) 直译为“块级格式化上下文”。</p><p>他是一个独立的渲染区域，只有块级元素参与，它规定了内部块级元素的布局，并且与这个区域外部毫不相关，外部元素也不会影响这个渲染区域的元素。</p><blockquote><p>简单说：BFC 就是页面上的一个隔离的独立渲染区域，区域里边的子元素不会影响到外面的元素。外边的元素也不会影响到区域里面的子元素。</p></blockquote><p>以下是一些常见的创建 BFC 的方法：</p><ol><li>浮动元素：将一个元素设置为浮动（<code>float: left</code> 或 <code>float: right</code>）会创建一个 BFC。</li><li>绝对定位元素：将一个元素设置为绝对定位（<code>position: absolute</code>）会创建一个 BFC。</li><li>固定定位元素：将一个元素设置为固定定位（<code>position: fixed</code>）会创建一个 BFC。</li><li>具有 <code>overflow</code> 属性的元素：将一个元素的 <code>overflow</code> 属性设置为非 <code>visible</code> 的值（例如 <code>overflow: hidden</code>、<code>overflow: auto</code> 或 <code>overflow: scroll</code>）会创建一个 BFC。</li><li>具有 <code>display</code> 属性为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code> 或 <code>flex</code> 的元素：这些元素会自动创建一个 BFC。</li><li>根元素（<code>html</code> 元素）：根元素始终是一个 BFC。</li></ol><p><strong>BFC 可以解决那些问题</strong></p><ol><li>避免垂直方向的<code>margin</code>合并。问题：垂直方向上的，两个元素<code>margin</code>相遇，两元素间的距离并不等于两个<code>margin</code>之和。而是等于最大的<code>margin</code>。小的<code>margin</code>会被大的<code>margin</code>吞并。</li><li>清除浮动元素的影响。问题：如果父元素包含一个浮动元素，那么其他元素可能会受到浮动元素的影响，导致布局混乱。但是给父元素变成BFC，浮动元素对其他元素的布局不再产生影响。</li><li>防止高度塌陷。问题：父元素不写高度时，子元素浮动后，导致父元素会发生高度塌陷（造成父元素高度为0）。但是将父元素变成BFC，就不会造成高度塌陷，最简单的方法是，给父元素设置<code>overflow: hidden</code>属性。</li><li>垂直布局。问题：父元素包含多个子元素，并且这些子元素的高度不同，那么在没有创建 BFC 的情况下，这些子元素可能会在垂直方向上重叠。但是将父元素变成BFC，子元素在垂直方向上就能正确排列。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>真的是。。。越整理越感觉离谱，我都感觉自己人生中浪费了数个小时在整理这些冷门问题到底在干嘛。</p><p>实话实说，这些老古董问题，在我眼里除了AI应该知道之外，正常的前端开发都不需要知道，最多就大概了解一下就行，哪怕是专门拿来问都有点显得掉架子，正经的老开发很难去了解这些问题。</p><p>我实在想不通为什么有很多傻逼面试官会问到这种老古董的冷僻问题，他自己平时难道用得到吗？难道这些人平时自己就能用得到？就是为了考察所谓的基础？这些基础到底有什么用？</p><p>我不说别的，DOCUTYPE的作用这个，在这些年里真的会有人遇到这方面的问题吗？兼容IE11? 除非是银行项目，到底是哪些人还他妈的固执的在用IE11?</p><p>很多政府项目都不在要求兼容IE11了，偏偏这些人还在要求，这是否有点太离谱了？</p><p>只能说，内卷化的极端时间里，现在找个工作太难，导致这种不知道从哪抠出来的冷僻问题居然成了热门的面试题，真他妈的傻逼。</p><p>除了外行和新手，我真的想不懂这些问题对开发的意义，哪怕多问问项目实现的难点我都不会对这些面试官有意见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7280007125999681588">我在公司是怎么做面试官的？</a></p><p><a href="https://www.cnblogs.com/tianmiaogongzuoshi/p/16341179.html">src和href的区别</a></p><p><a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从掘金的一篇文章中摘下来的部分问题，这种级别的面试题，问问三年前的新人还好，问现在的新人多少有点过时了。&lt;/p&gt;
&lt;p&gt;而问我这种前端老登，如果不是为了找工作，放在以前我真会喷他。&lt;/p&gt;
&lt;p&gt;这里没什么好说的，谁叫现在是为了找工作呢，统一整理出来看看吧，我实在想不懂问这些阴间问题的到底是哪些面试官想出来的，这些面试题显得你很会搜集面试题吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="HTML5" scheme="https://crazystudent13.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue3相对于vue2的变化</title>
    <link href="https://crazystudent13.github.io/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>https://crazystudent13.github.io/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/</id>
    <published>2024-07-18T04:39:05.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>vue3与vue2的区别算是较为火热的面试题之一了，之前早就想整理一遍了，但是奈何没有太多时间去关注。</p><p>在两者的深度上，我个人一直觉得自己了解的较少，了解的越深就越不敢说自己深入了解。</p><p>经过两个月左右的整理，我应该可以勉强说自己算是略懂了。</p><p>这里放上自己的拙见，我尽可能的确认了自己理解的准确性，不过我仍然感觉自己似乎做的不到位，这就当是抛砖引玉，希望大家在评论区多多拍砖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这段时间看了很多相关的文档，自己也翻了很多遍<a href="https://cn.vuejs.org/">vue3的官网文档</a>，同时自己也在项目中重新按照自己的经验重新用了一遍Vue3的新写法。</p><p>在一段时间的使用之后，个人认为，Vue3与Vue2的区别，要从使用者和开发者的角度来看。</p><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><p>使用者，就是我们平时写业务的这些普通开发者。</p><p>大多数情况下，使用者不负责源码开发，仅仅只要知道有个新特性，然后按照新特性使用就行了。</p><p>就像是伐木工学会了用A型号的电锯，这时候电锯做了个升级，加入了一些特性，而我们只要知道如何用好这些新特性。</p><p>相对于Vue2，我认为Vue3的新特性如下。</p><ul><li>取消了根元素，每个组件不必再必须嵌套一个根元素标签了</li><li>响应式用法的改变，用reactive和ref取代了之前的data声明的变量的方式</li><li>新增了组合式写法，相对于传统的选项式更灵活，可读性更高，这种写法也支持</li><li>父子组件传参方式发生了些许改变，不过用法大致和Vue2的思路没差，<strong>defineProps</strong>，<strong>defineEmits</strong>，<strong>defineExpose</strong>这三个稍微看看用法就能很快上手</li><li>生命周期的写法和名称有些许改变，新增了setup，但是大致流程没有变化</li><li>v-if和v-for的优先级调整，以v-if的优先级更高，如果二者要在同一标签内使用，将v-for放在外边，不然v-if会直接覆盖掉v-for的效果</li><li>修饰符发生了一些改变，取消了.native，不过总的来说没有太大变化</li></ul><p>总之，Vue3相对于Vue2，虽然很多人说是有些破坏式更新，写法发生了巨大的改变，这是一次失败的更新。</p><p>但从使用者的角度来讲，我个人认为，这次更新并不算是一次破坏式更新，至少大部分写法和习惯都是保留好了。</p><p>这里浅谈一下争论最大的选项式与组合式。</p><h4 id="选项式？"><a href="#选项式？" class="headerlink" title="选项式？"></a>选项式？</h4><p>选项式就是V2的写法，选项式上手简单，且不容易出岔子，有这个基础架子的保证，新手只要不是特别离谱，写出来的代码至少具有一定的可读性。</p><p>但这种写法在代码量上去之后，可读性就会变得差。</p><p>主要原因就是变量和函数分开，不同块的变量混合在一起，每次翻阅代码的时候就要上下翻看，要么就要拆开面板去分开看，很麻烦。</p><p>而且，所有的变量都是在data中申明，全部指向了this。</p><p>指向this固然好用，但是随着后续模块的增多，这些this声明出来的变量会让人不知道这到底是哪个模块的内容，容易造成混乱。</p><p>而组合式确实解决了这个痛点。</p><h4 id="组合式？"><a href="#组合式？" class="headerlink" title="组合式？"></a>组合式？</h4><p>组合式写法其实就是回归了传统的script标签写法，声明了变量，然后按照传统的JS写法继续做就可以。</p><p>相对于V2的写法，V3的写法太过自由，可能很多人第一时间拿到手之后会有些不知所措。</p><p>不过经过几个项目铺垫之后，大概就能明白组合式的优势了。</p><p>组合式相对于选项式，可以更模块化的拆业务，通过<code>reactive</code>包裹不同的代码块之后，我们能够更有逻辑的去切割页面上的逻辑块。</p><p>在完成页面的代码块的切分之后，不同变量不会再全部指到this了，这样让我们更清楚这些变量是负责哪个代码块的。</p><p>这就是组合式，更模块化，更容易排查，更好的代码可读性。</p><h4 id="hooks？minxin？"><a href="#hooks？minxin？" class="headerlink" title="hooks？minxin？"></a>hooks？minxin？</h4><p>随着代码量的增加，还可以将多个页面的重复业务块拆出来，放入hooks中供全局使用（Vue2中也有minxin），但是二者实际使用后，就能明白二者的不同。</p><ul><li>hooks像是以前抽离出来的公用方法，抽离的是逻辑，我们将一段公用的逻辑方法封入Hooks中，这里可以封入一定的业务逻辑</li><li>minxin更像是抽离出一部分公用模板，抽离的是模板，我们将一些写烦了的公用方法封入minxin中，省的每次都写。</li></ul><p>当然，我这个说法还是有点怪，实际开发中，这二者的用法硬要用的话，可混为一谈的。</p><p>不过，我个人依旧推荐大家用hooks去封装逻辑，不要用来封装模板。</p><h3 id="开发者"><a href="#开发者" class="headerlink" title="开发者"></a>开发者</h3><p>开发者，就是指Vue框架的源码开发者。</p><p>源码开发者，大家平时其实很少接触到，不过部分使用者在常规业务开发到极度深入的时候，肯定会去了解相关内容。</p><p>尽管我们不去开发，但是用久了，肯定多少会要了解一些的。</p><p>相对于Vue2，Vue3在源码层面的特性变动如下</p><ul><li>整个框架用TS重写，对Vue3对TS有了更好的支持</li><li>重写了响应式的数据劫持方式，用proxy取代了vue2的Object.defineProperty()</li><li>重写了虚拟Dom的实现，编译模板优化，更高效的组件初始化效果</li><li>diff算法重写，参考<a href="https://segmentfault.com/a/1190000042586883">前端 - Vue2、Vue3的diff对比 - 哈啰技术 - SegmentFault 思否</a></li></ul><p>通过这些，开发者做到让Vue3具有了哪些优势呢？</p><h4 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h4><ul><li>Vue 3 的代码库已经全面采用 TypeScript 重写，提供了更好的类型推断和类型提示。</li><li>提供了更多的内置类型声明，使得开发时更容易发现代码错误和调试。</li></ul><h4 id="更好的响应式系统"><a href="#更好的响应式系统" class="headerlink" title="更好的响应式系统"></a>更好的响应式系统</h4><ul><li>Vue 3 使用了 Proxy 来重写响应式系统，相比 Vue 2 的 Object.defineProperty，更加直观和强大。</li><li>在 Vue 3 中，可以在更深的层次上追踪响应式变量的变化，使得开发者能够更准确地监听数据变化。</li></ul><h4 id="更灵活的组合式-API"><a href="#更灵活的组合式-API" class="headerlink" title="更灵活的组合式 API"></a>更灵活的组合式 API</h4><ul><li>Vue 3 引入了组合式 API，使得组件的逻辑可以更好地组织和复用。</li><li>组合式 API 提供了更直观、更灵活的方式来组织组件代码，使得代码更易读、易维护。</li></ul><h4 id="更快的渲染性能"><a href="#更快的渲染性能" class="headerlink" title="更快的渲染性能"></a>更快的渲染性能</h4><ul><li>Vue3 相比 Vue2 来说，Vue3 重写了虚拟 <code>Dom</code> 实现，编译模板的优化，更高效的组件初始化。</li></ul><h4 id="更小的体积"><a href="#更小的体积" class="headerlink" title="更小的体积"></a>更小的体积</h4><ul><li>Vue 3 的运行时核心相比 Vue 2 更小，这意味着更小的打包体积，减少了前端加载时间。</li><li>Tree-shaking 支持：Vue 3 代码更容易被 Tree-shaking 优化，因此可以更好地剔除不需要的代码。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>个人虽然是个vue老登了，但是在很多时候都是在自我学习，所以我整理的这些内容实在是过于浅薄，并未深入，让大家见笑了。</p><p>关于Vue2与Vue3的选择，我个人并不排斥任何一种选择，这需要我们根据实际情况来进行选择，很多老项目如果能不动，最好还是别动。</p><p>当然，从长远的角度来讲，我还是期望用Vue3的，毕竟Vue2已经停止了更新，而Vue3继承了2的特性，并且还在持续更新，显然Vue3更有潜力。</p><p>而且，社区内似乎有不少人开始追随Vue3的更新，同时也出现了<a href="https://vueuse.org/">VueUse</a>这种社区好物。</p><p>长远的来看，显然是Vue3的社区会更壮大。</p><p>这种不错的未来前景，是最值得追逐技术的理由之一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340676808436563987?searchId=20240718123318E0F013B86F459BBDBB95">vue3和vue2的区别，你知道多少 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7030992475271495711">vue3保姆级教程</a></p><p><a href="https://segmentfault.com/a/1190000042586883">前端 - Vue2、Vue3的diff对比 - 哈啰技术 - SegmentFault 思否</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vue3与vue2的区别算是较为火热的面试题之一了，之前早就想整理一遍了，但是奈何没有太多时间去关注。&lt;/p&gt;
&lt;p&gt;在两者的深度上，我个人一直觉得自己了解的较少，了解的越深就越不敢说自己深入了解。&lt;/p&gt;
&lt;p&gt;经过两个月左右的整理，我应该可以勉强说自己算是略懂了。&lt;/p&gt;
&lt;p&gt;这里放上自己的拙见，我尽可能的确认了自己理解的准确性，不过我仍然感觉自己似乎做的不到位，这就当是抛砖引玉，希望大家在评论区多多拍砖。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue2与3的数据劫持区别</title>
    <link href="https://crazystudent13.github.io/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-14T08:52:52.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>两年前在vue3在社区兴起之时，很多社区弄潮儿就在分析2与3源码区别，那时候很多人都以为是个新时代会到来。</p><p>可是两年过去了，vue3的新时代依旧在缓慢迭代。</p><p>对于大部分业务流选手，大家都不关心源码，大家更期望Vue3的相对于Vue2在工程上的亮点在哪，到底能否更爽快的开发，更好更稳定的替换当前工程。</p><p>除非是面试，这种源码级的改动几乎是一个必然的面试题。</p><p>很不巧，我现在刚好需要处理面试，于是这里整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文默认使用者都用过Vue2和Vue3的，如果您没有看过Vue2的响应式原理，推荐您最好先去了解Vue2的响应式原理，因为本文会直接略过很多内容，如果不清楚相关知识，看起来可能体验会很差。</p><p>好了，接下来就开始对V2与V3的数据劫持进行区分。</p><p>在正式进入对二者区别的分析前，我们需要先简单了解一下，什么是数据劫持。</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>在没有进入MVVM框架的时代时候，我们要操作DOM中的数据，就需要自己手动封装一套方法，获取对应节点的DOM，然后修改。</p><p>因为这样很麻烦，才诞生了前端时代的MVVM的各种响应式实现方式。</p><p>这里不展开细说其他框架的响应式原理，单说Vue这块的响应式，在实现响应式的第一步，就是要进行数据劫持。</p><p><strong>数据劫持是Vue数据响应式的核心和基础，通过添加代理来给属性的变化添加额外的操作的方式</strong></p><h4 id="Vue2方式"><a href="#Vue2方式" class="headerlink" title="Vue2方式"></a>Vue2方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Obejct</span>.<span class="title function_">defineProperty</span>(obj,prop,descriptor)</span><br></pre></td></tr></table></figure><p>这个方法可以精确修改对象的属性，decriptor有四个参数，分别是</p><ul><li>configurable：数据是否可删除，可配置，</li><li>enumerable：属性是否可枚举，</li><li>get:一个给属性提供 getter 的方法，如果没有 getter 则为 undefined，</li><li>set:一个给属性提供 setter 的方法，如果没有 setter 则为 undefined object.defineProperty()通过getter&#x2F;setter属性对数据进行监听，getter监听访问数据，setter监听修改数据，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置值&#x27;</span>)</span><br><span class="line">        value = qqq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">o.<span class="property">a</span> = <span class="string">&#x27;sss&#x27;</span> </span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>)</span><br><span class="line"><span class="comment">// 获取值</span></span><br></pre></td></tr></table></figure><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li><p><strong>只有getter&#x2F;setter属性无法监听属性的修改删除</strong>，在Vue 2.x赋值对象时，需要对对象进行初始化，否则需要使用$Set()进行设置</p></li><li><p>无法监听组数的数据变化，数组的长度发生变化的时候无法监听，这也是为什么我们直接根据下标改动数组内容时候会失效，vue2通过处理数组扩展方法（push、pop、shift、unshift、splice、sort、reverse这7个方法），通过这些方法，我们依然是可以对数组进行响应式的数组操作的。</p><p>这个核心原因就是在于遍历数组消耗的性能太大，Vue2如果要做数组的响应式，按照原有的实现方式实在是买椟还珠了。针对这点，Vue2也给出来了一些解决方案，比如$Set()方法解决数组内的数据改变无响应的问题</p></li><li><p>无法拦截对象属性的多层嵌套。vue 2.x表现，watch对多层对象的监听中会失效，也需要$forceupdate()来更新视图。</p></li></ul><h4 id="Vue3方式"><a href="#Vue3方式" class="headerlink" title="Vue3方式"></a>Vue3方式</h4><p>为了解决上面的缺陷，Vue3使用了ES6的proxy方法，直接对源数据进行代理操作。</p><p>通过建立一个新的实例对象，才操作原有对象，并且提供13种监听操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target,thisArg,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">construct</span>(target,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,name,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(target,name,value,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target,name,desc)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(target, prototype)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&quot;获取数组元素&quot; + key);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置数组&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1. 改变已存在索引的数据</span></span><br><span class="line">obj[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment">// result: 设置数组</span></span><br><span class="line"><span class="comment">// 2. push,unshift添加数据</span></span><br><span class="line">obj.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// result: 设置数组 * 2 (索引和length属性都会触发setter)</span></span><br><span class="line"><span class="comment">// // 3. 直接通过索引添加数组</span></span><br><span class="line">obj[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment">// result: 设置数组 * 2</span></span><br><span class="line"><span class="comment">// // 4. 删除数组元素</span></span><br><span class="line">obj.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>显然Proxy完美的解决了数组的监听检测问题，针对数组添加数据，删除数据的不同方法，代理都能很好的拦截处理。</p><p>另外Proxy也很好的解决了深层次嵌套对象的问题。</p><p>这里我们综合整理一下<code>proxy</code>的优势</p><ol><li><strong>性能提升</strong>：Proxy API 比 defineProperty API 在许多情况下具有更好的性能。Vue2使用 Object.defineProperty 方法来拦截对象属性的访问和修改，但它需要遍历每个属性进行拦截。而 Proxy API 允许拦截整个对象，可以更高效地捕获对对象的访问和修改。</li><li><strong>更全面的拦截能力</strong>：Proxy API 提供了更多的拦截方法，比 defineProperty API 更灵活、丰富。它支持拦截目标的各种操作，包括读取、设置、删除、枚举等，甚至还可以拦截函数调用和构造函数实例化。</li><li><strong>更好的数组变化检测</strong>：Vue 3.0 使用 Proxy API 改善了数组的变化检测机制。Proxy 可以直接拦截数组的索引访问和修改，使得对数组的变化更容易被监听到，从而提供了更可靠的响应式行为。</li><li><strong>更易于处理嵌套对象</strong>：Proxy API 能够递归地拦截对象的嵌套属性，而 defineProperty 无法自动递归处理嵌套对象。这使得在 Vue 3.0 中处理嵌套对象更加简单和方便。</li><li><strong>更好的错误提示</strong>：相比于 defineProperty，Proxy API 提供了更好的错误追踪和调试信息。当使用 Proxy API 时，如果访问或修改了一个不存在的属性，会直接抛出错误，从而更容易发现和修复问题。</li></ol><p>不过，如果硬要挑刺的话，总是能找到缺点的。</p><p>比如<code>proxy</code>属性毕竟是ES6的特性，如果有人要兼容低版本的IE10之类的说法，可能vue3这套响应式就不是很能玩得转了。</p><p>但是大多情况下，在现代浏览器环境中，V3的<code>proxy</code>代理确实是比V2的<code>Object.defineProperty()</code>实现方式更还好用</p><h5 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h5><p>我们在日常的工作中，估计已经非常熟悉二者的使用了，相对于Vue2中用data()声明之后即可简单实现响应式，Vue3提供的这两种方式对于Vue2的习惯用户来说简直是一种致命缺陷。</p><p>关于ref和reactive的使用方式优化，在前文<a href="https://crazystudent13.cn/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB/">浅析ref与reactvie的区别</a>一文中，我给出了一些相对好用的使用方案，至少能让开发者在开发项目的过程中有更好的开发体验。</p><p>不过，今天这次不再是简单的讲二者的使用，而是更深层的剖析他们的实现方式。</p><h5 id="reactive的缺陷"><a href="#reactive的缺陷" class="headerlink" title="reactive的缺陷"></a>reactive的缺陷</h5><ol><li>reactive只能用来处理引用类数据的响应式，不能处理基础类型的数据，这个是官方自己这么规定的且<code>proxy</code>也只适合代理对象罢了。</li><li>reactive声明的数据，解构赋值会导致响应式失效</li><li>引用式数据直接赋值会导致响应式失效，比如用reactive代理数组，代理对象，如果你直接赋值一个新数组或者新对象，都会导致响应式失效</li></ol><p>以上缺陷几乎是我们日常开发中经常遇到的问题，稍微有点经验的开发老手大概都能猜出来什么原因。</p><p>很简单，深拷贝改变了引用类型数据的位置，而引用类的数据都是要根据存储位置的指针去找源数据的存储地址的。</p><p>而引用类型数据直接赋值，会直接改变指存储地址，这个重新赋值的过程丢失了响应式自然不奇怪。</p><p>解构赋值也是同理，我们用解构赋值处理引用类型数据，也会改变数据存储位置，原理同上，所以这两种情况都会导致响应式失效。</p><h5 id="ref的本质"><a href="#ref的本质" class="headerlink" title="ref的本质"></a>ref的本质</h5><p>很多开发者在开发中都非常喜欢ref一把梭，虽然这都需要.value&#96;这个小尾巴去获取实际内容。</p><p>相对于reactive，ref不需要考虑数据类型，无论是引用类型和基础类型的数据都能用ref代理。</p><p>但，ref的本质实际上就是reactive。</p><p>很多新人朋友可能在这个过程可能会有点犯迷，为什么ref的本质是reactive？</p><p>ref不是比reactive多了一个基础数据类型代理吗？</p><p>既然ref既能处理基础数据类型，又能处理引用数据类型，为什么不用ref一把梭？</p><p>这里我们放一段在vue工程中随手声明的测试变量，看看这个输出结果吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="title function_">ref</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是基础类型test的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">_value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testObj  = <span class="title function_">ref</span>(&#123; <span class="attr">a</span>: test &#125;)</span><br><span class="line"><span class="comment">// 以下是引用类型数据testObj的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">dep</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">_value</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>) &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">value</span>: (...)</span><br><span class="line">    [[<span class="title class_">Prototype</span>]]: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个复杂对象会有__v_isRef，__v_isShallow等属性，引用类型。</p><p>而我们将reactive包裹的对象输出，就没有该属性。</p><p>再结合上述示例的输出结果我们就能明白，<code>ref</code>实际上在处理基础数据的时，就是用普通的处理，将基础类型数据转换为一个<code>.value</code>的对象来完成响应式的处理。</p><p>而<code>ref</code>在处理引用类型数据时，通过输出结果，我们发现了<code>proxy</code>代理的数据，这和reactive输出的结果一模一样的。</p><p>显然，ref在处理对象的时候，本质上还是调用reactive。</p><p>根据__v_isRef的值去判断，如果是简单的数据，就有ref去处理，如果是复杂的数据，本质还是用reactive去代理。</p><p>所以，在处理引用类型数据时候，本质上还是<code>reactive</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，本次简单的说完了V2与V3的数据劫持方式的不同，不过我水平浅薄，没敢放自己对源码的解读，所以显得有点low。</p><p>不过，我尽可能保证自己说的内容都是查证和实验过了，所以准确性还是有保证的。</p><p>后续会持续整理更新V2与V3之后，也算是对得起自己这多年前端的经验。</p><p>如果您有更好的见解，欢迎在评论区留言，我会参考修正自己的认知。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6968657795977576455">Vue 2.x和Vue 3.x 数据劫持的实现和优缺点</a></p><p><a href="https://www.bilibili.com/video/BV1Lm4y1v72m/?share_source=copy_web&vd_source=a848031cce5c755167a3d6aa6bd87859">【Vue中修改了数组数值，为什么界面没有更新？】</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两年前在vue3在社区兴起之时，很多社区弄潮儿就在分析2与3源码区别，那时候很多人都以为是个新时代会到来。&lt;/p&gt;
&lt;p&gt;可是两年过去了，vue3的新时代依旧在缓慢迭代。&lt;/p&gt;
&lt;p&gt;对于大部分业务流选手，大家都不关心源码，大家更期望Vue3的相对于Vue2在工程上的亮点在哪，到底能否更爽快的开发，更好更稳定的替换当前工程。&lt;/p&gt;
&lt;p&gt;除非是面试，这种源码级的改动几乎是一个必然的面试题。&lt;/p&gt;
&lt;p&gt;很不巧，我现在刚好需要处理面试，于是这里整理一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，规则的意义</title>
    <link href="https://crazystudent13.github.io/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://crazystudent13.github.io/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2024-07-11T11:33:43.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>为了让工程提速，我们制造了规则。</p><p>为了让工程提速，我们漠视了规则。</p><p>本文给新踏上开发之路的朋友，1~3年左右开发经验的朋友可以看看，虽然这不是实打实的开发技能，但这却是我这数年开发的实际心得，您看完了，或许会有所收获，也可能会莞尔一笑，不过无论如何，肯定都不算是耽误您人生中的些许时光。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在早期单打独斗的时候，从来没有在意规则，一个人想怎么写就怎么写。</p><p>不过为了让未来的自己读代码没那么累，于是我开始在代码中写入注释，并且开始了简单的语义化，不再简单使用<code>a,b,c,d</code>这种临时变量。</p><p>这是最开始的简单规则，一直到团队开发的时候，我开发人生中第一套规则才开始正式诞生。</p><p>而数年之后，我为公司打造了一套低代码工具，将工程化发挥到了极致。</p><p>遥遥回想过往，简直感觉一切简直是不可思议。</p><h3 id="开发规则"><a href="#开发规则" class="headerlink" title="开发规则"></a>开发规则</h3><p>在早年前后端分离的思潮刚刚诞生的时候，我入职的前端开发团队大约两人左右，那时后端也仅一人。</p><p>很多时候商量着来，就能完成。</p><p>而后来，随着业务量的增加，前后端数量开始增加，三人以上的前端团队，对接三人以上的后端，在没有统一规则的指导下，开发进度一言难尽。</p><p>大部分的时间，前后端为了对接接口而费劲了心思。</p><h4 id="情景复盘"><a href="#情景复盘" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>三个人的后端，写出了三种风格的接口，大小写不统一，中英文混写，接口传参方式混乱，传参方式不同，且接口变动频繁导致前端根本无法稳定对接。</p><p>大家可能不能想象，那我就说一点，增删改查这一套流程中，有人同样一个字段居然写出了四种命名，有的是拼音，有的是小驼峰的单词，有的是大驼峰的单词，有的还用下划线方式命名，传参的code甚至都能出现字符串和数字两种类型，判定接口成功的code：200，20000，且这个过程中还有两种类型。</p><p>后端一团乱麻，而前端也没好到哪里去。</p><p>样式写法混乱，不用公用样式，非要自己改权重，写入样式覆盖公用样式。</p><p>接口写入方式不同，明明有着开源框架的标准方式，却偏偏要自己手动引入<code>axios</code>写接口，导致<code>api</code>接口文件非常不便管理。</p><p>而且，当时那个时间大约是2019年，那时候，前后端分离方式的思潮还很新，部分前端依旧是习惯于<code>Jquery</code>操作<code>Dom</code>的写法，然后你可以在vue的项目中看到有人引入了<code>Jquery</code>的在线链接，然后在框架内写代码操作表格。</p><p>这种思潮时至今日我居然还能在部分新手代码中遇到，有些时候我甚至可以在vue3中看到Jquery操作表格的代码，我也是不得不感叹，世界真是太大了，大到会发生任何不可思议的事。</p><h4 id="整理问题"><a href="#整理问题" class="headerlink" title="整理问题"></a>整理问题</h4><p>毫无疑问，不规范的问题极大拖累了开发速度，我们两周后复盘了一下，近乎7成以上的事件浪费在这种毫无意义的调试上。</p><p>我们当时在做的是一个系统的翻新，之所以接口会出现频繁变动，是因为大多数后端对业务不熟悉，进而导致接口频繁变动，而我们需要快速翻新出成果。</p><p>为了追求快，我们放弃了规则，这是管理上的隐患。</p><p>公司当时用的是非常好上手的Vue2，写过Vue2的朋友大概率应该知道，这是一个非常好上手的新手框架，但是我们那时候简直能用出一坨屎。</p><p>我将这个开发过程中犯的毛病整理一下，权当一篇避雷指南了。</p><p>如果您现在的项目中中了以下几条，那您就必须要反思一下，您做项目到底将多少精力花在这些无意义的调试上了？</p><ul><li>管理上追求快，不做标准要求，按照要求的时间点开始倒排开发日期，导致开发无限期加班，精力极大程度的消耗在对接空耗上了</li><li>UI风格不统一确定，很多时候出成品，经常会有样式上的变动</li><li>前后端不做业务交流，双方都在一次会议之后，简单确认了任务，就毫无修正的朝着各自以为的目标推进</li><li>后端接口标准不统一，数种不同风格的接口导致前端难以适配，即便写统一处理字段的方法也没法讲中文字段转换成英文字段，这极大的拖累的开发进度</li><li>前后端未约定联调标准，导致传参方式适配难度极大，后端成功与失败的code都不统一，有的后端甚至不写接口报错捕获，所有的传参结果都是成功</li><li>前端未使用公用样式，导致样式管理极度混乱，无法统一修改部分公用样式</li><li>前端技术栈不统一，有人在项目中使用JQuery，加重了调试的心智负担</li><li>前端语义化命名不明显，在样式中多处使用<code>L1，R1，T1，B1</code>这类风格，scss样式嵌套加深之后，阅读极为困难，变量中更是重量级，基本上不用ES6，狂用ES5的写法，几乎不用ES6的新特性来处理数组，导致代码阅读极为困难</li><li>前端代码风格不同，导致不同格式化的代码风格经常冲突</li><li>前端不用VueX存储的公共数据来读取一些数据字典，反而每次都要请求一次接口去读数据，每次页面都要拉取很多接口</li><li>没有公共工具方法库，所有人判空，取整，时间格式化都是按照自己的想法来，八仙过海，各显神通</li></ul><p>综上，这是开发中问题，至于发布测试等方面的问题，这里先按住不表，因为后续更是重量级。</p><p>由于以上的问题，我们开发页面过程极度缓慢，翻新进度简直慢的发指。</p><p>四个简单的增删改查页面，前端后端6人，每天工作12小时以上，而且是时刻有交流条件的情况下，大家根本不交流。</p><p>然后，居然在一周内没有完成两个单表的增删改查。</p><p>而后续一个复杂的多字段表单，更是整整耗时一周，才勉强调通，且不能保证全流程完全走通。</p><p>是的，这就是我们的开发进度，6个人，做成这样，肉眼可见的丢人，但这就是那时的开发进度。</p><p>我们放弃了规矩，但是我们并未追求到进度。</p><p>在复数人员的开发情况下，一个混沌的开发体系，进度便是如此的可笑。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>幸亏管理也算是技术出身，且技术功底扎实，简单的商量之后，我们制定了以下的简单方案</p><ul><li>后端接口由管理负责，定好统一格式，后端全员按照接口格式开发</li><li>在正式确认业务之前，前后端都要过一遍业务，彼此确认业务的大致流程，同时后端在没有给定正式业务之前，要先给出确定字段的接口，便于双方确认（那时候我们还不会Mock数据）</li><li>制定统一风格，由管理人员确定一套风格，然后开发出最初的模板，之后尽可能使用<code>element-ui</code>框架来实现功能，避免前端使用自己手写的样式覆盖，如果一定要调整全局样式，那么需要报备，除非必须要求改动，否则就放弃修改</li><li>技术栈统一，放弃JQuery，全面拥抱Vue2的写法，每晚定期进行代码审查（草草检查，主要确认没有jquery）</li><li>公共接口抽离，将一些公用方法抽离出来，如上传，部分复杂的业务数据字典，</li><li>公共方法本地化封装，将一些判空之类的方法写在工具类中，省去每人手写工具方法的时间</li><li>命名语义化，尽可能减少无意义的变量命名</li><li>代码格式化插件统一，开发工具统一，保证所有人调试起来方便（笔者并不太会用webstorm的格式化，当时也没时间去研究，只能禁了那位组员的webstorm，让他用vscode）</li></ul><p>经过这些小手段，效果立竿见影。</p><p>开发进度确实有了些许提升，但是页面功能的稳定性显而易见的上升，同时每人的工作量大幅下降，勉强可以8点下班，至少不用彻夜彻夜的加班了（在这之前巅峰时间甚至能达到每天14小时以上的工作强度）。</p><p>可能大家会觉得，这并未提升多少，但是于那时的我们来说，在这之前，团队几乎是肉眼可见要崩塌，所有人都不觉得这样的团队能做成这个项目。</p><p>但是这些简单的规定做下来之后，虽然强度还在，但是工作目标至少可以量化了，同时任务终于可以拆解了，不再是将所有人都堆在任务中。</p><p>而团队工程化的路，就是从那时候开始的。</p><h3 id="运维发布"><a href="#运维发布" class="headerlink" title="运维发布"></a>运维发布</h3><p>因为团队一开始并不大，所以很多时候都是开发运维一把抓，然后在这个过程中，又诞生了一堆混乱至极的问题。</p><h4 id="情景复盘-1"><a href="#情景复盘-1" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>那时，我们用的仍然是SVN进行版本管理，相对于git的分布式版本管理，SVN的集中管理有个弱势点，那就是版本管控必须要将代码文件提交到中心服务器。</p><p>而这就有个隐患，如果有人没有将自己的逻辑走完，那么为了版本管控，他也只能将代码提交到SVN，而客户几乎每天都会过来看一下进度。</p><p>如果有经验的人，想必此时已经发现哪里有隐患了。</p><p>因为有人会将未完成的功能提交到线上，那么发布到线上的时候，碰到演示这种未完成的功能时候，免不了会被客户一顿痛批。</p><p>部分公司为了解决这种问题，会选择再买个服务器，做一个测试版本，但我们当时是内网开发，客户表示只有这一个服务器，然后结果就很尴尬了。</p><p>这个过程，开发流程管理也很混乱，客户会经常在我们开发过程中插入一些新的要求，导致我们项目需求翻新的进度极度拖延。</p><h4 id="整理问题-1"><a href="#整理问题-1" class="headerlink" title="整理问题"></a>整理问题</h4><p>在我们刚解决了开发上的规范问题之后，我们就遇到了这种运维及需求沟通的问题上的问题。</p><h5 id="需求混乱"><a href="#需求混乱" class="headerlink" title="需求混乱"></a>需求混乱</h5><ul><li>翻新需求不明确，做无用功，很多旧版本的功能，在旧版时候明确不用了，但是项目Leader没有细细筛过需要翻新的功能，导致经常做了无用功</li><li>客户需求不评审，因为客户可以直接到现场催稿，导致经常会插入一些客户优先的功能，延误了正常工期排序</li><li>对业务不熟悉，导致返工。这个是最常见的事情，很多时候，我们评审业务，项目Leader没有说明白业务，进而导致开发者对业务的理解南辕北辙，不停翻新做无用功。</li></ul><p>针对这些问题，我们项目Leader只能将自己从开发序列中抽离，自己去整理业务对接客户。</p><p>因为他最懂这块的业务，所以只有他自己可以去，他将需求承接完成后，顶住客户的需求压力，按照排期给我们捋顺业务和开发进度。</p><p>之后，由他来作为团队大核，指导对业务不熟悉的我们，由我们负责具体的开发内容。</p><p>这之后的效果，也算是立竿见影，虽然项目Leader不用实际开发了，但我们的进度却并未落下，甚至质量再次提升，做无用功的情况越来越少，随着大家对业务的逐渐熟悉，所有人甚至可以对业务中不合理的地方及时预警。</p><h5 id="混乱发布"><a href="#混乱发布" class="headerlink" title="混乱发布"></a>混乱发布</h5><p>这是在需求没有整理之前的情况，我们的发布突出一个随心所欲，几乎所有小团队中能犯的错，我们这里都犯过。</p><ul><li>版本不指定，我们没有既定的版本，只是按照大致的感觉和客户的催命程度来发布，这时候我们和上版本相比有了什么进步只有项目Leader知道</li><li>功能不自测，因为经常翻新，为了追求演示效果，我们经常赶时间发布，这导致演示的时候经常翻车</li><li>人员不指定，所有人都可以发布，然后我们经常在发布的时候撞车（趁没有测出BUG悄悄发布，小团队这种事想必很多）</li><li>项目现场不指定，当时翻新的这个项目部分源码涉及到另一个项目现场，手动发布必然会有失误，经常忘记改配置，导致项目现场读取的内容错乱</li><li>日期不指定，因为没有固定的发布时间，所以客户经常回来催我们（后来由项目Leader去抗这个压力了）</li></ul><p>综上，我们提出了一系列的解决方案。</p><ul><li>定好版本发布规则，确认需求后，固化发布日期。除非客户强烈要求，否则不会加入新功能排期，按照周为单位进行迭代。</li><li>指定专门的运维人员，其他人不能碰发布服务器</li><li>前端开发打包版本插件，让代码可以根据时间自动生成版本，并抽离配置，减少手动发包导致项目现场错配的问题</li><li>安排运维人员书写运维文档，保证客户和开发人员都能明白我们要改什么，接下来要做什么</li></ul><h3 id="提速方向"><a href="#提速方向" class="headerlink" title="提速方向"></a>提速方向</h3><p>讲到这里，时间基本上挺接近现在了，我这里没有接触过更高标准的团队，但是就我打听的情况来看，大厂似乎也将工程化的流程走到顶点了。</p><p>我在面试过程中，发现很多团队实际上基本就是前者的形态了，很少有进入到这一步的，以下提到的这些需求，几乎是只有大型团队才会出现的需求。</p><p>这一步几乎是工程化的高标准状态了，大多数草创的开发团队，甚至是一些较为成熟的团队，他们几乎没有到这一步的意识和需求。</p><p>到了这一步，公司业务几乎固定，因为业务线的固定，也逐渐衍生出产品化的概念，自然也就有了产品迭代的需求。</p><p>于是，工程提速的玩法再次发生了改变。</p><ul><li>自动化发布</li><li>代码管控，自动生成发布日志</li><li>组件库</li><li>工具包</li><li>脚手架</li><li>前后端约定统一，技术栈固化</li></ul><p>集成以上方式之后，便有了终极形态，低代码。</p><p>在那时，我们几乎可以将一个两月交付的项目在一周内迭代出原型，供客户参考，然后在那基础上修改。</p><p>同时极大程度节约人力，不过受限于篇幅，这里就不展开说了，后续会随着自己的要求，逐步解释我们项目中为什么进行这些操作。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>开发规则的诞生，是一个几乎必然的过程，人人都在骂这种制度化，但是一旦走向了大型团队化，我们又不可避免的制度化。</p><p>有些时候，人真是有趣，讨厌一件事，理解一件事，融入一件事，成为这件事。</p><p>制度化，团队化，似乎是人类群体的必然性，这种过程似乎是大型团队的必然答案，也是一种趋同进化的趋势。</p><p>当然，扯远了，我们仅仅说的是工程，一个工程想要做的正常，并非一定要上大型工程的规则。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7390319475525107764">工程提速，规则的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了让工程提速，我们制造了规则。&lt;/p&gt;
&lt;p&gt;为了让工程提速，我们漠视了规则。&lt;/p&gt;
&lt;p&gt;本文给新踏上开发之路的朋友，1~3年左右开发经验的朋友可以看看，虽然这不是实打实的开发技能，但这却是我这数年开发的实际心得，您看完了，或许会有所收获，也可能会莞尔一笑，不过无论如何，肯定都不算是耽误您人生中的些许时光。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解JS中的常用遍历</title>
    <link href="https://crazystudent13.github.io/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/"/>
    <id>https://crazystudent13.github.io/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/</id>
    <published>2024-07-09T04:48:10.000Z</published>
    <updated>2024-09-08T15:57:30.329Z</updated>
    
    <content type="html"><![CDATA[<p>最近写代码频繁写map，以至于想写for…of的时候，都忘记这块的讲究了，索性整理下，以备面试。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>常规开发中我们可能已经习惯性的使用map了，但我们肯定不能只会map。</p><p>这里我们索性通盘整理下，把前端开发中遍历的熟面孔遍历一遍。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code>循环是一种常用的遍历方法，特别适用于已知遍历次数的情况。</p><p>它由三个部分组成：初始化表达式、循环条件和循环迭代器。</p><p>这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++ )&#123; <span class="comment">//(初始化表达式; 循环条件; 循环迭代器)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环非常灵活，你可以根据需要自定义循环变量的初始值、循环条件和迭代方式。它适用于各种遍历需求，包括遍历数组、对象的属性等。</p><ol><li>通过<strong>continue</strong>中断当次循环</li><li>通过<strong>break</strong>中断整个循环</li><li>通过<strong>retrun</strong>中断函数执行</li></ol><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法用于对数组的每个元素执行指定的操作，并返回一个新的数组，新数组的元素是原数组经过操作后的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> modifiedElement;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>map</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行操作，并返回经过操作后的新值<code>modifiedElement</code>。</p><p><code>map</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的结果组成一个新的数组。</p><p>下面是一个使用<code>map</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>map</code>方法对数组<code>array</code>的每个元素进行操作，将每个元素乘以2，并将操作后的结果组成一个新的数组<code>newArray</code>。</p><p><code>map</code>方法是一种非常有用的方法，它可以方便地对数组的每个元素进行操作，并生成一个新的数组。</p><p> 需要注意的是</p><ul><li><code>map</code>方法不会修改原始数组，而是返回一个新的数组</li><li><code>map</code>方法无法遍历对象，仅适用于数组的遍历</li><li><code>map</code>方法不会对空数组进行检测</li><li><code>map</code>循环只能通过return中断当次循环</li></ul><h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for..in 和 for..of 的区别"></a>for..in 和 for..of 的区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h4><p>for…in是为遍历对象属性而构建的，它以任意顺序遍历一个对象的除Symbol以外的可枚举属性，可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 name age</span></span><br></pre></td></tr></table></figure><p>在JavaScript中，数组也是对象的一种，所以数组也是可以使用for…in遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2</span></span><br></pre></td></tr></table></figure><h4 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h4><p>for…of语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句（包括Array，Map，Set，String，TypedArray，arguments等等，不包括Object），可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 obj is not iterable (obj不是可迭代的)</span></span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>无论是for…in还是for…of都是迭代一些东西。它们之间的主要区别在于它们的迭代方式</p><ul><li>for…in语句以任意顺序迭代对象的可枚举属性</li><li>for…of语句遍历可迭代对象定义要迭代的数据</li></ul><p>总之，for…in 循环主要是为了遍历对象而生，不适用于遍历数组</p><p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ufo</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2 ufo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br></pre></td></tr></table></figure><h3 id="使用for…-of遍历对象的方法"><a href="#使用for…-of遍历对象的方法" class="headerlink" title="使用for….of遍历对象的方法"></a>使用for….of遍历对象的方法</h3><h4 id="遍历类数组对象"><a href="#遍历类数组对象" class="headerlink" title="遍历类数组对象"></a>遍历类数组对象</h4><p>使用Array.from()方法将对象转换为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历普通对象"><a href="#遍历普通对象" class="headerlink" title="遍历普通对象"></a>遍历普通对象</h4><ul><li>给对象添加一个[symbol.iterator]属性，并指向一个迭代器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(count&lt;keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  onsole.<span class="title function_">log</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二（使用Generator函数生成迭代器）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*()&#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-和-forEach区别"><a href="#for-和-forEach区别" class="headerlink" title="for 和 forEach区别"></a>for 和 forEach区别</h3><ul><li>for循环可以使用break跳出循环，但forEach不能。</li><li>for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。</li><li>for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。</li></ul><h3 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h3><p><code>reduce</code>方法用于对数组的每个元素进行累积操作，并返回一个最终的累积结果。</p><p>以下是<code>reduce</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element, index, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulatedValue;</span><br><span class="line">&#125;, initialValue);</span><br></pre></td></tr></table></figure><p>在<code>reduce</code>方法中，我们传入一个回调函数作为参数。该回调函数接受四个参数：累积值<code>accumulator</code>、当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行累积操作，并将累积结果返回。<code>reduce</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的累积结果作为下一次迭代的累积值。</p><p>下面是一个使用<code>reduce</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element</span>) &#123; <span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line">    <span class="keyword">return</span> accumulator + element;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>reduce</code>方法对数组<code>array</code>的每个元素进行累积操作，将所有元素相加得到最终的累积结果。</p><p>需要注意的是:</p><ul><li><code>reduce</code>方法不会改变原数组。</li><li><code>reduce</code>方法可以接受一个可选的初始值<code>initialValue</code>作为第二个参数。如果提供了初始值，累积值<code>accumulator</code>的初始值将为该值；如果未提供初始值，则累积值将为数组的第一个元素，且从数组的第二个元素开始进行累积操作。</li><li>如果数组为空，且未提供初始值，则<code>reduce</code>方法会抛出一个<code>TypeError</code>。在处理可能为空的数组时，要确保提供了合适的初始值或进行适当的错误处理。</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于筛选数组中满足指定条件的元素，并返回一个新的数组。</p><p>以下是<code>filter</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element, index, array</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>filter</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否保留该元素。如果回调函数返回<code>true</code>，则该元素将被保留在新的数组中；如果返回<code>false</code>，则该元素将被过滤掉。</p><p>下面是一个使用<code>filter</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>filter</code>方法筛选数组<code>array</code>中的偶数元素，并将满足条件的元素组成一个新的数组<code>newArray</code>。</p><p><code>filter</code>方法非常灵活，可以根据不同的条件筛选数组中的元素。回调函数应该返回一个布尔值，表示是否保留该元素。返回<code>true</code>表示保留，返回<code>false</code>表示过滤掉。</p><p>需要注意的是：</p><ul><li><code>filter</code>方法会返回一个新的数组，该数组包含满足指定条件的元素。请确保在回调函数中返回一个布尔值，表示是否保留该元素。</li><li><code>filter</code>方法不会对空数组进行检测。</li></ul><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p><code>some</code>方法用于检测数组中是否至少有一个元素满足指定条件。</p><p>以下是<code>some</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>some</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。如果回调函数返回<code>true</code>，则表示至少有一个元素满足条件；如果所有元素都不满足条件，回调函数返回<code>false</code>。</p><p>下面是一个使用<code>some</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>some</code>方法检测数组<code>array</code>中是否存在大于3的元素。</p><p>由于数组中存在元素4和5满足条件，所以<code>some</code>方法返回<code>true</code>。</p><p><code>some</code>方法可以用于检测数组中是否满足某个条件的元素。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>some</code>方法在找到满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>some</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p><code>every</code>方法用于检测数组中的所有元素是否都满足指定条件。</p><p>以下是<code>every</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>every</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。</p><p>如果回调函数对数组中的所有元素都返回<code>true</code>，则<code>every</code>方法返回<code>true</code>；如果有任何一个元素返回<code>false</code>，则<code>every</code>方法返回<code>false</code>。</p><p>下面是一个使用<code>every</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>every</code>方法检测数组<code>array</code>中的所有元素是否都大于0。由于数组中的所有元素都大于0，所以<code>every</code>方法返回<code>true</code>。</p><p><code>every</code>方法可以用于检测数组中的所有元素是否满足某个条件。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>every</code>方法在找到不满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>every</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端遍历循环，最熟悉的陌生人。</p><p>平时开发的过程中，很多新人肯定会直接map或者for循环一把梭，这样固然简单有效，但是不够语义化，所以才有了这些api。</p><p>我们要尽可能的多用这些原生的API，减少日常开发中不够语义化的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://conistudy.club/interview/javascript.html#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB">JavaScript | Conistudy</a></p><p><a href="https://juejin.cn/post/7361809254044647465?searchId=20240710123929C9622D5B87737C588848">详解JavaScript遍历：掌握for、forEach、for in、for of和map等方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近写代码频繁写map，以至于想写for…of的时候，都忘记这块的讲究了，索性整理下，以备面试。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，低代码的意义</title>
    <link href="https://crazystudent13.github.io/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://crazystudent13.github.io/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2024-07-07T11:29:59.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>低代码在22~23年左右的时候，这个概念是最火的，同时期，若依开源项目也在这期间加入了低代码的功能。</p><p>之后，在23年低代码的风潮达到了鼎盛，但是之后就陷入了 各种声音的质疑中，最后陷入的沉寂。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>低代码的没落并非是低代码本身的没落，而是需求本身的没落。</p><h3 id="低代码平替"><a href="#低代码平替" class="headerlink" title="低代码平替"></a>低代码平替</h3><p>低代码并非万能银弹，在开发者的世界里，是不可能存在万能的银弹的。</p><blockquote><p>银弹，即<a href="https://baike.baidu.com/item/%E7%BA%AF%E9%93%B6/0?fromModule=lemma_inlink">纯银</a>质或<a href="https://baike.baidu.com/item/%E9%95%80%E9%93%B6/9937426?fromModule=lemma_inlink">镀银</a>质的子弹。在古老的欧洲民间传说、鬼怪题材的小说和电影，尤其是19世纪以来<a href="https://baike.baidu.com/item/%E5%93%A5%E7%89%B9%E5%B0%8F%E8%AF%B4/0?fromModule=lemma_inlink">哥特小说</a>风潮影响下，银色子弹往往被描绘成是<a href="https://baike.baidu.com/item/%E7%8B%BC%E4%BA%BA/24621?fromModule=lemma_inlink">狼人</a>和<a href="https://baike.baidu.com/item/%E5%90%B8%E8%A1%80%E9%AC%BC/64596?fromModule=lemma_inlink">吸血鬼</a>、<a href="https://baike.baidu.com/item/%E5%A5%B3%E5%B7%AB/2007?fromModule=lemma_inlink">女巫</a>以及其他怪物的克星，一发即可致命，并具有驱魔的效力。</p><p>后来在开发中，有人比喻为万能解法，因为很多西部片和小说中的不死邪魔经常都被一发银弹解决，这种不讲道理的方式，就被戏称为银弹，在戏剧中也有类似的玩法，叫做机械降神，不过这个就不细展开说了。</p><p>无论是银弹还是机械降神，都是比喻一种万能解法，而在开发者的世界中，这种万能的银弹是不存在的。</p></blockquote><p>低代码的诞生和火爆，离不开早些年互联网的火爆，各种<code>ToB（面向公司老板）</code>，<code>ToC（面向客户）</code>，<code>ToG（面向政府）</code>等业务的不断上扬和增加，这时候，不可避免的出现了N多的管理系统。</p><p>一旦管理系统落成，那么不可避免的，就要对表的增删改查。</p><p>这时候，很多开发者不可避免的要一遍又一遍的陷入前端写表单列表，后端写<code>curd</code>的接口，在这种重复业务中不断耽误时间，加班赶进度，却十分枯燥的情况。</p><p>针对这种情况，于是才有了低代码。</p><p>但是低代码，却绝非是现代才有的概念，而是很早之前就有的概念，早在现代低代码概念爆火之前，就有类似的说法。</p><p>说穿了，低代码就是配置化系统的变种，但是生成出来的代码又需要一定开发技术去按照需求修改，相对于传统的工具系统，这种低代码平台肯定更好用。</p><p>譬如ERP，CMS及等工具系统，对已经固定的业务线，仅仅需要配置就可以配置好一个系统，供用户使用，这应该就是最早的低代码系统。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>低代码并非是小型公司可以玩转的东西，这东西的诞生是为了解决特定的场景内的需求。</p><p>个人曾在公司有幸接触过相关业务，所以这里分享一下低代码的具体的应用场景及基础要求。</p><h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><p>注意，需要满足以下绝大多数条件的，可以考虑在公司产品中加入低代码的功能，否则开发用来造轮子的工作时间会远大于使用低代码这个轮子的节约的时间。</p><ul><li>重复的业务场景，需要消耗大量人力时间去写重复的增删改查工作量</li><li>业务线路稳定，不会频繁变动，多数业务逻辑可以拆分成简单的增删改查实现</li><li>表单关系简单，相互之间交互关系不大</li><li>UI风格稳定，需求方对UI不做大规模的变动要求，并且基于这个稳定的UI库，形成一套属于公司自己的风格</li><li>稳定的组件库，能够极大程度减少代码生成文件的代码量，便于改动</li><li>如果有双端适配的要求，那移动端也要有稳定的组件库和设计风格，同时业务量不要统一</li><li>前端基建相对稳定，脚手架，工具包，组件库都统一，并基建代码和业务代码能够并行推进，相互干扰程度小</li><li>稳定的权限管理功能，从路由到按钮级别的管理，不是一个混沌的权限管理系统（在很多中小厂中至今没有一个像样的权限管理系统）</li><li>前端负责人需要对公司业务有较为深层的了解，能够把控和预测公司接下来的发展方向，不会完全受制于设计或者后端，不至于一点话语权也没有。</li></ul><p>综上，我们会发现，这并非是个小公司使用的工具。</p><p>低代码的诞生，是一个团队的工作成果。</p><blockquote><p>稳定的UI，业务线，产品化的前后端框架，成熟的运维人员，几乎缺一不可。</p></blockquote><p>低代码热门的场景，大概是中型公司或者大厂业务部门中常用的工具，通过这东西，应该可以快速生成一些增删改查的表单，快速完成项目任务。</p><p>而小厂接到的业务，多数个性化要求较高，甚至是外包业务，根本就不在乎你用什么技术，混乱的项目管理根本不适合低代码的的使用。</p><h3 id="低代码优劣"><a href="#低代码优劣" class="headerlink" title="低代码优劣"></a>低代码优劣</h3><p>开发者固然要追求更新潮，更有趣的技术，这是一个开发者固有的技术素养。</p><p>但工程不能，工程是一个公司，一个团队的心血，工程要以稳定为主，你可以小步迭代，决不能贸然使用不稳定的技术。</p><p>毕竟，所有的技术诞生，都是为了解决某种特殊的需求，不要为了技术追星，去强上看上去很酷炫的技术。</p><p>这里我列举一下低代码的优劣，各位可以根据自己的需求权衡，是否在公司内使用</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>大量节省人力，原本一个项目至少需要一个熟手前端，后端同时协同开发数月才能完成一个项目，而使用低代码之后，简单的项目完全可以由一个运维人员通过简单的配置，生成一个系统，个性化的页面申请给开发部调整，将数月级别的项目缩减到两周。</li><li>可以快速迭代项目，很多时候需求方不清楚自己需要什么，而我们通过对表单的和列表的配置，很容易就能让客户明白自己的缺陷和需求，这样便于快速迭代，但是注意，不要被客户套进去。</li><li>使用简单，基本上一个运维人员通过培训，只要稍微有点项目经验和些许的开发经验，就可以覆盖一个项目现场，一旦完成交付后，还可以快速迭代到下一个项目现场。</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>技术固化。随着项目的不断推进，低代码系统涉及到的组件库必须得稳定维护，组件库会随着项目的增多而不断臃肿，随着时间的增加，低代码的尽头必然是需要前端组长花很大的力量去维护和平衡各个项目现场的需求。</li><li>项目臃肿。很多人在使用低代码的时候，简单生成了代码，后续这里不用之后，就隐藏废弃，代码也不会删除，时间长了之后，这种废弃代码就堆在业务系统中，久而久之，这项目就会很臃肿。</li><li>依赖管理困难。各个前端项目没有版本锁，当时Pnpm也没有流行开来，现在相对来说应该好的多，但是随着时间的推移，这种组件库的适配早晚也会在依赖管理上出问题的。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多大厂的为了做业绩，在那两年几乎把这玩意吹成了万能银弹，这是不对的。</p><p>在它的固有领域内，低代码能极大节省人力，减少开发者的业务工作量，让开发者更专注于自身的开发优势，不过这也让开发者更远离业务，难以进入业务管理层了。</p><p>总之，有利又有弊，是否使用低代码，需要根据自身情况做决定。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7389077092136452148">工程提速，低代码的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;低代码在22~23年左右的时候，这个概念是最火的，同时期，若依开源项目也在这期间加入了低代码的功能。&lt;/p&gt;
&lt;p&gt;之后，在23年低代码的风潮达到了鼎盛，但是之后就陷入了 各种声音的质疑中，最后陷入的沉寂。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅析const声明的ref，reactive变量为什么可以修改</title>
    <link href="https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/"/>
    <id>https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/</id>
    <published>2024-07-06T04:33:39.000Z</published>
    <updated>2024-09-08T15:57:30.337Z</updated>
    
    <content type="html"><![CDATA[<p>事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。</p><p>当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>const</code>关键字用于声明一个变量，该变量的值在其生命周期中不会被重新赋值。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>我们都知道const声明的常量不可改变，但是为什么Vue3中的ref和reactive声明的变量就可以修改？</p><p>这里我们先看几个例子，我们会发现，不止是ref和reactive，const声明的引用类数据，都是会被改变的。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>对于基本数据类型（如数字、字符串、布尔值），<code>const</code>确保变量的值不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// num = 43;  // 这会抛出错误</span></span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于对象，仍然可以修改对象的属性，但不能重新赋值整个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girlfriend = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小宝贝&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">girlfriend.<span class="property">name</span> = <span class="string">&quot;亲爱的&quot;</span>;  <span class="comment">// 这是允许的，因为你只是修改了对象的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// girlfriend = &#123; name: &quot;亲爱的&quot; &#125;;  // 这会抛出错误，因为你试图改变obj的引用</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>对于数组，你可以修改、添加或删除元素，但不能重新赋值整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>;  <span class="comment">// 这是允许的，因为你只是修改了数组的一个元素</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">5</span>);  <span class="comment">// 这也是允许的，因为你只是向数组添加了一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [6, 7, 8];  // 这会抛出一个错误，因为你试图改变arr的引用</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在JavaScript中，<code>const</code>并不是让变量的值变得不可变，而是让变量指向的<strong>内存地址</strong>不可变。</p><p>换句话说，使用<code>const</code>声明的变量不能被重新赋值，但是其所指向的内存中的数据是可以被修改的。</p><p>使用<code>const</code>后，实际上是确保该变量的引用地址不变，而不是其内容。</p><p>其实，这就是一次浅拷贝，只要地址指向的位置不发生改变，你做什么操作都可以，关于深浅拷贝不清楚的，可以参考一下我的：<a href="https://crazystudent13.cn/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">10分钟了解深浅拷贝</a>。</p><p>基础数据类型定死了内存地址，所以当你重新赋值的时候，自然就会报错。</p><p>而引用数据类型虽然也定死了内存地址，但是其中内容未完全定死，所以可以操作和修改，这就是为什么引用类的数据类型使用const修改不会报错，但是重新赋值就会报错的原因了。</p><p>当const<code>声明一个变量并赋值为一个对象或数组，这个变量实际上存储的是这个对象或数组在内存中的地址，形如</code>0x00ABCDEF&#96;（这只是一个示例地址，实际地址会有所不同），而不是它的内容。这就是为什么我们说变量“引用”了这个对象或数组。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>这种看似矛盾的特性实际上在开发中经常用到。</p><p>例如，在开发过程中，可能希望保持一个对象的引用不变，同时允许修改对象的属性。这可以通过使用<code>const</code>来实现。</p><p>考虑以下示例：</p><p>假设你正在开发一个应用，该应用允许用户自定义一些配置设置。当用户首次登录时，你可能会为他们提供一组默认的配置。但随着时间的推移，用户可能会更改某些配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">const</span> userSettings = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&quot;light&quot;</span>,  <span class="comment">// 主题颜色</span></span><br><span class="line">    <span class="attr">notifications</span>: <span class="literal">true</span>,  <span class="comment">// 是否开启通知</span></span><br><span class="line">    <span class="attr">language</span>: <span class="string">&quot;en&quot;</span>  <span class="comment">// 默认语言</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时间点，用户决定更改主题颜色和语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateUserSettings</span>(<span class="params">newTheme, newLanguage</span>) &#123;</span><br><span class="line">    userSettings.<span class="property">theme</span> = newTheme;</span><br><span class="line">    userSettings.<span class="property">language</span> = newLanguage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用函数，将主题更改为&quot;dark&quot;，语言更改为&quot;zh&quot;</span></span><br><span class="line"><span class="title function_">updateUserSettings</span>(<span class="string">&quot;dark&quot;</span>, <span class="string">&quot;zh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userSettings);  <span class="comment">// 输出：&#123; theme: &quot;dark&quot;, notifications: true, language: &quot;zh&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个<code>userSettings</code>对象，它包含了用户的默认配置。</p><p>尽管我们使用<code>const</code>来声明这个对象，但我们仍然可以随后更改其属性来反映用户的新配置。</p><p>这种模式在实际开发中很有用，因为它允许我们确保<code>userSettings</code>始终指向同一个对象（即我们不会意外地将其指向另一个对象），同时还能够灵活地更新该对象的内容以反映用户的选择。</p><h4 id="为什么不用let"><a href="#为什么不用let" class="headerlink" title="为什么不用let"></a>为什么不用let</h4><p>以上所以案例中，使用let都是可行，但它的语义和用途相对不同，主要从这几个方面进行考虑：</p><ol><li><strong>不变性</strong>：使用<code>const</code>声明的变量意味着你不打算重新为该变量赋值。这为其他开发人员提供了一个明确的信号，即该变量的引用不会改变。在上述例子中，我们不打算将<code>userSettings</code>重新赋值为另一个对象，我们只是修改其属性。因此，使用<code>const</code>可以更好地传达这一意图。</li><li><strong>错误预防</strong>：使用<code>const</code>可以防止意外地重新赋值给变量。如果你试图为<code>const</code>变量重新赋值，JavaScript会抛出错误。这可以帮助捕获潜在的错误，特别是在大型项目或团队合作中。</li><li><strong>代码清晰度</strong>：对于那些只读取和修改对象属性而不重新赋值的场景，使用<code>const</code>可以提高代码的清晰度，可以提醒看到这段代码的人：“这个变量的引用是不变的，但其内容可能会变。”</li></ol><p>一般我们默认使用<code>const</code>，除非确定需要重新赋值，这时再考虑使用<code>let</code>。这种方法旨在鼓励不变性，并使代码更加可预测和易于维护。</p><p>由此，我们应该也明白，ref和reactive使用const声明，而非使用let了。</p><h4 id="避免修改"><a href="#避免修改" class="headerlink" title="避免修改"></a>避免修改</h4><p>如果我们想要避免修改<code>const</code>声明的变量，当然也是可以的。</p><p>例如，我们可以使用浅拷贝来创建一个具有相同内容的新对象或数组，从而避免直接修改原始对象或数组。这可以通过以下方式实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">originalArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">const <span class="attr">newArray</span> = [...originalArray]<span class="comment">; // 创建一个原始数组的浅拷贝</span></span><br><span class="line">newArray.push(4)<span class="comment">; // 不会影响原始数组</span></span><br><span class="line">console.log(originalArray)<span class="comment">; // 输出: [1, 2, 3]</span></span><br><span class="line">console.log(newArray)<span class="comment">; // 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>const</code>声明的变量之所以看似可以被修改，是因为<code>const</code>限制的是变量指向的内存地址的改变，而不是内存中数据的改变。</p><p>这种特性在实际开发中有其应用场景，允许我们保持引用不变，同时修改数据内容。</p><p>然而，如果我们确实需要避免修改数据内容，可以采取适当的措施，如浅拷贝。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7268087637239463997">const声明的变量还能修改？原理都在这了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。&lt;/p&gt;
&lt;p&gt;当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解nginx</title>
    <link href="https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/"/>
    <id>https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/</id>
    <published>2024-07-02T12:53:32.000Z</published>
    <updated>2024-09-08T15:57:30.333Z</updated>
    
    <content type="html"><![CDATA[<p>nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。</p><p>等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。</p><p>现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>nginx这东西，好用也不难学，学会了之后，对于前端来说，就可以自己操控服务器进行独立应用部署了。</p><p>学一学也好，简单又强大的东西，也是其成为新时代的开发宠儿的原因。</p><p>以前只是简单的用过，但是从来没有系统性的整理过，这次干脆花些时间简单整理一下。</p><h3 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h3><p><strong>第一部分 全局块</strong></p><p>主要设置一些影响 nginx 服务器整体运行的配置指令。</p><p>比如： worker_processes 1；worker_processes 值越大，可以支持的并发处理量就越多。</p><p><strong>第二部分 events块</strong></p><p>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。</p><p>比如： worker_connections 1024; 支持的最大连接数。</p><p><strong>第三部分 http块</strong></p><p>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p><ul><li><strong>server块</strong>：配置虚拟主机的相关参数。</li><li><strong>location块</strong>：配置请求路由，以及各种页面的处理情况。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attribute">error_log</span> log/<span class="literal">error</span>.log <span class="literal">debug</span>;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attribute">log_format</span> myFormat <span class="string">&#x27;<span class="variable">$remote_addr</span>–<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="variable">$request</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="variable">$http_referer</span> <span class="variable">$http_user_agent</span> <span class="variable">$http_x_forwarded_for</span>&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> mysvr &#123;   </span><br><span class="line">      <span class="attribute">server</span> <span class="number">127.0.0.1:7878</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">120</span>; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">4545</span>;   <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;   <span class="comment">#监听地址       </span></span><br><span class="line">        <span class="section">location</span>  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attribute">proxy_pass</span>  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attribute">deny</span> <span class="number">127.0.0.1</span>;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           <span class="attribute">allow</span> <span class="number">172.18.5.54</span>; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="nginx特性"><a href="#nginx特性" class="headerlink" title="nginx特性"></a>nginx特性</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理，就是代理服务器替客户端去访问目标服务器。</p><p>在用户去访问目标服务器的时，<code>nginx</code>所在的服务器通过正向代理，作为中介服务器，将用户的访问指到目标服务器。</p><p>正向代理，代理的对象是客户端。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理针对的是目标服务器。</p><p>反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。</p><p>客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。</p><p>反向代理，代理的对象是服务器。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>配合反向代理，将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p><p>这适合于一些大型应用，通过反向代理+负载均衡，我们可以将单个服务器的压力分散到多个服务器。</p><p>在这些被代理的服务器集群中，如果某个服务器上的后台应用挂了，那么这些被代理压力可以被转移到其他服务器，而这个过程中，用户不会有感知，这是目前大多数大型企业web应用面对多用户访问的标准解法之一。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来负责解析，加快解析速度，降低原来单个服务器的压力。</p><p>简单的来说，就是静态的页面，代理到专门的静态页面处理</p><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><h5 id="实战一"><a href="#实战一" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器输入 <em><a href="http://www.abc.com/">www.abc.com</a></em> , 从 nginx 服务器跳转到 linux 系统 tomcat 主页面。</p><h6 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#/html目录</span></span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;  <span class="comment">#请求转向</span></span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;      <span class="comment">#设置默认页       </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实战二"><a href="#实战二" class="headerlink" title="实战二"></a>实战二</h5><h6 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h6><p>根据在浏览器输入的路径不同，跳转到不同端口的服务中</p><h6 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9000</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址       </span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example1/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:5000;         </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example2/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;         </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>location</strong> 指令说明：</p><ul><li><strong>~ :</strong> 表���uri包含正则表达式，且区分大小写。</li><li><strong>~* :</strong> 表示uri包含正则表达式，且不区分大小写。</li><li><strong>&#x3D; :</strong> 表示uri不含正则表达式，要求严格匹配。</li></ul><h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="实战一-1"><a href="#实战一-1" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器地址栏输入 <em><a href="https://link.juejin.cn/?target=http://192.168.4.32/example/a.html">http://192.168.4.32/example/a.html</a></em> ，平均到 5000 和 8080 端口中，实现负载均衡效果。</p><h6 id="具体配置-2"><a href="#具体配置-2" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   <span class="comment">#监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#html目录</span></span><br><span class="line">       <span class="attribute">index</span> index.html index.htm;  <span class="comment">#设置默认页</span></span><br><span class="line">       <span class="attribute">proxy_pass</span>  http://myserver;  <span class="comment">#请求转向 myserver 定义的服务器列表      </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx 分配服务器策略</strong></p><ul><li><p><strong>轮询</strong>（默认）</p><p> 按请求的时间顺序依次逐一分配，如果服务器down掉，能自动剔除。</p></li><li><p><strong>权重</strong><br> weight 越高，被分配的客户端越多，默认为 1。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span> weight=<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ip</strong><br> 按请求 ip 的 hash 值分配，每个访客固定访问一个后端服务器。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    ip_hash;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fair</strong></p><p> 按后端服务器的响应时间来分配，响应时间短的优先分配到请求。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    fair;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>nginx是运维人员常用的工具，严格意义上不是前端负责的区域。</p><p>但是随着最近面试难度的不断提升，再加上有时候人手紧缺，需要前端部署应用的时候，也许我们需要掌握这些技能，所以，有备无患，我梳理一下以前不成体系的知识框架。</p><p>不过，nginx这东西么，其实更多的都是想起来再用，个人感觉有点像前端开发中的UI工具库，平时很少有人会记着怎么用，一直都是到了使用的时候现场翻书。</p><p>所以，我后续可能不会对nginx太过深入吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7267003603095879714">写给前端同学的Nginx配置指南</a></p><p><a href="https://juejin.cn/post/6844904041542221832">从原理到实战，彻底搞懂Nginx</a></p><p><a href="https://juejin.cn/post/6844904046789132301">从原理到实战，彻底搞懂Nginx（高级篇）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。&lt;/p&gt;
&lt;p&gt;等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。&lt;/p&gt;
&lt;p&gt;现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://crazystudent13.github.io/tags/nginx/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
