<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远川的个人博客</title>
  
  <subtitle>CrazyStudent13的个人日志</subtitle>
  <link href="https://crazystudent13.github.io/atom.xml" rel="self"/>
  
  <link href="https://crazystudent13.github.io/"/>
  <updated>2024-07-07T05:42:08.920Z</updated>
  <id>https://crazystudent13.github.io/</id>
  
  <author>
    <name>CrazyStudent13</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析const声明的ref，reactive变量为什么可以修改</title>
    <link href="https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/"/>
    <id>https://crazystudent13.github.io/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/</id>
    <published>2024-07-06T04:33:39.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。</p><p>当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>const</code>关键字用于声明一个变量，该变量的值在其生命周期中不会被重新赋值。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>我们都知道const声明的常量不可改变，但是为什么Vue3中的ref和reactive声明的变量就可以修改？</p><p>这里我们先看几个例子，我们会发现，不止是ref和reactive，const声明的引用类数据，都是会被改变的。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>对于基本数据类型（如数字、字符串、布尔值），<code>const</code>确保变量的值不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// num = 43;  // 这会抛出错误</span></span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于对象，仍然可以修改对象的属性，但不能重新赋值整个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girlfriend = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小宝贝&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">girlfriend.<span class="property">name</span> = <span class="string">&quot;亲爱的&quot;</span>;  <span class="comment">// 这是允许的，因为你只是修改了对象的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// girlfriend = &#123; name: &quot;亲爱的&quot; &#125;;  // 这会抛出错误，因为你试图改变obj的引用</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>对于数组，你可以修改、添加或删除元素，但不能重新赋值整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>;  <span class="comment">// 这是允许的，因为你只是修改了数组的一个元素</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">5</span>);  <span class="comment">// 这也是允许的，因为你只是向数组添加了一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [6, 7, 8];  // 这会抛出一个错误，因为你试图改变arr的引用</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在JavaScript中，<code>const</code>并不是让变量的值变得不可变，而是让变量指向的<strong>内存地址</strong>不可变。</p><p>换句话说，使用<code>const</code>声明的变量不能被重新赋值，但是其所指向的内存中的数据是可以被修改的。</p><p>使用<code>const</code>后，实际上是确保该变量的引用地址不变，而不是其内容。</p><p>其实，这就是一次浅拷贝，只要地址指向的位置不发生改变，你做什么操作都可以，关于深浅拷贝不清楚的，可以参考一下我的：<a href="https://crazystudent13.cn/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">10分钟了解深浅拷贝</a>。</p><p>基础数据类型定死了内存地址，所以当你重新赋值的时候，自然就会报错。</p><p>而引用数据类型虽然也定死了内存地址，但是其中内容未完全定死，所以可以操作和修改，这就是为什么引用类的数据类型使用const修改不会报错，但是重新赋值就会报错的原因了。</p><p>当const<code>声明一个变量并赋值为一个对象或数组，这个变量实际上存储的是这个对象或数组在内存中的地址，形如</code>0x00ABCDEF&#96;（这只是一个示例地址，实际地址会有所不同），而不是它的内容。这就是为什么我们说变量“引用”了这个对象或数组。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>这种看似矛盾的特性实际上在开发中经常用到。</p><p>例如，在开发过程中，可能希望保持一个对象的引用不变，同时允许修改对象的属性。这可以通过使用<code>const</code>来实现。</p><p>考虑以下示例：</p><p>假设你正在开发一个应用，该应用允许用户自定义一些配置设置。当用户首次登录时，你可能会为他们提供一组默认的配置。但随着时间的推移，用户可能会更改某些配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">const</span> userSettings = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&quot;light&quot;</span>,  <span class="comment">// 主题颜色</span></span><br><span class="line">    <span class="attr">notifications</span>: <span class="literal">true</span>,  <span class="comment">// 是否开启通知</span></span><br><span class="line">    <span class="attr">language</span>: <span class="string">&quot;en&quot;</span>  <span class="comment">// 默认语言</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时间点，用户决定更改主题颜色和语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateUserSettings</span>(<span class="params">newTheme, newLanguage</span>) &#123;</span><br><span class="line">    userSettings.<span class="property">theme</span> = newTheme;</span><br><span class="line">    userSettings.<span class="property">language</span> = newLanguage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用函数，将主题更改为&quot;dark&quot;，语言更改为&quot;zh&quot;</span></span><br><span class="line"><span class="title function_">updateUserSettings</span>(<span class="string">&quot;dark&quot;</span>, <span class="string">&quot;zh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userSettings);  <span class="comment">// 输出：&#123; theme: &quot;dark&quot;, notifications: true, language: &quot;zh&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个<code>userSettings</code>对象，它包含了用户的默认配置。</p><p>尽管我们使用<code>const</code>来声明这个对象，但我们仍然可以随后更改其属性来反映用户的新配置。</p><p>这种模式在实际开发中很有用，因为它允许我们确保<code>userSettings</code>始终指向同一个对象（即我们不会意外地将其指向另一个对象），同时还能够灵活地更新该对象的内容以反映用户的选择。</p><h4 id="为什么不用let"><a href="#为什么不用let" class="headerlink" title="为什么不用let"></a>为什么不用let</h4><p>以上所以案例中，使用let都是可行，但它的语义和用途相对不同，主要从这几个方面进行考虑：</p><ol><li><strong>不变性</strong>：使用<code>const</code>声明的变量意味着你不打算重新为该变量赋值。这为其他开发人员提供了一个明确的信号，即该变量的引用不会改变。在上述例子中，我们不打算将<code>userSettings</code>重新赋值为另一个对象，我们只是修改其属性。因此，使用<code>const</code>可以更好地传达这一意图。</li><li><strong>错误预防</strong>：使用<code>const</code>可以防止意外地重新赋值给变量。如果你试图为<code>const</code>变量重新赋值，JavaScript会抛出错误。这可以帮助捕获潜在的错误，特别是在大型项目或团队合作中。</li><li><strong>代码清晰度</strong>：对于那些只读取和修改对象属性而不重新赋值的场景，使用<code>const</code>可以提高代码的清晰度，可以提醒看到这段代码的人：“这个变量的引用是不变的，但其内容可能会变。”</li></ol><p>一般我们默认使用<code>const</code>，除非确定需要重新赋值，这时再考虑使用<code>let</code>。这种方法旨在鼓励不变性，并使代码更加可预测和易于维护。</p><p>由此，我们应该也明白，ref和reactive使用const声明，而非使用let了。</p><h4 id="避免修改"><a href="#避免修改" class="headerlink" title="避免修改"></a>避免修改</h4><p>如果我们想要避免修改<code>const</code>声明的变量，当然也是可以的。</p><p>例如，我们可以使用浅拷贝来创建一个具有相同内容的新对象或数组，从而避免直接修改原始对象或数组。这可以通过以下方式实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">originalArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">const <span class="attr">newArray</span> = [...originalArray]<span class="comment">; // 创建一个原始数组的浅拷贝</span></span><br><span class="line">newArray.push(4)<span class="comment">; // 不会影响原始数组</span></span><br><span class="line">console.log(originalArray)<span class="comment">; // 输出: [1, 2, 3]</span></span><br><span class="line">console.log(newArray)<span class="comment">; // 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>const</code>声明的变量之所以看似可以被修改，是因为<code>const</code>限制的是变量指向的内存地址的改变，而不是内存中数据的改变。</p><p>这种特性在实际开发中有其应用场景，允许我们保持引用不变，同时修改数据内容。</p><p>然而，如果我们确实需要避免修改数据内容，可以采取适当的措施，如浅拷贝。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7268087637239463997">const声明的变量还能修改？原理都在这了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。&lt;/p&gt;
&lt;p&gt;当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解nginx</title>
    <link href="https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/"/>
    <id>https://crazystudent13.github.io/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/</id>
    <published>2024-07-02T12:53:32.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。</p><p>等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。</p><p>现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7267003603095879714">写给前端同学的Nginx配置指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。&lt;/p&gt;
&lt;p&gt;等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。&lt;/p&gt;
&lt;p&gt;现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。&lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://crazystudent13.github.io/tags/nginx/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解cookie，sessionStorage，localStorage</title>
    <link href="https://crazystudent13.github.io/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/"/>
    <id>https://crazystudent13.github.io/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/</id>
    <published>2024-07-01T14:32:43.000Z</published>
    <updated>2024-07-07T05:42:08.912Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie、sessionStorage和localStorage这些都是面试中问烂的问题，这里统一整理一下，便于后续</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Cookie、sessionStorage和localStorage都是Web存储机制，用于在用户的浏览器中存储数据。</p><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><ul><li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><h4 id="cookie-重要的属性"><a href="#cookie-重要的属性" class="headerlink" title="cookie 重要的属性"></a>cookie 重要的属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name&#x3D;value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td>**指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘**。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table><h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</strong></li></ul><p><img src="https://s2.loli.net/2024/07/01/cMNzOIbCZAT63LD.png" alt="QQ截图20240701225448"></p><h3 id="什么是localStorage"><a href="#什么是localStorage" class="headerlink" title="什么是localStorage"></a>什么是localStorage</h3><p>localStorage（本地存储） 允许你访问一个Document 的远端(Origin)对象的Storage；</p><p>Storage:Web Storage API的接口，Storage提供了访问特定域名下的会话存储(session storage)或本地存储(local storage) 的功能，例如可以添加、修改或删除本地存储的数据项。</p><p>localStorage 类似于sessionStorage。</p><p>localStorage：没有时间限制的数据存储，</p><p>seesionStorage：针对一个 session的数据存储即当页面会话结束，也就是说当页面被关闭时，数据存储在seesionStorage会被清除。</p><p>tips：无论数据存储在localStorage 还是sessionStorage，它们都特定于页面的协议，对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>localStorage相对于cookie，存储量大，一般的浏览器大概在PC在4M左右，手机端在2M左右</li><li>存储数据是永久的</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h4 id="localStorage与sessionStorage的区别"><a href="#localStorage与sessionStorage的区别" class="headerlink" title="localStorage与sessionStorage的区别"></a>localStorage与sessionStorage的区别</h4><p>localStorage与sessionStorage的唯一区别就是localStorage属于永久性存储。</p><p>sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空</p><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><p>上边提了localStorage与sessionStorage的区别，这里干脆把三者的区别放在一起比较。</p><h4 id="存储位置与大小限制"><a href="#存储位置与大小限制" class="headerlink" title="存储位置与大小限制"></a>存储位置与大小限制</h4><p><code>Cookie</code>，存储在客户端，即用户的浏览器中。由于Cookie是通过HTTP请求头在服务器和浏览器之间传输的，因此它们的大小有限制，通常不超过 4KB。大多数浏览器限制在20个，有的可能50个。</p><p> <code>sessionStorage</code>，也是存储在客户端的，但它是一个临时会话存储对象。sessionStorage没有严格的大小限制，但它仅在当前浏览器窗口或标签页中有效，并且当窗口或标签页关闭时，存储的数据会被自动删除。 </p><p><code>localStorage</code>，同样存储在客户端，并且提供了比Cookie更大的存储空间。一般来说，浏览器对localStorage的支持可以达到 5MB，这使得它可以存储更多的数据。</p><h4 id="数据有效期与持久性"><a href="#数据有效期与持久性" class="headerlink" title="数据有效期与持久性"></a>数据有效期与持久性</h4><p><code>Cookie，</code>可以设置过期时间，从而决定其在浏览器中的有效期。一旦过期，Cookie将被删除。</p><p> <code>sessionStorage</code>，数据在页面会话期间保持有效，当页面会话结束（例如关闭浏览器窗口或标签页）时，数据会被清除。它提供了一种在单个会话中跟踪用户数据的方式。</p><p> <code>localStorage</code>，存储的数据没有过期时间，它们会一直保留在浏览器中，直到被手动删除或清除缓存。</p><h4 id="与服务端的通信"><a href="#与服务端的通信" class="headerlink" title="与服务端的通信"></a>与服务端的通信</h4><p><code>Cookie</code>，会在每次HTTP请求中发送到服务器，因此它们可以用于在客户端和服务器之间传递数据。这种特性使得Cookie成为处理用户身份验证和会话管理的常用机制。</p><p> <code>sessionStorage</code> 和 <code>localStorage</code>，不与服务器的通信。它们主要用于在客户端存储数据，以便在后续的页面请求或用户交互中使用。</p><h4 id="数据共享与独立性"><a href="#数据共享与独立性" class="headerlink" title="数据共享与独立性"></a>数据共享与独立性</h4><p><code>Cookie</code>，对于同一域名下的网站，可以共享Cookie数据。</p><p> <code>sessionStorage</code>，数据在不同的窗口或标签页之间不共享。 </p><p><code>localStorage</code>，在整个浏览器实例中共享数据，无论打开多少个窗口或标签页，都可以访问到相同的localStorage数据。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>Cookie</code>，适用于需要在客户端和服务器之间传递小量数据的场景，如身份验证和会话管理； </p><p><code>sessionStorage</code>，适用于在同一浏览器窗口或标签页中存储临时数据的场景；</p><p> <code>localStorage</code>，则适用于需要在客户端长期存储大量数据的场景。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次仅仅只是简单的按照面试题标准说了一下这三者之间的区别，后续会专门出一篇内容，详细整理cookie与session在项目开发中的实际作用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904034181070861?searchId=202407012223169FB3FBAFB1729A23E3CC">傻傻分不清之 Cookie、Session、Token、JWT</a></p><p><a href="https://juejin.cn/post/7350143110495518770?searchId=202407012223169FB3FBAFB1729A23E3CC">Cookie、sessionStorage和localStorage的区别详解</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cookie、sessionStorage和localStorage这些都是面试中问烂的问题，这里统一整理一下，便于后续&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解前端各种像素，em，rem等概念</title>
    <link href="https://crazystudent13.github.io/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
    <id>https://crazystudent13.github.io/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/</id>
    <published>2024-06-30T13:43:26.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>前端经典的em,rem，还有像素概念的问题，我发现很多说法都不统一，怎么说的都有，搞得我都有点不好抄统一的面试回答了。</p><p>干脆这里结合自己的理解，统一整理下，以便防止面试时候混乱。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于像素问题，几乎提到移动端适配这方面，这些基础概念就是在面试中绕不开的。</p><p>看了很多面试中都提到相关的问题，各种说法混乱无比，索性自己这里一把梭，把所有的概念都整理一下。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>我们实际开发中常说分辨率，但开发中说的内容可能指向的是不一样的内容。</p><h4 id="物理分辨率"><a href="#物理分辨率" class="headerlink" title="物理分辨率"></a>物理分辨率</h4><p>指的是显示屏的最高分辨率，又称标准分辨率。</p><p>屏幕实际存在的像素行数乘以列数的数学表达方式，是显示屏固有的参数，不能调节，其含义是指<strong>显示屏最高可显示的像素数</strong>。</p><p>我们实际使用过程，分辨率是可以改变的，比如我们手动将1920 * 1080的屏幕换成1600 * 900的分辨率，屏幕会按照你调整的要求，重新将屏幕切割为1600 * 900的像素点阵，形成新的分辨率。</p><p>不过，此时屏幕实际的物理分辨率依然还是1920 * 1080，这是屏幕自己固有的设备像素大小，并非我们可以手动调整的。</p><p>我们平时说的时候习惯性的说的分辨率，多数情况下都是指代最高分辨率，没什么人提你当前屏幕的分辨率是多少。</p><h4 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h4><p>正常来说，像素越大肯定是越清楚，但是这前提是要加个限定条件，那就是屏幕实际的大小要一样。</p><p>不然，物理分辨率同样是1920 * 1080的屏幕，一个尺寸是32寸，一个屏幕是100寸，实际显示效果确实一样的话，这怎么可能呢？</p><p>这里，就要引入一个概念：<strong>像素密度，ppi（pixels per inch）</strong>。</p><p>像素密度，表示沿对角线每英寸长度的像素数目（单位是dpi），越大显示的越细腻。</p><p>通过上边的例子，我们应该很快就能明白，像素密度的含义。</p><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p><strong>物理像素</strong>(px:physical pixel)又可以称为<strong>设备像素</strong>(dp:device pixel)</p><p>我们以实际设备屏幕举例，我们说的1920 * 1080的屏幕，实际上就是在说：宽度方向有1920个像素点，长度方向有1080个像素点。</p><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><blockquote><p>设备尺寸 × 像素密度 &#x3D; 物理分辨率（设备像素）</p></blockquote><p>这里举个例子：</p><p>iphone6s 对角线长度为5.5 英寸，像素密度401 dpi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。</p><p>5.5 * 401 &#x3D; 2205.5</p><p>这里说明白了这三者的关系，我们才好说明白接下来CSS的像素概念，即逻辑像素。</p><h3 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h3><p>CSS 的像素单位，其尺寸大小是相对的，也有称其为独立像素的，这里为了避免大家混乱，下边统一称呼CSS的像素为逻辑像素。</p><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p>提到<strong>逻辑像素(logical pixel)<strong>，也可以称为</strong>设备独立像素(dip : device independent pixel）</strong>。</p><p>当然，这两个名词我们大多数开发者可能都会陌生，实际上这里就是我们平常用到的CSS样式的像素单位。</p><h4 id="物理像素与逻辑像素的关系"><a href="#物理像素与逻辑像素的关系" class="headerlink" title="物理像素与逻辑像素的关系"></a>物理像素与逻辑像素的关系</h4><p>很多人这时候估计平时没有遇到过相关概念，所以一时间会有些懵，难道物理像素和逻辑像素有什么不同吗？难道我写了个100 * 100 的box，在小屏幕上就不是100 * 100了？</p><p>答案是：不是的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比武我们这里写了一个100 * 100的box，假设在物理分辨率为100*100的屏幕上，它以100 * 100的方式展示，1个逻辑像素，用1 * 1个物理像素来表示。</p><p>而在 400 * 400 的屏幕上，我们同样让这个BOX达到充满屏幕的效果，那就需要4 * 4个物理像素来表示。</p><p>后者因为用更多的物理像素来展示，所以看起来更清晰，更精细。</p><h4 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h4><p>我上边这个例子说的有个问题，为什么在有点屏幕上要以物理像素：css逻辑像素 &#x3D; 1 ：1 的比例展示，有的要以 4： 1的概念展示呢？</p><p>这里要引入一个概念：<strong>设备像素比（dpr : device pixel ratio）</strong>。不过这个说法也很混乱，我看很多整理的说法，有的说缩放比，也有说缩放因子的。</p><p>实际上，这就是物理像素与逻辑像素的比例概念。</p><p>我们这里为了接下来不混淆概念，统一就叫设备像素比。</p><p>1个css的逻辑像素，用更多的物理像素表示，那当时是比例越高，越清晰喽，如下例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标清屏：dpr = 2 / 2 = 1</span><br><span class="line">高清屏：dpr = 4 / 2 = 2</span><br></pre></td></tr></table></figure><p>因此，设备像素比越高，我们看到的网页也就越清晰，这也是为什么有时候我们看到有些手机实际屏幕很小，但看到页面的效果却很清晰。</p><p>屏幕虽小，但是实际物理分辨率和大屏一样，因此同样的网页，在更高的设备像素比的设备上显然看着更清晰，更细腻。</p><p>我们经常在设计师手中拿到的UI稿件，肯定会看到@1X，@2X，@3X，实际上就是这个就是指设备像素比。</p><blockquote><p>tips：逻辑像素相对于设备像素的放大比例，可通过window.devicePixelRatio获得，pc上可以用个个性化来设置，但二者并不完全等同。</p></blockquote><h4 id="禁用缩放"><a href="#禁用缩放" class="headerlink" title="禁用缩放"></a>禁用缩放</h4><p>提到上边的设备像素比的概念，有人可能会有疑问，按照这么说，岂不是我把页面用手势捏一下，就能改动页面的设备像素比？</p><p>是的，用户在移动端可以随意通过手势缩放网页，为了防止用户随意控制，我们便有了如下的操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">width // 设置 viewport 的宽度，正整数/字符串 device-width</span><br><span class="line">height // 设置 viewport 的高度，正整数/字符串 device-height</span><br><span class="line">initial-scale // 设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数</span><br><span class="line">maximum-scale // 设置最大缩放系数，0.0-10.0之间的正数</span><br><span class="line">minimum-scale // 设置最小缩放系数，0.0-10.0之间的正数</span><br><span class="line">user-scalable // 如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no</span><br></pre></td></tr></table></figure><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>因为不同设备的的dpi不同，有时候PC上看上去非常正常的页面，放在手机端可能就显得不正常。</p><p>为了做各端的适配，于是前端衍生出了一种概念，相对单位。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>上面提到，想让我们的网页在不同分辨率的设备（移动端）上正常显示，最好我们的元素长宽，外边距，内边距等都是动态的。</p><p>上面说到，我们在移动端一般这样设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width;initial-scale=1&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这个时候我们1px的大小就已知，iPhone6上为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1px</span> = <span class="number">1</span>/<span class="number">750</span>（分辨率） * <span class="number">2</span>（设备像素比） = <span class="number">1</span>/ <span class="number">375</span>。</span><br></pre></td></tr></table></figure><p>既然1px的大小固定了，那么我们只能动态改变一个元素设置的px了，比如说在iPhone8上是120px；而在iPhone6上需要是100px。</p><p>这时候我们可以用js去动态计算，根据屏幕大小。</p><p>但是显然很麻烦，需要对每一个元素的长宽，内边距，外边距都需要调整，这显然是一个巨大的工程。</p><p>这时候我们就可以用到em这个单位了，em单位的名称为相对长度单位，是根据它父元素的字体大小来计算的。</p><p>一般默认情况下：16px &#x3D; 1em，这里要插一嘴，有的远古面试官经常会问：为什么1em要等于16px？</p><blockquote><p>因为浏览器默认的字体大小都是16px，所以没有重新设置浏览器默认字体大小的话1em就等于16px。</p><p>在页面里要用到em作为单位的话，默认的<code>1em=16px</code>会使得在计算他们转换的值时非常不方便，比如我要把一个块里面的内容字体大小设置成18px，但我只想用em做为单位，那么情况就会这样，<code>1em=16px，1px=0.0625em</code>，得<code>18px=1.125em（0.0625em*18）</code>。</p><p>这太麻烦，所以为了简化px和em之间的换算，需要在body里定义<code>font-size:62.5%</code>，即将浏览器初始化为即<code>1em=10px</code>，这样的话，上面的<code>font-size:18px</code>就等于<code>font-size:1.8em</code>。</p></blockquote><blockquote><p>计算公式：1&#x2F;父元素font-size值*需要转换的px&#x3D;em值    (PS:父元素font-size的单位没有关系，无论px还是em)</p></blockquote><p>这是早期的适应方式，当所有单位都采用em时，我们只需要改变body的 font-size，那么其他子元素宽度就能动态变化了，显然方便很多。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem是CSS3新增的一个相对长度单位，它的出现是为了解决em的缺点，em可以说是相对于父级元素的字体大小，当父级元素字体大小改变时，又得重新计算。</p><p>rem出现就可以解决这样的问题，rem只相对于根目录，即HTML元素。</p><p>有了rem这个单位，我们只需要通过JS调整根元素html的font-size就能达到所有元素的动态适配了，这里附上一段常用适配代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ================================================</span></span><br><span class="line"><span class="comment">    *   设置根元素font-size</span></span><br><span class="line"><span class="comment">    * 当设备宽度为375(iPhone6)时，根元素font-size=16px; </span></span><br><span class="line"><span class="comment">    × ================================================</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">doc, win</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = win.<span class="property">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="keyword">var</span> resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> refreshRem = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientWidth = win.<span class="property">innerWidth</span></span><br><span class="line">                      || doc.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">                      || doc.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clientWidth)</span><br><span class="line">    <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> fz;</span><br><span class="line">    <span class="keyword">var</span> width = clientWidth;</span><br><span class="line">    fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!doc.<span class="property">addEventListener</span>) <span class="keyword">return</span>;</span><br><span class="line">  win.<span class="title function_">addEventListener</span>(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">refreshRem</span>();</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">document</span>, <span class="variable language_">window</span>);</span><br></pre></td></tr></table></figure><h4 id="vh，vw"><a href="#vh，vw" class="headerlink" title="vh，vw"></a>vh，vw</h4><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。</p><p>vw 始终是针对窗口的宽，同理，<code>vh</code>则为窗口的高度。</p><p>这里的窗口分成两种情况</p><ul><li>在桌面端，指的是浏览器的可视区域</li><li>移动端指的就是布局视口</li></ul><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素，而<code>vw</code>、<code>vh</code>相对的是指代当前窗口。</p><h3 id="适配方案分析"><a href="#适配方案分析" class="headerlink" title="适配方案分析"></a>适配方案分析</h3><p>无论是哪种方案，本质上都是为了解决移动端适配的问题。</p><p>这里本来打算自己整理一下各种方案的优劣，没想到有人已经整理好了，而且非常详尽：<a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a>。</p><p>虽然是数据大屏的方案整理，但是已经够用了。</p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>vw vh</strong></td><td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td><td>1.可以动态计算图表的宽高，字体等，灵活性较高 2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td><td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td></tr><tr><td><strong>scale</strong></td><td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td><td>1.代码量少，适配简单 2.一次处理后不需要在各个图表中再去单独适配</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况  2.当缩放比例过大时候，字体会有一点点模糊，就一点点  3.当缩放比例过大时候，事件热区会偏移。</td></tr><tr><td><strong>rem + vw vh</strong></td><td>1.获得 rem 的基准值 2.动态的计算<code>html根元素的font-size</code> 3.图表中通过 vw vh 动态计算字体、间距、位移等</td><td>1.布局的自适应代码量少，适配简单</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些基础概念，如果不是深入研究移动端适配的人，应该不会去深入了解，毕竟这都算是以前的老古董知识了。</p><p>实际开发中，移动端大多数中小厂商为了节省成本，应该是用Uni-app一把梭，直接用rpx完成移动端单位的适配。</p><p>甚至有些项目为了图省事的，直接用px糊弄了事，很少有人去实际操心适配的问题，毕竟多数都是为了赶工期。</p><p>这里今天整理一下，也算是梳理以前有些混乱的知识体系，把以前脑海中各种混乱的名称做了个整合，心情也算是颇为舒畅。</p><p>不过，关于移动端的适配，我这里只是浅浅聊了一下，后续有时间会逐步整理相关的知识，防止面试官去面试这些乱七八糟的考验广度的面试题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="px/em/rem%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8">px&#x2F;em&#x2F;rem的区别与应用</a></p><p><a href="https://juejin.cn/post/7125603588084072455?searchId=2024063013543065534144521E4587DF9D">【CSS】一文搞懂 em、px、rem、vh、vw 的区别！</a></p><p><a href="https://blog.csdn.net/qq_30811721/article/details/106326253">px&#x2F;em&#x2F;rem的关系与区别_不同分辨率的设备上,1px的大小是不一样的-CSDN博客</a></p><p><a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端经典的em,rem，还有像素概念的问题，我发现很多说法都不统一，怎么说的都有，搞得我都有点不好抄统一的面试回答了。&lt;/p&gt;
&lt;p&gt;干脆这里结合自己的理解，统一整理下，以便防止面试时候混乱。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="css" scheme="https://crazystudent13.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，工具文档托管</title>
    <link href="https://crazystudent13.github.io/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/"/>
    <id>https://crazystudent13.github.io/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/</id>
    <published>2024-06-28T11:43:58.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，我们经常会整理一下业务文档或者工具文档供团队参考使用，这就是简单的前端基建工程。</p><p>以前是由公司运维来处理这活，现在脱离团队了，只能自己来了，正好这块不熟悉，统一整理一下吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次记录算是一个面向新手的简化版教程，这里默认大家都有一台服务器，一个简单的前端页面，都会用各自的SSH工具。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>为了保证大家都能顺利走完流程，这里先列一下需要用到的东西。</p><h4 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h4><ol><li>优先双核的服务器，虽然单核凑活也能用，但是如果同时访问人数一旦较多，单核的效率很容易产生卡顿，所以还是双核比较好</li><li>优先香港或者亚洲区服务器，不然域名绑定的时候，大陆服务器需要服务器备案，来回走流程会很麻烦</li><li>优先选择linux服务器，因为便宜，环境干净，而且相关的教程很多。当然，你也可以选择window服务器，不过同样的配置，window服务器更贵，且win系统因为自带图形界面，所以相对系统会吃掉更多的硬盘空间，所以，普遍推荐linux服务器。</li><li>优先选择腾讯云的服务器，控制台更简单更好操作，虽然安全配置不高，但是效果不错。如果经济条件允许，可选阿里云，会比腾讯云稍微贵一些。</li><li>新用户优先购买长期，所有的服务器供应商都喜欢新用户，优惠力度最大，如果你是新用户购买，能买多久就买多久，最好选个四核的，四核服务器甚至可以用来部署一些游戏的私服，并且体验相当不错。</li></ol><h4 id="SSH工具"><a href="#SSH工具" class="headerlink" title="SSH工具"></a>SSH工具</h4><p>SSH工具就是能够让你在本地电脑访问云服务器的工具。</p><p>因为linux不需要什么图形化界面，所以很多人都喜欢用SSH工具直连服务器，通过命令行操作。</p><p>我个人推荐<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，个人觉得它比FinalShell，Xshell，PUTTY这三个工具好用。</p><p>不过mobaxterm的免费版的连接数有上限，只能存10个服务器地址，如果一个人需要管理很多服务器，要么付费要么换一个吧。</p><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>一个有着<code>index.html</code>的前端页面，当然，名字并非是强制要求，只是大家都习惯了，于是约定俗成的以<code>index.html</code>为准。</p><h3 id="Nginx服务器安装"><a href="#Nginx服务器安装" class="headerlink" title="Nginx服务器安装"></a>Nginx服务器安装</h3><p>我们暂时先别管什么是Nginx，我们只要配置好Nginx，后续就可以将配置托管到服务器上。</p><p>服务器系统推荐centOS7.6，虽然这个版本的系统有点老，但是折腾的人最多，所以遇到什么问题都能找到对应的解决方案。</p><p>这里需要略懂一点linux的常规操作，如果不清楚的，推荐看文：<a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a>，这篇文章介绍的流程要比我目前的操作详细的多，我这里只是简洁版。</p><h4 id="vim编辑nginx-repo"><a href="#vim编辑nginx-repo" class="headerlink" title="vim编辑nginx.repo"></a>vim编辑nginx.repo</h4><p>输入以下指令，然后按回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>按<code>i</code>键进入编辑模式，底部出现“插入”则说明成功进入编辑模式</p><p>复制以下代码，粘贴进去（注意别用ctrl+v粘贴，在finalshell里点击鼠标右键，然后选择粘贴）</p><p>注意每行开头不能有空格，否则可能会报错（vim编辑器不适用左键改变光标位置，可以通过上下左右控制）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nginx-stable]</span></span><br><span class="line"><span class="attr">name</span>=nginx stable repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[nginx-mainline]</span></span><br><span class="line"><span class="attr">name</span>=nginx mainline repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 复制完确认没问题后，点击键盘上的esc退出编辑模式，然后输入:wq保存并退出 Vim 编辑器（注意输入法一定要是英文模式，不要因为<code>:</code>的中英文区别报错）</p><h4 id="输入指令安装nginx"><a href="#输入指令安装nginx" class="headerlink" title="输入指令安装nginx"></a>输入指令安装nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><h4 id="安装完之后查看nginx状态"><a href="#安装完之后查看nginx状态" class="headerlink" title="安装完之后查看nginx状态"></a>安装完之后查看nginx状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>如果控制台报的命令如下，这个说明nginx已经安装成功，但是未启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-centos#systemctl status nginx</span><br><span class="line">nginx.service -nginx-high performance web server</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">Active:inactive(dead)</span><br></pre></td></tr></table></figure><p>现在启动一下nginx，启动后再次查看nginx状态，出现active (running)说明启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p>查看80端口是否被nginx占用，然后在浏览器地址栏直接访问你的公网ip地址，如果出现nginx提示，则说明nginx已经配置OK。</p><blockquote><p>注意，80端口是http协议的默认端口，如果你没有配置好<code>https</code>，这里外部访问的时候，记得要用<code>http:// </code>开头访问，否则会访问无效。</p></blockquote><h3 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h3><p> 在你的电脑上新建一个文本文档，重命名为nginx.conf，用记事本打开，然后把以下内容粘贴进去</p><p>这里注意配置重点，下边这个配置是让你的目录设置，是为了让外部访问目录能指向你的服务器文件位置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/index.html</span><br></pre></td></tr></table></figure><p>就比如我上边用locahost本地的访问的<code>/index.html</code>，这个按照下方配置后，就是访问<code>/usr/local/dist/index.html</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /usr/local/dist<span class="comment">;</span></span><br><span class="line">    index index.html<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root配置根目录，index配置入口文件。</p><p>打包好的文件需要放到usr下的local文件夹内，我这边前端打包生成的文件是dist,所以root配置为&#x2F;usr&#x2F;local&#x2F;dist。</p><p>我这里需要配置两个文档托管，于是就采用了根据次级域名转换到不同文件目录的方式，根据次级域名（也有叫二级域名的）不同而指向不同的资源，从而访问不同的内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line">user nginx<span class="comment">;</span></span><br><span class="line">worker_processes auto<span class="comment">;</span></span><br><span class="line">error_log /var/log/nginx/error.log<span class="comment">;</span></span><br><span class="line">pid /run/nginx.pid<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user <span class="section">[$time_local]</span> &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    sendfile            on<span class="comment">;</span></span><br><span class="line">    tcp_nopush          on<span class="comment">;</span></span><br><span class="line">    tcp_nodelay         on<span class="comment">;</span></span><br><span class="line">    keepalive_timeout   65<span class="comment">;</span></span><br><span class="line">    types_hash_max_size 2048<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types<span class="comment">;</span></span><br><span class="line">    default_type        application/octet-stream<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  cattools.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/dist<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  lintdoc.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/lintdoc<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers PROFILE=SYSTEM;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入&#x2F;etc&#x2F;nginx目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br></pre></td></tr></table></figure><p>将目录下原有的nginx.conf拷贝一份（注意刷新一下才会显示）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> nginx.conf nginxCopy.conf</span><br></pre></td></tr></table></figure><p>备份旧配置（这一步不是必然，但是出于运维的好习惯，凡事留备份）</p><p>删除目录下的nginx.conf，然后将本地电脑上的nginx.conf上传到目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f nginx.conf</span><br></pre></td></tr></table></figure><h3 id="重启发布"><a href="#重启发布" class="headerlink" title="重启发布"></a>重启发布</h3><p>将静态文件发布到<code>/usr/local</code>目录下，因为我们直接配置的是dist文件夹，这里我们需要将dist整个文件夹发到<code>/usr/local</code>目录下。</p><p>发布完成之后，重启nginx，读取新的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>为了保险，我们可以查看一下发布之后的效果，有绿色的（active）代表发布成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>将下方的ip地址替换为自己的服务器地址，就可以访问到自己发布的前端页面了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip地址/index.html</span><br></pre></td></tr></table></figure><p>如果不想要用IP地址在外访问，我这里就用二级域名绑定了自己服务器IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://cattools.crazystudent13.cn</span><br><span class="line">http://lintdoc.crazystudent13.cn</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为前端基建的必然基石，像这种通用的工具文档部署是必然的需求。</p><p>团队化作战的过程中，我们肯定会在现代开发过程中遇到部署这些文档，这是一件绕不开的事。</p><p>这次是一次简单的部署，后续会持续集成，完成自动化部署的流程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发过程中，我们经常会整理一下业务文档或者工具文档供团队参考使用，这就是简单的前端基建工程。&lt;/p&gt;
&lt;p&gt;以前是由公司运维来处理这活，现在脱离团队了，只能自己来了，正好这块不熟悉，统一整理一下吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://crazystudent13.github.io/tags/nginx/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解link与import的区别</title>
    <link href="https://crazystudent13.github.io/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://crazystudent13.github.io/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-06-27T11:21:12.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>朋友：最近听说你在整理面试题？那我考考你，css样式的引入，link和import有什么区别？</p><p>我：你他妈疯了？这哪怕是五年前也是很少有人问到的，现在都是直接打包压进去的，你问我这个？</p><p>朋友：这关系到你的基础牢不牢靠，万一面试官问了呢。</p><p>我：你他妈就是一个大傻逼。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>尽管这道面试题是五年前的老古董了，这个问题放在五年前都是冷门问题。</p><p>在当初已经盛行前端工程化的时代了，这种问题实在是没有必要放在嘴边，样式都拆到项目里边了，谁管你最后是怎么引入的呢。</p><p>但是，问都问了，索性看看整理一下吧。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>二者毫无问都是引入CSS样式，我们没必要找什么共性，直接看看区别吧。</p><h4 id="从属关系"><a href="#从属关系" class="headerlink" title="从属关系"></a>从属关系</h4><ul><li>link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 </li><li>@import是 CSS 提供的语法规则，只有导入样式表的作用；</li></ul><h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><ul><li>link标签引入的 CSS 被同时加载；</li><li>@import引入的 CSS 将在页面加载完毕后被加载。</li></ul><h4 id="兼容性区别"><a href="#兼容性区别" class="headerlink" title="兼容性区别"></a>兼容性区别</h4><ul><li>link标签作为 HTML 元素，不存在兼容性问题。 </li><li>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；</li></ul><h4 id="DOM可控性区别"><a href="#DOM可控性区别" class="headerlink" title="DOM可控性区别"></a>DOM可控性区别</h4><ul><li>可以通过 JS 操作 DOM ，插入link标签来改变样式；</li><li>由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</li></ul><h4 id="权重区别"><a href="#权重区别" class="headerlink" title="权重区别"></a>权重区别</h4><p>link引入的样式权重大于@import引入的样式。（相同的类名或者标签名，而不是含有!important之类的才生效）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>尽管现在我们不怎么需要关注了，但有时候项目工程化打包会遇到二者优先度或其他问题，这里备注下。</p><blockquote><p>@import一定要写在除@charset外的其他任何 CSS 规则之前，如果置于其它位置将会被浏览器忽略。</p><p>而且，在@import之后如果存在其它样式，则@import之后的分号是必须书写，不可省略的</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>2024年了，还问这种问题的面试官就是纯纯的大傻逼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903890832326664?searchId=2024062719174374BA1A8A291721F074D7">link和@import的区别 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朋友：最近听说你在整理面试题？那我考考你，css样式的引入，link和import有什么区别？&lt;/p&gt;
&lt;p&gt;我：你他妈疯了？这哪怕是五年前也是很少有人问到的，现在都是直接打包压进去的，你问我这个？&lt;/p&gt;
&lt;p&gt;朋友：这关系到你的基础牢不牢靠，万一面试官问了呢。&lt;/p&gt;
&lt;p&gt;我：你他妈就是一个大傻逼。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="css" scheme="https://crazystudent13.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解域名等级</title>
    <link href="https://crazystudent13.github.io/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/"/>
    <id>https://crazystudent13.github.io/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/</id>
    <published>2024-06-24T15:37:09.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>我：买了个新服务器，又得买个域名挂靠了，有点太费钱，有没有什么好办法？</p><p>朋友：为什么要买新域名？用二级域名处理一下就可以了。</p><p>我：什么是二级域名？</p><p>朋友：远川同学，你这块的知识有点水啊，你要不去补一下，以后面试可有点够呛。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近刚买了一个服务器，本想买新域名挂在服务器上，然后和朋友说了一下，他说你可以用二级域名。</p><p>关于二级域名这种说法，以前工作中偶尔听到，当时都是由运维的朋友来处理，我很少操心这些事。</p><p>自考有关计算机网络原理的部分，并未提及相关内容，于是我自考中也没了解过相关知识。</p><p>幸亏被朋友点了我一下，不然要是被面试官问到了，那还是真是愧对我这五年经验。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><h4 id="什么是DNS解析"><a href="#什么是DNS解析" class="headerlink" title="什么是DNS解析"></a>什么是DNS解析</h4><p>先说DNS解析，我们浏览器输入域名，就可以直接渲染出我们需要的页面。</p><p>做前端的都是知道，这其中有一个很重要的步骤：域名解析，又叫DNS解析，域名解析就是由域名查找到 IP 的过程。</p><p>域名解析的工作由DNS服务器完成。</p><p>简单了来说，域名实际上就是一个IP的昵称，我们通过DNS服务器去打听这个昵称是哪个IP，最后锁定IP，然后访问对应的机器。</p><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>已知一个域名，先会访问根域的DNS服务器，全球一共有13台根域名服务器，根域名服务器储存了负责每个顶级域（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>拿到顶级域名服务器地址后，访问得到二级域名的域名服务器地址信息，以此类推，直到最终确定某个 IP 地址。</p><p>常见的解析方式有三种：A记录解析、CNAME记录解析、MX记录解析。</p><p>如果我们新增、减少了 DNS 解析记录，正常情况下的 TTL 是10 min。</p><h3 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h3><p>前边我们提到了域名的根服务器，这里详细解释下根域名的定义。</p><blockquote><p>根域是指整个互联网的最高层级，位于所有的顶级域名之上。</p></blockquote><p>它没有任何域名前缀，只有一个点号。</p><p>例如，在某些场合，<code>www.baidu.com</code>被写成<code>www.baidu.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p>根域由互联网的根服务器组成，这些服务器负责解析所有的顶级域名（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>理论上，所有<a href="https://cloud.tencent.com/act/pro/domain-sales?from_column=20065&from=20065">域名查询</a>都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p><p><strong>根域名服务器</strong>是 13个 固定 <strong>ip</strong> 所组成服务器群的简称，它保存的只是所有<strong>一级域名服务器</strong>的 <strong>ip</strong> 地址信息。</p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>顶级域名，也叫一级域名。</p><p>域名最后面的那一部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 .com 就是顶级域名，又叫一级域名。</p><p>顶级域名分为国际顶级域名、国家顶级域名。</p><h4 id="国际顶级域名（gTLD）"><a href="#国际顶级域名（gTLD）" class="headerlink" title="国际顶级域名（gTLD）"></a>国际顶级域名（gTLD）</h4><p>这里列举一下我们常见的域名，如下这种指向各种机构的域名，共有700多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.com</td><td>工商企业</td></tr><tr><td>.net</td><td>网络提供商</td></tr><tr><td>.org</td><td>非盈利组织</td></tr><tr><td>.gov</td><td>政府网站</td></tr><tr><td>.edu</td><td>教育机构</td></tr></tbody></table><p>为了解决域名紧张的问题，后来也引入了一些其他的顶域</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.firm</td><td>公司企业</td></tr><tr><td>.store</td><td>销售公司或企业</td></tr><tr><td>.web</td><td>突出WWW活动的单位</td></tr><tr><td>.arts</td><td>突出文化、娱乐活动的单位</td></tr><tr><td>.rec</td><td>突出消遣、娱乐活动的单位</td></tr><tr><td>.info</td><td>提供信息服务的单位</td></tr><tr><td>.nom</td><td>个人</td></tr></tbody></table><h4 id="国家顶级域名（ccTLD）"><a href="#国家顶级域名（ccTLD）" class="headerlink" title="国家顶级域名（ccTLD）"></a>国家顶级域名（ccTLD）</h4><p>另一类是国别顶级域名（ccTLD），这种指向国家地域的域名，总共有300多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.cn</td><td>中国</td></tr><tr><td>.us</td><td>美国</td></tr><tr><td>.jp</td><td>日本</td></tr><tr><td>.cc</td><td>科科斯群岛</td></tr></tbody></table><h3 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h3><p>一级域名左侧的部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 baidu 就是二级域名。</p><p>国际顶级域名下二级域名，一般是指域名注册人选择使用的网上名称，如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 中的 baidu 。</p><p>国家顶级域名下二级域名，一般是指类似于国际顶级域名的表示注册人类别和功能的标志，例如com，edu，gov，net等如：<a href="https://link.juejin.cn/?target=https://www.moe.gov.cn">www.moe.gov.cn</a> 中的 gov，其实可以发现 <a href="https://link.juejin.cn/?target=https://www.baidu.com.cn">www.baidu.com.cn</a> 也是可以访问到的，这个时候的二级域名就是 .com ，但是会被重定向到 <a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 。</p><p>这里的二级域名并不是朋友说的二级域名，这里的二级域名，实际上是我们买的域名，譬如我个人的博客域名：<a href="https://crazystudent13.cn/">crazystudent13.cn</a>，这里的crazystudent13就是二级域名。</p><h3 id="三级域名"><a href="#三级域名" class="headerlink" title="三级域名"></a>三级域名</h3><p>三级域名可以当做是二级域名的子域名，比如：<a href="https://link.juejin.cn/?target=https://naotu.baidu.com">naotu.baidu.com</a> ，对于使用者而言，三级域名都是二级域名的附属物而无需单独费用，四级域名等依次类推即可。</p><p>又如：<a href="https://link.juejin.cn/?target=http://www.neea.edu.cn/">www.neea.edu.cn</a> 中的 neea (教育考试网)。</p><p>所以严格意义上，朋友说的二级域名的说法是不对的，正常的来说，应该是三级域名了，也有说法叫次级域名。</p><h3 id="域名风险"><a href="#域名风险" class="headerlink" title="域名风险"></a>域名风险</h3><p>这个知识属于拓展了，因为我们偶尔访问一些页面失效的时候，经常会听网上传言说是DNS污染或者DNS劫持。</p><p>那这里干脆顺便讲一下，就当是相关知识拓展。</p><h4 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h4><p>DNS又称<strong>域名服务器缓存投毒</strong>，是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。</p><p>简单的来说，就是域名服务器内IP和域名的指向被其他人投了错误的数据包，导致指向错误了，就像一个人的昵称和本人对不上，这样自然会导致访问错误。</p><p>一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><p>这种污染基本上是大范围的，批量的，并不是针对某个网站，而是某片网域的污染。</p><p>通常对于DNS污染，一般除了使用代理服务器和VPN之类的软件之外，我们并没有什么还办法，大多数人只能干等域名供应商将污染的数据恢复。</p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>了解了域名的一些知识，我们经常听到的一个名词：域名劫持（DNS 劫持）。</p><p>正常的流程应该是我们根据域名，访问正确的 DNS 解析服务器来获取我们最终的 IP。但如果让用户访问到的错误的 DNS 解析服务器上，返回错误的 IP，让用户展示攻击者指定的页面，这就是域名劫持了。</p><p>经典案例就是有的年久不用的网站，被他人恶意劫持，指向了某个黄色网站，这类事情发生的很多，尤其是国内很多政府网站，早年没有什么网安，也没人关注这类门面网站，发生这种事很常见。</p><p>相对于DNS污染那种大范围破坏来说，DNS劫持目标更单一，就是针对某个网站的恶意行为。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个不算面试题，只是个普通知识拓展，后续随着计算机网络知识的了解，会不断丰富相关知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904192868352007">域名等级、DNS域名解析</a></p><p><a href="https://cloud.tencent.com/developer/article/1147777">根域名的知识</a></p><p><a href="https://developer.baidu.com/article/detail.html?id=2594936">域名解析：顶级域名、根域&#x2F;二级域名、一级域名&#x2F;子域名解析</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我：买了个新服务器，又得买个域名挂靠了，有点太费钱，有没有什么好办法？&lt;/p&gt;
&lt;p&gt;朋友：为什么要买新域名？用二级域名处理一下就可以了。&lt;/p&gt;
&lt;p&gt;我：什么是二级域名？&lt;/p&gt;
&lt;p&gt;朋友：远川同学，你这块的知识有点水啊，你要不去补一下，以后面试可有点够呛。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="网络原理" scheme="https://crazystudent13.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>解决git SSL certificate problem</title>
    <link href="https://crazystudent13.github.io/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/"/>
    <id>https://crazystudent13.github.io/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/</id>
    <published>2024-06-24T04:38:07.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>提交项目代码到github上的时候，突然就报了这个问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实是个很简单的问题，只是以前没遇到过，所以不知道怎么处理。</p><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>这个错误表明Git在尝试通过HTTPS进行通信时，遇到了SSL证书验证问题。</p><p>具体来说，Git客户端无法获取到用于验证本地颁发者证书的信息。</p><p>这通常发生在Git客户端没有正确配置或者没有本地证书文件的情况下，尤其是在自签名的证书或者是过期的证书文件缺失的情况下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git SSL certificate problem: unable to get local issuer certificate</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一：忽略验证"><a href="#方案一：忽略验证" class="headerlink" title="方案一：忽略验证"></a>方案一：忽略验证</h4><p>使用Git的配置选项来忽略SSL证书验证（不推荐，因为这会降低通信的安全性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><h4 id="方案二：更新CA证书库"><a href="#方案二：更新CA证书库" class="headerlink" title="方案二：更新CA证书库"></a>方案二：更新CA证书库</h4><p>确保系统中安装了正确的CA证书。</p><p>在Linux系统中，你可以通过更新CA证书库来解决问题。</p><p>如果是自签名的证书，你可以将服务器的证书添加到Git的信任列表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslCAInfo /path/to/certificate.pem</span><br></pre></td></tr></table></figure><p>如果你使用的是代理服务器，请确保代理服务器的SSL证书是有效的，或者配置Git以跳过代理的SSL验证。</p><p>更新Git到最新版本，以确保包含最新的证书信息。</p><p>如果问题仍然存在，可以考虑使用SSH方式克隆或者拉取远程仓库，从而绕过HTTPS的SSL验证问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个常规的CA证书验证问题，但是平时很少遇到，所以这里记录一下，如果后续遇到，方便排查。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_44014995/article/details/109900149">解决：git SSL certificate problem: unable to get local issuer certificate</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提交项目代码到github上的时候，突然就报了这个问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="github" scheme="https://crazystudent13.github.io/tags/github/"/>
    
    <category term="疑难杂症" scheme="https://crazystudent13.github.io/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解spa,ssr,seo</title>
    <link href="https://crazystudent13.github.io/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/"/>
    <id>https://crazystudent13.github.io/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/</id>
    <published>2024-06-23T04:56:01.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近被一个新人模拟面试折腾的高血压又犯了，以前我是碰都不会碰这类基础面试题的，这种常识还有人不会？</p><p>结果还真有人不会，为了给新手开开眼，于是特意整理了这篇文档。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近有个刚入行的新手问我什么是SPA，我说就是单页面应用。</p><p>他又问什么是单页面应用，我寻思这是来考我了？</p><p>然后我就认真回了一下：就是一次加载前端所有资源，然后由前端的JS脚本来控制用户的交互行为。这样做的好处是可以在客户端处理掉所有的交互，减小服务器的压力，但是坏处是服务器做SEO时候，不好做数据抓取，相对于传统的SSR不太好。</p><p>然后，新人又问：什么是SEO?SSR不是抽卡吗，和这个有什么关系？</p><p>我：。。。你他妈的就是来找茬的？新生代的前端都这么没常识的吗？</p><h3 id="单页面应用（SPA）"><a href="#单页面应用（SPA）" class="headerlink" title="单页面应用（SPA）"></a><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">单页面应用（SPA）</a></h3><p>单页面应用这个面试题从我入行的时候就在问，因为那时候还是jquery刚刚倾倒的时刻，vue，ng，react三大框架刚刚兴起，对于那时候的人来说，这个概念很新鲜。</p><p>如今都他妈快5到6年了，还在问这个问题，我只能说社会进步还是挺缓慢的。</p><p>我这里懒得自己写定义了，引用一下vue官方的说法。</p><blockquote><p>一些应用在前端需要具有丰富的交互性、较深的会话和复杂的状态逻辑。</p><p>构建这类应用的最佳方法是使用这样一种架构：Vue 不仅控制整个页面，还负责处理抓取新数据，并在无需重新加载的前提下处理页面切换。</p><p>这种类型的应用通常称为单页应用 (Single-Page application，缩写为 SPA)。</p></blockquote><p>说的简单点，就是以前页面切换等操作，每次都需要向服务器发送请求，抓取新的页面资源，到了本地重新解析资源，压力都在服务器端。</p><p>为了缓解服务器的渲染压力，也为了开发提速，于是就有了单页面应用（SPA）的处理方式。</p><p>这样避免每次切换页面对服务端造成压力，也不需要前端页面在服务器渲染，进一步削弱了服务器的压力。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>减小了后端开发心智负担，使后端更专注业务开发，前端来处理交互逻辑。SPA必然伴随着前后端解耦，传统开发需要后端调试前端的写的页面逻辑，比如JSP交互，如今将交互逻辑分离出来，页面及跳转之类的交互逻辑全部由前端开发，使后端更专注于业务逻辑的开发。</li><li>增加开发速度，因为前后端逻辑解耦，各自负责自己的部分，可以并行安排开发任务，双方通过接口进行联调，相对于传统的开发模式，不需要后期全部由后端挑大梁。</li><li>减小对服务器的压力，SPA是一次性加载所有资源到本地，由用户本地的浏览器来处理交互逻辑，在后续的人机交互过程中，除了需要请求接口数据，几乎不需要请求大量的页面资源，也不需要再服务端渲染，故而极大程度的减小的服务器的压力。</li><li>页面之间的切换非常快，用户体验好。因为全部由前端处理交互，不需要过服务器的渲染，不会受限于服务器的性能造成处理问题，所以相对传统的服务器端渲染页面，SPA能够更快的完成前端页面交互效果。</li></ol><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，由此衍生出了很多首屏优化的要求。</li><li>不方便SEO。SEO是根据每个页面的固定内容进行抓取，而SPA是一次性加载所有资源，故而这种方式不利于SEO抓取。</li></ol><h3 id="搜索引擎优化（SEO）"><a href="#搜索引擎优化（SEO）" class="headerlink" title="搜索引擎优化（SEO）"></a>搜索引擎优化（SEO）</h3><p>既然提到了SEO，这里就先讲SEO。</p><p>这里引用一下百度百科给的定义，虽然百科不怎么正规，但是它这部分说的还是相对来说较为严谨的。</p><blockquote><p>SEO（Search Engine Optimization）：汉译为搜索引擎优化。</p><p>是一种利用<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>的规则提高网站在有关搜索引擎内的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%8E%92%E5%90%8D/2092669?fromModule=lemma_inlink">自然排名</a>的方式。目的是让其在行业内占据领先地位，获得<a href="https://baike.baidu.com/item/%E5%93%81%E7%89%8C/235720?fromModule=lemma_inlink">品牌</a>收益。</p><p>很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。</p></blockquote><h4 id="搜索引擎工作原理"><a href="#搜索引擎工作原理" class="headerlink" title="搜索引擎工作原理"></a>搜索引擎工作原理</h4><p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。</p><p>随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。</p><p>反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。</p><p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。</p><p>在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。</p><p>这样一个过程我们称之为SEO。</p><h4 id="SEO与SEM的区别"><a href="#SEO与SEM的区别" class="headerlink" title="SEO与SEM的区别"></a>SEO与SEM的区别</h4><p>讲到两者的区别时候，先放一下SEM的定义，我看了一下百科的定义，个人感觉不够直白，这里自己干脆重写一下。</p><blockquote><p>SEM一般指竞价推广，在搜索引擎后台账户投钱，使广告获取相关的排名，一般搜索页面上会展现“广告”的标签。</p></blockquote><p>这里我们从不同维度去比较一下两者的区别。</p><table><thead><tr><th>维度</th><th>SEO</th><th>SEM</th></tr></thead><tbody><tr><td>关键词前置条件</td><td>需要网站有权重基础，小站无法做热词，不能随时增减关键词</td><td>不需要网站基础，任何关键词都可以投放</td></tr><tr><td>关键词收费</td><td>相对较低，随着SEO优化好，收费会降低</td><td>关键词越多，收费越高，随着同类站点竞争激烈，收费越高</td></tr><tr><td>见效时长</td><td>3-5月以上</td><td>立刻见效</td></tr><tr><td>持续性</td><td>停止SEO，效果可以持续很久</td><td>停止SEM，立刻失效</td></tr></tbody></table><p>如果你们老板实际开发官网，希望你能优化一下官网的SEO排名，我个人建议，在国内的话，直接找个靠谱的厂商去买关键字竞价吧。</p><p>现在搜索排名靠前的全部都是广告，搜不出什么正经的东西，你各种花里胡哨的操作，都不如直接去买关键字权重。</p><p>我之前呆的一家公司，甚至没做SSR的优化，直接用vue弄了个单页面应用，硬是靠着关键字排名砸到了前排，SEO总归是商业行为，技术角度总归只是辅助，了解一下就行。</p><p>当然，也并非说国内完全没有做seo的价值，详情可以参考这篇文：<a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a>，讲的很不错。</p><p>另外，在国内的网站最好还是备案一下，虽然<strong>备案不影响SEO的优化</strong>，但在国内有备案的网站终归更具有可信度。</p><h4 id="白帽SEO与黑帽SEO"><a href="#白帽SEO与黑帽SEO" class="headerlink" title="白帽SEO与黑帽SEO"></a>白帽SEO与黑帽SEO</h4><p>在市面上，按照各种操作行为，大致可以分为白帽SEO和黑帽SEO。</p><p><strong>白帽SEO</strong>：起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。</p><p><strong>黑帽SEO</strong>：利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。</p><p>我们常规的技术手段，大概就是白帽SEO，具体手段参考：<a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a>，实际开发过程中，我们主要做如下操作。</p><ol><li>SSR服务器渲染</li><li>预渲染prerender-spa-plugin</li><li>对网站的的title、description、keywords精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</li><li>网站内容优化：内容与关键字的对应，合理增加关键字的密度；</li><li>饰性图片必须加alt</li><li>在网站上合理设置Robots.txt文件；</li><li>语义化化的HTML代码，符合W3C规范</li><li>增加外部链接，到各个网站上宣传；</li><li>向各大搜索引擎提交收录自己的站点</li><li>少用iframe：iframe中的内容是不会被抓取到的</li></ol><p>详细的操作手段这里就不说了，我后续会专门整理一篇文档，毕竟从零开始弄一个网站，然后通过SEO优化打到前排这种操作我也没做过，公司都是直接用钱砸关键字权重的，只能说钱多任性。</p><p>后续我会尝试做个简单的玩具网站，试试能不能通过白帽SEO把排名打上去，如果打不上去，我这里介绍的再怎么花哨也没什么用。</p><h3 id="服务器端渲染（SSR）"><a href="#服务器端渲染（SSR）" class="headerlink" title="服务器端渲染（SSR）"></a>服务器端渲染（SSR）</h3><p>这里依旧放一下百度百科的定义。</p><blockquote><p>服务器端渲染（Server-Side Rendering）是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p></blockquote><p>SSR没什么好说的，就是传统的服务端页面，因为页面的接口都是在服务端完成拼接处理，当浏览器的请求资源的时候，已经是完整的DOM结构。</p><p>故而，SSR相对于传统的SPA更适合搜索引擎抓取关键字，所以SEO效果会更好。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了</li><li>更好的SEO，将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li><li>一些常用的浏览器API可能无法正常使用，比如<code>window</code>、<code>docment</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致</li></ol><h4 id="SSR常用框架"><a href="#SSR常用框架" class="headerlink" title="SSR常用框架"></a>SSR常用框架</h4><ul><li>React 的 <a href="https://link.juejin.cn/?target=https://nextjs.org/">Next</a></li><li>Vue.js 的 <a href="https://nuxt.com/">Nuxt3</a></li></ul><h4 id="Nuxt静态化"><a href="#Nuxt静态化" class="headerlink" title="Nuxt静态化"></a>Nuxt静态化</h4><p>因为个人之前是用Nuxt来做官网的，而且本人的技术栈主要也是vue全家桶，所以这里主要也就讲一下Nuxt3。</p><p>静态化是Nuxt.js打包的另一种方式，算是Nuxt.js的一个创新点，部署到服务器上之后，这种页面加载速度很快。</p><p>这里再次放一下Nuxt3官网的关于服务端渲染的说法。</p><h5 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title=" 服务器端渲染"></a><a href="https://nuxt.com/docs/getting-started/introduction#server-side-rendering"> 服务器端渲染</a></h5><p>默认情况下，Nuxt具有内置的服务器端渲染（SSR）功能，无需自己配置服务器，这对Web应用程序有很多好处</p><ul><li><strong>更快的初始页面加载时间：</strong>Nuxt将完全呈现的HTML页面发送到浏览器，该页面可以立即显示。这可以提供更快的感知页面加载时间和更好的用户体验 （UX），尤其是在速度较慢的网络或设备上。</li><li><strong>改进的 SEO：</strong>搜索引擎可以更好地索引 SSR 页面，因为 HTML 内容可以立即使用，而不需要 JavaScript 在客户端呈现内容。</li><li><strong>在低功耗设备上具有更好的性能：</strong>它减少了需要在客户端下载和执行的 JavaScript 数量，这对于可能难以处理繁重的 JavaScript 应用程序的低功耗设备非常有益。</li><li><strong>更好的辅助功能：</strong>内容在初始页面加载时立即可用，从而提高了依赖屏幕阅读器或其他辅助技术的用户的可访问性。</li><li><strong>更轻松的缓存：</strong>页面可以缓存在服务器端，这可以通过减少生成内容并将其发送到客户端所需的时间来进一步提高性能。</li></ul><p>总体而言，服务器端渲染可以提供更快、更高效的用户体验，并改善搜索引擎的优化和可访问性。</p><blockquote><p>注意：在Nuxt.js执行 generate静态化打包时，动态路由会被忽略。</p></blockquote><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>纯静态文件，访问速度超快</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>动态路由（params传参），参数多的时候，Nuxt不适用</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些常识类的东西，虽然对开发没什么作用，但是作为见识拓展一下比较好。</p><p>这些问题也不是什么新鲜问题，基本上都是老古董的问题了，这里整备一下，省的哪天被别人面试挖了犄角旮旯的问题拉出来拷打。</p><p>假如上级布置了一个SSR开发任务，不会闹出来SSR抽卡用的词的笑话，多了解一点，总归是没什么错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a></p><p><a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a></p><p><a href="https://juejin.cn/post/7230303948925665341?searchId=20240623132441364A0B270D1932943462">挑战15分钟了解SEO、SMO、SPA、SSR可以吗？</a></p><p><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">使用 Vue 的多种方式 | Vue.js (vuejs.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为最近被一个新人模拟面试折腾的高血压又犯了，以前我是碰都不会碰这类基础面试题的，这种常识还有人不会？&lt;/p&gt;
&lt;p&gt;结果还真有人不会，为了给新手开开眼，于是特意整理了这篇文档。&lt;/p&gt;</summary>
    
    
    
    
    <category term="浏览器" scheme="https://crazystudent13.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工程提速,vue3项目代码书写规范整理</title>
    <link href="https://crazystudent13.github.io/2024/06/20/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-vue3%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
    <id>https://crazystudent13.github.io/2024/06/20/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-vue3%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/</id>
    <published>2024-06-20T12:51:54.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>本次是基于最近工作团队协作中，不同风格的代码书写风格放在一个项目中，导致整个项目的打包变得异常闹心。</p><p>这种问题也是老生常谈了，为了让团队能够更协调的推进项目，这里遵守约定大于配置的规则，整理一套相对宽松的前端规范，以便于所有组员开发。</p><p>本次项目以vue3为主，所以这里前端代码风格的核心是偏向vue3的，大家酌情自取。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>传统的代码规范文档可能会从HTML，CSS，JS这种顺序来进行细数。</p><p>但是考虑到团队内的开发者大多不是专职的前端开发，且本次项目翻新不需要太多的HTML和样式文件的书写，这里就按照当前团队内最不规范的部分开刀。</p><h3 id="GIT规范"><a href="#GIT规范" class="headerlink" title="GIT规范"></a>GIT规范</h3><p>因为所有人开发水平参差不齐，这里暂时不考虑自动化检测，后续大家习惯逐渐统一之后，会加入代码提交自动检测的。</p><h4 id="提交内容规范"><a href="#提交内容规范" class="headerlink" title="提交内容规范"></a>提交内容规范</h4><ol><li><strong>避免空文件的提交！！绝对避免！！</strong></li><li>不要提交空信息，每次提交用最简单的话写明白自己做了什么。</li><li>多文件修改不要一次性提交，尽可能分开提交文件，将自己每次修改了什么单次提交。</li><li>做有意义的提交，每次提交尽可能是一次工作完成的节点，通过撤回上次提交来修改每次提交进度的内容。</li><li>每次提交之前进行代码格式化，让风格大体统一，保证编译不报错。</li></ol><p>这里我逐个解释一下原因。</p><ol><li>避免空文件，是为了避免打包时候，vite打包会报错，空文件导致vite无法编译。</li><li>空信息不便于排查，数个月之后排查对应代码，没有清晰的信息，很难排查对应的错误。</li><li>多文件一次性提交，同样不利于排查，如果本次提交导致报错，会加大排查的工作量。</li><li>无意义提交太多，同样也会增加排查的工作量，所以尽可能让每次提交都是一个功能的闭环。</li><li>暂时因为所有人的开发水平不一致，所以这里不考虑使用代码提交格式检测，但是尽可能的保证每次代码的规范性。</li></ol><h3 id="组件拆分规范"><a href="#组件拆分规范" class="headerlink" title="组件拆分规范"></a>组件拆分规范</h3><p>组件拆分是很重要的一环，vue3相对于v2做了很多解耦的便捷性改动，我们必须利用好这些特性。</p><h4 id="拆分思路"><a href="#拆分思路" class="headerlink" title="拆分思路"></a>拆分思路</h4><ol><li>常规列表的增删改查，尽可能的项目中封装好的动态表单和表格来实现，不要用<code>element-plus</code>的自己写</li><li>如果页面有弹窗操作，先看看这类弹窗操作是否在原项目中多次复用，如多次复用，需将该类弹窗操作封装成公用业务组件，通用业务组件代码统一放在<code>src/component/business</code>文件夹下，命名规则为大驼峰命名法。</li><li>如果群内有其他人完成开发，则可以考虑直接复用他人组件。</li><li>如果是普通的新增或编辑弹窗操作，命名<code>MoudleAction</code>新开一个文件夹进行书写。</li></ol><h3 id="JS规范"><a href="#JS规范" class="headerlink" title="JS规范"></a>JS规范</h3><p>因为本次开发以Vue3技术栈为主，所以这里有些规范会偏向于vue3的书写思路。</p><h4 id="组合式优先"><a href="#组合式优先" class="headerlink" title="组合式优先"></a>组合式优先</h4><ol><li>template标签放在最上方，不要把script标签放在上方</li><li>直接在script标签中添加setup，不要在内额外使用<code>setup()</code>函数增加额外的代码行数</li><li>不推荐用ref包裹业务变量，ref应该用来去包裹一些非业务的，界面操作性质的变量。</li><li>不推荐用react的函数式写法去写组件</li><li>使用reactive成块的包裹业务块，成块的分割逻辑，便于代码逻辑的阅读</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/**<span class="doctag">@table</span> - 用reactive包装,将变量和方法都封在这一个逻辑块中，这块的是最核心的代码*/</span></span><br><span class="line"><span class="keyword">const</span> table = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">column</span>:[],</span><br><span class="line">    <span class="attr">data</span>:[],</span><br><span class="line">    <span class="attr">listLoading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">request</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 封装请求，这里我们赋值也不需要从.value什么的拿，直接用table.data就能获取列表的值，简直方便，省的ref那种搞法了。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>:<span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">action</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 这里存放增删改查的逻辑</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">delete</span>:<span class="function">() =&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 日常开发时优先采用这种命令式直接写业务逻辑，不要包裹到table中，便于特殊处理，如果业务逻辑过于复杂，就抽离到一个单独的TS文件中*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 钩子这块直接放置所有需要触发的机制*/</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    table.<span class="title function_">request</span>()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="尽可能的削减代码行数"><a href="#尽可能的削减代码行数" class="headerlink" title="尽可能的削减代码行数"></a>尽可能的削减代码行数</h4><ol><li>在不需要代码换行的时候，尽量避免换行，比如动态表单和动态表格，都尽量避免换行；</li><li>优先考虑三目运算符，但谨记不要写超过3层的三目运算符；</li><li>多使用扩展运算符<code>...</code>和解构赋值，在接口提交参数的时候放出去；</li><li>接口放在api文件下统一处理，减少甚至避免在vue文件中用url写入原生的url；</li></ol><h4 id="使用async-await获取数据"><a href="#使用async-await获取数据" class="headerlink" title="使用async await获取数据"></a>使用async await获取数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 接口请求 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> req 接口api </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> params 参数 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">const</span> table = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="title function_">async</span>(<span class="attr">params</span>:any) =&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">req</span>(params) </span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="坚持函数功能单一原则"><a href="#坚持函数功能单一原则" class="headerlink" title="坚持函数功能单一原则"></a>坚持函数功能单一原则</h4><p>函数内仅做该函数应该做的，尽量避免通过传入标记控制不同行为；</p><p>通过命名语义化减少代码阅读的难受程度。</p><ol><li>request，将代码接口请求逻辑封装在此类命名的方法中，避免使用</li><li>action，代表操作逻辑的聚合，减少非操作的业务逻辑的聚合</li></ol><h4 id="使用-代替src"><a href="#使用-代替src" class="headerlink" title="使用/@代替src"></a>使用<code>/@</code>代替src</h4><p>在vue-cli 脚手架使用架自带的指向 src 开发目录的 ‘&#x2F;@’ 符号引入文件资源.</p><p>当然，这点可以通过代码智能提示自动引入，平时搭建不用太过关注。</p><h4 id="统一使用单引号"><a href="#统一使用单引号" class="headerlink" title="统一使用单引号"></a>统一使用单引号</h4><p>简单的来说就是业务中的JS代码字符串之类的，用单引号而非双引号。</p><p>不过，这个有eslint规范会自动格式化的，大家平时用不着记。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>命名规范是为了解决代码目录阅读速度慢的问题，这里做的规定尽量做。</p><p>不然后续排查起成百上千的文件夹，实在太过麻烦。</p><h4 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h4><ul><li>业务文件目录命名 按照小驼峰命名，首字母小写（如：projectName）</li><li>组件目录命名 按照大驼峰命名，如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- components</span><br><span class="line">| |-- <span class="title class_">ProjectName</span></span><br><span class="line">| | | -- <span class="title class_">ProjectName</span>.<span class="property">vue</span></span><br><span class="line">| | | -- index.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>小驼峰命名的业务文件，便于日常翻阅。</p><p>而大驼峰对应的组件，则可以避免全局引入的时候出现代码混淆的问题。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><ol><li>按照路由的路径进行命名，存放在views目录中。</li><li>非路由的文件，尽可能的复用原项目的名称，如果原项目文件名太过冗长，可适当缩短。</li><li>按照小驼峰命令，英文单词过长或超出2个以上，可缩略至前四位。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务统计 </span></span><br><span class="line">approvalStatistical </span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩略 </span></span><br><span class="line">approvalStat</span><br></pre></td></tr></table></figure><h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>这里尽量按照原本的代码进行处理即可。</p><p>按照小驼峰命名法，可使用常见动词约定；</p><ul><li><code>can</code> 判断是否可执行某个动作，函数返回一个布尔值。true：可执行；false：不可执行</li><li><code>has</code> 判断是否含有某个值， 函数返回一个布尔值。- true：含有此值；false：不含有此值</li><li><code>is</code>： 判断是否为某个值，函数返回一个布尔值。true：为某个值；false：不为某个值</li><li><code>get</code>： 获取某个之，函数返回一个非布尔值</li><li><code>set</code>： 设置某个值，无返回值、返回是否设置成功或者返回链式对象 load 加载某些数据,无返回值或者返回是否加载完成的结果</li></ul><p>语义化英文命名，仅组件内部使用方法前加上_（下划线）区分，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共方法的定义，可以提供外面使用</span></span><br><span class="line">publicbFunction () &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法，下划线定义，仅供组件内使用。多单词，注意与系统名字冲突！</span></span><br><span class="line">_privateFunction () &#123;&#125; </span><br></pre></td></tr></table></figure><h5 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h5><p>首字母大写的驼峰法命名。推荐使用 ES6 的方式引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Article</span> <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ArticleDetail</span> <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>使用驼峰式命名，优先使用<code>let</code>、<code>const</code>、避免使用<code>var</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="title function_">ref</span>(<span class="string">&#x27;luffy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;luffy&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>字母全部大写，以下横线<code>_</code>划分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Api</span> = &#123; </span><br><span class="line">  <span class="variable constant_">ITEMS_OFONE_TYPE</span> = <span class="string">&#x27;***&#x27;</span>, <span class="comment">// 获取事项分类 </span></span><br><span class="line">  <span class="variable constant_">SOLUTION_LIST</span> = <span class="string">&#x27;***&#x27;</span>,, <span class="comment">// 获取事项列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用词"><a href="#常用词" class="headerlink" title="常用词"></a>常用词</h4><p>这里常用的增删改查可能之前大家各有习惯，这里推荐使用</p><h4 id="常用动词"><a href="#常用动词" class="headerlink" title="常用动词"></a>常用动词</h4><table><thead><tr><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>get\set</td><td>取值\给值</td></tr><tr><td>add\remove</td><td>增加\移除</td></tr><tr><td>show\hide</td><td>显示\隐藏</td></tr><tr><td>view</td><td>查看</td></tr><tr><td>browse</td><td>浏览</td></tr><tr><td>modify</td><td>修改</td></tr><tr><td>save</td><td>保存</td></tr><tr><td>delete</td><td>删除</td></tr><tr><td>find</td><td>查询</td></tr><tr><td>undo</td><td>撤销</td></tr><tr><td>redo</td><td>重做</td></tr><tr><td>clean</td><td>清除</td></tr><tr><td>index</td><td>索引</td></tr><tr><td>observe</td><td>观察</td></tr><tr><td>send\receive</td><td>发送\接收</td></tr><tr><td>refresh\synchronize</td><td>刷新\同步</td></tr></tbody></table><ol><li>常用缩写</li></ol><table><thead><tr><th>数据类型&#x2F;标签</th><th>简写后缀</th></tr></thead><tbody><tr><td>object</td><td>obj</td></tr><tr><td>array</td><td>arr</td></tr><tr><td>json</td><td>json</td></tr><tr><td>function</td><td>fn</td></tr><tr><td>message</td><td>msg</td></tr><tr><td>button</td><td>btn</td></tr></tbody></table><h4 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h4><p>这里不做强制要求，但是样式命名尽可能的语义化，不要<code>-l,-r,-t,-b</code>这种简写无限嵌套，这种很读起来很伤神的。</p><p>样式，尽可能的少些甚至不写，用自带组件的样式解决就可以，不要非得去还原样式。</p><p>class命名以小写字母开头，小写字母、中划线和数字组成。不建议使用驼峰法命名 class 的属性。</p><p>以下是一些常用到的 class的名字：</p><ul><li>包裹层: .xx-wrap;</li><li>列表: .xx-list;</li><li>列表项: .xx-list-item; </li><li>左边内容: .xx-left; </li><li>中间内容: .xx-middle; </li><li>右边内容: .xx-right; </li><li>某个页面: .xx-page;</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="及时删除log调试日志"><a href="#及时删除log调试日志" class="headerlink" title="及时删除log调试日志"></a>及时删除log调试日志</h4><p>一旦代码合并到正式分支中，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由&#x27;</span>: 文件路由, <span class="string">&#x27;打印简述&#x27;</span>: 打印数据) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(打印数据, <span class="string">&#x27;1111&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>双斜线后应跟空格，且缩进与上下文的代码保持一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些说明... </span></span><br><span class="line"><span class="keyword">const</span> userID = <span class="number">24</span>; </span><br></pre></td></tr></table></figure><h4 id="多行注释（不推荐）"><a href="#多行注释（不推荐）" class="headerlink" title="多行注释（不推荐）"></a>多行注释（不推荐）</h4><p>一般用于注释难以理解的、可能存在错误的、逻辑强的代码，且缩进一致；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 针对下方代码的说明 </span></span><br><span class="line"><span class="comment">* 第一行太长写第二行 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>；</span><br></pre></td></tr></table></figure><h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><p>如果特别重要的方法，且复用度很高才推荐使用）写明传入参数名称，类型，推荐完整注释以下格式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 加入购物车</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> lint </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 2020-09-08</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; goodId 商品id </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Number&gt;</span>&#125; specs sku规格 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; amount 数量 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; remarks 备注</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns</span> &lt;Promise&gt; 购物车信息 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">apiProductAddCard = <span class="function">(<span class="params">goodId, specs, amount, remarks</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;***&#x27;</span>, &#123; goodId, specs, amount, remarks &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h3><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>标签语义化，切忌清一色的 div 元素。列表可以使用 ul li，文字使用 p 标签，标题使用 h* 标签，等等。 </p><p>HTML5 推出了语义化的标签，建议使用：section，aside，header，footer，article，等 HTML5 布局标签。</p><h4 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h4><p>推荐使用自闭合标签的写法(自闭合标签不使用连线方式）。</p><p>不用记，格式化工具会自动处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponents</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="多特性分行写"><a href="#多特性分行写" class="headerlink" title="多特性分行写"></a>多特性分行写</h4><p>不用记，格式化工具会自动处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">scroll</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">ref</span>=<span class="string">&quot;scrollWrap&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">class</span>=<span class="string">&quot;home-scroll-warp&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:data</span>=<span class="string">&quot;homeData&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:pullDownRefresh</span>=<span class="string">&quot;true&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:pullUpLoad</span>=<span class="string">&quot;true&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">pullingDown</span>=<span class="string">&quot;pullingDownGetNewData&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">pullingUp</span>=<span class="string">&quot;pullingUpGetMore&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h4><p>在模版中使用表达式，复杂情况使用计算属性或函数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;getLimitData(data)&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   ... </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;data.type !== &#x27;dir&#x27; &amp;&amp; dzqz &amp;&amp; hasBtn &amp;&amp; attrs.mode !== &#x27;ended&#x27;&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   ... </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="代码嵌套"><a href="#代码嵌套" class="headerlink" title="代码嵌套"></a>代码嵌套</h4><p>尽可能的保证代码行缩减，避免半个标签占一行的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  test-title  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  test-text  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h4><p>避免过多重复代码，如果超过三行类似的代码，配置数据再循环遍历</p><h4 id="活用v-show-v-if"><a href="#活用v-show-v-if" class="headerlink" title="活用v-show, v-if"></a>活用v-show, v-if</h4><p>v-show，v-for，v-if不要同时出现在一个标签上。</p><ul><li>v-show不会改变dom树，也就是说不会导致重排。</li><li>v-if会改变dom树，会导致重排。</li></ul><p>比如，我们在查询表单的页面上，不要用v-if，用v-show会减少页面性能的开销。</p><h4 id="注释规范-1"><a href="#注释规范-1" class="headerlink" title="注释规范"></a>注释规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单行注释 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 组件注释 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">CustomTable</span> <span class="attr">ref</span>=<span class="string">&quot;customTableRef&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 其他注释 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- </span><br><span class="line">  多行注释</span><br><span class="line">  多行注释</span><br><span class="line">--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h3><p>推荐使用UnoCSS引擎进行原子化CSS开发 推荐使用scss预编译 由于样式的情况比较多也比较复杂  做出如下规范</p><h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ul><li>避免使用标签选择器。因为在 Vue 中，特别是在局部组件，使用标签选择器效率特别低，损耗性能，建议需要的情况，直接定义 class；</li><li>非特殊情况下，禁止使用 ID 选择器定义样式。有 JS 逻辑的情况除外；</li><li>避免使用important选择器；</li><li>避免大量的嵌套规则，控制在3级之内，对于超过4级的嵌套，考虑重写或新建子项；</li><li>避免使用ID选择器及全局标签选择器防止污染全局样式；</li></ul><h4 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h4><ul><li>提取公用样式进assets文件styles里，按模块&#x2F;功能区分；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|assets</span><br><span class="line">|-- styles</span><br><span class="line">| |-- common 放置公用样式，如重置，混合，复写element样式等 </span><br><span class="line">| |-- modules 放置模块样式</span><br></pre></td></tr></table></figure><ul><li>推荐使用直接子选择器；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 推荐 */</span> </span><br><span class="line">.<span class="property">jdc</span> &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> li &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> li p&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐 */</span> </span><br><span class="line">*&#123;&#125; </span><br><span class="line">#jdc &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> div&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 scoped 关键字，约束样式生效的范围</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;scss&quot;</span> scoped&gt;</span><br><span class="line">.<span class="property">app</span>-wrapper &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>使用变量 可复用属性尽量抽离为页面变量，易于统一维护</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css */</span> </span><br><span class="line"><span class="selector-class">.class-name</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border-color</span>: red; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* scss */</span>  </span><br><span class="line">$<span class="attribute">color</span>: red; </span><br><span class="line"><span class="selector-class">.class-name</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: $color;</span><br><span class="line">  <span class="attribute">border-color</span>: $color; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h4><p>CSS 属性书写顺序：先决定定位宽高显示大小，再做局部细节修饰，推荐顺序（可以提升浏览器渲染 <code>dom</code> 的性能）：</p><p>定位属性(或显示属性，display)-&gt;宽高属性-&gt;边距属性(margin, padding)-&gt;字体，背景，颜色等，修饰属性的定义，这样定义为了更好的可读性，让别人只要看一眼就能在脑海中浮现最终显示的效果。</p><ol><li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li><li>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient … 以下给出常用的定义示例：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">class</span>-name &#123;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">top</span>: 100px; </span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">right</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">display</span>: block; </span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%; </span><br><span class="line">  <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">  <span class="attr">margin</span>: 10px; </span><br><span class="line">  <span class="attr">padding</span>: 10px; </span><br><span class="line">  font-<span class="attr">size</span>: 14px; </span><br><span class="line">  <span class="attr">color</span>: #<span class="number">000</span>; </span><br><span class="line">  background-<span class="attr">color</span>: red; </span><br><span class="line">  border-<span class="attr">radius</span>: 2px; </span><br><span class="line">  line-<span class="attr">height</span>: <span class="number">1.42</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="样式覆盖"><a href="#样式覆盖" class="headerlink" title="样式覆盖"></a>样式覆盖</h4><p>组件内部需要覆盖UI框架样式，必须在最外层组件加类名</p><h4 id="注释规范-2"><a href="#注释规范-2" class="headerlink" title="注释规范"></a>注释规范</h4><p>以&#x2F; 注释内容 &#x2F;格式注释，前后空格，嵌套子类需要一个回车分割开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注释内容 */</span></span><br><span class="line">.<span class="property">pha</span>-element &#123;</span><br><span class="line">  <span class="attr">width</span>: 20px;</span><br><span class="line">  <span class="comment">/* 这里需要换行 */</span> </span><br><span class="line">  .<span class="property">pha</span>-element-l &#123; </span><br><span class="line">    <span class="attr">color</span>: blue </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>代码规范这套并非是越严格越好，而是要根据团队的特性不断调整修改。</p><p>随着团队的逐渐磨合，这样开发效率会逐渐提高。</p><p>当本次代码规范磨合完成并证实确实可行有效之后，会在掘金上整合出一份代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7331714933388525580?searchId=20240620205348AEFE866814D0411E41DB">前端代码规范（vue篇）</a></p><p><a href="https://crazystudent13.cn/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB">浅析ref与reactvie的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次是基于最近工作团队协作中，不同风格的代码书写风格放在一个项目中，导致整个项目的打包变得异常闹心。&lt;/p&gt;
&lt;p&gt;这种问题也是老生常谈了，为了让团队能够更协调的推进项目，这里遵守约定大于配置的规则，整理一套相对宽松的前端规范，以便于所有组员开发。&lt;/p&gt;
&lt;p&gt;本次项目以vue3为主，所以这里前端代码风格的核心是偏向vue3的，大家酌情自取。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解vue修饰符</title>
    <link href="https://crazystudent13.github.io/2024/06/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://crazystudent13.github.io/2024/06/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2024-06-19T14:35:06.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>本来没想整理的，基本上是用到的时候现查为主。</p><p>然后刷到一个面试题要求随便举几个例子，虽然磕磕绊绊的说出来了一些，但是这实在不符合一个老前端应有的知识储备。</p><p>索性这里统一整理下，反正也不是太麻烦的事情。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>事件修饰符Vue框架本身提供的事件语法糖，无论是V2还是V3，大部分都是通用的。</p><p>这里就不详细去分析他们的原理，仅收集供面试和平时开发时使用。</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在正式进入事件修饰符事件之前，我们需要先简单了解一些概念，不然新人直接看这些修饰符可能会懵。</p><h4 id="事件相关内容委托"><a href="#事件相关内容委托" class="headerlink" title="事件相关内容委托"></a>事件相关内容委托</h4><p>众所周知，我们平时写的页面是由DOM树不断嵌套堆叠而成的，当我们与DOM交互的时候，实际上是要穿透这一层层DOM结构，触发到对应节点的事件。</p><p>早年这里会考个面试题，如果每层节点都绑定事件，那么这是这每层事件的执行顺序是怎样的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123; createApp, ref &#125; = Vue</span><br><span class="line">  createApp(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const count = ref(0)</span><br><span class="line">        return &#123; count &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      test(num)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div @click=&quot;test(1)&quot;&gt;</span><br><span class="line">        &lt;div @click=&quot;test(2)&quot;&gt;</span><br><span class="line">            &lt;div @click=&quot;test(3)&quot;&gt;</span><br><span class="line">            测试</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">  &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 输出结果：</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>看到这个结果，我们可能会疑惑，为什么最外层的绑定的事件反而最后才触发？</p><p>由此，我们需要明白两个基础概念：<strong>事件冒泡</strong> 与 <strong>事件委托</strong>。</p><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p><code>事件冒泡（dubbed bubbling）</code>：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 <code>window</code> （注意这里传递的仅仅是事件，例如<code>click、focus</code>等等这些事件， 并不传递所绑定的事件函数。）</p><p>事件源 &#x3D;&gt;根节点（由内到外）进行事件传播。</p><p>所以我们会发现，这次的事件触发结果，实际上就是由内而外的执行。</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p><code>事件捕获（event capturing）</code>： 当鼠标点击或者触发<code>dom</code>事件时（被触发<code>dom</code>事件的这个元素被叫作事件源），浏览器会从根节点 &#x3D;&gt;事件源（由外到内）进行事件传播。</p><p>事件捕获与事件冒泡是比较类似的，最大的不同在于事件传播的方向。</p><p>这里我们不再用vue讨巧举例了，因为vue的事件本质上就是封装了事件注册方法：<code>addEventListener(&#39;click&#39;,() =&gt;&#123;&#125;, false)</code>。</p><p>事件注册：<code>addEventListener</code>，通过控制最后一个传值，我们就能决定触发的方向是由内向外还是由外向内。</p><p>我们将三个div，由外到内命名为：big，center，small，再看一结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">big.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big----事件捕获&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">center.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;center----事件捕获&#x27;</span>)</span><br><span class="line">&#125;，<span class="literal">true</span>)</span><br><span class="line">small.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;small----事件捕获&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">big.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big----事件冒泡&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">center.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;center----事件冒泡&#x27;</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">small.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;small----事件冒泡&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// big----事件捕获</span></span><br><span class="line"><span class="comment">// center----事件捕获</span></span><br><span class="line"><span class="comment">// small----事件捕获</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// small----事件冒泡</span></span><br><span class="line"><span class="comment">// center----事件冒泡</span></span><br><span class="line"><span class="comment">// big----事件冒泡</span></span><br></pre></td></tr></table></figure><p>这里我们就会发现，两者的触发方向完全不一样。</p><ul><li>事件冒泡：由内向外。</li><li>事件捕获：由外向内。</li></ul><h5 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h5><p>当点击页面的表格内的按钮时候，有时候我们会触发行点击事件，这时候我们希望仅仅点击按钮，那么我们必然要阻止这种事件传播的问题。</p><p>阻止事件传播，常用的有两种方法：</p><ul><li><code>event.stopPropagation()</code> 阻止事件传播，<code>不会</code>阻止同一元素上的其他的事件处理程。</li><li><code>event.stopImmediatePropagation()</code> 阻止事件传播，<code>会</code>阻止同一元素上的其他的事件处理程。</li></ul><p>当然也不仅仅局限于此，有时候，表单被提交时默认的submit事件，我们不希望触发，这里我们也可以通过这种方式阻止这些默认事件。</p><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p><code>事件委托</code>也称为<code>事件代理</code>。</p><p>就是利用<code>事件冒泡</code>，把子元素的事件都绑定到父元素上。</p><p>如果子元素阻止了事件冒泡，那么委托就无法实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><p>现在要为每一个<code>li</code>添加一个事件，假设<code>li</code>有100个，于是就需要为每一个<code>li</code>添加一个事件，这样会占用100个内存。</p><p>因此，如果使用事件委托的话，可以利用事件的冒泡机制，为<code>ul</code>绑定一个事件，那么点击任意一个<code>li</code>的时候，都会将事件触发到父元素<code>ul</code>上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用<code>event.target</code>获取到点击的元素，<code>event.target.innerHTML</code>获取到点击的元素的内容。 如下代码，当你点击<code>li</code>时，会添加一个红色的背景，再次点击，会将背景变为白色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ulE = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ulE.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ulE event&#x27;</span>, event.<span class="property">target</span>, event.<span class="property">target</span>.<span class="property">innerHTML</span>)</span><br><span class="line">  <span class="keyword">const</span> target = event.<span class="property">target</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">style</span>.<span class="property">backgroundColor</span> !== <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单的来说，就是事件的目标源委托给父级元素，减少性能的损耗。</p><p>故此，使用<code>事件代理/委托</code>可以提高性能，减少注册的事件。</p><h4 id="v-on事件修饰符"><a href="#v-on事件修饰符" class="headerlink" title="v-on事件修饰符"></a><code>v-on</code>事件修饰符</h4><p>vue官方提供了很多处理事件的修饰符，主要我们平时很多用不到，所以并未深入了解。</p><p>我这里简单的按照使用频率，将事件修饰符分为通用修饰符和特殊修饰符，特殊修饰符我会单独讲一下它们的应用场景。</p><h5 id="通用修饰符"><a href="#通用修饰符" class="headerlink" title="通用修饰符"></a>通用修饰符</h5><p>这些修饰符有些在vue2中，Vue3就没有了相应的修饰符，所以这里会备注一下支持的版本。</p><table><thead><tr><th>修饰符名称</th><th>支持版本</th><th>事件</th><th>备注</th></tr></thead><tbody><tr><td><code>.native</code></td><td>v2</td><td>监听组件根元素的原生事件</td><td></td></tr><tr><td><code>.prevent</code></td><td>v2,v3</td><td>阻止事件的默认动作</td><td>比如表单默认的submit按钮会刷新页面，我们用这个就可以阻止刷新页面</td></tr><tr><td><code>.once</code></td><td>v2,v3</td><td>仅触发一次</td><td>可用来避免用户重复点击导致多次提交表单</td></tr><tr><td><code>.stop</code></td><td>v2,v3</td><td>阻止事件传播&#x2F;冒泡</td><td>避免事件冒泡触发了父元素的方法</td></tr><tr><td><code>.self</code></td><td>v2,v3</td><td>只当事件是从侦听器绑定的元素本身触发时才触发回调。</td><td>通过事件委托的形式，减少页面性能小号</td></tr><tr><td><code>.passive</code></td><td>v2,v3</td><td>滚动事件的默认行为 (scrolling) 将立即发生而非等待 <code>onScroll</code> 完成</td><td>移动端常用处理滚动监听，PC端很少用</td></tr><tr><td><code>.capture</code></td><td>v2,v3</td><td>指向内部元素的事件，在被内部元素处理前，先被外部处理</td><td>采用了捕获的方式，可以调整执行顺序</td></tr></tbody></table><blockquote><p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。</p><p>因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为</strong>。</p><p>而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p></blockquote><h5 id="passive修饰符"><a href="#passive修饰符" class="headerlink" title=".passive修饰符"></a>.passive修饰符</h5><p><code>.passive</code> 修饰符一般用于触摸事件的监听器，可以用来<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">改善移动端设备的滚屏性能</a>，详情参考CSDN的这篇：<a href="https://blog.csdn.net/weixin_43524214/article/details/136574108">Vue事件处理:.passive修饰符与应用场景</a></p><blockquote><p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。</p><p>如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告。</p></blockquote><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p><code>.&#123;keycode | keyAlias&#125;</code> </p><p>键盘中每个按键都有自己对应的keycode，vue提供的语法糖，让我们可以直接使用对应事件绑定，也可以用对应的keycode绑定。</p><p>这里，我们以常用的回车事件为例子，我们按键加入enter修饰符，代表我们点击回车时，可以触发<code>test()</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> @<span class="attr">keypress.enter</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span> @<span class="attr">keypress.13</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- enter事件的keycode对应13，所以这两个例子都是回车触发按钮。 --&gt;</span> </span><br></pre></td></tr></table></figure><p>这里我们就可以发现，使用keycode和修饰符都可以达到对应的效果。</p><p>vue官方提供了很多便利性的事件，如果您需要将方法绑定对应的按钮，不妨参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/keyCode">MDN的KeyCode码表</a>，这样绑定会方便很多。</p><table><thead><tr><th>修饰符名称</th><th>事件</th></tr></thead><tbody><tr><td><code>.enter</code></td><td>回车</td></tr><tr><td><code>.delete</code></td><td>Delete或Backspace</td></tr><tr><td><code>.ctrl</code></td><td>ctrl按键</td></tr><tr><td><code>.alt</code></td><td>alt按键</td></tr><tr><td><code>.shift</code></td><td>shift按键</td></tr><tr><td><code>.tab</code></td><td>tab按键</td></tr><tr><td><code>.esc</code></td><td>esc按键</td></tr><tr><td><code>.space</code></td><td>space空格按键</td></tr><tr><td><code>.up</code>,<code>.down</code>,<code>.left</code>,<code>.right</code></td><td>上下左右方向键</td></tr><tr><td><code>.meta</code></td><td>win键&#x2F;mac的commond键</td></tr><tr><td>[<code>.exact</code>](<!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --> &lt;button @click.ctrl&#x3D;”onClick”&gt;A</button> <!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --> &lt;button @click.ctrl.exact&#x3D;”onCtrlClick”&gt;A</button> <!-- 仅当没有按下任何系统按键时触发 --> &lt;button @click.exact&#x3D;”onClick”&gt;A</button>)</td><td>修饰符允许精确控制触发事件所需的系统修饰符的组合。</td></tr></tbody></table><blockquote><p>注意：如果多个组件注册了键盘事件，最好销毁，保证键盘事件的唯一性，不然有时候会导致整个页面出现一些意料之外的问题。</p></blockquote><p>另外，有人可能对exact的描述有些迷惑，这里放一下官方的例子，一看就明白，就是为了精确操作使用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span><br><span class="line">&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure><h4 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h4><p><code>@click</code>鼠标事件，没什么好说的。</p><table><thead><tr><th>修饰符名称</th><th>事件</th></tr></thead><tbody><tr><td><code>.left</code></td><td>左键</td></tr><tr><td><code>.right</code></td><td>右键</td></tr><tr><td><code>.middle</code></td><td>中间</td></tr></tbody></table><h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind">v-bind</a></h4><p>v-bind的修饰符我们几乎很少用，这里推荐大家看看，知道有这么回事儿就行。</p><table><thead><tr><th>修饰符名称</th><th>备注</th></tr></thead><tbody><tr><td><code>.prop</code></td><td>强制绑定为 DOM property</td></tr><tr><td><code>.attr</code></td><td>强制绑定为 DOM attribute</td></tr><tr><td><code>.camel</code></td><td>将短横线命名的 attribute 转变为驼峰式命名</td></tr><tr><td><code>.sync</code></td><td>vue2支持，vue3不支持了。</td></tr></tbody></table><p>这里直接放一下官方的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绑定 attribute --&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名 --&gt;</span><br><span class="line">&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src=&quot;imageSrc&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src=&quot;src&quot; --&gt;</span><br><span class="line">&lt;img :src /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名的缩写 --&gt;</span><br><span class="line">&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定对象形式的 attribute --&gt;</span><br><span class="line">&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop” 必须在子组件中已声明。 --&gt;</span><br><span class="line">&lt;MyComponent :prop=&quot;someThing&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传递子父组件共有的 prop --&gt;</span><br><span class="line">&lt;MyComponent v-bind=&quot;$props&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- XLink --&gt;</span><br><span class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><table><thead><tr><th>修饰符名称</th><th>备注</th></tr></thead><tbody><tr><td><code>.trim</code></td><td>去除输入框首尾字符串</td></tr><tr><td><code>.number</code></td><td>将用户输入的类型由string型转为number型</td></tr><tr><td><code>.lazy</code></td><td>使得用户在输入数据之后，当数据失去焦点或点击回车时，才会进行数据的更新</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事件修饰符平时用的不多，最多就是输入框判空，表单单次提交，键盘回车等常用事件的使用，平时没有别的用法。</p><p>关于事件冒泡和事件捕获，这个就更是远古面试题了，如今在梳理修饰符时候刷到，属实有点老乡见老乡了。</p><p>如今仔细梳理了一番，感觉自己确实受益匪浅。</p><p>虽然依然用的场景可能不太多，但是相对以前，可能在开发中会更得心应手一些？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/guide/essentials/event-handling.html#exact-modifier">Vue3-事件处理</a></p><p><a href="https://juejin.cn/post/7327686547809124386">浅谈js的事件机制，事件冒泡、事件捕获、事件代理(事件委托)</a></p><p><a href="https://juejin.cn/post/7192584563799883832?searchId=20240620234605BBB5CDD54E47D434F762">JS中的事件冒泡、事件捕获、事件委托</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%EF%BC%9F">MDN_什么是事件</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来没想整理的，基本上是用到的时候现查为主。&lt;/p&gt;
&lt;p&gt;然后刷到一个面试题要求随便举几个例子，虽然磕磕绊绊的说出来了一些，但是这实在不符合一个老前端应有的知识储备。&lt;/p&gt;
&lt;p&gt;索性这里统一整理下，反正也不是太麻烦的事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>vue3生命周期</title>
    <link href="https://crazystudent13.github.io/2024/06/19/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://crazystudent13.github.io/2024/06/19/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2024-06-19T12:12:04.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>因为今天用vue3写代码，新版的触发钩子已经不再是destory的，这导致我写业务的时候错误排查耽误了些许时间。</p><p>故此，整理此文，增强一下自己的对vue3生命周期的使用熟悉度。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>vue3的生命周期相对于前者没有什么太大的区别，多了一个setup，然后就是钩子函数稍微改了一下名字，别的并无任何修改。</p><p>这里默认大家都清楚vue2的生命周期中的钩子函数，这里就不展开与vue2比较了，直奔主题。</p><blockquote><p>钩子函数（hook）：一种在系统或程序处理消息时被自动调用的函数。</p><p>个人理解，因为这种机制就像是牵动钩子拉起一串程序，因为被称作钩子函数，很形象。</p></blockquote><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><p>相对于vue2多了setup，并且组合式的写法名字有所变化，同时destroy换为了unmount。</p><table><thead><tr><th>选项式</th><th>组合式</th><th>备注</th></tr></thead><tbody><tr><td></td><td><code>setup</code></td><td>setup执行在所有钩子函数之前。</td></tr><tr><td><code>beforeCreate</code></td><td></td><td>创建实例之前调用，此时实例的数据观测、事件等还未初始化。</td></tr><tr><td><code>created</code></td><td></td><td>创建实例后调用，此时实例的数据观测、事件等已经初始化完成。</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount()</code></td><td>挂载实例之前调用，此时模板已经编译完成，但是还未挂载到DOM。</td></tr><tr><td><code>mounted</code></td><td><code>onMounted()</code></td><td>挂载实例后调用，此时实例已经挂载到DOM，可以进行DOM操作。</td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate()</code></td><td>数据更新之前调用，此时可以进行状态的最后更改。</td></tr><tr><td><code>updated</code></td><td><code>onUpdated()</code></td><td>数据更新后调用，此时DOM已经完成更新，可以进行DOM操作。</td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount()</code></td><td>卸载实例之前调用，此时实例仍然完全可用。</td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted()</code></td><td>卸载实例后调用，此时实例已经完全卸载。</td></tr></tbody></table><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>这里放了一下官方的汉化图，看的更清楚一些。</p><p><img src="https://s2.loli.net/2024/06/18/vTxqXj6D1EQOnUo.png" alt="QQ截图20240618201244"></p><h3 id="选项式与组合式"><a href="#选项式与组合式" class="headerlink" title="选项式与组合式"></a>选项式与组合式</h3><p>在组合式 API 中，<code>beforeCreate</code> 、<code>created</code> 生命周期由 setup 函数代替。</p><p>即在 <code>beforeCreate</code> 、<code>created</code> 生命周期选项中编写的代码，都可以写在 setup 函数中。</p><p>同一个生命周期，同时用选项式 API 和组合式 API 中注册，组合式 API 中的生命周期函数会先于选项式 API 中的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 后输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;mounted1&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 先输出</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;mounted2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// mounted2 会比 mounted1 先输出。</span></span><br></pre></td></tr></table></figure><h3 id="其他钩子"><a href="#其他钩子" class="headerlink" title="其他钩子"></a>其他钩子</h3><blockquote><p>关于所有生命周期钩子函数，推荐看这个大佬整理的问：<a href="https://juejin.cn/post/7352075662453702694?searchId=20240618195833939AD610B79031D8EF9E">一文吃透 Vue3 组件的 16 个生命周期</a></p></blockquote><p>这些钩子函数点陌生，以前可能大多没见过，这里看到有大佬做了整理，这里我引用一下</p><p>其中有一部分钩子函数很眼熟的。</p><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><table><thead><tr><th>选项式</th><th>组合式</th><th>备注</th></tr></thead><tbody><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured()</code></td><td>注册一个钩子，在捕获了后代组件传递的错误时调用。</td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked()</code></td><td>注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用</strong>。</td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered()</code></td><td>注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用</strong>。</td></tr><tr><td><code>activated</code></td><td><code>onActivated()</code></td><td>仅针对 KeepAlive 包裹的组件。注册一个回调函数，当组件被插入到 DOM 中时调用。<strong>这个钩子在服务器端渲染期间不会被调用</strong> 。</td></tr><tr><td><code>deactivated</code></td><td><code>onDeactivated()</code></td><td>仅针对 KeepAlive 包裹的组件。注册一个回调函数，当组件从 DOM 中被移除时调用。<strong>这个钩子在服务器端渲染期间不会被调用</strong> 。</td></tr><tr><td><code>serverPrefetch</code></td><td><code>onServerPrefetch()</code></td><td>仅在服务端渲染期间使用，用于注册一个异步函数，在组件实例在服务器上被渲染之前调用。可用于在服务器上请求后台接口数据，它比在客户端上请求后台数据更快。</td></tr></tbody></table><blockquote><p>有关 <code>onErrorCaptured()</code> 更多详细信息参考这个大佬写的另一篇文章：<a href="https://juejin.cn/post/7329033936956260362">深入源码，剖析 Vue3 是如何做错误处理的</a></p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在组合式 API 中，<code>beforeCreate</code> 和 <code>created</code> 生命周期函数已经被 setup 函数取代了，很多时候我们在写组合式的API的时候，并不考虑使用create相关的两个生命周期方法。</p><ul><li><code>beforeCreate</code> 生命周期函数会在组件实例初始化完成并且 props 被解析后立即调用。</li><li><code>created</code> 生命周期函数在组件实例处理完所有与状态相关的选项后调用。</li><li><code>beforeMount</code> 生命周期函数在组件被挂载之前调用</li><li><code>mounted</code> 生命周期函数在组件被挂载之后调用</li><li><code>beforeUpdate</code> 生命周期函数在组件即将因为响应式状态变更而更新其 DOM 树之前调用。</li><li><code>updated</code> 生命周期函数在组件因为响应式状态变更而更新其 DOM 树之后调用</li><li><code>beforeUnmount</code> 生命周期函数在一个组件实例被卸载之前调用</li><li><code>unmounted</code> 生命周期函数在一个组件实例被卸载之后调用</li></ul><blockquote><p><code>beforeUnmount</code> 和 <code>unmounted</code> 用于替代被废弃的 <code>beforeDestroy</code> 和<code>destroyed</code> 生命周期函数</p></blockquote><ul><li><code>errorCaptured</code> 生命周期函数在捕获了后代组件传递的错误时调用</li><li><code>renderTracked</code> 生命周期函数在组件渲染过程中追踪到响应式依赖时调用</li><li><code>renderTriggered</code> 生命周期函数在响应式依赖的变更触发了组件渲染时调用</li></ul><blockquote><p><code>renderTracked</code> 和 <code>renderTriggered</code> 生命周期函数仅在 DEV 模式下可用</p></blockquote><ul><li><code>activated</code> 生命周期函数与 KeepAlive 组件有关，当组件被插入到 DOM 中时调用</li><li><code>deactivated</code> 生命周期函数也与 KeepAlive 组件有关，当组件从 DOM 中被移除时调用</li><li><code>serverPrefetch</code> 生命周期函数在组件实例在服务器上被渲染之前调用，仅在服务器渲染期间调用。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vue3的生命周期钩子虽然多了一些，但实际开发过程中，大多人主要应该也是用组合式写一下onMounted就可以，没必要太过深入。</p><p>至于选项式API，在vue3的时代中，估计未来很少有人使用。</p><p>官方之所以提供选项式的写法，估计也是为了大部分人能够习惯过渡一下，所以这里就不细说选项式与组合式写法的优先级问题了。</p><p>本文受限于现阶段开发的见识不足，后续如有新的认知，会视情况更新。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html">生命周期钩子 | Vue.js (vuejs.org)</a></p><p><a href="https://juejin.cn/post/7352075662453702694?searchId=20240618195833939AD610B79031D8EF9E">一文吃透 Vue3 组件的 16 个生命周期</a></p><p><a href="https://juejin.cn/post/7329033936956260362">深入源码，剖析 Vue3 是如何做错误处理的</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为今天用vue3写代码，新版的触发钩子已经不再是destory的，这导致我写业务的时候错误排查耽误了些许时间。&lt;/p&gt;
&lt;p&gt;故此，整理此文，增强一下自己的对vue3生命周期的使用熟悉度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue3" scheme="https://crazystudent13.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue路由概念及实现逻辑</title>
    <link href="https://crazystudent13.github.io/2024/06/17/%E6%B5%85%E6%9E%90vue%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"/>
    <id>https://crazystudent13.github.io/2024/06/17/%E6%B5%85%E6%9E%90vue%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/</id>
    <published>2024-06-17T13:47:11.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：您能说说vue的路由模式吗？</p><p>我：hash和history，hash相对于传统模式不够美观，是spa独有的类型，无法服务端渲染，history是传统的方式，更符合平时的使用直觉，大概是这样。</p><p>面试官：您能更详细的说说吗？</p><p>我：行。。。。你故意找茬是吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这种问题其实算是很早之前刷过的面试题了，但是实际开发过程中基本没细研究过，除了在服务端渲染的时候稍微了解了一下，后续确实没有深入了解。</p><p>而这也是三年前端必须要掌握的基础功能了，我这里没有深入了解，确实显得基础不扎实了。</p><h3 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h3><p>在正式了解vue实现逻辑之前，我们先了解一下路由的一些概念。</p><h4 id="后端路由（传统路由）"><a href="#后端路由（传统路由）" class="headerlink" title="后端路由（传统路由）"></a>后端路由（传统路由）</h4><p>传统的 Web 应用都是由多个页面组成，页面之间通过链接的方式进行跳转。</p><p>每切换一个页面，就由浏览器发起页面请求，后端服务器接收到请求，对这个地址进行匹配，找到这个地址对应的逻辑，解析地址及参数，最终返回这个地址对应的页面 HTML。</p><p>这个对请求地址进行匹配的逻辑就被称为路由，它是在后端发生的，因此也叫<strong>后端路由</strong>。</p><p>对后端路由来说，每一个页面对于前端代码来说都是全新的，前端代码在页面加载的时候开始运行，在页面关闭或者跳到下一个页面的时候结束运行。</p><p>这种类型的路由便于网络爬虫抓取，便于搜索殷勤收录，所以这种路由模式更适合一些官网或展示类页面。</p><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p>前端路由的概念是随着单页面应用（Single Page Application）的流行而产生的。</p><p>单页面应用，是指整个 Web 应用只有一个页面。</p><p>由浏览器发起请求再由后端返回页面 HTML 这样的过程只会在第一次访问时发生。</p><p>在第一次请求完毕后，后面的页面逻辑都由前端进行控制。</p><p>好处是一旦用户完成第一次页面加载，在后续的使用中，用户都不会看到页面加载的过程，从而获得更流畅的使用体验，也减少了服务器的压力。</p><p>坏处在于，失去了 Web 应用最核心的特性 <code>URL</code>。</p><p>一个典型的前端路由在单页面场景下大概需要关注以下几个问题：</p><ol><li>定义路由表，即各种 URL 分别对应哪些逻辑（一般来说就是对应界面的渲染）。</li><li>获取当前访问的 URL，并根据路由表匹配中对应的逻辑并调用它（渲染对应的界面）。</li><li>处理链接跳转，如果链接地址是在单页面应用的范围内，则不能使用浏览器导航，而是直接完成新 URL 对应的界面的渲染，并将浏览器中显示的 URL 更新为新界面对应的 URL。</li><li>监视 URL 的变更，当用户手工更改 URL 或者有其它逻辑更改了 URL 之后，需要重新进行路由匹配并完成界面的渲染。</li></ol><p>一般来说，</p><p>（1）是纯计算逻辑，不需要什么特别的处理，（2）可以由 location 这个 API 进行获取，因此前端路由中值得关注的核心问题主要就是 （3）和 （4），简单地归纳就是更新浏览器 URL 和监视浏览器 URL 改变。</p><p>单页面应用因为不需要关注网络搜索引擎的收录，所以更适合用在管理系统中。</p><p>而且，相对于传统模式，这种前端路由不需要服务器进行渲染处理，所以可以大幅减少服务器压力，在现代开发中更推荐使用。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>这里的vue模式，主要是针对<a href="https://router.vuejs.org/zh/">Vue-Router</a>推出的两种模式做个总结，我个人对react不是很熟，所以不清楚react是否也有类似的路由组件。</p><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>对于一个 URL 如：<code>/home#/hello/world</code>，其中的 hash 部分就是<code>#/hello/world</code>。</p><p>当我们在单页面应用中切换到另一个页面时，修改 hash 即可。</p><p>hash 部分在浏览器导航的时候并不会被传给后端服务器，也可以方便地用 JavaScript 修改，并且修改它时也不会发生重新导航的情况，因此对于单页面应用来说，非常适合用来作为前端路由的方案。</p><p>对于 hash 模式下 URL 的监听：</p><ul><li>老旧的浏览器，使用定时器，定时获取浏览器的 URL，并与之前的结果比对</li><li>较新的浏览器提供了 hashchange 事件，直接监听这个事件即可</li><li>更新的浏览器提供了 popstate 事件</li></ul><p>hash 模式的缺点：</p><ul><li>不符合用户的固有认知，也不太美观</li><li>hash 部分不会被传递给后端服务器，导致没有办法进行服务端渲染，进而影响搜索引擎的收录</li><li>和a元素的锚点跳转的功能冲突，导致a元素的锚点跳转无法使用</li></ul><h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><p>在单页面应用下，这个模式的核心在于 history.pushState(state, title, url) 这个 API，它的含义是向浏览器的历史栈（即前进后退的栈）中压入一个新的状态，从逻辑上相当于跳转到了一个新的页面，但是并不真的重新加载或重新导航。</p><p>使用这个 API 很方便地修改浏览器中的 URL，并正确地处理前进 &#x2F; 后退的问题。</p><p>该模式下对 URL 的监听使用 popstate 事件。</p><p>当用户进行导航动作（前进 &#x2F; 后退等）或有 history.back()、history.forward() 之类的调用时，popstate 事件就会发生。</p><h3 id="占位组件"><a href="#占位组件" class="headerlink" title="占位组件"></a>占位组件</h3><p>Vue-Router 的作用不仅是管理路由，还需要配合 Vue 完成路由对应界面的渲染，Vue 本身是声明式渲染的，而 Vue-Router 通过声明组件（<code>&lt;router-view&gt;</code>）的方式来接管渲染。</p><p>当开发者使用 Vue-Router 时，<code>&lt;router-view&gt;</code> 组件会被全局注册，但它并没有具体的内容可渲染，当渲染到 <code>&lt;router-view&gt;</code> 时，就会由 Vue-Router 来决定这个组件的位置应该渲染哪个界面，从而实现从 URL 到路由匹配再到渲染对应界面的过程。</p><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>这里主要讲vue-router源码的实现逻辑，这里就是简单看看，没必要深入。</p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>Vue.use() 是 Vue 提供的用来安装插件的方法，它要求参数提供一个 install() 方法，Vue 会调用这个 install() 方法完成安装。</p><p>vue-router 的 install() 方法位于一个单独的文件，即 src&#x2F;install.js。</p><p>install() 方法主要做了这么几件事情：</p><ul><li>声明了 beforeCreate() 和 destroyed() 两个 mixin，这样在 Vue 实例的生命周期中能够处理 vue-router 相关的逻辑。</li><li>声明了两个属性 router和router 和 router和route，分别指向了 this._routerRoot 对象上的_router 和_route。</li><li>将_route 变成响应式数据，这样当它变更的时候就会触发组件的重新渲染。</li><li>声明了两个全局组件 RouterView 和 RouterLink，这正是我们经常使用的 <code>&lt;router-view&gt;</code> 和 <code>&lt;router-link&gt;</code>。</li></ul><h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><p>声明 VueRouter 类，代码位于 src&#x2F;index.js，new VueRouter() 时调用。</p><p>初始化时主要有这样几件事情：</p><ul><li>创建了用于进行 URL 匹配的路由表。路由表用来存储定义好的路由与对应的页面组件（用于在 <code>&lt;router-view&gt;</code> 中渲染）的关系。</li><li>根据 mode 配置项决定使用 hash 模式还是 history 模式。</li><li>根据对应的模式，选择负责管理历史记录和 URL 的 History 子类，初始化后赋值给 this.history。</li></ul><p>VueRouter 类中 通过<code>this.matcher = createMatcher(options.routes || [], this)</code>创建路由表。</p><p><code>createMatcher</code>方法源码位于 src&#x2F;create-matcher.js 。</p><p>使用名称或 URL 匹配路由表中定义好的路由，参数解析（如解析 &#x2F;foo&#x2F;:bar），子路由处理，别名 alias 处理，都是通过 <code>createMatcher</code> 处理的。</p><p>最后会返回Route对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">route</span>: <span class="title class_">Route</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: location.<span class="property">name</span> || (record &amp;&amp; record.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">meta</span>: (record &amp;&amp; record.<span class="property">meta</span>) || &#123;&#125;,</span><br><span class="line">  <span class="attr">path</span>: location.<span class="property">path</span> || <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">hash</span>: location.<span class="property">hash</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  query,</span><br><span class="line">  <span class="attr">params</span>: location.<span class="property">params</span> || &#123;&#125;,</span><br><span class="line">  <span class="attr">fullPath</span>: <span class="title function_">getFullPath</span>(location, stringifyQuery),</span><br><span class="line">  <span class="attr">matched</span>: record ? <span class="title function_">formatMatch</span>(record) : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一说的是，传入一个路由的时候，路由会被编译成一个正则表达式进行参数解析（rc&#x2F;create-matcher.js&#x2F;matchRoute）。</p><p>如传入一个路由 &#x2F;foo&#x2F;:bar：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [];</span><br><span class="line"><span class="keyword">const</span> regexp = <span class="title function_">pathToRegexp</span>(<span class="string">&quot;/foo/:bar&quot;</span>, keys);</span><br><span class="line"><span class="comment">// regexp = /^\/foo(?:\/([^\/#\?]+?))[\/#\?]?$/i</span></span><br><span class="line"><span class="comment">// keys = [&#123; name: &#x27;bar&#x27;, prefix: &#x27;/&#x27;, suffix: &#x27;&#x27;, pattern: &#x27;[^\\/#\\?]+?&#x27;, modifier: &#x27;&#x27; &#125;]</span></span><br></pre></td></tr></table></figure><p>如果有参数则将参数从匹配的结果中取出，最终放到 Route 对象中的 params 属性中。</p><h3 id="路由模式的实现"><a href="#路由模式的实现" class="headerlink" title="路由模式的实现"></a>路由模式的实现</h3><p>路由模式的处理源码在 src&#x2F;history 目录下，hash 模式的处理逻辑在 hash.js， history 模式在 html5.js中，两个类的接口很相似。</p><p>路由模式的实现主要任务点在，更新浏览器 URL（ensureURL 方法） 和监视浏览器 URL 改变（setupListeners 方法）。</p><p>处理完之后回到VueRouter 类的 init 方法修改 _route, _route 是一个响应式数据，当它发生变更的时候，组件会重新渲染。</p><h3 id="RouterView-和-RouterLink"><a href="#RouterView-和-RouterLink" class="headerlink" title="RouterView 和 RouterLink"></a>RouterView 和 RouterLink</h3><h4 id="RouterView"><a href="#RouterView" class="headerlink" title="RouterView"></a>RouterView</h4><p><code>RouterView</code>的主要作用就是将当前匹配的路由的组件渲染出来，因为当前是哪个组件是会动态变化的，因此 Vue-Router 选择了使用 render() 方法来实现。</p><p>首先从路由中取出对应的组件，然后使用 h() 方法（即 createElement() 方法）返回组件的虚拟 DOM，后续跟 Vue 中的组件渲染一样。</p><h4 id="RouterLink"><a href="#RouterLink" class="headerlink" title="RouterLink"></a>RouterLink</h4><p><code>RouterLink</code>主要是对链接的事件做了拦截，当点击链接的时候，会尝试调用 router.push() 或者 router.replace() 方法来完成导航，并阻止浏览器默认的导航，从而使这些链接也变成前端路由接管。</p><p>如果我们查看页面渲染的出来的H5源码，我们也会发现，<code>routerLink</code>会完成</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vueRouter实现的很精妙，极大的方便了我们日常切换不同功能模块的需求。</p><p>如今，vueRouter几乎已经是开发中必须的插件，对其略作深入的了解也是必须的，虽然出在面试题中不算合理，但是也是考量了开发者的了解广度。</p><p>虽然，我仍然觉得意义不大，不过确实算是扩充了一些熟悉的知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7380241307116765194">Vue-Router 前端路由原理</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：您能说说vue的路由模式吗？&lt;/p&gt;
&lt;p&gt;我：hash和history，hash相对于传统模式不够美观，是spa独有的类型，无法服务端渲染，history是传统的方式，更符合平时的使用直觉，大概是这样。&lt;/p&gt;
&lt;p&gt;面试官：您能更详细的说说吗？&lt;/p&gt;
&lt;p&gt;我：行。。。。你故意找茬是吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
  </entry>
  
  <entry>
    <title>10分钟了解set,map,weakset,weakmap</title>
    <link href="https://crazystudent13.github.io/2024/06/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3set,map,weakset,weakmap/"/>
    <id>https://crazystudent13.github.io/2024/06/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3set,map,weakset,weakmap/</id>
    <published>2024-06-17T12:17:57.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>面试官（朋友）：看简历上，您对JS很熟悉，您了解set和map吗？</p><p>我：set我常用来做数据去重，map没了解过。</p><p>面试官（朋友）：哈哈哈，您真是太幽默了，欢迎那您来参加面试，后续人事会通知您面试结果的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于set和map的面试题，我个人确实没怎么看，除了一开始翻过ES6的书，记得要用set去重数组之外，后续就没有深入了解了。</p><p>我甚至记不得weakset和weakmap这两种。</p><p>这里今天朋友客串了一把面试官，然后狠狠地嘲笑了我一顿，想想真是糟糕。</p><h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h3><p>Set和Map是ES6新增加的数据类型。其中Set被称作“集合”，Map被称作“映射”。</p><p>新增的这两个数据结构提供了更灵活和强大的方式来处理和存储数据。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是一个简单值的集合，类似于数组。Set的特点：Set成员的值都是唯一的，不允许重复。</p><p>通过Set这一特性，可以运用Set进行去重操作。</p><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><p>通过数组的解构和Set无重复值的特性，可以产生一个数组去重的小妙招。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br><span class="line"><span class="comment">// 结果:[1,2,3]</span></span><br></pre></td></tr></table></figure><h6 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h6><p>数组可以通过Set特性去重，而且数组还有join方法可以将数组转换成字符串，这样我们可以联想到字符串去重的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abcabcaaa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> newStr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr);</span><br><span class="line"><span class="comment">// 结果：abc</span></span><br></pre></td></tr></table></figure><h5 id="Set常用方法"><a href="#Set常用方法" class="headerlink" title="Set常用方法"></a>Set常用方法</h5><p>通过<code>new Set()</code>初始化Set对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//或从一个数组创建</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br></pre></td></tr></table></figure><p>调用<code>add(value)</code>方法向 set 集合 中添加指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>调用<code>has(value)</code>方法检查集合中是否存在指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>调用<code>delete（value）</code>方法删除集合中的指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>调用<code>clear()</code>方法清空集合内所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p>set对象中的<code>size</code>属性可以返回集合中元素的数量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>)<span class="comment">//1(不存在重复值)</span></span><br></pre></td></tr></table></figure><h5 id="Set的遍历方法"><a href="#Set的遍历方法" class="headerlink" title="Set的遍历方法"></a>Set的遍历方法</h5><ol><li>调用<code>keys()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素的键。</li><li>调用<code>values()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素的值。</li><li>调用<code>entries()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素（值和键）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3, 4 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure><h5 id="遍历Set的方法"><a href="#遍历Set的方法" class="headerlink" title="遍历Set的方法"></a>遍历Set的方法</h5><p><code>forEach</code>方法</p><p>和数组一样，Set也有forEach方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果为：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果为：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="Set的优缺点"><a href="#Set的优缺点" class="headerlink" title="Set的优缺点"></a>Set的优缺点</h5><ul><li>优点：<ol><li>Set中的元素都是唯一的，不会重复的值。</li><li>因为Set中的值是唯一的，所有查找、删除和添加的操作执行得更快。</li></ol></li><li>缺点：<ol><li>在ES6中，Set保持了插入顺序，但是存在兼容问题。</li><li>与数组不同，Set不能通过索引来访问Set中的元素。</li></ol></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>在普通对象中，对象的键名的类型都是字符串，如果不是字符串类型也会被转换为字符串类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [n]: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">n</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    [[<span class="string">&#x27;测&#x27;</span>]]: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="comment">// 结果：&#123;123: 1, n: 1, name: &#x27;张三&#x27;, &quot;测&quot;: &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>这里我们注意到了，二维数组也被转为了空字符串。</p><p>然而随着需求的不断增加，出现了对象中的键名需要是其他类型的需求，因此JavaScript提供了Map这一数据结构。</p><p>Map这一数据结构允许使用任何值作为键。</p><blockquote><p>注意：不要将数组的map方法和Map数据结构记混。</p></blockquote><h5 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h5><p>通过<code>new Map()</code>初始化Map对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure><p>调用<code>set(key,value)</code>方法向Map中添加一个键值对。</p><p>注意：不要和上面的Set数据结构搞混喽。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>get(key)</code>方法根据提供的键名返回对应的值，如果不存在该键名则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>has(key)</code>方法可以检查是否包含指定的键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>如果包含就返回true，如果不包含就返回false。</p><p>调用<code>delete(key)</code>方法可以删除指定的键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>clear()</code>方法可以删除所有键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p>Map的属性<code>size</code>可以返回键值对数量。（注意size不是方法，而是属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h5 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h5><p>与Set的遍历方法相似。</p><ol><li><code>keys()</code>:返回一个新的迭代器对象，其中包含Map的所有键名。</li><li><code>values()</code>:返回一个新的迭代器对象，其中包含Map的所有键值。</li><li><code>entries()</code>:返回一个新的迭代器对象，其中包含Map的所有键值对。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;1&#x27;</span>], <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;1&#x27;, Array(1)&#125;</span></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;2&#x27;, &#x27;1&#x27;&#125;</span></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;1&#x27; =&gt; &#x27;2&#x27;, Array(1) =&gt; &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="遍历Map的方法"><a href="#遍历Map的方法" class="headerlink" title="遍历Map的方法"></a>遍历Map的方法</h5><p><code>forEach</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 张三</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"><span class="comment">// gender 男</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name 张三</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"><span class="comment">// gender 男</span></span><br></pre></td></tr></table></figure><h5 id="Map的优缺点"><a href="#Map的优缺点" class="headerlink" title="Map的优缺点"></a>Map的优缺点</h5><ul><li>优点：<ul><li>Map可以存储任何类型的键和值</li><li>Map的键也是唯一的，不存在重复的键</li><li>Map内的顺序和插入顺序一致</li></ul></li><li>缺点：<ul><li>Map不能和数组一样通过索引直接访问</li><li>存在兼容IE的问题</li></ul></li></ul><h5 id="Map的应用场景"><a href="#Map的应用场景" class="headerlink" title="Map的应用场景"></a>Map的应用场景</h5><p><code>Map</code>因为是一组键值对的结构，具有极快的查找速度。</p><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure><p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p><p>这里我们用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.<span class="keyword">get</span>(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>，<code>Map</code>具有以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure><h3 id="弱引用和强引用"><a href="#弱引用和强引用" class="headerlink" title="弱引用和强引用"></a>弱引用和强引用</h3><p>WeakSet和WeakMap都是弱引用。</p><p>首先了解一下什么是弱引用。</p><p>弱引用是不能确保其引用的对象不会被垃圾回收器回收的引用，而强引用是确保其引用的对象不会被垃圾回收器回收的引用。</p><p>也就是说，JavaScript引擎在执行代码时，对象通过变量直接赋值形成的引用会被视为强引用，垃圾回收器就不会回收这类对象；</p><p>通过<code>WeakMap</code>和<code>WeakSet</code>建立的引用会被视为弱引用，这类引用无法阻止垃圾回收器的回收。</p><p>当一个变量被设置为<code>null</code>时，会断开该变量与原对象间的引用，该对象就会变成垃圾回收器的回收目标。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = [person]; </span><br><span class="line">person = <span class="literal">null</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); </span><br></pre></td></tr></table></figure><p>创建一个叫<code>person</code>的对象，并将该对象存储到<code>person1</code>中；</p><p>然后将<code>person</code>设置为<code>null</code>，断开引用，但是因为变量<code>person1</code>存在对<code>person</code>对象的强引用，所以该对象不会被垃圾回收器给盯上。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line">person1.<span class="title function_">set</span>(person, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">person = <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 等待垃圾回收后 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); </span><br></pre></td></tr></table></figure><p>创建一个<code>weakMap</code>对象<code>person1</code>和一个对象<code>person</code>，并且将该对象作为键，键值为<code>&quot;张三&quot;</code>添加到<code>person1</code>中；</p><p>然后将变量<code>person</code>设置为<code>null</code>，断开了变量与对象的引用，然而<code>person1</code>对<code>person</code>是弱引用，所以垃圾回收器可以回收<code>person</code>对象。</p><h4 id="WeakSet和WeakMap"><a href="#WeakSet和WeakMap" class="headerlink" title="WeakSet和WeakMap"></a>WeakSet和WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>WeakSet和Set非常相似，但是有一些不同之处：</p><ol><li>成员类型：WeakSet的成员只能是Symbol值和对象，不能是其他的数据类型；Set的成员可以是任意数据类型。</li><li>引用类型：WeakSet是弱引用；Set是强引用。</li><li>方法和属性：WeakSet不支持迭代，所以没有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，并且也没有<code>size</code>属性；Set有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，也有<code>size</code>属性。</li><li>作用：WeakSet可以实现自动清理回收；Set可以通过元素的唯一性用于实现去重工作。</li></ol><h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p>WeakMap和Map也非常相似，但是也是有一些不同：</p><ol><li>键的类型：WeakMap的键类型只能是对象和Symbol值；Map的键类型可以是任意数据类型。</li><li>引用类型：WeakMap是弱引用；Map是强引用。</li><li>方法和属性：WeakMap不支持迭代，所以没有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，并且也没有<code>size</code>属性；Map有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，也有<code>size</code>属性。</li><li>作用：WeakMap也可以实现自动清理回收；Map提供需要高效键值对的操作。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>set和Map是常用的数据去重的类型，我个人平时没怎么用过去重的方法，所以接触的不深。</p><p>今天了解了一下，依然感觉没什么太广阔的用途，作为知识点了解下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7377635432967192585?searchId=20240616145532E914394B07D15EA32D34">ES6数据结构深度解析：Set, Map, WeakSet 和 WeakMap</a></p><p><a href="https://juejin.cn/post/7080066742642278407?searchId=2024061721181220C10D42B076B557B9A0">Map和Set的应用场景（搬运）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官（朋友）：看简历上，您对JS很熟悉，您了解set和map吗？&lt;/p&gt;
&lt;p&gt;我：set我常用来做数据去重，map没了解过。&lt;/p&gt;
&lt;p&gt;面试官（朋友）：哈哈哈，您真是太幽默了，欢迎那您来参加面试，后续人事会通知您面试结果的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>关于生产力极大发展的浅思</title>
    <link href="https://crazystudent13.github.io/2024/06/16/%E5%85%B3%E4%BA%8E%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%9E%81%E5%A4%A7%E5%8F%91%E5%B1%95%E7%9A%84%E6%B5%85%E6%80%9D/"/>
    <id>https://crazystudent13.github.io/2024/06/16/%E5%85%B3%E4%BA%8E%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%9E%81%E5%A4%A7%E5%8F%91%E5%B1%95%E7%9A%84%E6%B5%85%E6%80%9D/</id>
    <published>2024-06-16T09:18:19.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>人是一根会思考的芦苇——帕斯卡。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文是长久的思索的阶段性结论，我个人认为，生产力极大发展之后，人将不会再是人，至少不是现在人类。</p><p>人类，只是人类文明在漫长时间长河中，一段无足轻重的注脚罢了，未来人类，绝对不是现在人类想象中的那样。</p><p>在正式开始之前，先简单叠个甲。</p><p>我不过一介凡人，从未觉得不凡，在我成长的人生路上，早已经习惯了自己的平凡，可是随着时间的推移，我渐渐地发现了有些不对。</p><p>很多人放弃了对于宏大想法的思索，他们曾有数学系的天才，我曾在秀的算法面前感到一阵头皮发麻，也见过三天之内突击，现场暴打蓝桥杯的竞赛的怪物。</p><p>我见过在团队中的多面手，一人可以解决数种问题，同时能够高度抗压，完美带领团队。</p><p>也见过儒商一般的精英天才，数次创业不断盈利，硬生生将公司从普通的小公司带到数百人的规模，并且辉耀至极。</p><p>无数的天骄英才在我这短暂的生命中滑过，看着这些辉耀的人生，我常常感到自己人生真是不虚此行，真实跟这些共事，是我的荣幸。</p><p>我一直觉得自己很平凡，从未觉得自己有什么不同的地方。</p><p>直到这脱离人群的数年内，我渐渐感觉到自己的不同了，我渐渐地觉得，我这个平凡的家伙，似乎真有点不同，不是那种利他性的不同。</p><p>我的想法，太不合群了。</p><h3 id="脱离群体"><a href="#脱离群体" class="headerlink" title="脱离群体"></a>脱离群体</h3><p>我的想法，是从什么时候逐渐脱离人群的呢？记不清了，在高中大学混沌时刻，我并未有这么多古怪的想法，而随着工作的不断增长，我愈发的发现，我的思维开始脱离群体。</p><p>我不习惯用社会的既有规则去融入，面对既有的社会分工，我总感觉有种说不出的古怪。</p><p>在摆脱了生存的危机之后，直至去年在家的空闲期，我的思维愈发的发散。</p><p>我居然在思考整个社会的走向和未来人类社会的形态。</p><p>该怎么说呢？这种想法太过傲慢，也太过无用了。</p><p>只是，脱离人群之后，人的思想会逐渐变得怪异，不合群便会诞生一些奇怪的想法，这种想法我个人感觉不是被大众接受的，不利于群体使用的，不合规矩，不能经世致用的瞎想。</p><p>因为这些想法并不能带来什么收益，所以很少有人去关注这些。</p><p>一开始，我以为我的这些瞎想太过抽象，也太过无趣，在我身边的那些精英们大多应该早就思考过，他们思考过，所以他们选择了自己的道路。</p><p>我一度质疑我这种想法肯定有很多人都有类似的想法，但是后来发现不是的，并非所有人都有类似的想法。</p><p>经过漫长的生活，我发现没有人去思考这个社会。</p><p>大众在迫于生存的压力中，放弃了自己的思考，为了生存和社会分工的规划，他们按照社会分配的角色，被社会完成了规划，成为了整个机器的运转的一环。</p><p>即便是思考这个社会形态的人，多数也只是思考这个社会如何能运转的更好。</p><p>这是一种很自利的利他想法，为了避免这台社会机器的崩塌，更多人选择放弃更深层的思考，让社会顶层的人代替自己思考。</p><p>在这种不断的推诿下，最终，统治阶级成型了。</p><p>只有这部分生产力极度富裕的人，他们才有着对未来思索的权力。</p><p>于是，我们发现了一个怪诞的情况，很多精英明明能力极强，但是想法却和大多数人的认知差不多，他们由于自己的认知或者生活的规训，不再关注和思索未来，只是不断专注于自己手中技能的打磨，在自己的专精领域内不断精深，而不再关注这种有些偏向于虚无的思索。</p><p>最终，居然只是我这种平凡的家伙，在思考这些怪诞的事？</p><h3 id="生存本质"><a href="#生存本质" class="headerlink" title="生存本质"></a>生存本质</h3><blockquote><p>生存的本质就是掠夺，对他人的掠夺，对外物的剥削，他人即地狱</p></blockquote><p>幸而有历史书的记录，我得以窥见人类的社会体制的不断进步，这里感谢一下人类社会体系中的史官，感谢他们的记录。</p><p>从原始奴隶制，到远古封建，继而后帝国封建，再后来是资本主义，国家资本主义的时代。</p><p>人类的社会，从远古的蛮荒到如今的文明，虽然看似剥削手段渐渐地温和，但是本质上将生存的矛盾转嫁到其他物种身上了。</p><p>我并非什么万物共产的那种傻逼，我只是点出来人类生存环境为何看起来变好的原因。</p><p>人类如今的生存，是建立在对整个生物圈的资源拓张，包括各种资源的开采，对其他生物的规模化体系化猎杀，人类之所以不再血腥，是因为这种血腥可以对外转嫁了。</p><p>因为脱离了对生存的基本威胁，为了更有效的获取资源，更好的生存，更稳定的生存，于是便有了社会这个需求。</p><p>社会的本质，是更好的利用人群为一部分人获取资源，是对他人的生存资源的掠夺。</p><p>即便现代文明社会采用了更温和的交换手段，但是受限于信息，地域，保存成本等因素，不可避免的，这仍然是一种掠夺，只是披上了一层温和的底色，社会的本质，仍然是对他人的掠夺。</p><h3 id="生产力大发展"><a href="#生产力大发展" class="headerlink" title="生产力大发展"></a>生产力大发展</h3><p>生产力大发展个人认为依然是一种掠夺，不过相对于之前那种原始的掠夺，这种方式能让被掠夺者也有一定的生存空间。</p><p>在基础生存条件的保证下，人类群体开始分化，无产阶级和资产阶级的群体分类开始逐渐明显。</p><p>这时候，人类内部发生了数次大规模战争，暴动，因为既有生产关系无法适应生产体系，为了适配新的掠夺体系，在不断的暴动和战争中，新生代的规则逐渐建立。</p><p>以下是个人的暴论，通过对科技发展史的窥探，个人得出了一部分结论，如果不正确，欢迎评论区指正。</p><ul><li>第一次蒸汽时代，随着纺织机和火车的出现，人类社会为了倾销，便有了各种对外战争和自由贸易搞垄断倾销，这可比做海盗赚的快的多了</li><li>第二次电气时代，随着内燃机和电力的兴盛，美国人在喝饱了枪火交易的红利，在内部搞西进运动圈地和杀人，之后大基建（虽然有逼不得已的成分），但无论是何等疯狂的方式，确实让人类的屠戮规模降了不少</li><li>第三次网络时代，随着网络的下方，人类的交流成本开始极大程度的缩减，这让人与人之间的信息获取方式便利，此前美苏冷战，此后续苏联解体，一直到现在次时代的中美贸易（个人感觉这是另一种类型的冷战），全球都在打代理人战争，核武保证了大规模的热战不会出现，但是非核的代理人战争开始逐渐兴盛。</li></ul><p>目前仍然没有第四次科技革命的苗头，所以生产力陷入瓶颈，阶级闭锁，进入历史内的垃圾时间。</p><p>纵观这段时间的科技史，我们大概可以窥探到，生产力大发展之后，为了保证新生时代的生产关系能够适配，自然也就会有流血冲突，为了保证能够大规模的铺开新生代的生产力，全面迭代，那么就需要一场世界级的战争。</p><p>这是人类无法自控的，是出于本能的，为了要生存，要更好的生存，就必须要伤害他人。</p><p>不，不是一两个人的伤害，而是要一群两群，甚至是一代两代人的伤害。</p><p>想要生产力大发展，就需要对另一群人进行掠夺，倾销，垄断，世界大战，代理人战争，总归是一个群体对另一个群里的掠夺，把对方的资源加入到己方手中。</p><p>虽然在这个过程中，人类社会逐渐变得越发精密化，分工合理化，但本质并未改变。</p><p>生存本质就是掠夺，大大小小的国家，都是为了掠夺和防掠夺而形成的团体。</p><h3 id="资本异化"><a href="#资本异化" class="headerlink" title="资本异化"></a>资本异化</h3><p>这是共产主义提到的，说资本主义对人的工具化，但是思考了一段时间后，我认为这说的还是肤浅了一些。</p><p>是生产关系对人类的本身的驯化，无关乎是什么主义，只要有体系，为了保证体系内的人都有用，就要想办法去让他们发挥作用，继而工具化。</p><p>这便是我开头提到的那些了，人是极为容易被塑造的，只要你手里有资本，在指定好规则后，便可以通过规则将人塑造成统治阶层想要的形状。</p><p>这点无关乎于是资本主义还是别的什么主义，只要掌握了生产资料，制定了生产关系，便会有对应的群体替你想办法，去规训整个群体，设计规则，工具化人类群体。</p><p>这里并不批判这种异化和规训是好还是坏，单纯就是想说明一点。</p><blockquote><p>思想，是很容易被改变的。</p></blockquote><p>这里举一些生活的例子，比如爱国。</p><p>什么是爱国呢？</p><p>在旧中国封建时代，是君要臣死臣不得不死，在日本最狂热的军国时代中，无数死士愿意为了他们的天皇板载冲锋，在早年的美国开国时代，美国人还是一个信奉天主教为主的国家，甚至搞出过禁酒令这种傻逼活动。</p><p>这些都是爱国。</p><p>然后，不过两百年的时间，发生了什么呢？</p><p>东亚地区的新中国和日本不再兴盛于个人崇拜，君王的光辉逐渐散去，那种为了君王而死的思想被摒弃，在美国，如今已经是极为开放，甚至开放到魔怔的时代，完全不再是当初天主教徒为主的保守模样。</p><p>这还是爱国吗？</p><p>答案仍然是爱国，因为新时代爱国的定义变了，只要你不危害国家，这本身就一种爱国，新生代的道德评价体系变了。</p><p>异化，是轻易而简单的，为了适配新时代的生产力，这种速度是极为快速的。</p><p>如果感觉是不明显，那我再用国内的彩礼体系举个例子。</p><p>彩礼的价格是多少？爱情到底应该是什么样子？这里仅从男性婚娶角度来思考。</p><p>70-90年代的中国人，结婚只有三大件要求，“手表、自行车、缝纫机”到“冰箱、彩电、洗衣机”，不过那时候还要求是城市户口。</p><p>2000年之后，随着改革开放的开始发力，逐渐要求房子，车子，存款，这是那个时代的三件套，那时候女方可能学历是大学生更吃香一些。</p><p>2010年之后，随着网络市场下沉，彩礼逐渐开始成为重头戏，江西的天价彩礼开始进入全国的视野，之后各地经济发展，彩礼价格开始提升，从1万逐渐提升至8万，此时各地并未超过10万，此时并未要求房子是否无贷款。</p><p>2020年之后，彩礼的标配已经开始提升至10-20万左右，房子要求工作地，最好要求无贷款，工作要求稳定或者是体质内，存款要求10万起步，且有了相貌的要求，这在大多数人眼中是正常现象。</p><p>从2010年-2020年，这个时代不过十年，结婚的成本整个翻了近十倍不止，但是社会的生产力并未跟上，只是之前房地产抬高了整个社会的经济活力，让所有人感觉这种财富增长的现象会是常态。</p><p>这里并不发散，我只是想说，在经济发展的数十年内，道德的工具化效果就很明显了，这是一种为了生存而形成的自发的规则化掠夺行为。</p><p>结婚发展史就是一种道德变化的要求，所谓的爱不爱，就是在不断抬高生存成本的一种规训。</p><p>这种规训，便是所谓的资本异化，无论是推翻既有的社会体系，还是重建一套体系，都无法避免这种东西的存在。</p><p>这就是人类社会底层逻辑：要掠夺，要通过既有的分配体系来掠夺，保证自己的生存。</p><p>彩礼的标配，与其说是彩礼的定义，倒不如说是这个时代对人类的定义，只要符合这个定义，才能使算作这个时代的人类，具有了繁衍资格。</p><p>不符合这个定义，却拥有人类的血统？</p><p>这种物种，在蜂群中有个很合适的定位：工蜂。</p><p>工蜂只能用来劳动，绝对不能用来思考和繁衍，他们只是个会说话的工具罢了，工蜂只能被用来消耗，不具有繁衍资格。</p><p>这一点，在人类漫长的历史中从未改变。</p><p>这点不仅仅在中国发生，是世界通用的，譬如福特也曾经说过：我明明只想雇一双手，为什么来了一个人？</p><p>只是需要工具，而非需要人类，这便为了掠夺效率最大化而产生的绝对逻辑，是人类社会对人类群体自我异化的必然性。</p><h3 id="共产主义？"><a href="#共产主义？" class="headerlink" title="共产主义？"></a>共产主义？</h3><blockquote><p>生产力水平极大提高，物资极度丰富，劳动成为人的第一需要，按需分配，国家消失，人人自由而平等。</p></blockquote><p>这是共产主义社会的特征，我曾经对此深信不疑，因为前时代，随着科技的兴盛和发展，我真的见识到了社会被科技改造的历程。</p><p>可是随着社会生产力的不断发展，随着生活阅历的不断丰富，我逐渐质疑起共产主义的可行性。</p><p>生产力极大富裕之后，真的会有有人自由平等吗？</p><p>如果真的平等，为什么会有地区差异。</p><p>如果真的平等，不同职业为什么收入差距会如此之大。</p><p>如果真的平等，为什么官僚体系内的收入福利会如此之多？</p><p>官方每次的回应总是说我们处于社会主义初级阶段，但是仔细看看，我始终不感觉统治阶层的老爷们和底层人是一个物种。</p><p>随着时代的进步，这些底层燃料被完成消耗之后，如果平稳进入了共产主义，那么共产主义时代的人，还会在意底层这些和他们完全不一样的旧人类吗？</p><p>共产主义，真的会养出来让所有人都平等的社会吗？</p><p>如果人类生存的本质是要掠夺，那么共产主义要如何破局？</p><p>这和传销所宣扬的所有人都能挣钱的结局有什么本质上的区别吗？</p><p>共产主义是假的，一场传销骗局。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我并不信奉任何主义，人类社会的本质，就是一场掠夺式的骗局。</p><p>共产主义，是梦幻的温柔乡。资本主义，是明牌的杀戮。</p><p>我认为，在生产力极度富裕的未来，无论是幻想中的共产主义，还是资本主义的终产个体，我都不认为会存在。</p><p>人类的思维始终被人类禁锢了，在那个时代的诞生时候，现有的人类制度将会随着现代人类彻底消亡。</p><p>必然会有新时代的人类随着新生代的而诞生，那种未来人类，不会禁锢于我们现有的道德规则，然后如同每次生产力革新时代的暴力运动一样，他们会横扫所有现时代所有的人类。</p><p>而那时的人类，那时的文明，便也许有了新的称呼。</p><p>或许，那就是，神。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《中国近代史》</p><p>《资本论》</p><p>《自私的基因》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;人是一根会思考的芦苇——帕斯卡。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="思考" scheme="https://crazystudent13.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，选用volta的理由</title>
    <link href="https://crazystudent13.github.io/2024/06/15/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8volta%E7%9A%84%E7%90%86%E7%94%B1/"/>
    <id>https://crazystudent13.github.io/2024/06/15/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8volta%E7%9A%84%E7%90%86%E7%94%B1/</id>
    <published>2024-06-15T12:02:32.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>我：开发环境node环境有点乱，下个nvm用用吧。</p><p>同事：也许你应该考虑放弃nvm，考虑一下这款好用的volta？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在公司的电脑环境上安装了自用的hexo博客，打算日常午休时候，可以稍微写点什么。</p><p>但是，hexo和公司电脑环境上的配置发生了冲突。</p><p>公司项目是<code>node20</code>版本的环境，hexo的环境是不支持的，本来打算用nvm处理一下算了，甚至算了一下时间，我都想放弃用公司电脑摸鱼写博客了。</p><p>但是后来朋友说，用<code>volta</code>，这是比nvm更好的node版本管控工具，能完美解决我的痛点。</p><p>我一开始不信，翻了一下<a href="https://docs.volta.sh/guide/#why-volta">volta官网</a>，也没明白到底好用在哪里，我承认我英语不好，但首页说明很简单，这点我还是看的明白。</p><blockquote><p>使用 Volta，您可以一次选择 Node 引擎，然后不再担心它。您可以在项目之间切换，而不必手动切换 nodejs 版本。</p><p>你可以在工具链中安装 npm 包，不必定期重新安装它们，或者弄清楚它们停止工作的原因。</p></blockquote><p>官网这话说的比较拗口，一开始我没明白什么意思，之后上手用了一下，我瞬间明白了。</p><p>这玩意能给项目锁node版本！每个项目在设置好自己的版本之后，不同项目可以同时运行。</p><p>这不需要像nvm一样，每次换项目都得手动命令行切换node版本。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>相信，我上边的例子已经让您明白到底什么样的环境适合使用<code>volta</code>工具了。</p><p>这里，个人总结一下适合的应用场景</p><ol><li>多项目，一台电脑上有多个需要开发的项目</li><li>node多版本，多个项目之间node版本跨度要求大，不能同时使用一个环境</li><li>需并行开发，要同时运行数个node环境不同的项目</li></ol><p>如果满足以上应用条件，不妨尝试一下使用<code>volta</code>。</p><p>除了无缝衔接，每个项目的无须手动切换外，它还有如下特点：</p><ul><li>速度，因为是用时下流行的rust重写的，所以运行速度很快</li><li>跨平台支持，包括 Windows 和所有 Unix shell</li><li>稳定的工具安装-无需每次升级都重新安装!</li></ul><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><p>因为个人是win系统，且win系统的操作相对繁琐，这里先说win系统的安装。</p><h4 id="win"><a href="#win" class="headerlink" title="win"></a>win</h4><p>对于 Windows，<a href="https://link.juejin.cn/?target=https://github.com/volta-cli/volta/releases/download/v1.1.1/volta-1.1.1-windows-x86_64.msi">下载并运行 Windows 安装程序</a>并按照说明操作。</p><p>Volta 的功能依赖于创建符号链接，所以你必须<a href="https://link.juejin.cn/?target=https://learn.microsoft.com/zh-cn/windows/apps/get-started/enable-your-device-for-development%23accessing-settings-for-developers">启用开发者模式</a>。</p><p>启用开发者模式的意思很简单，就是打开设置&gt;开发者选项，然后打开开发人员模式即可。</p><p>对了，这里要注意下，有时候VScode窗口命令行不支持的时候，把所有的VScode全部关掉再重开即可。</p><h4 id="mac与linux"><a href="#mac与linux" class="headerlink" title="mac与linux"></a>mac与linux</h4><p>这里我没有mac，所以我就不细说了，反正mac环境很干净，知道对应的目录敲一下命令就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.volta.sh | bash</span><br></pre></td></tr></table></figure><p>如其他开发的环境工具一样，安装完成之后，我们可以用如下命令确认是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volta --version</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>这里也不墨迹，直接与nvm使用方式的对比一下。</p><table><thead><tr><th>名称</th><th>volta</th><th>nvm</th></tr></thead><tbody><tr><td>下载</td><td>volta install node@16</td><td>nvm install @16.12.0</td></tr><tr><td>卸载</td><td>volta uninstall</td><td>nvm uninstall @16.12.0</td></tr><tr><td>使用node版本</td><td>–</td><td>nvm use</td></tr><tr><td>固定node版本</td><td>volta pin node@16</td><td>–</td></tr><tr><td>查看安装的版本</td><td>volta list</td><td>nvm list</td></tr><tr><td>查看可安装的版本</td><td>–</td><td>nvm list available</td></tr></tbody></table><p>注意，volta uninstall 命令似乎卸载不了已经安装node版本，这里我尝试过使用命令去安装和卸载，结论就是volta除了针对pnpm和nvm的安装卸载有效果，其他毫无作用。</p><p>可能这是一个bug，如果有人能正式用出来，可以再我的评论区说一下，我这边立刻改掉，反正我是没试出来。</p><p>正式的命令，可以参考这个：<a href="https://volta.jikun.dev/reference/">Volta 命令 | Volta (jikun.dev)</a>，这应该是同人做的官网文档中文翻译，不过，我参考这个卸载命令试了一下，还是不行。</p><p>总之，目前除了卸载，一切都算是正常。</p><h3 id="同类工具"><a href="#同类工具" class="headerlink" title="同类工具"></a>同类工具</h3><p>本来是没有这项的，在整理到一半的时候，在群友提示下，我才发现volta还有同类的工具——<a href="https://gitcode.com/Schniz/fnm/overview?utm_source=csdn_github_accelerator">fnm</a></p><p>这可真是铁板上烤鱿鱼——卷起来了啊。</p><p>和volta一样，fnm也是rust编写的，很快且支持项目固定node环境，而且也能稳定安装环境，同时wiki上也是中文。</p><p>感兴趣的可以参考这篇文档：<a href="https://blog.csdn.net/weixin_43288600/article/details/135073118">还在用nvm？来试试更快的node版本管理工具——fnm_fnm windows-CSDN博客</a>。</p><p>这博客虽然是在csdn上写的，但写的简单干脆，适合阅读，没啥车轱辘话，挺不错的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不得不说，真是江山代有人才出，明明一年没正式在开发团体中做事，就感觉现在前端圈子变了好多。</p><p>我们那个时候对于node版本管控需求不高，所以最多就一个nvm就够用了，而现在不同node版本的新旧项目叠在一起，如此环境，</p><p><code>volta</code>，确实好用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/691809574">软件丨node版本管理的神！ - 知乎 (zhihu.com)</a></p><p><a href="https://volta.jikun.dev/reference/">Volta 命令 | Volta (jikun.dev)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我：开发环境node环境有点乱，下个nvm用用吧。&lt;/p&gt;
&lt;p&gt;同事：也许你应该考虑放弃nvm，考虑一下这款好用的volta？&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅析解构赋值到底是深拷还是浅拷</title>
    <link href="https://crazystudent13.github.io/2024/06/13/%E6%B5%85%E6%9E%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7/"/>
    <id>https://crazystudent13.github.io/2024/06/13/%E6%B5%85%E6%9E%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7/</id>
    <published>2024-06-13T12:42:50.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>群友：听说你最近在刷面试题？要不我问一道题你看看你能不能回答？</p><p>我：没问题，我对面试八股文多少还是有点自信的。</p><p>群友：那，解构赋值到底是深拷贝还是浅拷贝？</p><p>我：你他妈是故意来找茬的吧？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从来没想过的基础问题，一下子被干懵了，我个人在入行第二年的时候就通读了《ES6标准入门》这本书。</p><p>关于解构赋值这里，因为用的不熟悉所以特别多看了两眼，我记得文中从来没提过这事儿，而且我也从来没想过这茬子事情。</p><p>哎，这种题作为面试题，真把人干躺了也无所谓，就当是吃个经验教训。</p><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>明确一下深拷贝和浅拷贝的定义，或者说深拷贝和浅拷贝所应用于的数据类型。</p><ul><li>深拷贝：修改新变量的值不会影响原有变量的值。默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。</li><li>浅拷贝：修改新变量的值会影响原有的变量的值。默认情况下引用类型（object）都是浅拷贝。</li></ul><p>其实你只要理解透彻了这两句话就应该明白了解构赋值，甚至深拷贝的原理；</p><p>写两个例子，理解一下深拷贝和浅拷贝；</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>我们平时开发中，这种情况很常见的，直接用等号赋值就是深拷贝，如果没有新的内存空间存放变量，我们岂不是会直接修改元数据？</p><p>因此，此时对b的数值的修改并未影响a，所以基本数据类型赋值就是深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br><span class="line"><span class="comment">// 打印出：1,2</span></span><br></pre></td></tr></table></figure><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>所谓深浅拷贝，核心就是要不要用新的存储空间来存放变量，而且平时也主要是针对引用类型的数据。</p><p>这里直接用等号赋值，我们会发下，是浅拷贝赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="comment">// 打印出：&#123;name: &#x27;张三&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>其实这个时候，我们大概就能想明白一件事儿，那就是一门语言在面对这种大小不确定的引用类数据类型，底层原理上肯定是倾向于浅拷贝。</p><p>不然，各个都是深拷贝，那就得开辟大量的新空间用来存储，一旦全面铺开，将会有一笔很大的存储空间消耗。</p><p>如果是这样，那这门语言一定会得到最消耗内存的烂名声，任何一名语言设计者在设计之初的时候，肯定不会希望自己设计的语言大量消耗存储空间。</p><p>所以，大多语言，引用类型数据的默认赋值方式，大概率都会是浅拷贝。</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>在上边赋值的时候，我们已经注意到了，</p><p>ES6的解构赋值，大家应该都清楚，本质上其实就是一种语法糖，可以快速取出数组或者对象中的值，这里放个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, marriage&#125; = a;</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;name1&#x27;</span>;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">marriage = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"><span class="comment">// 打印出：&#123; name:&#x27;name&#x27;,age:18, marriage: false &#125;</span></span><br></pre></td></tr></table></figure><p> 发现a的数据并没有被改变，解构赋值好像是深拷贝啊？？？？？</p><p>我们再改一下上面的例子看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">addr</span>: &#123; <span class="attr">province</span>: <span class="string">&#x27;sichuan&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;chengdu&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, marriage, addr &#125; = a</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;myname&#x27;</span></span><br><span class="line">age = <span class="number">26</span></span><br><span class="line">marriage = <span class="literal">true</span></span><br><span class="line">addr.<span class="property">province</span> = <span class="string">&#x27;shanghai&#x27;</span></span><br><span class="line">addr.<span class="property">city</span> = <span class="string">&#x27;shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, marriage, addr) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我直接将结果放在这里，感兴趣的可以直接用上述代码运行</span></span><br><span class="line"><span class="comment">// 打印出:myname 26 true &#123;province: &#x27;shanghai&#x27;, city: &#x27;shanghai&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 打印出: </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">addr</span>: &#123;<span class="attr">province</span>: <span class="string">&#x27;shanghai&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line"><span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 发现解构赋值出来的对象将原对象a中的addr的数据修改了，这样看还是浅拷贝；</p><p>这里我们根据上述情况，可以简单的</p><blockquote><p>解构赋值，如果所解构的原对象是一维数组或对象，其本质就是对基本数据类型进行等号赋值，那它就是深拷贝；</p></blockquote><p>如果是多维数组或对象，其本质就是对引用类型数据进项等号赋值，那它就是浅拷贝；</p><p>最终的结论就是：解构赋值是浅拷贝（因为它确实不能对多维数组或对象达到深拷贝的作用）；</p><h3 id="深拷贝本质"><a href="#深拷贝本质" class="headerlink" title="深拷贝本质"></a>深拷贝本质</h3><p>这里我们放一套常规的深拷贝赋值方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">source</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> targetObj = source.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;; <span class="comment">// 判断复制的目标是数组还是对象</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> keys <span class="keyword">in</span> source)&#123; <span class="comment">// 遍历目标</span></span><br><span class="line">    <span class="keyword">if</span>(source.<span class="title function_">hasOwnProperty</span>(keys))&#123;</span><br><span class="line">      <span class="keyword">if</span>(source[keys] &amp;&amp; <span class="keyword">typeof</span> source[keys] === <span class="string">&#x27;object&#x27;</span>)&#123; <span class="comment">// 如果值是对象，就递归一下</span></span><br><span class="line">        targetObj[keys] = source[keys].<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        targetObj[keys] = <span class="title function_">deepClone</span>(source[keys]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 如果不是，就直接赋值</span></span><br><span class="line">        targetObj[keys] = source[keys];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现了吗？其实深拷贝本质上还是将对象拆开为基本数据类型进行赋值。</p><p>所以，解决问题的本质就是让复杂问题简单化，所谓的深拷贝，本质上无非就是加强版的基础类型赋值罢了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是，就直接赋值</span></span><br><span class="line">targetObj[keys] = source[keys];</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然是非常基础的一个问题，但是却让我颇有受益。</p><p>所有语言开发之初，肯定对相关问题都有过优化，如今项目工程越来越繁杂，这种曾经精妙的设计确实也落入了尘埃，到底也是时代的眼泪了。</p><p>当然，感叹归感叹，但依然是实际开发中用不到的知识，不过确实有趣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/blessYou/p/13038566.html">ES6的解构赋值与深拷贝和浅拷贝 - 前端随笔 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;群友：听说你最近在刷面试题？要不我问一道题你看看你能不能回答？&lt;/p&gt;
&lt;p&gt;我：没问题，我对面试八股文多少还是有点自信的。&lt;/p&gt;
&lt;p&gt;群友：那，解构赋值到底是深拷贝还是浅拷贝？&lt;/p&gt;
&lt;p&gt;我：你他妈是故意来找茬的吧？&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JS" scheme="https://crazystudent13.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>2024年第一次长途骑行</title>
    <link href="https://crazystudent13.github.io/2024/06/12/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/"/>
    <id>https://crazystudent13.github.io/2024/06/12/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/</id>
    <published>2024-06-12T13:07:06.000Z</published>
    <updated>2024-07-07T05:42:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>我从未想过有一天，自己会如此的落魄，我也从未想到过有一天，自己会如此的坚强。</p><p>从老家骑自行车到徐州，一路107公里，用时约莫11个小时，我熬过来了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>相比于去年惬意而安定的日子，今年这个时间简直是雪上加霜。</p><p>本篇并非一篇技术性的文，单纯是个人一点儿小小的感伤。</p><p>一切实在是太有趣了。</p><p>因为现在身上背着债，所以很多地方都不是很敢花钱，原本我不说，我还以为家里都有钱，结果现在我需要的时候，家里个个都欠着外债，日子过的这么阴间的时候还是头一回。</p><p>之所以会有这次从老家骑车到徐州的经历，完全是生活所迫。</p><p>具体前因就不描述了，总之，这次骑行是逼不得已的下策，是人生最窘迫的时刻之一。</p><h3 id="107公里"><a href="#107公里" class="headerlink" title="107公里"></a>107公里</h3><p>从老家到徐州，约莫30公里的时候，途径邳州，如同以往的经验一样，此时极度饥饿，于是停下来，吃了一碗炒面。</p><p>一碗炒面只有9块钱，但是为了后续路上有劲骑车，我又让老板多加了3块钱的炒面，后续我再没有吃过任何一点儿饭，因为到了夜里，路上没有一家店开门，都打烊了。</p><p>饥饿不是最糟糕的感觉，缺水才是最糟的体验。</p><p>路上没有地方能接开水，一路上买水又消耗了不少钱，估摸着消耗了快20块钱左右。</p><p>毕竟，不可能只买矿泉水，也买了一点电解质水（其实就是盐水），防止自己路上流汗过多脱水。</p><p>一路上，顶着饥饿和缺水的debuff硬是骑车骑了约莫一半的路程，然后最坑的时刻来了。</p><p>省道没有灯，虽然也有路灯，但是根本不亮，很显然，这灯就是看个乐子，根本没什么用的。</p><h3 id="G311"><a href="#G311" class="headerlink" title="G311"></a>G311</h3><p>恐怕是这条路上最黑的一段时间了，因为没有等，再加上手机没有电，后半程约莫有50公里的路，我勉强靠月光和路上的车的灯光分清了道路的大致线路，不然我连路上的线都看不清。</p><p>我敢保证，我这次出门最大的问题，就是没把握的夜骑灯带上，不然这次骑行至少等提前一个小时结束。</p><p>饥饿，缺水，同时也不能停下。</p><p>手机快没有电了，于是只能关掉手机，保留最后百分之十五的电量。</p><p>没有夜骑灯，只能靠着视力和路过车辆的灯光，勉强分清路线。</p><p>G311，这条路直达我要到的徐州站，好处是，我确实不需要看导航就可以走了，坏处是，我感觉这路上自己遇到了鬼打墙。</p><p>每隔一段时间，我几乎都能看到路上标识的G311路牌。</p><p>尽管我知道，这代表我走过了不小的一段路，但是每当看到这似曾相识的路牌时候，我总觉得，自己似乎完全没有任何前进，只是在原地踏步的打转罢了。</p><h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><p>怎么说呢，在这段路上，如果我没有点什么想法，那肯定是不可能的。</p><p>在路上，我总有一种恍如隔世的感觉，因为前一段时间我还在送外卖，数天前我在办公室开发项目，两天前我在刷面试题，一天前我抱着猫在家里睡觉，听歌。</p><p>然后，今天，我在黑暗中一路狂飙。</p><p>而且，无人能帮我什么。</p><p>我此时也没有什么钱，只能在这条路上一路到底，说起来，骑到最难熬的时候，心里反而有种奇怪的宁静感。</p><p>嘿，真有趣。</p><p>当G311进入市区路段的时候，我反而懈怠了，就像我之前工作到迷惘了一般，我感觉那时候可以歇歇，因为目的地太近了，我感觉自己好像可以退休了。</p><p>离目的地只有十公里，但是我怕路上真睡着后，之后就不会再想走了，所以一路又骑了过去。</p><p>最后十公里，骑得并不顺利，市区有几条路有岔路口，徐州的市政规划非常不好，路线极其扭曲，立交桥和各种岔路搞得市区路线简直一坨屎。</p><p>每当遇到岔路，我就得开机看看地图，然后每次开启，掉2%的电量，等到回到宿舍的时候，只有3%的电量了。</p><p>就这么一路熬着，居然也熬到了终点。</p><p>当我回到宿舍的那一刻，心里虽然很激动，但是我却出乎意料的平静。</p><p>发说说（装逼），洗个澡，然后喝了些开水，打开电脑想了一会儿，本来想立刻写一篇文档，记录一下那时候的心情，但是最终还是放弃了。</p><p>太累了。</p><p>没有那种传说中的酸痛，但是胯和臀部几乎被磨破皮了，疼的坐不住。</p><p>很疲累却很精神，我几乎感觉不到自己的想睡觉，但是头疼的感觉又不断地强迫我去睡觉。</p><p>怎么说呢，真是一种有趣的经历，我已经记不清这是我人生中第几次绝境了，想着想着居然似乎也习惯了。</p><p>大概所谓的心态好，就是麻木吧。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不过不论怎么说，此次经历也算是心态上的一次历练，不过一段奇遇罢了。</p><p>忽然此时想到了觅长生，颇有种现实里的红尘奇遇感，人生可能会更好或者更差，但无须介怀。</p><p>人生不若一场倾盆大雨，汹涌来去。</p><p>纵因一钱落魄，然又何须介怀？</p><p>红尘百炼方显男儿本色，一切不过些许风霜罢了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我从未想过有一天，自己会如此的落魄，我也从未想到过有一天，自己会如此的坚强。&lt;/p&gt;
&lt;p&gt;从老家骑自行车到徐州，一路107公里，用时约莫11个小时，我熬过来了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://crazystudent13.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>工程提速，选用pnpm的原因</title>
    <link href="https://crazystudent13.github.io/2024/06/09/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8pnpm%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://crazystudent13.github.io/2024/06/09/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8pnpm%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2024-06-09T15:05:29.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>本文并不针对仅仅面试，也是对过往遗憾的一段怀念，就是看到新公司选用pnpm，一时有些感慨。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>遥想起过往的时候，<code>pnpm</code>的风潮刚刚在社区里走起来，而自己一直没能在老公司推广<code>pnpm</code>。</p><p>如今，<code>pnpm</code>在很多公司项目中都通用了，我这个老年人也算是起了个大早，赶了个晚集。</p><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>关于pnpm，yarn，npm三者的发展历史，我这里不详细介绍了，详情可以自己去看：<a href="https://juejin.cn/post/7286362110211489855?searchId=2024061223325379085B7FEAC424101D04">pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 - 掘金 (juejin.cn)</a>。</p><p>关于三者的发展历史，无非就是从npm时代有了线上管理的方式，到了yarn时代拍平包依赖，版本锁定，然后被npm抄走。</p><p>之后为了解决多项目重复依赖的问题，于是就诞生了pnpm，至于之后会不会被npm抄走，也很难说。</p><p>三者现阶段也并非完全的你死我活状态，具体的使用场景，还是要根据自身环境来判断的。</p><p>本次不会花时间去讲三者的发展史，而是笔者根据自身经验，简单讲讲使用pnpm的场景。</p><h3 id="选用原因"><a href="#选用原因" class="headerlink" title="选用原因"></a>选用原因</h3><p>如果你有以下需求，可以考虑选择用<a href="https://pnpm.io/zh/installation">pnpm</a></p><ol><li>项目node版本不低于v20</li><li>大型项目，企业级管理系统，项目依赖包很多，且多同类型项目开现场开发，重复使用npm下载依赖包，导致硬盘内存占用过大</li><li>对npm依赖安装速度不满，且符合以上两个条件</li></ol><p>如果您有以上的需求，那就请选择<a href="https://pnpm.io/zh/installation">pnpm</a>吧。</p><p>之所以pnpm快，就是因为pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，这样可以做到不会出现重复安装。</p><p>如果你仔细观察的话，你会发现pnpm安装的依赖的<code>node_moudles</code>下边都是快捷方式类型的文件夹。</p><p>在项目中需要使用到依赖的时候，pnpm 只会安装一次，之后再次使用都会直接<strong>硬链接</strong>指向该依赖，极大节省磁盘空间，并且加快安装速度</p><blockquote><p>注：硬链接是多个文件名指向同一个文件的实际内容，而软链接（符号链接）是一个独立的文件，指向另一个文件或目录的路径</p></blockquote><p>首次安装的速度可能较慢，但是后续安装和删除<code>node_moudles</code>都会极快。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>npm、yarn和pnpm都是当下十分优秀的包管理工具，具体选择哪个，还是要根据团队项目情况和个人喜好来决定。</p><p>npm 是 Node.js 生态系统的一部分，yarn 提供了更快的依赖项安装和锁定文件功能，而 pnpm 则专注于减少磁盘空间的使用和安装时间。</p><table><thead><tr><th>功能</th><th>pnpm</th><th>Yarn</th><th>npm</th></tr></thead><tbody><tr><td>工作空间支持（monorepo）</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>隔离的 node_modules</td><td>✔️ - 默认</td><td>✔️</td><td>✔️</td></tr><tr><td>提升的 node_modules</td><td>✔️</td><td>✔️</td><td>✔️ - 默认</td></tr><tr><td>自动安装 peers</td><td>✔️</td><td>❌</td><td>✔️</td></tr><tr><td>Plug’n’Play</td><td>✔️</td><td>✔️ - 默认</td><td>❌</td></tr><tr><td>零安装</td><td>❌</td><td>✔️</td><td>❌</td></tr><tr><td>修补依赖项</td><td>✔️</td><td>✔️</td><td>❌</td></tr><tr><td>管理 Node.js 版本</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>有锁文件</td><td>✔️ - pnpm-lock.yaml</td><td>✔️ - yarn.lock</td><td>✔️ - package-lock.json</td></tr><tr><td>支持覆盖</td><td>✔️</td><td>✔️ - 通过 resolutions</td><td>✔️</td></tr><tr><td>内容可寻址存储</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>动态包执行</td><td>✔️ - 通过 pnpm dlx</td><td>✔️ - 通过 yarn dlx</td><td>✔️ - 通过 npx</td></tr><tr><td>辅助缓存</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>列出许可证</td><td>✔️ - 通过 pnpm licenses list</td><td>✔️ - 通过插件</td><td>❌</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章本来想多抄点别人整理的发展史，但是想了想，pnpm终归是工具，实在没必要在这种发展史上花太多时间。</p><p>而且，面试也很少有人去考你发展史，人家都是直接问你真实的使用经历，所以这里干脆直接捞干的来说。</p><p>总之，推荐企业级大型项目开发使用<code>pnpm</code>，尤其是多项目现场部署的那种。</p><p>至于个人级别的普通项目，依然推荐按照自己的习惯来做，普通的npm足够覆盖大多数人的普通项目开发需求了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7047556067877716004?searchId=20240612235251C4198614ACEA50122B6D">pnpm对比 npm&#x2F;yarn好在哪里</a></p><p><a href="https://juejin.cn/post/7286362110211489855?searchId=2024061223325379085B7FEAC424101D04">pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7316409548994625574?searchId=2024061223325379085B7FEAC424101D04">为什么 pnpm+monorepo 是组件库项目的最佳实践</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文并不针对仅仅面试，也是对过往遗憾的一段怀念，就是看到新公司选用pnpm，一时有些感慨。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="工程化" scheme="https://crazystudent13.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue2的虚拟dom与diff算法</title>
    <link href="https://crazystudent13.github.io/2024/06/09/%E6%B5%85%E6%9E%90vue2%E7%9A%84%E8%99%9A%E6%8B%9Fdom%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"/>
    <id>https://crazystudent13.github.io/2024/06/09/%E6%B5%85%E6%9E%90vue2%E7%9A%84%E8%99%9A%E6%8B%9Fdom%E4%B8%8Ediff%E7%AE%97%E6%B3%95/</id>
    <published>2024-06-09T09:46:21.000Z</published>
    <updated>2024-07-07T05:42:08.920Z</updated>
    
    <content type="html"><![CDATA[<p>这个也是较为常考的面试八股题，很早之前面试准备时候了解过，如今也算是捡起来重新看看了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇算是Vue响应式原理浅析那篇的补充，在响应式原理中，着重讲了vue实现响应式原理的核心思路，但是在针对页面渲染这块没怎么细说。</p><p>虚拟dom渲染这块，面试核心便是算法的思路，真让你手写实现，大概率也最多就是个伪代码的思路图，不可能真让大家去实现的。</p><p>所以，在本篇，本文并不深入探讨算法的源码实现，更多的是讲明白这个渲染的思路。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟dom在响应式原理那边解释过，如果直接操作dom进行响应式的修改的话，对页面的性能开销会很大。</p><p>作为前端开发，我们都知道的，重排是比重绘性能开销大的多的操作，如果每个变动都要直接操作整个DOM树进行替换，那么毫无疑问，vue绝对会被扫入历史垃圾堆。</p><p>为了解决这么大的开销，vue在这里讨个巧，将对应的节点用JS封装成了<code>vnode</code>对象，通过对<code>vnode</code>对象的操作，进而一次性完成对dom的更改，减少了页面性能的消耗。</p><p>这样，便是所谓虚拟DOM了，如果看不懂，我们直接放个简单的例子，例子一看就能明白。</p><p>这是真实dom</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode = <span class="title function_">h</span>(<span class="string">&#x27;ul.list&#x27;</span>, [</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这里放个补充说明，平时我们开发中一定见过的。</p><p>上面的h函数大家可能有点熟悉的感觉但是一时间也没想起来,没关系我来帮大伙回忆; <code>开发中常见的现实场景,render函数渲染</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例1 vue项目中的main.js的创建vue实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例2 列表中使用render渲染</span></span><br><span class="line"><span class="attr">columns</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;操作&quot;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;action&quot;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">render</span>: <span class="function">(<span class="params">h, params</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">                <span class="title function_">h</span>(<span class="string">&#x27;Button&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">props</span>: &#123;</span><br><span class="line">                        <span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">style</span>: &#123;</span><br><span class="line">                        <span class="attr">marginRight</span>: <span class="string">&#x27;5px&#x27;</span>,</span><br><span class="line">                        <span class="attr">marginBottom</span>: <span class="string">&#x27;5px&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">on</span>: &#123;</span><br><span class="line">                        <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            <span class="variable language_">this</span>.<span class="title function_">toEdit</span>(params.<span class="property">row</span>.<span class="property">uuid</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">&#x27;编辑&#x27;</span>)</span><br><span class="line">            ]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里的render函数，实际上就是将虚拟的节点转换为真实dom加入到了dom树中，这样，我们就不需要更新整个dom数，而是只更新对应的节点即可。</p><p>这里关于虚拟dom的实现，这里就不贴源码了，感兴趣的可以自己去翻<a href="https://github.com/snabbdom/snabbdom">snabbdom</a>，vue2内部使用的虚拟DOM就是改造的Snabbdom。</p><p>哦，可能有的面试官会有个灵魂发问：虚拟dom更新一定就比真实dom更新来的快吗？</p><p>这个要看情况，如果dom数足够的复杂，用虚拟dom会自然会更快，但是简单操作一个dom节点的话，比如换换文字什么，这种肯定是真实dom操作更快一点。</p><p>不过，这个问题也就图一乐，为了这点性能开销单独写个dom操作一个不重要的节点，多少有点大可不必了。</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>重头戏了来了，虚拟dom只是个简单的开胃菜，重头戏还是得是diff算法。</p><p>如果你vue的开发者，现在你拿到了虚拟dom，你要如何知道前后两者发生了什么地方的改变呢？</p><p>有些朋友可能会说，这有什么难的，直接拿着每个节点挨个遍历比对就可以了，最暴力最直接的手法即可。</p><p>这种做法其实就是传统的diff算法，简单粗暴，直接有效。</p><p>不过，我们这里先看看vue是怎么实现虚拟dom的比对的。</p><p>本图来自于<a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337">B站思学堂UP</a>的整理，他的这张图是我目前看到整理的最清晰的图片，我大致回想了一下，和我以前看到的理解差不多，只要看懂了这张图，大致就明白vue的diff算法是这块是怎么一回事了。</p><p><img src="https://s2.loli.net/2024/06/09/BOETmXxVslHNjW5.png" alt="00325814-9fc9-490b-8b4d-34d765016118 (1)"></p><h4 id="vue的diff算法优化"><a href="#vue的diff算法优化" class="headerlink" title="vue的diff算法优化"></a>vue的diff算法优化</h4><p><a href="https://github.com/snabbdom/snabbdom">snabbdom</a>做的的优化，相对于传统简单粗暴的遍历法，根据dom的特性做了一个优化，那就是同级比对。</p><p>如果我对应的节点已经发生了改变，那这个节点之下的子节点我还有什么必要进行比对呢？这样的话，就省下了了很多性能，所以，vue2出道的时候，vue2这套diff算法也一度是热门面试题，只不过现在是2024年了，大家很少提及相关的事情了。</p><p>关于vue这套算法的特点，这里不细讲，这里稍微总结了一下，便于大家面试时候回答。</p><ul><li>Snbbdom根据DOM的特点对传统的diff算法做了<code>优化</code></li><li>DOM操作时候很少会跨级别操作节点</li><li>只比较<code>同级别</code>的节点</li></ul><h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>在上边的图中，我们注意到了一件事，那就是新旧节点比对，都有子节点，于是转入了<code>updateChildren()</code>的方法。</p><p>这里便是重点，前边的三种情况都好说，换文本，删除或新增节点，很干脆快速的就能完成。</p><p>但是如果之下还有子节点，要怎么继续判断才能最省性能的方式完成对dom的操作呢？</p><p>就是首尾指针法，这种方法个人认为非常切中我们平日操作数组的习惯，算是大幅提高效率的一种方法。</p><p>这里稍微浅谈一下所谓的首尾指针法，就是将数组分为首尾两个指针。</p><p>vue的在updateChildren的时候，会将新旧两个虚拟dom树做比对，这时候，取新旧两个dom树的数组首尾，于是得到了四个节点：新前，新后，旧前，旧后。</p><p>然后按照如下顺序执行：新前与旧前，新后与旧后，新后与旧前，新前与旧后。</p><p><img src="https://s2.loli.net/2024/06/12/3ItV52urUwX4aiN.png" alt="c134f0af-408f-4310-93bc-a83c89cc1979"></p><p>尚硅谷的<a href="https://www.bilibili.com/video/BV1v5411H7gZ?p=12&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【尚硅谷】Vue源码解析之虚拟DOM和diff算法</a>，我个人比较推荐他的视频，讲的很清楚。</p><p>我这里大致通过这张图，我们就很能明白比对的方式了，这里暂时就不按照其他讲解放箭头图了，总之，通过前后对比的方法，首尾指针接近，直至循环完成之后，将旧树中未命中的旧节点移除，将新树中的新增节点加入。</p><p>在比对完成之后，只需要操作一次真实dom，而且只操作没有key标记的DOM，这样可以最小限度的减少对dom树的破坏，减少页面开销，这也是我们在之前遇到的vue2如果不绑定Key的时候，为什么一部分dom更新会出问题的原因。</p><h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><p>这里，又联系到之前提到v-for相关的说法了，因为你给节点加了<code>key</code>，所以，虚拟dom在遍历的时候，就很容易能找到对应的节点不会找错，因此，更快更准。</p><p>而如果你用索引作为key，自然会出现一个问题，那就是索引不具有唯一性，因此索引作为key会导致渲染出BUG的原因便在于此。</p><ul><li>Diff操作可以<strong>更加快速</strong></li><li>Diff操作可以<strong>更加准确(避免渲染错误)</strong></li><li><strong>不推荐使用索引作为key，因为索引被修改后不具有唯一性</strong></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虚拟dom和diff算法，说破天，都是为了节省对dom操作的性能浪费而应对的办法，大多业务层面的前端开发者可以图个乐子了解一下。</p><p>面试中问到，其实也是可以理解的，毕竟这也是vue的看家本事之一，所以对自己的工具原理不稍微了解下，确实也说不过去。</p><p>不过，我们实际上其实用不到太多，做个大概得了解就可以，如果需要对源码进行深入拓荒的，可以尝试对源码层面进行了解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7000266544181674014?searchId=20240609164240AFF5E00BCB5E76BED20E">DIff算法看不懂就一起来砍我(带图)</a></p><p><a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337">6分钟彻底掌握vue的diff算法，前端面试不再怕！</a></p><p><a href="https://www.bilibili.com/video/BV1v5411H7gZ?p=12&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【尚硅谷】Vue源码解析之虚拟DOM和diff算法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个也是较为常考的面试八股题，很早之前面试准备时候了解过，如今也算是捡起来重新看看了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://crazystudent13.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="vue2" scheme="https://crazystudent13.github.io/tags/vue2/"/>
    
  </entry>
  
</feed>
