<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>智能家居，远程下载机</title>
      <link href="/2024/12/06/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%EF%BC%8C%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA/"/>
      <url>/2024/12/06/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%EF%BC%8C%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>关于智能家居的构想，一开始我只是想有个家用网盘能存东西就够。</p><p>但是，今年外出之后，才发现很多事的麻烦超出预料，不说别的，外部访问和下载速度就是一个很恶心的问题。</p><p>实际使用过程中，官方自带的外部访问速度很慢，并不好用，有时候甚至没法在外部看一些<code>1080p</code>的番剧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>总之，我必须得整一台下载机放在家里，主要作用是作为跳板来操作家里的其他工具。</p><p>家庭的上传带宽实际上是可以满足我的需求的，我测过峰值，实际使用的时候，很多时间是没问题的。</p><p>为了保证使用，我一开始在家里开的最稳定最好用的电信带宽。</p><p>但外部访问文件总会不稳定，大概率就出在群晖提供的跳板服务器，可能压制了中转速度了。</p><p>而且很多时候我需要对家里电脑进行操作，但是家里又没有这么一个跳板，所以这次打算一步到位，把该做的东西都做好。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我需要家里有一台电脑，能够方便我控制家里的其他智能家电，访问家里的nas。</p><p>同时，我需要能在外部用远程桌面访问，保证没有什么问题，这是一个保底手段，确保再外网穿透等手段崩盘的时候，能有个手段访问到我的家庭设备。</p><p>这个电脑需要具有如下特性：</p><ol><li>够便宜，因为现在钱极少，所以这是最核心的需求，价格最好能压到<strong>600元</strong>以下，不是新件也无所谓，有就可以。</li><li>够耐操，不是对环境有什么要求，单纯就是这台机子可能放在某个角落用3年以上，希望中间别用几个月就崩掉就好</li><li>低能耗，至少不能是个电老虎，常规的<code>400w</code>电源能撑住就行，当然，主要是稳妥，别出现炸电源的情况</li><li>容量大，硬盘的容量必须够大，而且因为现在固态容量低，且这玩意的本质就是下载机，所以希望有个自带2T的固态</li><li>高扩展，希望主板能保证有一个<code>m2</code>的固态插槽位置，<code>sata</code>口的固态很麻烦，我后续装硬盘不好装，如果可以，最好再预留一个固态的位置</li><li>速度快，希望主板能自带千兆的网卡，保证外部访问的速度，虽然外网肯定跑不满，但是家庭内网之间，这个带宽是可以跑满的，便于大文件的传输</li></ol><p>除此之外，常规状态下，我还是希望能运行一些稍微有点吃性能的工具软件。</p><p>如：<code>cad</code>，<code>手机模拟器</code>以及<code>DNF</code>这类经典的横版游戏，大致要求就是这样了。</p><p>不考虑笔记本，二手笔记本价格都不低，且如果配件出问题，台式机配件更便宜，且方便更换。</p><h3 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h3><p>经过和朋友的联络，成功的搞到两台不错的选项，事情比预想中的要好很多。</p><h4 id="肯德基套餐"><a href="#肯德基套餐" class="headerlink" title="肯德基套餐"></a>肯德基套餐</h4><p>硬件都是朋友的赞助，算是人情价，我自己再弄点机箱，线板之类的，累计约莫不到200就能入手，我只需要包邮加上<code>V50的疯狂星期四</code>即可。</p><p>显卡有两个朋友都愿意出，我正好也愿意收，AMD RX580 包邮就能拿，爽到。</p><table><thead><tr><th>配件</th><th>硬件类型</th><th>市场估价</th></tr></thead><tbody><tr><td>CPU</td><td></td><td></td></tr><tr><td>主板</td><td></td><td></td></tr><tr><td>内存</td><td></td><td></td></tr><tr><td>主硬盘</td><td></td><td></td></tr><tr><td>显卡A</td><td>R9 280X</td><td></td></tr><tr><td>显卡B</td><td>AMD RX580</td><td></td></tr></tbody></table><p>这么一整套，价格被压倒了极致，配合手里的一些零碎物件，用来做家里的跳板机，简直再合适不过。</p><h4 id="回旋镖电脑"><a href="#回旋镖电脑" class="headerlink" title="回旋镖电脑"></a>回旋镖电脑</h4><p>这是我一年前转给朋友的电脑，当时价格是3600，这电脑最开始我配置的时候原价差不多近6000，三年掉了近一半，真是没想到。</p><p>后来朋友需要电脑，我拆掉了部分配置，按照当时市场价卖他了。</p><p>正好，当时显卡价格有点虚，所以我砍了不少价格卖出去。</p><p>时隔一年，朋友换了新电脑，我正好要有台家用的远程电脑，这一套我卖出去的电脑仿佛去年的纸飞机回到我手里（暂时还没买，只是一个备选项）。</p><p>一开始，我预计现在价格差不多应该在2k左右，但是查了一下市价，比想象中的要低一些。</p><table><thead><tr><th>配件</th><th>硬件类型</th><th>市场估价</th></tr></thead><tbody><tr><td>CPU</td><td>i7-8700 CPU</td><td>500-600</td></tr><tr><td>主板</td><td>技嘉 B360 M</td><td>150</td></tr><tr><td>内存</td><td>32.00 GB (   2666 MHz)</td><td>180-200</td></tr><tr><td>主硬盘</td><td>256 GB  (三星 SAMSUNG MZVLB256HAHQ)</td><td>50</td></tr><tr><td>显卡</td><td>NVIDIA GeForce GTX 1060 3GB (3072MB)</td><td>450-500</td></tr></tbody></table><p>这套配置已经出乎意料的强了，没想到现在价格居然差不多两千就能入手，折价有点太狠，一时间有些唏嘘。</p><p>不过，暂时不考虑入手，毕竟现在手里经济已经拮据到一定程度了，实在是没有办法。</p><h3 id="远程方案"><a href="#远程方案" class="headerlink" title="远程方案"></a>远程方案</h3><p>远程方案我看了市面上的很多方案，大致总结了一下，主要要分为两步。</p><ol><li>远程开机，通过遥控的方式，在需要使用的时候打开家用电脑，在不需要的时候关闭，节省能耗</li><li>远程操作，目前市面上的第三方操作工具用的都不是很舒心，而开源的<code>rust-desk</code>效果不错，未来说不定会以此为主</li></ol><p>操作已经确定，剩下的就是确定方案了。</p><p>首先，是远程开机方案。</p><ol><li>远程电源控制+<code>BIOS</code>联动开机的方案，</li><li>另一种就是第三方提供的远程开机棒。</li></ol><p>以上，是市面上两种常规的方案，因为现状窘迫，我更倾向于第一种，远程电源控制+<code>BIOS</code>联动的方式来开机。</p><p>两者都要花钱，但是小米的远程控制供电还是更稳妥些。</p><p>其次，是远程控制，这个暂时没确定，不过我目前更倾向于使用<code>rust-desk</code>，毕竟是开源的项目，没有会员费用啥的，用着也省心。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>未完待定，节后续更。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年度个人大事件总结</title>
      <link href="/2024/11/27/2024%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E5%A4%A7%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2024/11/27/2024%E5%B9%B4%E5%BA%A6%E4%B8%AA%E4%BA%BA%E5%A4%A7%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>马上就要年末了，这是经历的最多的一年，发生了很多事，值得总结。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在2024阳历年落幕之前，我从技术，生活，游戏相关方向整理一下今年发生的事情。</p><p>顺带的，我会对今年的时政新闻做个简单的总结，算是对这个魔幻的时代做个记录。</p><p>这大概是我人生第二精彩的一年，因为今年有趣的事和糟糕的经历实在是多。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>今年上半年，按照个人规划，原本是要在徐州工作，原因是离家近，将来很多事儿方便。</p><p>但因为种种原因，加上自己家里出了事，且徐州工资较低，最终，我还是放弃了徐州的工作。</p><p>果然，低工资低消费会产生一个大问题，就是容错会极低。</p><h4 id="工作地"><a href="#工作地" class="headerlink" title="工作地"></a>工作地</h4><p>今年的工作地就两处，徐州和苏州，最终还是选择苏州，工资和生活水平相对没那么难受。</p><h5 id="徐州"><a href="#徐州" class="headerlink" title="徐州"></a>徐州</h5><p>徐州的工资水平难以超过8000，按照地方的工资水平，8000算是T1级别的工资，如果是上万，就算是妥妥的T0级别了。</p><p>关于地方物价，个人评价：极低。</p><p>一碗盖浇饭最多8-12左右，一碗偏荤的好菜，大约15就能吃到相当不错的菜了，而且这能保证我这个大胃王都能吃饱。</p><p>房租700左右，就能租到一个相当不错的单间，这房子放在苏州稍微热门的区域，估计得1500左右。</p><p>且今年还做了一个百公里骑行，把自己的自行车弄回来了，这种夸张的行为，可能是我这辈子仅见的事情了。</p><h5 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h5><p>苏州算是我的起始之地，很多朋友熟人都在这边，他们帮了我很多。</p><p>相对于上海的超高消费，苏州的消费没那么离谱，不至于让我第一步都走的那么艰难。</p><p>而且，苏州生活节奏相对较慢，是个清闲之地。</p><p>不过，这里毕竟是苏南，相对于徐州，苏州这边物价相对偏高，但是工资还算是不错。</p><p>虽然现在的工资没高过以前，只能算是持平。</p><p>这个没办法，毕竟很长时间没工作，这个空窗期让很多人招聘有顾忌，如今能有一份能持平之前薪资的工作，已经不错了。</p><p>而且，自己的学历没弄好，在苏州很难找到一个15K以上的工作。</p><p>又有今年工作特别难找的缘故，很多面试机会都没有，自己的经济水平又极为着急，所以我就先安稳下来了。</p><p>如今勉强算是稳定下来，好在工作不错，相对稳定，且作息很准时，不会像以前一样瞎搞加班。这让我有充分的时间能安排自己，这让我很开心，也很感激现在的老板和项目组。</p><p>不过，这边的技术栈相对来说有点旧，不知道后续能不能主导升级。</p><p>同年，做了小自考的报名，给大自考做个托底，省的自己大自考后续拖延了自己的进度。</p><h4 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h4><ol><li>年终体检，左肾结石，右肾有结晶，且中度偏重度脂肪肝，尿酸偏高，同时高血脂，这问题比较糟糕，得作为下一年的重要事项。</li><li>明明经常换衣服，同事还是好意提醒说体味较大，怀疑是身体内分泌出了问题</li><li>血压控制初见成效，后续保持服药，剩下的等报告出来之后再细究。</li></ol><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>技术相对于之前固定的技术栈有了长足的进步，因为今年徐州之行接触的公司，至少技术不错。</p><p>可以说，今年很多相关的新技术都是在那时候开始使用实践的，加上今年新工作难度不高，业余时间相对充裕，所以，做了很多事。</p><ol><li>通过<code>vue3</code>的相关项目开发，学习了<code>vue3</code>+ <code>ts</code>的开发方式，建立了<code>vue3</code>的开框架</li><li>整合了自己前端的知识体系，填充了很多边缘地带的技术</li><li>补习<code>nestjs</code>为底的相关后端技术，让自己的技术体系逐渐完整，不算半吊子开发了，从运维，后端开发的角度提升了自己</li><li>参与了数个开源项目的开发，让自己拓展的知识体系能够有实践的平台</li></ol><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>今年是玩游戏最憋屈的一年，要么是没有时间玩，只能说当穷了的时候，什么事情都做的很憋屈。</p><p>这里整理一下，今年要是有钱有闲了，我得花个时间好好玩玩一下。</p><ol><li>6月，艾尔登法环<code>dlc</code>发布，但是没钱，没时间，也没配置</li><li><code>820</code>黑神话发售，但是没钱买，没配置，但是此时其实勉强有时间，只能去贴吧进行论坛PVP</li><li>买了<code>逸剑风云决</code>，但是没时间玩，此时有空间</li><li>玩了卡琳典狱长，玩了，也很喜欢，但是没时间整理相关攻略，太可惜了，难得游戏性不错的黄游</li></ol><h3 id="时政"><a href="#时政" class="headerlink" title="时政"></a>时政</h3><p>今年的时政是极为特殊的一年，甚至可以说是这数年最为有趣的一年了。</p><p>果然，懂王上台，时政区就是会变得极为有趣。</p><ol><li>特朗普以极为有趣形式重新回归，如有神佑的那一幕真是太酷了，传说他要整治<code>LGBT</code>的相关内容，不知道能不能成型。</li><li>因为特朗普登台，乌克兰现阶段没有了援助，未来俄乌战场似乎会变得消停，这有些太无趣了</li><li>国内房价似乎开始终于开始回归理性，不少地方的房价开始逐渐腰斩，就这样还卖不出去，但是也不是全部腰斩，核心地段的房价依然坚挺，只能依靠等待了</li><li>市面上，技术工作开始逐渐难找，前端技术开发和3年前的招聘要求完全是滑档了两个层次</li><li>京东在今年双11找杨笠代言，引发了众怒，今年平台居然罕见的被大部分男性群体抵制，这大概是男女矛盾第一次如此直观剧烈的显现出来</li><li>2024年12月，韩国总统尹锡悦在任期内发动一场政变，似乎要搞集权，但是不到一晚就失败，过程极为戏剧性，似乎不到六小时，我几乎以为我活在一个戏剧的世界里，这场政变中，李明博直接翻墙（因为士兵封锁大门，但是也许出于师出无名的问题，又没有完全封锁），结果就是这种磨洋工的现状，我还以为会是新的一场光州无限制格斗大赛来着。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前先整理这么多，后续在2024年阳历年结束之前，我会逐步整理。</p><p>这虽然是我过的最操蛋的一年，但确实是最近数年来最精彩的一年，值得记录。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>暂无</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解强缓存与协商缓存</title>
      <link href="/2024/11/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
      <url>/2024/11/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>关于强缓存与协商缓存，之前从未深入了解过。</p><p>一直到最近优化项目的时候，群友提到了刷新页面的时候，为什么资源会比第一次更快？</p><p>我自然知道这是缓存，深入一些就是强缓存，然后具体的呢？我回答不上了。</p><p>于是，为了弄明白为什么浏览器第二次访问效果会更快，我这里就整理了本篇，便于自己理解相关概念。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>所谓强缓存，可以理解为强制缓存的意思</p><p>即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用。</p><p>且由于直接从本地缓存读取资源文件，大大提高了加载速度。</p><p>强缓存的具体流程为：</p><p>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置<code>Cache-Control: max-age=31536000</code>，max-age代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</p><p>使用缓存的话，状态码200后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p><p>当缓存时间到期后再次访问时，状态码200后面便没有括号内的内容了。</p><blockquote><p>一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！</p></blockquote><p><code>Cache-Control</code>除了max-age外，还可以设置其它属性值：</p><ul><li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li><li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li><li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li><li>public: 客户端和代理服务器都可缓存。</li><li>s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。</li></ul><p>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是Http1.0规范，<code>Cache-Control</code>是Http1.1规范，<code>Expires</code>返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。</p><p>因为<code>Expires</code>参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是<code>Expires</code>的一个缺点，所以有了后来Http1.1规范的<code>Cache-control</code>。</p><p>另外，<code>Cache-control</code>的优先级要高于<code>Expires</code>，如果两者同时设置，会优先使用<code>Cache-control</code>而忽略掉Expires。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存。</p><p>协商缓存的具体流程如下：</p><p>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比。</p><ul><li>如果没有变化则返回304，告诉浏览器继续使用缓存（不返回资源文件）。</li><li>如果发生变化，则返回200和最新的资源文件给浏览器使用。</li></ul><p>除了<code>Etag</code>外，还有一个<code>Last-Modified</code>的属性，它是Http1.0规范的，服务器返回<code>Last-Modified</code>，浏览器请求头对应携带的是<code>If-Modified-since</code>，与<code>Etag</code>不同的是，<code>Last-Modified</code>的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p><p>相比<code>Last-Modified</code>，<code>Etag</code>优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code>不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p><blockquote><p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。</p></blockquote><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><h4 id="强缓存-1"><a href="#强缓存-1" class="headerlink" title="强缓存"></a>强缓存</h4><p>浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p><h4 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文大多并非原创，主要内容是摘录他人文章后整合的。</p><p>但是因为转载的内容并不单一，标注为转载又有点不太合适，且确实有我个人的理解在内。</p><p>于是，本文仅作为自己的收藏，而不发布到掘金。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7259298281578889273">什么是强缓存、协商缓存？</a></p><p><a href="https://juejin.cn/post/6844903838768431118?searchId=202411162334056453EA14D654B17A5778">http面试必会的：强制缓存和协商缓存</a></p><p><a href="https://juejin.cn/post/7065895592613904392?searchId=202411162334056453EA14D654B17A5778">不废话，代码实践带你掌握 强缓存、协商缓存！</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决前端JS精度丢失的问题</title>
      <link href="/2024/11/04/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AFJS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/11/04/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AFJS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>前端数据精度丢失是个常见的问题，本次记录说实话有点大可不必，毕竟这是一个前端常见的问题。</p><p>但是考虑到自己的记忆水平不够，每次再去找攻略又有点不太合适，太过浪费时间。</p><p>索性这次就记录一下，便于后续快速使用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在前端开发中，尤其是在处理财务数据或需要高精度计算的场景下，JavaScript 的浮点数运算可能会导致精度丢失。</p><p>例如，<code>0.1 + 0.2</code> 的结果不是 <code>0.3</code>，而是 <code>0.30000000000000004</code>。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul><li>JavaScript 使用 IEEE 754 标准来表示浮点数，这种表示方法在某些情况下会导致精度丢失。</li><li>浮点数的二进制表示无法精确表示某些十进制小数，从而导致计算结果不准确。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>我知道有很多可能为了方便会用使用 <code>toFixed</code> 或 <code>Math.round</code> ，对于简单的应用场景，这可能已经足够。</p><p>但是大多数我们要处理精度的场景，往往都是涉及到支付金额的计算，这些都是非常重要的场景，一定不能出现精度丢失的情况。</p><p>所以，此时我们就需要引入精度库。</p><p>市面上有常见的好几种精度库，我这里距离如下：</p><ul><li><a href="https://juejin.cn/post/7012270695145029639?searchId=20241104222945653935635CFFEC49C964">decimal.js</a>：功能最全面，适合大多数高精度计算需求。</li><li><a href="https://juejin.cn/post/6931167908429037582">big.js</a>：体积最小，适合对性能和体积有严格要求的项目。</li><li><a href="https://juejin.cn/post/6844903704714280968">bignumber.js</a>：功能强大，支持多种数据类型，适合复杂的高精度计算场景。</li></ul><p>以上是市面上常用的三种精度库，如果你想了解更多，欢迎参考下放链接。</p><p><a href="https://juejin.cn/post/7069965114564165662">big.js、bignumber.js 和 decimal.js 之间的差别（翻译）</a></p><h3 id="decimal-js"><a href="#decimal-js" class="headerlink" title="decimal.js"></a>decimal.js</h3><p>我这里就先介绍我自己常用的精度库，泛用性最广，使用起来也相对简单的库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install decimal.js</span><br></pre></td></tr></table></figure><p>Decimal.js 支持以下运算符的重载</p><table><thead><tr><th>运算符名称</th><th>运算符</th></tr></thead><tbody><tr><td>加法</td><td>+</td></tr><tr><td>减法</td><td>-</td></tr><tr><td>乘法</td><td>*</td></tr><tr><td>除法</td><td>&#x2F;</td></tr><tr><td>取模运算</td><td>%</td></tr><tr><td>指数运算</td><td>**</td></tr><tr><td>自增运算</td><td>++</td></tr><tr><td>自减运算</td><td>–</td></tr></tbody></table><p>这些运算符被重载后，可以直接用于 Decimal 对象之间的运算，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="string">&#x27;2.5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = a + b; <span class="comment">// 等同于 a.plus(b)</span></span><br><span class="line"><span class="keyword">const</span> d = b - a; <span class="comment">// 等同于 b.minus(a)</span></span><br><span class="line"><span class="keyword">const</span> e = a * b; <span class="comment">// 等同于 a.times(b)</span></span><br><span class="line"><span class="keyword">const</span> f = a / b; <span class="comment">// 等同于 a.div(b)</span></span><br><span class="line"><span class="keyword">const</span> g = b % a; <span class="comment">// 等同于 b.mod(a)</span></span><br><span class="line"><span class="keyword">const</span> h = a ** <span class="number">2</span>; <span class="comment">// 等同于 a.toPower(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">i++; <span class="comment">// 等同于 i = i.plus(1);</span></span><br><span class="line">i--; <span class="comment">// 等同于 i = i.minus(1);</span></span><br></pre></td></tr></table></figure><p>以下是它的通常用法：</p><h4 id="格式化数值"><a href="#格式化数值" class="headerlink" title="格式化数值"></a>格式化数值</h4><p>数值被处理后，不能直接展示到页面，得格式化一下，一般常用的由以下几种。</p><ul><li><code>toString()</code> 格式化为字符串。</li><li><code>valueOf()</code> 格式化为字符串，但是有符号零 <code>console.log((new Decimal(-0)).valueOf()) // -0</code>。</li><li><code>toNumber()</code> 格式化为Number类型，转换为原始数字的值。</li><li><code>toFixed()</code> 格式化为字符串类型，用法和JS中<code>toFixed()</code>一样，不同的是decimal.js中的<code>toFixed()</code>有第二参数，可以设置舍入的类型。</li></ul><p>还有一些不常用的</p><ul><li><code>toBinary()</code> 格式化为二进制。</li><li><code>toHexadecimal()</code> 格式化为十六进制。</li><li><code>toOctal()</code> 格式化为八进制。</li></ul><h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h4><p>在计算中最经常用到就是加减乘除，下面来看一下decimal.js中的加减乘除。</p><p>有两种用法，一种是使用<code>Decimal</code>类的静态方法，一种是使用<code>Decimal</code>类实例方法。</p><ul><li>加法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Decimal</span>.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> result = x.<span class="title function_">plus</span>(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>减法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Decimal</span>.<span class="title function_">sub</span>(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> result = x.<span class="title function_">sub</span>(<span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>乘法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Decimal</span>.<span class="title function_">mul</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> result = x.<span class="title function_">mul</span>(<span class="number">2</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>除法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Decimal</span>.<span class="title function_">div</span>(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> result = x.<span class="title function_">div</span>(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>使用除法时候要注意 除数（分母）不能为0。</strong></p><h4 id="取绝对值"><a href="#取绝对值" class="headerlink" title="取绝对值"></a>取绝对值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Decimal</span>.<span class="title function_">abs</span>(-<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(-<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> result = x.<span class="title function_">abs</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>大于</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">greaterThan</span>(y)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>大于等于</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">greaterThanOrEqualTo</span>(y)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>小于</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="title function_">lessThan</span>(x)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>小于等于</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="title function_">lessThanOrEqualTo</span>(x)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>等于</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">equals</span>(y)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul><li>是否是整数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">1</span>) </span><br><span class="line">x.<span class="title function_">isInteger</span>(); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">123.456</span>) </span><br><span class="line">y.<span class="title function_">isInt</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>是否是正数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">0</span>);</span><br><span class="line">x.<span class="title function_">isPositive</span>();<span class="comment">// true</span></span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(-<span class="number">2</span>);</span><br><span class="line">y.<span class="title function_">isPos</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>是否是负数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Decimal</span>(-<span class="number">0</span>); </span><br><span class="line">x.<span class="title function_">isNegative</span>(); <span class="comment">// true </span></span><br><span class="line">y = <span class="keyword">new</span> <span class="title class_">Decimal</span>(<span class="number">2</span>); </span><br><span class="line">y.<span class="title function_">isNeg</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有传言说这三种精度库是一个作者，其实用哪个都可以。</p><p>但是这个传言我记不清自己是在哪里看到的了，不过这里我就不去详细考证了。</p><p>于此时的我而言，能用就行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/nanfei/p/17247991.html">js 中使用 decimal.js 进行不丢失精度的小数计算 - 空明流光 - 博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化，gzip压缩加速访问</title>
      <link href="/2024/10/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8Cgzip%E5%8E%8B%E7%BC%A9%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/"/>
      <url>/2024/10/28/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8Cgzip%E5%8E%8B%E7%BC%A9%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p><code>gzip</code>文件压缩是一个常用的性能提升手段，几乎是现代前端做性能优化的必须手段。</p><p>以前一直想整理一下，但是没有合适的例子，最近正好在整理自己的开源项目，且服务器带宽很烂。</p><p>于是，这次经历就是一个极佳的性能优化案例了，一定要整理下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先说结论，<code>gzip</code>压缩效果出乎意料的好，大幅提升了访问速度，将一个访问极慢的页面改为至少勉强能用了。</p><p>废话不说多，我们直接看结果。</p><h3 id="对比结果"><a href="#对比结果" class="headerlink" title="对比结果"></a>对比结果</h3><table><thead><tr><th align="center">对比指标</th><th align="center">优化前</th><th align="center">优化后</th></tr></thead><tbody><tr><td align="center">文件大小</td><td align="center">2M左右</td><td align="center">500k左右</td></tr><tr><td align="center">访问时间</td><td align="center">90s左右</td><td align="center">15s左右</td></tr></tbody></table><p>可以看到，性能提升了不止一点点，尽管很慢，但是速度确实肉眼可见的大幅提升。</p><p>不过因为服务器带宽太低，这里访问速度效果还是很差。</p><h3 id="Vue3配置"><a href="#Vue3配置" class="headerlink" title="Vue3配置"></a>Vue3配置</h3><p>在 Vite 项目中配置 Gzip 压缩，可以通过 <code>vite.config.js</code> 文件来实现。</p><p>安装依赖， 如果你还没有安装 <code>vite-plugin-compression</code> 插件，可以使用以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vite-plugin-compression --save-dev</span><br></pre></td></tr></table></figure><p>配置 <code>vite.config.js</code>， 在 <code>vite.config.js</code> 文件中引入并配置 <code>vite-plugin-compression</code> 插件。</p><p>这里单独配置了一个插件，如下，当我们在生产环境时候再使用<code>gzip</code>比较好。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compression <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-compression&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createCompression</span>(<span class="params">env</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="variable constant_">VITE_BUILD_COMPRESS</span> &#125; = env</span><br><span class="line">    <span class="keyword">const</span> plugin = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">VITE_BUILD_COMPRESS</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> compressList = <span class="variable constant_">VITE_BUILD_COMPRESS</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (compressList.<span class="title function_">includes</span>(<span class="string">&#x27;gzip&#x27;</span>)) &#123;</span><br><span class="line">            plugin.<span class="title function_">push</span>(</span><br><span class="line">                <span class="title function_">compression</span>(&#123;</span><br><span class="line">                    <span class="attr">ext</span>: <span class="string">&#x27;.gz&#x27;</span>,</span><br><span class="line">                    <span class="attr">deleteOriginFile</span>: <span class="literal">false</span></span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (compressList.<span class="title function_">includes</span>(<span class="string">&#x27;brotli&#x27;</span>)) &#123;</span><br><span class="line">            plugin.<span class="title function_">push</span>(</span><br><span class="line">                <span class="title function_">compression</span>(&#123;</span><br><span class="line">                    <span class="attr">ext</span>: <span class="string">&#x27;.br&#x27;</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>: <span class="string">&#x27;brotliCompress&#x27;</span>,</span><br><span class="line">                    <span class="attr">deleteOriginFile</span>: <span class="literal">false</span></span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plugin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里将所有的文件都封装为一个config文件，搞定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> createCompression <span class="keyword">from</span> <span class="string">&#x27;./compression&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createVitePlugins</span>(<span class="params">viteEnv, isBuild = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> vitePlugins = [<span class="title function_">vue</span>()]</span><br><span class="line">isBuild &amp;&amp; vitePlugins.<span class="title function_">push</span>(...<span class="title function_">createCompression</span>(viteEnv))</span><br><span class="line">    <span class="keyword">return</span> vitePlugins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>vue.config.js</code>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createVitePlugins <span class="keyword">from</span> <span class="string">&#x27;./vite/plugins&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig, loadEnv &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> createVitePlugins <span class="keyword">from</span> <span class="string">&#x27;./vite/plugins&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; mode, command &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> env = <span class="title function_">loadEnv</span>(mode, process.<span class="title function_">cwd</span>())</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="variable constant_">VITE_APP_ENV</span> &#125; = env</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 部署生产环境和开发环境下的URL。</span></span><br><span class="line">    <span class="comment">// 默认情况下，vite 会假设你的应用是被部署在一个域名的根路径上</span></span><br><span class="line">    <span class="attr">base</span>: <span class="variable constant_">VITE_APP_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/&#x27;</span> : <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: <span class="title function_">createVitePlugins</span>(env, command === <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p>光完成vue3的配置打包，并不能在线上访问，这时候需要自行去处理<code>nginx</code>的配置，保证用户可以获取对应的配置。</p><h4 id="为什么要开启-gzip-压缩？"><a href="#为什么要开启-gzip-压缩？" class="headerlink" title="为什么要开启 gzip 压缩？"></a>为什么要开启 gzip 压缩？</h4><p>在深入了解如何开启之前，让我们先弄清楚为什么要使用 gzip 压缩。</p><p>简单来说，gzip 压缩可以将网页文件大小压缩至原大小的 30% 甚至更低，这直接导致了数据传输时间的缩短，进而提升了网站加载速度，提高用户体验。</p><p>尤其是对于文本类文件（如 HTML、CSS、JavaScript），gzip 可以极大地优化其传输效率。</p><h4 id="开启-Nginx-的-gzip-压缩"><a href="#开启-Nginx-的-gzip-压缩" class="headerlink" title="开启 Nginx 的 gzip 压缩"></a>开启 Nginx 的 gzip 压缩</h4><p>接下来，我们一步步来操作如何在 Nginx 中开启 gzip 压缩。</p><p>首先，你需要找到 Nginx 的配置文件 <code>nginx.conf</code>，通常位于 <code>/etc/nginx/nginx.conf</code>。</p><h5 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h5><p>使用你喜欢的文本编辑器打开 <code>nginx.conf</code>，然后在 <code>http</code> 模块（不是 <code>server</code> 或 <code>location</code>）中添加如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip on<span class="comment">;  # 开启 gzip 压缩</span></span><br><span class="line">gzip_min_length 1k<span class="comment">;  # 设置允许压缩的页面最小字节数</span></span><br><span class="line">gzip_buffers 16 64k<span class="comment">;  # 设置系统获取多少缓冲区，以及每个缓冲区的大小</span></span><br><span class="line">gzip_http_version 1.1<span class="comment">;  # 启用 HTTP/1.1 时的 gzip 压缩</span></span><br><span class="line">gzip_comp_level 9<span class="comment">;  # 设置 gzip 压缩级别，1（最快）到 9（最小）9是最高压缩率但占用CPU较多</span></span><br><span class="line">gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml<span class="comment">;  # 指定压缩的 MIME 类型</span></span><br><span class="line">gzip_vary on<span class="comment">;  # 根据请求的Accept-Encoding头信息来判断是否启用gzip</span></span><br></pre></td></tr></table></figure><p>这里简单解释一下关键参数：</p><ul><li><code>gzip on;</code>：启用 gzip 模块。</li><li><code>gzip_min_length 1k;</code>：仅压缩大于 1KB 的响应体内容，避免对小文件进行压缩反而增大体积。</li><li><code>gzip_comp_level 9;</code>：设置压缩等级，1-9，数值越大，压缩率越高，但相对会占用更多的 CPU 资源。</li><li><code>gzip_types</code>：定义哪些类型的文件需要被压缩，常见的有 HTML、CSS、JS 等文件类型。</li></ul><h4 id="重启-Nginx"><a href="#重启-Nginx" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h4><p>编辑完毕后，通过以下命令重新加载 Nginx 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="验证-gzip-压缩是否开启"><a href="#验证-gzip-压缩是否开启" class="headerlink" title="验证 gzip 压缩是否开启"></a>验证 gzip 压缩是否开启</h4><p>最简单的验证方式是通过浏览器的开发者工具。</p><p>在浏览器地址栏输入你的网站地址，打开网站，然后按 F12 打开开发者工具，选择“网络”(Network)标签页。</p><p>刷新网页，点击任意一个请求，在响应标头（Response Headers）中查找 <code>Content-Encoding</code> 字段。</p><p>如果看到 <code>gzip</code>，恭喜你，gzip 压缩已经成功开启！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述步骤，你可以轻松地在 Nginx 服务器上启用 gzip 压缩功能。</p><p>虽然这会稍微增加服务器的 CPU 负荷，但考虑到带宽成本和网站性能的提升，这通常是值得的。</p><p>另外，不要忘了定期检查你的网站性能，确保它能够为用户提供最佳的访问体验。</p><p>开启 gzip 压缩只是众多性能优化策略中的一个，持续优化，让我们的网站更快！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000045033478">Nginx 开启 gzip 压缩，让网站飞一会！ - 左诗右码 - SegmentFault 思否</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> nginx </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决MySQL8小时无连接自动关闭问题</title>
      <link href="/2024/10/10/%E8%A7%A3%E5%86%B3MySQL8%E5%B0%8F%E6%97%B6%E6%97%A0%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/10/%E8%A7%A3%E5%86%B3MySQL8%E5%B0%8F%E6%97%B6%E6%97%A0%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近部署了<code>nest-admin</code>线上环境，但是线上的<code>MySQL</code>总是在次日无法连接，每次都要重启。</p><p>一开始没弄明白的时候，被这个定期关机的情况折腾的心累。</p><p>后来稍微搜了一下，才发现这事儿好像是线上长时间断连之后，MySQL会自动关闭导致的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>经测试，此方法虽然在一定程度上缓解了这种问题，但是似乎并不能完美解决数据库断连的问题，如果有更好的办法，还请评论留言。</p><p>这里以常见的MySQL数据库为例，介绍如何配置其自动重启功能。</p><p>这些步骤同样适用于其他类型的数据库服务，如PostgreSQL、MongoDB等，但具体的命令和服务名称可能会有所不同。</p><p>在此之前，请确保已经装过了MySQL工具，另外，部分命令可能因为MySQL的版本不同而有差异，推荐用通义千问之类的AI工具辅助操作。</p><h3 id="确保服务开机自启"><a href="#确保服务开机自启" class="headerlink" title="确保服务开机自启"></a>确保服务开机自启</h3><p>对于大多数Linux发行版，可以通过以下命令来设置MySQL服务开机自启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure><p>这会创建一个符号链接到<code>/etc/systemd/system/multi-user.target.wants/</code>目录下，使得systemd在启动multi-user目标时也会启动MySQL服务。</p><h3 id="配置systemd自动重启策略"><a href="#配置systemd自动重启策略" class="headerlink" title="配置systemd自动重启策略"></a>配置systemd自动重启策略</h3><p>为了使数据库服务在意外停止时能够自动重启，可以编辑服务的systemd单元文件，添加或修改<code>[Service]</code>部分中的<code>Restart</code>选项。</p><p>对于MySQL，文件通常位于<code>/lib/systemd/system/mysql.service</code>或<code>/etc/systemd/system/mysql.service</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/mysqld.service</span><br></pre></td></tr></table></figure><p>在文件中加入或修改如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini[Service]</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10s</span><br></pre></td></tr></table></figure><ul><li><code>Restart=always</code> 指定当服务退出时，systemd将总是尝试重启它。</li><li><code>RestartSec=10s</code> 定义了systemd在尝试重新启动服务前等待的时间。</li></ul><p>修改完成后，重载systemd配置并重启MySQL服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart  mysqld.service</span><br></pre></td></tr></table></figure><blockquote><p><code>sudo systemctl daemon-reload</code> 是一个用于刷新 systemd 系统和服务管理器配置的命令。</p><p>执行该命令后，systemd 会重新加载所有服务单元文件，包括新添加的或已修改的单元文件。</p><p>这个命令通常在修改了服务配置文件（如 <code>.service</code> 文件）之后使用，以使更改生效。</p><p>无需重启系统即可应用新的配置，提高了配置调整的效率和灵活性。</p></blockquote><h3 id="测试自动重启功能"><a href="#测试自动重启功能" class="headerlink" title="测试自动重启功能"></a>测试自动重启功能</h3><p>为了验证上述配置是否有效，你可以手动停止MySQL服务，并观察它是否按照预期自动重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop mysqld</span><br></pre></td></tr></table></figure><p>然后等待一段时间，检查服务状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure><p>如果一切正常，你应该能看到服务已经自动重新启动。</p><h3 id="监控与日志"><a href="#监控与日志" class="headerlink" title="监控与日志"></a>监控与日志</h3><p>为了更好地管理和监控数据库服务的状态，建议设置日志记录和告警机制。</p><p>可以利用Linux的日志系统（如syslog）或者第三方工具（如Prometheus, Grafana）来实现这一目的。</p><p>通过以上步骤，你可以为Linux环境下的数据库服务配置自动重启功能，从而提高系统的可靠性和可用性。</p><h3 id="修改MySQL配置"><a href="#修改MySQL配置" class="headerlink" title="修改MySQL配置"></a>修改MySQL配置</h3><p>如果你的配置不是8小时无连接导致的自动断连，可能是你的配置有问题。</p><p>你可以通过修改间隔时长，至少保证不会因为间隔时间太短导致频繁断连。</p><p><code>interactive_timeout</code>参数，定义了对于交互式连接，服务端等待数据的最大时间。</p><p>如果超过这个时间，服务端仍然没有收到数据，则会关闭连接，默认是28800，单位秒，即8个小时。</p><h4 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h4><p>打开<code>/etc/my.cnf</code>，在属性组mysqld下面添加如下参数。</p><p>这样，我们有8H的间隔连接时间，这样我们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interactive_timeout=28800000</span><br><span class="line">wait_timeout=28800000</span><br></pre></td></tr></table></figure><h4 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h4><p>和linux一样，打开my.ini，添加同样配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interactive_timeout=28800000</span><br><span class="line">wait_timeout=28800000</span><br></pre></td></tr></table></figure><p>有实践表明，没有办法把这个值设置成无限大，即永久。</p><p>因此如果你无法保证你的应用程序必定在设定的秒数内至少有一次操作，那么最好用第二个方法解决这个问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我目前采用的方法算是治标不治本，简单的来说，就是设置一个定时重启MySQL的脚本配置，保证MySQL不断连。</p><p>实际开发中，大多使用连接池或者其他方式来解决这种问题，后续随着我对后端的深入，我会使用考虑使用其他方式来解决此类问题。</p><p>目前先用配置这种笨一些的方式吧，至少简单好用，能解决问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tongyi.aliyun.com/qianwen/">通义千问</a></p><p><a href="https://www.cnblogs.com/lanyangsh/p/11667233.html">MySQL 的连接时长控制–interactive_timeout和wait_timeout - 翔云123456 - 博客园 (cnblogs.com)</a></p><p><a href="https://developer.aliyun.com/article/131129">如何解决mysql数据库8小时无连接自动关闭</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决浏览器不支持getUserMedia!</title>
      <link href="/2024/09/25/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getUserMedia/"/>
      <url>/2024/09/25/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81getUserMedia/</url>
      
        <content type="html"><![CDATA[<p>这种问题在本地开发不会出现，只会在线上部署之后才会出现这种问题。</p><p>如果不是特殊情况，建议还是用更好的录音组件。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为最近有个录音需求，要求使用者能进行录音上传，然后读取后端传回来的链接，进行语音播放。</p><p>在比较了多个录音工具之后，我选用了<code>js-audio-recorder</code>，效果还不错。</p><p>在本地完成这个需求后，测了一下是没有问题的，但发布线上才发现不行。</p><h3 id="问题情况"><a href="#问题情况" class="headerlink" title="问题情况"></a>问题情况</h3><p>查了一下才知道，这是最新的api被浏览器锁了权限。</p><p>发布到线上之后，浏览器会报如下错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error :浏览器不支持 getUserMedia !</span><br></pre></td></tr></table></figure><p><code>js-audio-recorder</code>用的是<code>getUserMedia</code>这个<code>api</code>。</p><p> chrome，edge, <a href="https://so.csdn.net/so/search?q=fireFox&spm=1001.2101.3001.7020">fireFox</a> 等主流浏览器由于安全限制将不会暴露getUserMedia 方法，所以就不能够访问用户的媒体设备。</p><p><code>getUserMedia</code>在高版本的chrome下需要使用https，如果你的项目是部署在https页面，那么则不用此类方法也可以解决。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>复制下方链接，到浏览器上打开，进入配置页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://flags/#unsafely-treat-insecure-origin-as-secure</span><br></pre></td></tr></table></figure><p>将要录音的网站地址(ip+端口号)输入到<code>Insecure origins treated as secure</code>中，然后将<code>Disabled</code>下拉改为<code>Enabled</code></p><p>此时下方会提示重启浏览器，点击Relaunch重启浏览器。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>填入当前使用的网站，而不是要上传的服务器链接。</li><li>不用担心会关闭所有页面，所有页面在重启浏览器之后依然会重新打开。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这种方式属于是临时解决方式，如果有更好的录音解决方式，建议还是换其他的组件。</p><p>而且，<code>js-audio-recorder</code>的最新版本已经是4年前了，活跃度没那么高了。</p><p>虽然稳定，但是没什么活跃度和更新的组件，将来就算真的出问题，恐怕也很难解决。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/126965558">Vue中使用js-audio-recorder实现录音时提示:浏览器不支持getUserMedia!_浏览器不支持 getusermedia-CSDN博客</a></p><p><a href="https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/126957202">Vue中使用js-audio-recorder插件实现录音功能并实现上传Blob数据到SpringBoot后台接口-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】腾讯云OpenCloudOS部署NestJS项目</title>
      <link href="/2024/09/23/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2NestJS%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/09/23/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2NestJS%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>目前还在艰难摸索部署流程中，虽然初步完成了项目的部署。</p><p>不过由于种种原因，暂时还没成功，后续我会继续摸索完善该文档。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>整个流程其实和本地开发流程大概类似，安装配置好node环境，再安装PM2工具，用于管理进程。</p><p>在完成准备工作之后，上传<code>nestjs</code>的后端环境压缩包，然后在线上npm装好包，到此完成</p><p>只是流程多了个PM2工具来管理进程。</p><h3 id="安装node环境"><a href="#安装node环境" class="headerlink" title="安装node环境"></a>安装node环境</h3><p>安装完成后也要创建一个软链接才可以全局使用</p><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /server/soft/node</span><br></pre></td></tr></table></figure><h4 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /server/soft/node</span><br></pre></td></tr></table></figure><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p>下载最新版本的Node.js，这里我用<code>wget</code>命令下载，如果不能用，建议查一下其他的linux下载命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v20.5.0/node-v20.5.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h4 id="解压到指定目录"><a href="#解压到指定目录" class="headerlink" title="解压到指定目录"></a>解压到指定目录</h4><p>这里我们就解压到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xJvf node-v20.5.0-linux-x64.tar.xz -C /server/soft/node</span><br></pre></td></tr></table></figure><h4 id="配置nodejs环境"><a href="#配置nodejs环境" class="headerlink" title="配置nodejs环境"></a>配置nodejs环境</h4><p>看了其他人的文档，有人说创建软链接的方式不太好，个人参考那篇文档没跑通。</p><p>折腾了一段时间之后，还是选择如下方案，node环境推荐按照当前最新的稳定版本（node20）。</p><h5 id="在默认路径中创建对应的软链-推荐"><a href="#在默认路径中创建对应的软链-推荐" class="headerlink" title="在默认路径中创建对应的软链 (推荐)"></a>在默认路径中创建对应的软链 (推荐)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 node 软链</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /server/soft/node/node-v20.5.0-linux-x64/bin/node /usr/bin/node</span><br><span class="line"><span class="comment"># 创建 npm 软链</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /server/soft/node/node-v20.5.0-linux-x64/bin/npm /usr/bin/npm</span><br><span class="line"><span class="comment"># 创建 npx 软链</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /server/soft/node/node-v20.5.0-linux-x64/bin/npx /usr/bin/npx</span><br></pre></td></tr></table></figure><p>优点: 创建一次，所有用户均可运行node相关命令<br>缺点: 每增加一个全局node相关命令都要创建软链</p><h5 id="移除对应内容"><a href="#移除对应内容" class="headerlink" title="移除对应内容"></a>移除对应内容</h5><p>如果要是对应的软连接已经被占用，可以用以下命令移除对应的软连接，再重新执行上边的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /usr/bin/node</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/bin/npm</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/bin/npx</span><br></pre></td></tr></table></figure><h4 id="验证版本"><a href="#验证版本" class="headerlink" title="验证版本"></a>验证版本</h4><p>如果这里版本验证成功后，到此，<code>node</code>安装的流程就算是完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h3 id="安装PM2"><a href="#安装PM2" class="headerlink" title="安装PM2"></a>安装PM2</h3><p>安装<code>pm2</code>也要添加软连接，因为使用npm下载安装，所以下载目录就在node的<code>bin</code>目录下。</p><h4 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><h4 id="添加软连接"><a href="#添加软连接" class="headerlink" title="添加软连接"></a>添加软连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /server/soft/node/node-v20.5.0-linux-x64/bin/pm2  /usr/bin/pm2</span><br></pre></td></tr></table></figure><h3 id="启动nest项目"><a href="#启动nest项目" class="headerlink" title="启动nest项目"></a>启动nest项目</h3><p>将本地的nest项目打包成tar包，然后传到对应的目录。</p><p>不过，如果你nest项目如果是独立的，你也可以考虑直接在服务器上用<code>git</code>下载，只不过这么做太费事，我懒得整了，直接本地打包放上去就好。</p><h4 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h4><p>当前目录是用来放nest项目后端的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /server/soft/nest-admin</span><br></pre></td></tr></table></figure><h4 id="解压到指定目录-1"><a href="#解压到指定目录-1" class="headerlink" title="解压到指定目录"></a>解压到指定目录</h4><p>这里我们将对应的压缩包解压到我们刚才创建的目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf nest-server.tar -C /server/soft/nest-admin</span><br></pre></td></tr></table></figure><h4 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h4><p>这里我们切换到对应的项目目录，然后为npm安装做准备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /server/soft/nest-admin/server/</span><br></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>因为我这里没有多个项目，所以我就不额外安装<code>pnpm</code>来做包管理了，直接用<code>npm</code>安装包依赖就够了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>如果要是你喜欢使用pnpm来进行管理，也可以提添加一个pnpm的软连接，方便后续用pnpm管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 npm 软链</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /server/soft/node/node-v20.5.0-linux-x64/bin/pnpm /usr/bin/pnpm</span><br></pre></td></tr></table></figure><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /server/soft/nest-admin/server/dist</span><br><span class="line">pm2 start main.js</span><br></pre></td></tr></table></figure><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>我这里是用腾讯云小程序开了防火墙的对应的端口。</p><h4 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h4><p>因为我这里端口是8080，所以我这里就用8080启动项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip地址:8080/swagger-ui/</span><br></pre></td></tr></table></figure><h3 id="pm2相关操作"><a href="#pm2相关操作" class="headerlink" title="pm2相关操作"></a>pm2相关操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js # 运行pm2启动项目</span><br><span class="line">pm2 restart app.js # 运行pm2启动项目</span><br><span class="line">pm2 stop app.js # 运行pm2启动项目</span><br><span class="line">pm2 list # 显示所有进程状态</span><br><span class="line">pm2 monit # 监视所有进程</span><br><span class="line">pm2 logs # 显示所有进程日志</span><br><span class="line">pm2 stop all # 停止所有进程</span><br><span class="line">pm2 restart all # 重启所有进程</span><br><span class="line">pm2 reload all # 0 秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">pm2 stop 0 # 停止指定的进程</span><br><span class="line">pm2 restart 0 # 重启指定的进程</span><br><span class="line">pm2 startup # 产生 init 脚本 保持进程活着</span><br><span class="line">pm2 web # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">pm2 delete 0 # 杀死指定的进程</span><br><span class="line">pm2 delete all # 杀死全部进程</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前项目中的问题还比较多，开发环境可以连接，但是部署到线上，因为没有合适的文档，所以总是会有各种问题。</p><p>现在还在艰难排查中，总算是总结出了一套可能并不好用的部署方式。</p><p>万里长征现在刚走了第一步，艰难摸索中，希望能有一些好的收获。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lxy869718069/article/details/110185280">nestjs项目打包部署之linux系统上线]_nestjs部署-CSDN博客</a></p><p><a href="https://www.cnblogs.com/xiaodi-js/p/17883906.html">node.js - 在linux系统上安装和配置nodejs - 箫笛 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
            <tag> nestjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决公众号自动回复嵌套跳转链接失效的问题</title>
      <link href="/2024/09/19/%E8%A7%A3%E5%86%B3%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%B5%8C%E5%A5%97%E8%B7%B3%E8%BD%AC%E9%93%BE%E6%8E%A5%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/19/%E8%A7%A3%E5%86%B3%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%B5%8C%E5%A5%97%E8%B7%B3%E8%BD%AC%E9%93%BE%E6%8E%A5%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本文内容不多，主要是记录如何在小程序自动回复的内容中嵌入一个小程序自动回复文本。</p><p>很难想像是2024年的一款产品，居然需要再富文本中手动输入超链接。</p><p>实打实的垃圾玩意，这种东西居然一直没优化，我参考4年前的文档居然还能用，真他妈的离谱。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>整个过程其实非常简单，但是因为微信小程序实在过于蹩脚，有些问题还是要整理一下，给自己提个醒。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>需要先关联小程序，这个你在左侧菜单找一找就行，只要找到 <strong>小程序管理</strong> 的字样，点开，然后关联你接下来要用到的小程序即可。</p><p>这个过程，需要管理员扫码同意，如果你开发人员，记得要让管理员扫个码。</p><h3 id="自动回复"><a href="#自动回复" class="headerlink" title="自动回复"></a>自动回复</h3><p>自动回复这里，只要常常写MD文档的都知道怎么设置超链接，只不过公众号这里麻烦了些，需要用户自己用<code>&lt;a&gt;</code>标签包裹一下。</p><p>今天主要处理的是跳转小程序的问题，实现方式不麻烦，实现过程多灾多难。</p><p>以我工作的内容为例，这里需要嵌入一个小程序超链，我只要按照如下内容，粘贴到回复文本中就可以了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://yyb.happydo.net&quot;</span> <span class="attr">data-miniprogram-appid</span>=<span class="string">&quot;wxfce54d063c1fd52a&quot;</span> <span class="attr">data-miniprogram-path</span>=<span class="string">&quot;pages/home/index&quot;</span>&gt;</span>关注小程序银养宝<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="代码中各字段含义"><a href="#代码中各字段含义" class="headerlink" title="代码中各字段含义"></a>代码中各字段含义</h4><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">href</td><td align="left">如果无法正常跳转小程序，备用跳转的H5链接</td></tr><tr><td align="left">data-miniprogram-appid</td><td align="left">要跳转的目标小程序appid</td></tr><tr><td align="left">data-miniprogram-path</td><td align="left">要跳转的小程序页面地址（不知道的话可以问服务商或者开发者要）</td></tr></tbody></table><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>最好直接把上述内容复制粘贴，然后修改，避免一些奇怪的问题，有时候你自己手打的超链接，可能会因为种种问题没法用。</p><p>这里整理一些可能的情况，如有不对的地方，可自行参考。</p><ol><li>需要注意代码中间的空格不能缺少和增加</li><li>如果需要自行编辑需要注意<code>&lt;a&gt;</code>标签内的内容符号需要使用英文格式</li><li><code>&lt;a&gt;</code>标签适用与其他H5链接，对应代码为：<code>&lt;a href=&quot;https://www.saas.top&quot;&gt;点击进入h5&lt;/a&gt;</code></li><li>小程序跳转需要公众号关联小程序 <a href="https://developers.weixin.qq.com/community/develop/doc/000242cccdc670f02ea977e105e409?highLine=%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%B0%8F%E7%A8%8B%E5%BA%8F">公众号关联小程序绑定流程官方文档</a></li><li>附<a href="https://developers.weixin.qq.com/community/develop/doc/000c424a27c118ee347a587a950009?highLine=%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%E5%B0%8F%E7%A8%8B%E5%BA%8F">自定义菜单设置小程序相关问题官方文档</a></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于微信小程序及公众号这种开历史倒车的玩意，我一向是不喜欢的。</p><p>但因工作需求，这里遇到问题也不得不记录一下，防止后续忘记。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000ce41a2a4e08e973fafded857813">免开发实现公众号自动回复小程序文字链接 | 微信开放社区 (qq.com)</a></p><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/00022268e2c8902d56aae394156013">如何关注公众号以后自动推送小程序？ | 微信开放社区 (qq.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 疑难杂症 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解开源项目PR流程</title>
      <link href="/2024/09/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEPR%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/09/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEPR%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>由于今年工作相对较清闲，所以闲暇时间想在github参与开源项目。</p><p>不过，我以前对于git操作仅限于同组内的项目，很少有跨组合作修改，故此，我不是很了解开源项目的PR流程。</p><p>因此，稍微花了两天时间测试和梳理了一下PR流程，写成文档抛砖引玉，供大家参考和拍砖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这套流程目前已经在github上测试过数次，目前我个人没有遇到什么问题，算是比较完善的流程。</p><p>随着后续我对git的熟悉，我后续会不断完善该文档，这里抛砖引玉，大家如果有意见，欢迎在评论区留言。</p><p>本文面向有一定git基础知识的朋友，完全不懂git的朋友，最好先学习一下git的基础知识，不用太多，如下列所示，够用就行。</p><ul><li>明白git他人仓库和自己仓库的区别</li><li>使用git进行项目的下载和提交</li><li>明白git分支及如何操作分支合并</li></ul><p>好，话不多说，我们直接开始。</p><h3 id="fork项目"><a href="#fork项目" class="headerlink" title="fork项目"></a>fork项目</h3><p>首先，找到一个你有兴趣贡献的开源项目，可以是GitHub、GitLab或其他代码托管平台上的任何项目。</p><p>然后，我们需要fork你感兴趣的这个项目。</p><p>“fork”，是指创建一个现有仓库的副本到自己的git账户下。</p><p>这个副本通常是在你自己的账户或组织下创建的，这样你就有了原始项目的个人副本，可以在其中自由地进行修改而不会影响到原项目。</p><p>当你“fork”一个项目时，会发生以下几件事情：</p><ol><li>你会得到一个与原始仓库完全相同的仓库副本。</li><li>这个副本位于你自己的GitHub、GitLab等代码托管服务的账户下。</li><li>你可以在这个副本上进行任何修改而不影响到原始仓库。</li></ol><h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><p>在fork了项目之后，我们需要将这个副本下载到本地进行开发，然后在这个副本的基础上进行修改。</p><p>这里要注意，我们需要clone的，是已经fork到自己名下的项目仓库，而不是这个原始项目的仓库。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>我们在<code>clone</code>下来的项目基础上，签出一个分支，为接下来的开发做准备。</p><h4 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h4><p>这里要注意，我们fork过来，默认应该是<code>master</code>或<code>main</code>分支，我们并没有fork过来其他分支。</p><p>因此，我们需要关联原有项目，将源项目的其他分支也同步到自己的库中。</p><p>这里以我为例，比如，我这里要提交的项目是<code>taozhi1010/nest-admin</code>这个项目（这是源项目）。</p><p>那么，现在将源项目（<code>taozhi1010/nest-admin</code>）同步到自己的fork的项目仓库中（<code>CrazyStudent13/nest-admin</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git remote add 源项目别名（自己随便命名） git提供的ssh地址</span></span><br><span class="line">git remote add upstream git@github.com:taozhi1010/nest-admin.git</span><br></pre></td></tr></table></figure><p>执行这条命令后，你就可以通过名称<code>upstream</code>来引用这个远程仓库了。</p><p>例如，如果你想从这个远程仓库拉取更新，可以使用<code>git fetch upstream</code>或<code>git pull upstream</code>命令；</p><p>如果你要推送更改到该仓库，则可以使用<code>git push upstream</code>命令（前提是拥有相应的权限）。</p><p>我们这里不做其他操作，先将远端的分支更新到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure><p>将远程仓库（在这里别名为 <code>upstream</code>）的 <code>master</code> 分支合并到你当前所在的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><h4 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h4><p>根据项目的贡献指南，我们开始本地修改代码或文档，这里确保遵循项目的代码规范和风格指南。</p><p>在完成修改之后，我们可以使用命令或者图形化的git管理工具，提交内容。</p><p>总之，就是如下两个步骤。</p><ul><li><strong>添加更改</strong>：使用<code>git add .</code>来将所有更改标记为准备提交。</li><li><strong>提交更改</strong>：使用<code>git commit -m &quot;Your commit message&quot;</code>提交更改，并附上描述性的提交信息。</li></ul><h4 id="推送更改到远程仓库"><a href="#推送更改到远程仓库" class="headerlink" title="推送更改到远程仓库"></a>推送更改到远程仓库</h4><p>这里注意，推送不是推送到他人的仓库，而是推送到自己的远端仓库。</p><p>如之前一样，使用图形化工具或命令，将本地的<code>commit</code>推送到远端仓库。</p><h3 id="创建Pull-Request-PR"><a href="#创建Pull-Request-PR" class="headerlink" title="创建Pull Request (PR)"></a>创建Pull Request (PR)</h3><p>这时候，我以github为例，你登录到github的界面，打开那个同步过来的项目，你会发现有个非常明显的对比。</p><p>这里你点击一下，他会让你推送到源项目，是否要创建一个PR（pull request）。</p><p>这里，我们按照要求，填写PR描述，说明所做的更改及其原因。</p><p>然后，指定要合并的目标分支，通常是开发分支（dev），也可能主分支（如master或main）。</p><h3 id="等待审查"><a href="#等待审查" class="headerlink" title="等待审查"></a>等待审查</h3><p>提交后，项目的维护者或其他贡献者会审查你的PR。</p><p>他们会决定是否合并你的PR到自己的分支内。</p><h4 id="解决反馈"><a href="#解决反馈" class="headerlink" title="解决反馈"></a>解决反馈</h4><p>如果收到反馈需要解决某些问题，那我们重新修改代码，再次推送。</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>一旦你的PR被批准，它会被合并到主分支中。此时，你可以删除自己的功能分支（可选）。</p><p>以上就是给开源项目添加PR的一般流程。</p><p>不同的项目可能有不同的具体要求，所以请务必阅读项目的贡献指南以获得更详细的说明。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>走完上述流程，我们就算是完成一个PR了，如此，我们也算是参与开源项目了。</p><p>社区活跃度应该一些面试官比较喜欢的指标，多参与社区内的活跃项目，不仅能见识他人代码的精妙，也能让自己的努力被社区所见证。</p><p>因此，我很是推荐大家在开源社区中做出自己的贡献，哪怕只是一点点，都会让社区感到欣喜。</p><p>另外，本文由通义千问辅助编写，在一些命令的具体解释上，AI比人强了不少，比搜索引擎更是好用了太多。</p><p>不得不感叹，时代的伟力，能赶上AI风靡的大时代，不知道是幸运还是不幸。</p><p>当然，AI虽然辅助解释了部分命令，整体流程依然是我亲自把关的。</p><p>目前我已经根据这个流程提交了数次开源项目的PR，其中有些已经通过审核，确认整个流程无误，大家可以按照流程放心食用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1Qp4y1T797/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【Git】如何给一个开源项目提交代码？Fork、PR一次搞懂！</a></p><p><a href="https://tongyi.aliyun.com/qianwen">通义千问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】腾讯云OpenCloudOS部署redis</title>
      <link href="/2024/09/14/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2redis/"/>
      <url>/2024/09/14/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2redis/</url>
      
        <content type="html"><![CDATA[<p>接上文，之前的安装redis是用docker安装的。</p><p>本来感觉很方便，但是不知道为什么，换了一个系统后，那个安装流程不行了。</p><p>由于个人对docker不是很熟，所以还是按照常规流程，在服务器上安装部署redis。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>书接上文，我们在配置完MySQL之后，按照之前的目录，我们继续完成redis的安装。</p><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><p>这里图省事，用命令行创建了目录，你也可以根据自己需求，用SSH工具自行创建。</p><h4 id="创建下载目录"><a href="#创建下载目录" class="headerlink" title="创建下载目录"></a>创建下载目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir -p server/soft/redis</span><br></pre></td></tr></table></figure><p>切换到下载目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /server/soft/redis</span><br></pre></td></tr></table></figure><h4 id="下载并解压安装"><a href="#下载并解压安装" class="headerlink" title="下载并解压安装"></a>下载并解压安装</h4><p>这里用wget命令下载，有的系统可能不支持<code>wget</code>命令，总之是去下对应的压缩包就好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-7.0.1.tar.gz</span><br></pre></td></tr></table></figure><h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf redis-7.0.1.tar.gz</span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>这里我需要先切到对应的解压后的目录下，然后才能解压。</p><p>我们先切换到已经解压好的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /server/soft/redis/redis-7.0.1</span><br></pre></td></tr></table></figure><h5 id="编译redis"><a href="#编译redis" class="headerlink" title="编译redis"></a>编译redis</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h5 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h5><p>使用以下命令将编译后的Redis安装到系统中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="版本验证"><a href="#版本验证" class="headerlink" title="版本验证"></a>版本验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --version</span><br></pre></td></tr></table></figure><p>只要出现类似如下内容，就代表成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis server v=7.0.1 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=cb8ffba948693cc7</span><br></pre></td></tr></table></figure><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><p>经过上边的流程，我们已经安装完了redis。</p><p>接下来我们要去改配置，可能有人不清楚自己要改的配置文件在哪。</p><p>这里我们可以用linux自带的命令查找对应的配置文件。</p><h4 id="找到配置"><a href="#找到配置" class="headerlink" title="找到配置"></a>找到配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;redis.conf&quot;</span><br></pre></td></tr></table></figure><p>然后，我们切换到对应的目录。</p><p>这里以我为例，我找到之后，按照目录输出内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /server/soft/redis/redis-7.0.1/</span><br><span class="line">ls redis.conf</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>之前我们说过Redis，这里我们就不再讲了，而且，我们这里只是做必要的修改，大多配置我们不必去修改。</p><p>这里，我们只要改一条配置：<code>bind</code>，我们需要<code>bind</code>属性，允许外部访问当前服务器上的redis。</p><p>修改配置太多，使用命令行修改太麻烦，我建议大家用SSH工具直接打开配置文件。</p><p>默认情况下，Redis监听所有网络接口（0.0.0.0），也有的默认绑定（127.0.0.1）。</p><p>我们打开<code>redis.conf</code>，注释掉bind就可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1</span><br></pre></td></tr></table></figure><p>同时，配置一下redis密码，比如我这里配置123456为密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><p>切换到对应的redis目录，然后启动redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /server/soft/redis/redis-7.0.1/</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><h3 id="修改防火墙配置"><a href="#修改防火墙配置" class="headerlink" title="修改防火墙配置"></a>修改防火墙配置</h3><p>为了确保外部流量可以到达Redis服务器，你需要配置防火墙来开放相应的端口。</p><p>和MySQL需要打开<code>3306</code>的端口的一样，redis如果没有进行端口配置的话，默认应该是<code>6379</code>的端口。</p><p>于是，我们也需要关闭对应端口的防火墙，这里可以用腾讯云自带的防火墙配置，当然，我们也可以用如下的命令来配置。</p><p>这里，我们需要安装<code>ufw</code>来关闭防火墙。</p><h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h4><p>我之前抄的文档用的是<code>apt</code>命令配置，但因为我的系统是<code>OpenCloudOS</code>，所以这里无法使用<code>apt</code>。</p><p>如果你遇到了 <code>apt: command not found</code> 的错误，这通常意味着你当前使用的Linux发行版可能不是基于Debian的系统，或者是某个环境变量问题导致 apt 命令无法找到。</p><p>不同的Linux发行版使用不同的包管理系统，对于基于Red Hat的系统（如CentOS、Fedora、RHEL），可以使用<code>yum</code>命令来安装。</p><p>在打开防火墙端口之前，我们需要先安装并启动<code>ufw</code>，如下，我们先准备一下。</p><h4 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="安装UFW"><a href="#安装UFW" class="headerlink" title="安装UFW"></a>安装UFW</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ufw</span><br></pre></td></tr></table></figure><h4 id="启用UFW"><a href="#启用UFW" class="headerlink" title="启用UFW"></a>启用UFW</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum enable ufw</span><br></pre></td></tr></table></figure><h4 id="打开防火墙"><a href="#打开防火墙" class="headerlink" title="打开防火墙"></a>打开防火墙</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 6379/tcp</span><br></pre></td></tr></table></figure><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>大多数人应该都有自己习惯的数据库连接工具，这里我个人推荐用：<a href="https://www.navicat.com.cn/download/navicat-premium-lite">Navicat Premium Lite 17</a>。</p><p>相对于其他的数据库连接工具，Navicat简单易操作，界面干净美观，且算是这几年市场上的流行工具。</p><p>虽然分为免费版和付费版，但是免费版提供的功能足够用户去使用。</p><p>这里具体的流程我就不教了，因为太简单。</p><p>总之，和MySQL一样，我们配置一个新的redis连接，配置完成后，点击测试连接。</p><p>测试成功，至此，redis部署流程完成。</p><h3 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h3><p>有些时候，我们可能因为各种原因要停止或者重启，我们可以用如下命令重启redis。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart redis</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>redis的部署与使用并非什么麻烦事儿，但是没有一个靠谱的文档，这个流程就会变得极为麻烦。</p><p>所以，我特此整理了此文档，便于下次再服务器上部署该流程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/2358816">手把手安装部署Redis-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://tongyi.aliyun.com/qianwen/">通义千问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】腾讯云OpenCloudOS部署MySQL</title>
      <link href="/2024/09/13/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2MySQL/"/>
      <url>/2024/09/13/%E3%80%90%E8%BD%AC%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91OpenCloudOS%E9%83%A8%E7%BD%B2MySQL/</url>
      
        <content type="html"><![CDATA[<p>之前的安装是用docker安装的，本来感觉很方便，但是不知道为什么，换了系统之后安装流程不行了。</p><p>这次索性就简单不用docker安装了，直接用最传统的方式安装配置。</p><p>毕竟我对docker还是不够的熟练，此时上docker，出问题我还是不太会改。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>就和win环境一样，我们在服务器上需要先安装，再配置一个软件。</p><p>所以，本篇教程分为两个大部分：安装MySQL，配置MySQL。</p><p>亲测可用，系统配置：<code>OpenCloudOS 9</code>，安装流程顺畅，没有什么问题。</p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>很多人不熟悉Linux，安装的主要麻烦就是安装命令。</p><p>所以，这里重新整理</p><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>切换到根目录创建一个用来存mySql的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir -p server/soft/mysql</span><br></pre></td></tr></table></figure><h4 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /server/soft/mysql</span><br></pre></td></tr></table></figure><h4 id="查看自带数据库"><a href="#查看自带数据库" class="headerlink" title="查看自带数据库"></a>查看自带数据库</h4><p>有的系统会在镜像安装时候就自带数据库，我们先检测一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa l grep mari</span><br></pre></td></tr></table></figure><p>如果画框中的内容有，则rpm -e –nodeps XXX删除。</p><p>比如，我们这里举例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-connector-c-3.1.11-2.oc8.1.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mariadb-connector-c-config-3.1.11-2.oc8.1.noarch</span><br></pre></td></tr></table></figure><h4 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h4><p>切换到目录之后，我们先下载MySQL的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><h4 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure><h4 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h4><p>这里会问你是否同意，y就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</span><br><span class="line">yum install libncurses*</span><br></pre></td></tr></table></figure><h4 id="启动并测试连接"><a href="#启动并测试连接" class="headerlink" title="启动并测试连接"></a>启动并测试连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br><span class="line">ps -ef |grep mysql</span><br></pre></td></tr></table></figure><p>这里只要检测到mySQL的进程，就可以确认是启动成功了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql     613867       1  0 21:20 ?        00:00:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">root      614796  498031  0 21:22 pts/0    00:00:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure><h3 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h3><p>好了，就像是win上边，我们终于装好mySQL了。</p><p>接下来就是配置时间了。</p><h4 id="查看密码"><a href="#查看密码" class="headerlink" title="查看密码"></a>查看密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>这时候，mysql会帮我们生成一个临时密码，如下提示，我们拿到密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A temporary password is generated for root@localhost: xy?pa,n1o%M-</span><br></pre></td></tr></table></figure><h4 id="配置密码"><a href="#配置密码" class="headerlink" title="配置密码"></a>配置密码</h4><p>系统生成的密码安全性很强，但是也很难记，所以我们可能需要自己改动出一个好记的密码。</p><p>输入如下命令后，需要我们输入自己的密码，记得保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>当我们输入明码，进入mySQL的之后，需要逐行的输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;你的密码&#x27;;</span><br></pre></td></tr></table></figure><p>修改完成之后，我们刷新提交修改内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><strong>示例如下</strong>，我的密码是123456。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password_length=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="修改host配置"><a href="#修改host配置" class="headerlink" title="修改host配置"></a>修改host配置</h4><p>之前我们的配置默认是指向<code>localhost</code>，这里我们需要把<code>host</code>改到能给外部访问。</p><p><code>%</code>是一个通配符，表示任何主机。</p><p>这意味着具有<code>root</code>用户名的用户可以从任何IP地址或主机名连接到MySQL服务器。</p><p>通过将其<code>Host</code>列设置为<code>%</code>，这种设置通常用于扩展管理员账户的访问权限，使其不仅限于本地主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">SELECT Host, User FROM user;</span><br><span class="line">UPDATE user SET Host = &#x27;%&#x27; WHERE User = &#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT Host, User FROM user;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| Host      | User          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| localhost | mysql.session |</span><br><span class="line">| localhost | mysql.sys     |</span><br><span class="line">| localhost | root          |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE user SET Host = &#x27;%&#x27; WHERE User = &#x27;root&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="MySQL忘记密码了怎么办？"><a href="#MySQL忘记密码了怎么办？" class="headerlink" title="MySQL忘记密码了怎么办？"></a>MySQL忘记密码了怎么办？</h3><p>这段的操作我不推荐使用，原文的意思是，修改my.cnf配置。</p><p>在<code>skip-grant-tables</code>配置后，启动MySQL服务器时忽略权限表。</p><p>这意味着启动时不需要密码就可以访问数据库。这通常只在恢复或紧急情况下使用，因为这样会使数据库变得不安全。</p><p>改完配置文件之后，重新设置密码，然后再删除该</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>我们可以通过图形界面直接去<code>etc</code>文件夹下修改<code>my.cnf</code>。</p><p>我们也可以通过命令行去修改，不过需要你稍微了解一下linux命令行编辑的方式。</p><p>这里，我们需要在linux的目录下，如果之前还在mySQL路径里边，记得退出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p>修改配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># For advice on how to change settings please see</span><br><span class="line"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line"># innodb_buffer_pool_size = 128M</span><br><span class="line">#</span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line"># log_bin</span><br><span class="line">#</span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line"># join_buffer_size = 128M</span><br><span class="line"># sort_buffer_size = 2M</span><br><span class="line"># read_rnd_buffer_size = 2M</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"># 我们在这里添加我们需要的命令</span><br><span class="line">skip-grant-tables</span><br><span class="line"></span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure><p>编辑完成后，<code>:wq</code>退出编辑</p><p>保存退出，重启MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><h4 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure><h4 id="修改密码刷新权限"><a href="#修改密码刷新权限" class="headerlink" title="修改密码刷新权限"></a>修改密码刷新权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set authentication_string=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">exit；</span><br></pre></td></tr></table></figure><p>删除刚刚新增的命令，这里我们需要再删除配置里边的 <code>skip-grant-tables</code></p><h4 id="重新登录"><a href="#重新登录" class="headerlink" title="重新登录"></a>重新登录</h4><p>这里我们用新密码重新登录一下，或者是navicat之类的远程工具连一下看看。</p><p>只要保证新密码能连接上，那就没问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来打算用docker简单安装一下就算了，但是换了系统之后，之前的流程反而装不上了。</p><p>真是麻烦所以干脆自己再走个流程重新装一下。</p><p>本来也想选几个8.0版本的MySQL，但是好几个教程都因为各种问题走不下去。</p><p>反而是这个低版本的远古教程，居然意外的好用，于是特此记录下，便于后续使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_44079964/article/details/132016831">在腾讯云服务器OpenCLoudOS系统中安装mysql（有图详解）_opencloudos 安装mysql-CSDN博客</a></p><p><a href="https://tongyi.aliyun.com/">通义千问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】linux上安装nginx</title>
      <link href="/2024/09/12/%E3%80%90%E8%BD%AC%E3%80%91linux%E4%B8%8A%E5%AE%89%E8%A3%85nginx/"/>
      <url>/2024/09/12/%E3%80%90%E8%BD%AC%E3%80%91linux%E4%B8%8A%E5%AE%89%E8%A3%85nginx/</url>
      
        <content type="html"><![CDATA[<p>因为新升级了linux的系统，原有的部署命令失效了，因此这次整个新的部署流程。</p><p>这不是无意义的搬运，这是为了将来更快的部署nginx。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次使用的是腾讯云OpenCloudOS系统。</p><p>在 OpenCloudOS 上安装 Nginx 可以通过包管理器 yum 来完成，因为 OpenCloudOS 与 CentOS 高度兼容，所以你可以使用类似的方法。</p><p>以下是通过 yum 来安装 Nginx 的基本步骤。</p><h3 id="安装启动流程"><a href="#安装启动流程" class="headerlink" title="安装启动流程"></a>安装启动流程</h3><p>因为我这台服务器比较干净，所以我这边不考虑切换到任何目录，直接在root目录下进行操作。</p><h4 id="更新系统包列表"><a href="#更新系统包列表" class="headerlink" title="更新系统包列表"></a>更新系统包列表</h4><p> 在安装任何软件包之前，通常建议先更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><h4 id="安装-EPEL-仓库"><a href="#安装-EPEL-仓库" class="headerlink" title="安装 EPEL 仓库"></a>安装 EPEL 仓库</h4><p>EPEL（Extra Packages for Enterprise Linux）是一个大型的社区维护的仓库，包含了大量额外的软件包。虽然某些 OpenCloudOS 的版本可能已经预装了 EPEL，但如果你的系统没有，可以这样安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure><h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>使用 yum 来安装 Nginx，这里会问你是否ok，惯例，一路y就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><h4 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h4><p>安装完成后，启动 Nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h4><p>为了让 Nginx 在每次系统启动时自动启动，你可以启用 Nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><h4 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h4><p>检查 Nginx 服务是否正在运行，正常情况下会显示 active (running)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>最后，在浏览器中输入服务器公网 IP 地址，如果一切正常，你应该能看到 Nginx 的默认欢迎页面了。</p><p>如果访问不成功，记得去看一下是不是防火墙忘了关。</p><h3 id="配置重启流程"><a href="#配置重启流程" class="headerlink" title="配置重启流程"></a>配置重启流程</h3><p>在上边部署完成之后，我们需要开始进行配置。</p><h4 id="查看-nginx-安装目录"><a href="#查看-nginx-安装目录" class="headerlink" title="查看 nginx 安装目录"></a>查看 nginx 安装目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h4 id="查看配置文件-nginx-conf-路径"><a href="#查看配置文件-nginx-conf-路径" class="headerlink" title="查看配置文件 nginx.conf 路径"></a>查看配置文件 nginx.conf 路径</h4><p>这条命令也可以用于检查配置文件是否正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p>当然也可以使用 find 命令进行文件查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 / 根目录下查找文件名为 nginx.conf 的文件</span></span><br><span class="line">find / -name nginx.conf</span><br><span class="line"><span class="comment"># 从 /etc 目录下查找文件名为 nginx.conf 的文件</span></span><br><span class="line">find /etc -name nginx.conf</span><br></pre></td></tr></table></figure><h4 id="按需求配置目录"><a href="#按需求配置目录" class="headerlink" title="按需求配置目录"></a>按需求配置目录</h4><p>核心就是server指向目录的问题，这里不管https的事情了。</p><p>配置完目录，记得把自己的文件放到自己指定的目录上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">server &#123;  </span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  cattools.crazystudent13.cn;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      root /server/website/docsCatTools;</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  lintdoc.crazystudent13.cn;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      root /server/website/lintdoc;</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  resume.crazystudent13.cn;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      root /server/website/resume;</span><br><span class="line">      index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><p>配置完成后，这时候如果打开自己的目录会发现可能还是nginx的页面，这就需要我们重启一下nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>一般来说，重启是正常成功的，如果出于保险的考虑，可以在看看状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><h4 id="如果遇到问题"><a href="#如果遇到问题" class="headerlink" title="如果遇到问题"></a>如果遇到问题</h4><ul><li><p>查看错误日志文件通常可以帮助诊断问题，Nginx的错误日志位置通常在<code>/var/log/nginx/error.log</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/nginx/error.log</span><br></pre></td></tr></table></figure></li><li><p>或者检查Nginx配置是否正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yanyunfeng.com/article/48">腾讯轻量服务器 OpenCloudOS 上安装 Nginx - 鄢云峰的个人网站 (yanyunfeng.com)</a></p><p><a href="https://www.cnblogs.com/ryanzheng/p/13124128.html">Linux 查看 nginx 安装目录和配置文件路径 - Ryan_zheng - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】10分钟了解redis应用</title>
      <link href="/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%9110%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3redis%E5%BA%94%E7%94%A8/"/>
      <url>/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%9110%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3redis%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本篇是从<a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a>这篇文章中切出来的部分。</p><p>不过算是redis的基础知识和应用篇，目前还未完全了解，仅仅只是学习记录一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>目前独立开发项目时，出于节省时间的考虑，我试用了1panel进行部署。</p><p>如果你只是想快速完成开发，推荐使用1panel进行快速部署。</p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><p>默认连接：IP 127.0.0.1 端口 6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>指定IP端口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli –h <span class="number">127.0</span>.<span class="number">0.1</span> –<span class="selector-tag">p</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>Redis提供了PING-PONG机制，测试与客户端和服务器链接是否正常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>正常回复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;SET <span class="built_in">test</span> 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>错误回复（以error开头，后面跟着错误信息）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;TEST</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;TEST&#x27;</span></span><br></pre></td></tr></table></figure><p>整数回复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;INCR test_incr</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>字符串回复（最长久的一种回复，双引号包裹）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;get test</span><br><span class="line">“<span class="number">123</span>”</span><br></pre></td></tr></table></figure><p>多行字符串回复</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">127.0.0.1:6379&gt;KEYS *</span></span><br><span class="line">1) <span class="string">&quot;test_incr&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><p>字符串类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。可以存储JSON化的对象、字节数组等。一个字符串类型键允许存储的数据最大容量是512MB。</p><p>赋值与取值：</p><p>SET key value</p><p>GET key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> test1 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> test2 ab</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test2</span><br><span class="line"><span class="string">&quot;ab&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="keys通配符"><a href="#keys通配符" class="headerlink" title="keys通配符"></a>keys通配符</h4><p>获取符合规则的建名列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br><span class="line">keys <span class="built_in">test</span>[_]* </span><br><span class="line">keys t[a-d]</span><br></pre></td></tr></table></figure><p>说明：</p><p>？ 匹配一个字符，例如 keys ?est1</p><p>*  匹配任意个（包括0个）字符</p><p>[] 匹配括号间的任一字符，例如 keys test[12]。还可以使用“-“表示范围。</p><p>例如test[1-3]匹配test1&#x2F;test2&#x2F;test3</p><p>\x 匹配字符x，用于转义符合，如果要匹配“？“就需要使用?</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>redis默认支持16个数据库，对外都是以一个从0开始的递增数字命名，可以通过参数database来修改默认数据库个数。客户端连接redis服务后会自动选择0号数据库，可以通过select命令更换数据库，例如选择1号数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;GET <span class="built_in">test</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>说明：</p><p>Redis不支持自定义数据库名称。</p><p>Redis不支持为每个数据库设置访问密码。</p><p>Redis的多个数据库之间不是安全隔离的，FLUSHALL命令会清空所有数据库的数据。</p><p>清除屏幕内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><p>判断一个键是否存在。</p><p>如果键存在则返回整数类型1，否则返回0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test_incr&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists test1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists test3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><p>删除键，可以删除一个或者多个键，多个键用空格隔开，返回值是删除的键的个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del test1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; del test1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; del test1 test_incr</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>获得键值的数据类型，返回值可能是string（字符串）、hash（散列类型）、list（列表类型）、set（集合类型）、zset（有序集合类型）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> test1</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> test2</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span></span><br><span class="line">redis-cli 2.8.19</span><br><span class="line">Type: <span class="string">&quot;help @&lt;group&gt;&quot;</span> to get a list of commands <span class="keyword">in</span> &lt;group&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;command&gt;&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span> on &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;tab&gt;&quot;</span> to get a list of possible <span class="built_in">help</span> topics</span><br><span class="line">      <span class="string">&quot;quit&quot;</span> to <span class="built_in">exit</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> <span class="built_in">type</span></span><br><span class="line"></span><br><span class="line">  TYPE key</span><br><span class="line">  summary: Determine the <span class="built_in">type</span> stored at key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br></pre></td></tr></table></figure><p>官网：<a href="https://link.juejin.cn/?target=http://www.redis.io%E5%B8%AE%E5%8A%A9">www.redis.io帮助</a></p><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><p>清空所有数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="Redis数据类型之字符串"><a href="#Redis数据类型之字符串" class="headerlink" title="Redis数据类型之字符串"></a><strong>Redis数据类型之字符串</strong></h3><p>存放的字符串为二进制是安全的。字符串长度支持到512M。</p><h4 id="incry-x2F-incyby"><a href="#incry-x2F-incyby" class="headerlink" title="incry&#x2F;incyby"></a>incry&#x2F;incyby</h4><p>递增数字INCR key当存储的字符串是整数时，redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;test1&quot;</span></span><br><span class="line">2) <span class="string">&quot;test2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test1</span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get test2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;num&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">3) <span class="string">&quot;test&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>从上面例子可以看出，如果num不存在，则自动会创建，如果存在自动+1。</p><p>指定增长系数</p><p>语法：INCRBY key increment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="decr-x2F-decrby"><a href="#decr-x2F-decrby" class="headerlink" title="decr&#x2F;decrby"></a>decr&#x2F;decrby</h4><p>减少指定的整数</p><p>DECR key  按照默认步长(默认为1)进行递减</p><p>DECRBY key decrement 按照指定步长进行递减</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; decrby num 3</span><br></pre></td></tr></table></figure><h4 id="incrbyfloat"><a href="#incrbyfloat" class="headerlink" title="incrbyfloat"></a>incrbyfloat</h4><p>整数时，第一次加可以得到正确结果，浮点数后再加浮点就会出现精度问题。</p><p>原来下面的例子2.8.7注意在新版本中已经修正了这个浮点精度问题。3.0.7</p><p>INCRBYFLOAT key decrement</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> num 131</span><br><span class="line">(<span class="built_in">integer</span>) 131</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat num 0.7</span><br><span class="line">“131.7”</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat num 0.7</span><br><span class="line">“132.3999999999999999”</span><br></pre></td></tr></table></figure><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>向尾部追加值。如果键不存在则创建该键，其值为写的value，即相当于SET key value。返回值是追加后字符串的总长度。</p><p>语法：APPEND key value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;num&quot;</span></span><br><span class="line">2) <span class="string">&quot;test1&quot;</span></span><br><span class="line">3) <span class="string">&quot;test&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append <span class="built_in">test</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><p>字符串长度，返回数据的长度，如果键不存在则返回0。注意，如果键值为空串，返回也是0。</p><p>语法：STRLEN key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span></span><br><span class="line"><span class="string">&quot;123abc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen <span class="built_in">test</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; strlen tnt</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> tnt <span class="string">&quot;&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen tnt</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; exists tnt</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="mset-x2F-mget"><a href="#mset-x2F-mget" class="headerlink" title="mset&#x2F;mget"></a>mset&#x2F;mget</h4><p>同时设置&#x2F;获取多个键值</p><p>语法：MSET key value [key value …]</p><p>MGET key [key …]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget a b c</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis有效时间"><a href="#Redis有效时间" class="headerlink" title="Redis有效时间"></a><strong>Redis有效时间</strong></h3><h4 id="Expire-设置生效时长-单位秒"><a href="#Expire-设置生效时长-单位秒" class="headerlink" title="Expire (设置生效时长-单位秒)"></a>Expire (设置生效时长-单位秒)</h4><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置有效时间的(缓存内存是有限的，不可能无限制增加)，即到期后数据自动销毁。</p><p>语法：EXPIRE key seconds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire bomb 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>TTL查看key的剩余时间，当返回值为-2时，表示键被删除。</p><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以毫秒为单位，返回 key 的剩余生存时间。</p><p>注意：在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="Persist-取消时长设置"><a href="#Persist-取消时长设置" class="headerlink" title="Persist(取消时长设置)"></a>Persist(取消时长设置)</h4><p>通过persist让对特定key设置的生效时长失效。</p><p>语法：PERSIST key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire bomb 60</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 49</span><br><span class="line">127.0.0.1:6379&gt; persist bomb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>设置新的数据时需要重新设置该key的生存时间，重新设置值也会清除生存时间。</p><h4 id="pexpire-单位毫秒"><a href="#pexpire-单位毫秒" class="headerlink" title="pexpire(单位毫秒)"></a>pexpire(单位毫秒)</h4><p>pexpire 让key的生效时长以毫秒作为计量单位，可应用于秒杀场景。</p><p>语法：PEXPIRE key milliseconds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> bomb tnt</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpire bomb 10000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl bomb</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>设置生存时间为毫秒，可以做到更精确的控制。</p><h3 id="Redis高级中的hash结构"><a href="#Redis高级中的hash结构" class="headerlink" title="Redis高级中的hash结构"></a>Redis高级中的hash结构</h3><p>在redis中用的最多的就是hash和string类型。</p><h4 id="（1）问题"><a href="#（1）问题" class="headerlink" title="（1）问题"></a>（1）问题</h4><p>假设有User对象以JSON序列化的形式存储到redis中，User对象有id、username、password、age、name等属性，存储的过程如下：</p><p>保存、更新：</p><p>User对象-&gt;json(string)-&gt;redis</p><p>如果在业务上只是更新age属性，其他的属性并不做更新应该怎么做呢？</p><p>Redis数据类型之散列类型hash</p><p>散列类型存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他类型，也就是说，散列类型不能嵌套其他的数据类型。一个散列类型可以包含最多232-1个字段。</p><h4 id="（2）hset-x2F-hget"><a href="#（2）hset-x2F-hget" class="headerlink" title="（2）hset&#x2F;hget"></a>（2）hset&#x2F;hget</h4><p>相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line">HGET key field</span><br><span class="line">HMSET key field value [field value…]</span><br><span class="line">HMGET key field [field]</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>HSET和HGET赋值和取值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user username chenchen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user username</span><br><span class="line"><span class="string">&quot;chenchen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user username chen</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys user</span><br><span class="line">1) <span class="string">&quot;user&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; hset user age 18</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user address <span class="string">&quot;xi&#x27;an&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">3) <span class="string">&quot;address&quot;</span></span><br><span class="line">4) <span class="string">&quot;xi&#x27;an&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p><h4 id="（3）hincrby"><a href="#（3）hincrby" class="headerlink" title="（3）hincrby"></a>（3）hincrby</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdecrby article total 1<span class="comment">#执行会出错</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby article total -1<span class="comment">#没有hdecrby自减命令</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget article total<span class="comment">#获取值</span></span><br></pre></td></tr></table></figure><h4 id="（4）hmset-x2F-hmget"><a href="#（4）hmset-x2F-hmget" class="headerlink" title="（4）hmset&#x2F;hmget"></a>（4）hmset&#x2F;hmget</h4><p>HMSET和HMGET设置和获取对象属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset person username tony age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget person age username</span><br><span class="line">1) <span class="string">&quot;18&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>注意：上面HMGET字段顺序可以自行定义</p><h4 id="（5）hexists"><a href="#（5）hexists" class="headerlink" title="（5）hexists"></a>（5）hexists</h4><p>属性是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists killer</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;hexists&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; hexists killer a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hexists user username</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists person age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（6）-hdel"><a href="#（6）-hdel" class="headerlink" title="（6） hdel"></a>（6） hdel</h4><p>删除属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;chen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;18&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（7）hkeys-x2F-hvals"><a href="#（7）hkeys-x2F-hvals" class="headerlink" title="（7）hkeys&#x2F;hvals"></a>（7）hkeys&#x2F;hvals</h4><p>只获取字段名HKEYS或字段值HVALS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys person</span><br><span class="line">1) <span class="string">&quot;username&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals person</span><br><span class="line">1) <span class="string">&quot;tony&quot;</span></span><br><span class="line">2) <span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（8）hlen"><a href="#（8）hlen" class="headerlink" title="（8）hlen"></a>（8）hlen</h4><p>元素个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen user</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen person</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="Redis高级中的list结构"><a href="#Redis高级中的list结构" class="headerlink" title="Redis高级中的list结构"></a>Redis高级中的list结构</h3><h4 id="（1）问题-1"><a href="#（1）问题-1" class="headerlink" title="（1）问题"></a>（1）问题</h4><p>Redis高级中的list结构</p><p>Redis的list类型其实就是一个每个子元素都是string类型的双向链表。可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。</p><p>有意思的是list的pop操作还有阻塞版本的，当我们[lr]pop一个list对象时，如果list是空，或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop可以则可以阻塞，当然可以加超时时间，超时后也会返回nil。为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。</p><h4 id="（2）lpush"><a href="#（2）lpush" class="headerlink" title="（2）lpush"></a>（2）lpush</h4><p>在key对应list的头部添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush mylist <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>其中，Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><h4 id="（3）rpush"><a href="#（3）rpush" class="headerlink" title="（3）rpush"></a>（3）rpush</h4><p>在key对应list的尾部添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist2 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist2 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（4）查看list"><a href="#（4）查看list" class="headerlink" title="（4）查看list"></a>（4）查看list</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lrange mylist3 0 -1</span><br></pre></td></tr></table></figure><h4 id="（5）del"><a href="#（5）del" class="headerlink" title="（5）del"></a>（5）del</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mylist</span><br></pre></td></tr></table></figure><h4 id="（6）linsert"><a href="#（6）linsert" class="headerlink" title="（6）linsert"></a>（6）linsert</h4><p>在key对应list的特定位置之前或之后添加字符串元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist3 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist3 <span class="string">&quot;world&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mylist3 before <span class="string">&quot;world&quot;</span> <span class="string">&quot;there&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist3 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;there&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（7）lset"><a href="#（7）lset" class="headerlink" title="（7）lset"></a>（7）lset</h4><p>设置list中指定下标的元素值(一般用于修改操作)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist4 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mylist4 0 <span class="string">&quot;four&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mylist4 -2 <span class="string">&quot;five&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist4 0 -1</span><br><span class="line">1) <span class="string">&quot;four&quot;</span></span><br><span class="line">2) <span class="string">&quot;five&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（8）lrem"><a href="#（8）lrem" class="headerlink" title="（8）lrem"></a>（8）lrem</h4><p>从key对应list中删除count个和value相同的元素，count&gt;0时，按从头到尾的顺序删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist5 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist5 2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist5 0 -1</span><br><span class="line">1) <span class="string">&quot;foo&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>count&lt;0时，按从尾到头的顺序删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist6 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist6 -2 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist6 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>count&#x3D;0时，删除全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;foo&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist7 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mylist7 0 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist7 0 -1</span><br><span class="line">1) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（9）ltrim"><a href="#（9）ltrim" class="headerlink" title="（9）ltrim"></a>（9）ltrim</h4><p>保留指定key 的值范围内的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;one&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;two&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;three&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mylist8 <span class="string">&quot;four&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; ltrim mylist8 1 -1</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mylist8 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（10）lpop"><a href="#（10）lpop" class="headerlink" title="（10）lpop"></a>（10）lpop</h4><p>从list的头部删除元素，并返回删除元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="（11）rpop"><a href="#（11）rpop" class="headerlink" title="（11）rpop"></a>（11）rpop</h4><p>从list的尾部删除元素，并返回删除元素：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop mylist2</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist2 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;hello&quot;</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="（12）llen"><a href="#（12）llen" class="headerlink" title="（12）llen"></a>（12）llen</h4><p>返回key对应list的长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; llen mylist5</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（13）index"><a href="#（13）index" class="headerlink" title="（13）index"></a>（13）index</h4><p>返回名称为key的list中index位置的元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lrange mylist5 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mylist5 0</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mylist5 1</span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（14）rpoplpush"><a href="#（14）rpoplpush" class="headerlink" title="（14）rpoplpush"></a>（14）rpoplpush</h4><p>从第一个list的尾部移除元素并添加到第二个list的头部,最后返回被移除的元素值，整个操作是原子的.如果第一个list是空或者不存在返回nil：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush lst1 lst1</span><br><span class="line">rpoplpush lst1 lst2</span><br></pre></td></tr></table></figure><h3 id="Redis高机中的set结构"><a href="#Redis高机中的set结构" class="headerlink" title="Redis高机中的set结构"></a>Redis高机中的set结构</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数为232 - 1 (4294967295每个集合可存储40多亿个成员)。</p><h4 id="（1）sadd"><a href="#（1）sadd" class="headerlink" title="（1）sadd"></a>（1）sadd</h4><p>添加元素，重复元素添加失败，返回0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd name tony</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name hellen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name rose</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd name rose</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h4 id="（2）smembers"><a href="#（2）smembers" class="headerlink" title="（2）smembers"></a>（2）smembers</h4><p>获取内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers name</span><br><span class="line">1) <span class="string">&quot;hellen&quot;</span></span><br><span class="line">2) <span class="string">&quot;rose&quot;</span></span><br><span class="line">3) <span class="string">&quot;tony&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）spop"><a href="#（3）spop" class="headerlink" title="（3）spop"></a>（3）spop</h4><p>移除并返回集合中的一个随机元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop internet</span><br><span class="line"><span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop internet</span><br><span class="line"><span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（4）scard"><a href="#（4）scard" class="headerlink" title="（4）scard"></a>（4）scard</h4><p>获取成员个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h4 id="（5）smove"><a href="#（5）smove" class="headerlink" title="（5）smove"></a>（5）smove</h4><p>移动一个元素到另外一个集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd internet amoeba nginx redis</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd bigdata hadopp spark rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers bigdata</span><br><span class="line">1) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">2) <span class="string">&quot;spark&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove bigdata internet rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers internet</span><br><span class="line">1) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">2) <span class="string">&quot;redis&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers bigdata</span><br><span class="line">1) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">2) <span class="string">&quot;spark&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（6）sunion"><a href="#（6）sunion" class="headerlink" title="（6）sunion"></a>（6）sunion</h4><p>并集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sunion internet bigdata</span><br><span class="line">1) <span class="string">&quot;redis&quot;</span></span><br><span class="line">2) <span class="string">&quot;nginx&quot;</span></span><br><span class="line">3) <span class="string">&quot;rabbitmq&quot;</span></span><br><span class="line">4) <span class="string">&quot;amoeba&quot;</span></span><br><span class="line">5) <span class="string">&quot;hadopp&quot;</span></span><br><span class="line">6) <span class="string">&quot;spark&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Redis数据持久化的两种模式-重点"><a href="#Redis数据持久化的两种模式-重点" class="headerlink" title="Redis数据持久化的两种模式(重点)"></a>Redis数据持久化的两种模式(重点)</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>Redis中为了保证在系统宕机(类似进程被杀死)情况下，能更快的进行故障恢复，设计了两种数据持久化方案，分别为rdb和aof。</p><p>Rdb方式是通过手动(save-阻塞式或bgsave-异步)或周期性方式保存redis中key&#x2F;value的一种机制,Rdb方式一般为redis的默认数据持久化方式.</p><p>Aof方式是通过记录写操作日志的方式,记录redis数据的一种持久化机制,这个机制默认是没有开启的.</p><h4 id="（2）rdb和aof比较"><a href="#（2）rdb和aof比较" class="headerlink" title="（2）rdb和aof比较"></a>（2）rdb和aof比较</h4><table><thead><tr><th><strong>rdb</strong></th><th><strong>aof</strong></th></tr></thead><tbody><tr><td>fork一个进程，遍历hash table，利用copy on write，把整个db dump保存下来。  save,bgsave,shutdown, slave 命令会触发这个操作。粒度比较大，如果save, shutdown, slave 之前crash了，则中间的操作没办法恢复。</td><td>把写操作指令，持续的写到一个类似日志文件里。（类似于从postgresql等数据库导出sql一样，只记录写操作）  粒度较小，crash（宕机）之后，只有crash之前没有来得及做日志的操作,这些数据是没办法恢复。</td></tr></tbody></table><p>两种区别就是，一个是持续的用日志记录写操作，crash（崩溃）后利用日志恢复；一个是平时写操作的时候不触发写，只有手动提交save命令，或者是shutdown关闭命令时，才触发备份操作。</p><p>选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 最终一致性（eventually consistent）的意思了。</p><h3 id="Redis事务管理（重点）"><a href="#Redis事务管理（重点）" class="headerlink" title="Redis事务管理（重点）"></a>Redis事务管理（重点）</h3><h4 id="（1）背景"><a href="#（1）背景" class="headerlink" title="（1）背景"></a>（1）背景</h4><p>大多数数据库的事务控制，假如是乐观锁的方式，一般都是基于数据版本（version）的记录机制实现的。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据。</p><p>Redis也采用类似的机制，使用watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败。也可以调用watch多次监视多个key。这样就可以对指定的key加乐观锁了。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。当然exec，discard，unwatch命令都会清除连接中的所有监视。</p><h4 id="（2）基本概念"><a href="#（2）基本概念" class="headerlink" title="（2）基本概念"></a>（2）基本概念</h4><p>redis是单线程(但是在6.0中真正引用多线程的应用)，提交命令时，其它命令无法插入其中，轻松利用单线程实现了事务的原子性。那如果执行多个redis命令呢？自然就没有事务保证，于是redis有下列相关的redis命令来实现事务管理。</p><p>multi   开启事务</p><p>exec    提交事务</p><p>discard  取消事务</p><p>watch   监控，如果监控的值发生变化，则提交事务时会失败</p><p>unwatch  去掉监控</p><p>Redis保证一个事务中的所有命令要么都执行，要么都不执行(原子性)。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p><h4 id="（3）exec提交事务"><a href="#（3）exec提交事务" class="headerlink" title="（3）exec提交事务"></a>（3）exec提交事务</h4><p>例如：模拟转账，王有200，张有700，张给王转100。过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w 200</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> z 700</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;200&quot;</span></span><br><span class="line">2) <span class="string">&quot;700&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby z 100</span><br><span class="line">QUEUED<span class="comment">#注意此命令根本没有执行，而是把其放在一个队列中</span></span><br><span class="line">127.0.0.1:6379&gt; incrby w 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get w<span class="comment">#同时，这些相关的变量也不能再读取</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get z</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 600</span><br><span class="line">2) (<span class="built_in">integer</span>) 300</span><br><span class="line">3) 1) <span class="string">&quot;300&quot;</span></span><br><span class="line">   2) <span class="string">&quot;600&quot;</span></span><br><span class="line">4) <span class="string">&quot;300&quot;</span></span><br><span class="line">5) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（4）如果有错误指令，自动取消"><a href="#（4）如果有错误指令，自动取消" class="headerlink" title="（4）如果有错误指令，自动取消"></a>（4）如果有错误指令，自动取消</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget w z</span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get w</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> w 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; abc</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; mget w z<span class="comment">#可以看出数据并未变化</span></span><br><span class="line">1) <span class="string">&quot;300&quot;</span></span><br><span class="line">2) <span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="（5）discard取消事务"><a href="#（5）discard取消事务" class="headerlink" title="（5）discard取消事务"></a>（5）discard取消事务</h4><p>注意redis事务太简单，没有回滚，而只有取消。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget z w</span><br><span class="line">1) <span class="string">&quot;600&quot;</span></span><br><span class="line">2) <span class="string">&quot;300&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incrby z 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get z</span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) ERR EXEC without MULTI</span><br></pre></td></tr></table></figure><h4 id="（6）秒杀抢票事务处理"><a href="#（6）秒杀抢票事务处理" class="headerlink" title="（6）秒杀抢票事务处理"></a>（6）秒杀抢票事务处理</h4><p>客户端1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> ticket 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch ticket<span class="comment">#乐观锁，对值进行观察，改变则事务失败</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decr ticket</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby money 100</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>客户端2：还没等客户端1提交事务，此时客户端2把票买到了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get ticket</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr ticket</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>客户端1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)<span class="comment">#执行事务，失败</span></span><br><span class="line">127.0.0.1:6379&gt; get ticket</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch<span class="comment">#取消监控</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于redis的基础知识及应用，是上篇分离出来的。</p><p>因为我个人不怎么用JAVA，所以把java的相关内容移除了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】linux安装redis</title>
      <link href="/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85redis/"/>
      <url>/2024/09/08/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85redis/</url>
      
        <content type="html"><![CDATA[<p>完成了Docker和MySQL的安装，因为项目需要，这里需要安装redis。</p><p>redis是为了防止MySQL的连接被太多请求击穿做的防火墙（可以这么理解），是前后端连接的中间件。</p><p>所以，redis是大型项目必须要学习的必然知识，所以这里整理一下线上部署的知识，便于后续后端的学习。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这里并不用传动的方式进行redis在Linux服务器上的安装，全程都用docker进行安装。</p><p>在正式配置服务器之前，请参考我之前的<a href="https://crazystudent13.cn/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/">docker安装流程</a>，先把服务器上的Docker部署一下。</p><h3 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h3><p>在linux虚拟机中启动docker,从docker中将redis从网络上pull下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><h3 id="创建redis实例并启动"><a href="#创建redis实例并启动" class="headerlink" title="创建redis实例并启动"></a>创建redis实例并启动</h3><p>创建redis配置文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/docker/redis/conf</span><br></pre></td></tr></table></figure><p>在配置文件录下创建redis.conf配置文件(因为redis镜像中这个redis.conf是一个目录所以要先创建一个这个配置文件，否在我们本地挂载点也会变成一个目录)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /usr/local/docker/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>在linux上挂载redis并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /usr/local/docker/redis/data:/data \</span><br><span class="line">-v /usr/local/docker/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf </span><br></pre></td></tr></table></figure><h3 id="查看正在运行的进程"><a href="#查看正在运行的进程" class="headerlink" title="查看正在运行的进程"></a>查看正在运行的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="控制台直接连接redis测试"><a href="#控制台直接连接redis测试" class="headerlink" title="控制台直接连接redis测试"></a>控制台直接连接redis测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis bash</span><br></pre></td></tr></table></figure><h3 id="检测redisb版本"><a href="#检测redisb版本" class="headerlink" title="检测redisb版本"></a>检测redisb版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-server –v</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -v</span><br></pre></td></tr></table></figure><p>不过，这里更推荐直接将上面的两个步骤合为一个步骤，不容易出问题，指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-cli</span><br></pre></td></tr></table></figure><h3 id="停止redis服务"><a href="#停止redis服务" class="headerlink" title="停止redis服务"></a>停止redis服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop redis</span><br></pre></td></tr></table></figure><h3 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h3><p>在docker中，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start redis</span><br></pre></td></tr></table></figure><p>传统方式启动（非docker环境）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server <span class="comment">#默认找redis.conf配置文件</span></span><br><span class="line">redis-server &amp;<span class="comment">#上面ctrl+c中断reis会退出，这个不会</span></span><br><span class="line">redis-server redis6380.conf      <span class="comment">#指定配置文件，这样可以启动多个实例</span></span><br></pre></td></tr></table></figure><h3 id="重启redis服务"><a href="#重启redis服务" class="headerlink" title="重启redis服务"></a>重启redis服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure><h3 id="查看redis服务版本"><a href="#查看redis服务版本" class="headerlink" title="查看redis服务版本"></a>查看redis服务版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-server -v</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h3 id="设置访问密码"><a href="#设置访问密码" class="headerlink" title="设置访问密码"></a>设置访问密码</h3><p>默认没有密码，可以随意访问。</p><p>redis速度相当快，在一个较好的服务器下，外部用户每秒可以进行15w次的密码尝试，这意味着必须指定非常强大的密码来防止暴力破解。</p><p>如果要使用密码，打开redis.conf配置文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 123456    <span class="comment">#480行，设置请求密码，这样访问时都需要先登录</span></span><br></pre></td></tr></table></figure><p>修改完配置文件以后，要重启redis服务。（docker start redis）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456<span class="comment">#客户端访问方式</span></span><br><span class="line">jedis.auth(“123456”);<span class="comment">#jedis访问方式(学了以后用)</span></span><br></pre></td></tr></table></figure><p>部署到这里，基本上流程都差不多了，如果有什么具体的配置需求，可以参考下文中的内容，进行config的配置。</p><h3 id="Redis-conf配置文件"><a href="#Redis-conf配置文件" class="headerlink" title="Redis.conf配置文件"></a>Redis.conf配置文件</h3><p>Redis 支持很多的参数，但都有默认值。</p><h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a><strong>daemonize</strong></h4><p>默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes。</p><h4 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a><strong>pidfile</strong></h4><p>当 Redis 在后台运行的时候， Redis 默认会把 pid 文件放在&#x2F;var&#x2F;run&#x2F;redis.pid，你可以配置到其他地址。当运行多个 redis 服务时，需要指定不同的 pid 文件和端口</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a><strong>bind</strong></h4><p>指定 Redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求，在生产环境中最好设置该项</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a><strong>port</strong></h4><p>监听端口，默认为 6379</p><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><strong>timeout</strong></h4><p>设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</p><h4 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a><strong>loglevel</strong></h4><p>log 等级分为 4 级， debug, verbose, notice, 和 warning。生产环境下一般开启 notice</p><h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a><strong>logfile</strong></h4><p>配置 log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上</p><h4 id="databases"><a href="#databases" class="headerlink" title="databases"></a><strong>databases</strong></h4><p>设置数据库的个数，可以使用 SELECT 命令来切换数据库。默认使用的数据库是 0</p><h4 id="save"><a href="#save" class="headerlink" title="save"></a><strong>save</strong></h4><p>设置 Redis 进行数据库镜像的频率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(在 60 秒之内有 10000 个 keys 发生变化时)&#123;</span><br><span class="line">进行镜像备份 （redis/data/）</span><br><span class="line">&#125;else if(在 300 秒之内有 10 个 keys 发生了变化)&#123;</span><br><span class="line">进行镜像备份</span><br><span class="line">&#125;else if(在 900 秒之内有 1 个 keys 发生了变化)&#123;</span><br><span class="line">进行镜像备份</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a><strong>rdbcompression</strong></h4><p>在进行镜像备份时，是否进行压缩</p><h4 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a><strong>dbfilename</strong></h4><p>镜像备份文件的文件名</p><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a><strong>dir</strong></h4><p>数据库镜像备份的文件放置的路径。</p><p>这里的路径跟文件名要分开配置是因为 Redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中</p><p>等备份完成时，再把该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中</p><h4 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a><strong>slaveof</strong></h4><p>设置该数据库为其他数据库的从数据库</p><h4 id="masterauth"><a href="#masterauth" class="headerlink" title="masterauth"></a><strong>masterauth</strong></h4><p>当主数据库连接需要密码验证时，在这里指定</p><h4 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a><strong>requirepass</strong></h4><p>设置客户端连接后进行任何其他指定前需要使用的密码。</p><p>警告：因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解。</p><p><strong>maxclients</strong></p><p>限制同时连接的客户数量。当连接数超过这个值时， redis 将不再接收其他连接请求，</p><p>客户端尝试连接时将收到 error 信息。</p><h4 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a><strong>maxmemory</strong></h4><p>设置 redis 能够使用的最大内存。</p><h4 id="appendonly"><a href="#appendonly" class="headerlink" title="appendonly"></a><strong>appendonly</strong></h4><p>默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。</p><p>所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。</p><p>但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对appendonly.aof 进行重新整理。</p><p>所以我认为推荐生产环境下的做法为关闭镜像，开启appendonly.aof，同时可以选择在访问较少的时间每天对 appendonly.aof 进行重写一次。</p><h4 id="appendfsync"><a href="#appendfsync" class="headerlink" title="appendfsync"></a>appendfsync</h4><p>设置对 appendonly.aof 文件进行同步的频率。 always 表示每次有写操作都进行同步，</p><p>everysec 表示对写操作进行累积，每秒同步一次。这个需要根据实际业务场景进行配置</p><h4 id="vm-enabled"><a href="#vm-enabled" class="headerlink" title="vm-enabled"></a><strong>vm-enabled</strong></h4><p>是否开启虚拟内存支持。因为 redis 是一个内存数据库，而且当内存满的时候，无法接收新的写请求，所以在 redis 2.0 中，提供了虚拟内存的支持。</p><p>但是需要注意的是， redis中，所有的 key 都会放在内存中，在内存不够时，只会把 value 值放入交换区。这样保证了虽然使用虚拟内存，但性能基本不受影响</p><p>同时，你需要注意的是你要把vm-max-memory 设置到足够来放下你的所有的 key</p><h4 id="vm-swap-file"><a href="#vm-swap-file" class="headerlink" title="vm-swap-file"></a><strong>vm-swap-file</strong></h4><p>设置虚拟内存的交换文件路径</p><h4 id="vm-max-memory"><a href="#vm-max-memory" class="headerlink" title="vm-max-memory"></a><strong>vm-max-memory</strong></h4><p>这里设置开启虚拟内存之后， redis 将使用的最大物理内存的大小。默认为 0， redis 将把他所有的能放到交换文件的都放到交换文件中，以尽量少的使用物理内存。</p><p>在生产环境下，需要根据实际情况设置该值，最好不要使用默认的 0</p><h4 id="vm-page-size"><a href="#vm-page-size" class="headerlink" title="vm-page-size"></a><strong>vm-page-size</strong></h4><p>设置虚拟内存的页大小，如果你的 value 值比较大，比如说你要在 value 中放置博客、新闻之类的所有文章内容，就设大一点，如果要放置的都是很小的内容，那就设小一点。</p><h4 id="vm-pages"><a href="#vm-pages" class="headerlink" title="vm-pages"></a><strong>vm-pages</strong></h4><p>设置交换文件的总的 page 数量， 需要注意的是， page table 信息会放在物理内存中，每8 个 page 就会占据 RAM 中的 1 个 byte。总的虚拟内存大小 ＝ vm-page-size * vm-pages</p><h4 id="vm-max-threads"><a href="#vm-max-threads" class="headerlink" title="vm-max-threads"></a><strong>vm-max-threads</strong></h4><p>设置 VM IO 同时使用的线程数量。因为在进行内存交换时，对数据有编码和解码的过程，所以尽管 IO 设备在硬件上本上不能支持很多的并发读写，但是还是如果你所保存的 vlaue 值比较大，将该值设大一些，还是能够提升性能的</p><p><strong>glueoutputbuf</strong></p><p>把小的输出缓存放在一起，以便能够在一个 TCP packet 中为客户端发送多个响应，具体原理和真实效果我不是很清楚。所以根据注释，你不是很确定的时候就设置成 yes</p><h4 id="hash-max-zipmap-entries"><a href="#hash-max-zipmap-entries" class="headerlink" title="hash-max-zipmap-entries"></a><strong>hash-max-zipmap-entries</strong></h4><p>在 redis 2.0 中引入了 hash 数据结构。当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时， hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</p><h4 id="activerehashing"><a href="#activerehashing" class="headerlink" title="activerehashing"></a><strong>activerehashing</strong></h4><p>开启之后， redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用。</p><p>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no。</p><p>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇文章一开始只是想简单整理一个好用的线上redis部署流程。</p><p>但是在掘金上翻了一阵子之后，没想到找了一篇配置流程全面且准确的教程。</p><p>因为文档实在太长，这里仅截取了部署的部分，部署流程简单易懂，亲测可用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7031189105648074766?searchId=20240907222806EBEAF5650B7F2A5FFB08">Redis在docker下的的安装和基本使用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】linux安装MySQL</title>
      <link href="/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<p>关于在linux安装MySQL，我个人推荐使用Dcoker安装，流程比用原生手段安装更简单。</p><p>使用Docker之后，安装流程被简化了很多，简单易操作，也可以用<code>1panel</code>的图形化点击部署，很简单好用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果之前没有安装Docker的，推荐完整流程参考：<a href="https://juejin.cn/post/7406144322834382899?searchId=202409061945048DCECD6B5FCF23BDCB0D">从安装Docker到打包迁移MySQL的完整指南</a>这篇文档。</p><p>先安装一下Docker，这篇文章记录的比较详细。</p><p>本文仅截取部署MySQL的部分，主要是用Docker在服务器上部署MySQL的流程。</p><h3 id="用Docker部署MySQL"><a href="#用Docker部署MySQL" class="headerlink" title="用Docker部署MySQL"></a>用Docker部署MySQL</h3><p>MySQL是一种流行的开源关系数据库管理系统。</p><p>在Docker中部署MySQL非常简单。</p><p>以下步骤将引导你如何在Docker中运行MySQL容器。</p><h4 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取MySQL镜像</h4><p>为了加速镜像的下载速度，建议使用国内的镜像源。以下是从DaoCloud镜像源拉取MySQL官方镜像的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull daocloud.io/library/mysql:8.0</span><br></pre></td></tr></table></figure><p>千万千万不要使用下面命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:8.0</span><br></pre></td></tr></table></figure><p>因为有些服务器禁止连接外网，所以导致你不能从hub拿到镜像下载地址，导致pull失败。</p><p>比如政务内网环境，那么此时就只能是如此操作。</p><h4 id="运行MySQL容器"><a href="#运行MySQL容器" class="headerlink" title="运行MySQL容器"></a>运行MySQL容器</h4><p>使用拉取的MySQL镜像启动一个容器，并将MySQL的3306端口映射到主机的3306端口，以便外部访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name mysql-container -e MYSQL_ROOT_PASSWORD=my-secret-pw -p 3306:3306 -d mysql:8.0</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><ul><li><code>--name mysql-container</code>：指定容器名称为<code>mysql-container</code>。</li><li><code>-e MYSQL_ROOT_PASSWORD=my-secret-pw</code>：设置MySQL的<code>root</code>用户密码为<code>my-secret-pw</code>。</li><li><code>-p 3306:3306</code>：将容器内的3306端口映射到主机的3306端口。</li><li><code>-d mysql:8.0</code>：在后台运行MySQL 8.0镜像。</li></ul><h4 id="配置MySQL允许远程访问"><a href="#配置MySQL允许远程访问" class="headerlink" title="配置MySQL允许远程访问"></a>配置MySQL允许远程访问</h4><p>进入MySQL容器，允许<code>root</code>用户从任意主机访问数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it mysql-container mysql -uroot -p</span><br></pre></td></tr></table></figure><p>在MySQL命令行中，运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;my-secret-pw&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>如果你希望创建一个新用户以用于远程访问，可以运行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;userpassword&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;newuser&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="配置my-cnf"><a href="#配置my-cnf" class="headerlink" title="配置my.cnf"></a>配置<code>my.cnf</code></h3><p>记得在目录<code>/var/lib/docker/volumes/mysql-data/_data/</code>中，添加一个<code>my.cnf</code></p><p><code>my.cnf</code>的文件，输入如下内容即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">bind-address = 自己服务器的ip地址</span><br></pre></td></tr></table></figure><h4 id="防火墙配置（如适用）"><a href="#防火墙配置（如适用）" class="headerlink" title="防火墙配置（如适用）"></a>防火墙配置（如适用）</h4><p>如果你的服务器有防火墙，需要确保3306端口对外开放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>当然，这是用命令的方式，如果你使用的是腾讯云或者阿里云这种云服务器，是有端口配置的协议的。</p><p>有这种云服务器，这种事情就简单很多了。</p><p>你可以直接在防火墙的配置中，打开端口配置，把3306的端口打开就可以。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个流程还不完整，我可能测试的还不够完整，所以文档中应该有所缺漏。</p><p>不过，只要学习独立开发，后续必然还会再其他云服务器上部署项目，这个流程应该会被持续完善。</p><p>后续持续完善该部署流程，也欢迎大家提意见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7406144322834382899?searchId=202409061945048DCECD6B5FCF23BDCB0D">从安装Docker到打包迁移MySQL的完整指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> MySQL </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】linux安装docker</title>
      <link href="/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/"/>
      <url>/2024/09/06/%E3%80%90%E8%BD%AC%E3%80%91linux%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<p>因为需要安装MySQL，但是现在大多数主流的安装流程都要用到docker，所以在正式安装MySQL之前，先装Docker。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我看了一下这个流程，基本上<a href="https://link.juejin.cn/?target=https://docs.docker.com/engine/install/centos/">docker官方网站</a>是有介绍的，不过是英文，不太方便看，</p><p>而文档搬运的很好，个人亲测有效，推荐使用。</p><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><p>个人是linux服务器，纯命令行，请勿在windows上安装。</p><h4 id="删除docker信息"><a href="#删除docker信息" class="headerlink" title="删除docker信息"></a>删除docker信息</h4><p>原有安装信息清理，可跳过。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; yum remove docker \</span><br><span class="line">&gt; docker-client \</span><br><span class="line">&gt; docker-client-latest \</span><br><span class="line">&gt; docker-common \</span><br><span class="line">&gt; docker-latest \</span><br><span class="line">&gt; docker-latest-logrotate \</span><br><span class="line">&gt; docker-logrotate \</span><br><span class="line">&gt; docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装yum工具"><a href="#安装yum工具" class="headerlink" title="安装yum工具"></a>安装yum工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><h4 id="配置资源地址"><a href="#配置资源地址" class="headerlink" title="配置资源地址"></a>配置资源地址</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:<span class="comment">//download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.<span class="built_in">io</span> docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> docker</span><br></pre></td></tr></table></figure><h4 id="若安装docker报错"><a href="#若安装docker报错" class="headerlink" title="若安装docker报错"></a>若安装docker报错</h4><p>problem with installed package podman-1.6.4-10.module_el8.2.0+305+5e198a41.x86_64</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install <span class="attr">--allowerasing</span> docker-ce</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h4 id="阿里镜像加速配置"><a href="#阿里镜像加速配置" class="headerlink" title="阿里镜像加速配置"></a>阿里镜像加速配置</h4><p>阿里云：控制台-&gt;左上角菜单-&gt;产品与服务-&gt;容器-&gt;容器镜像服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;加速镜像地址&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h3><ul><li><strong>推荐一个前后端脚手架 <a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/MQoachhzJMGGdryo_VPeYg">lg-soar：助力开发者腾飞的利器</a></strong></li><li><strong>微信公众号</strong>：六哥是全栈</li><li>掘金主页：<a href="https://juejin.cn/user/3650034336021736/posts">六哥是全栈 的个人主页 - 文章 - 掘金 (juejin.cn)</a></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很好的安装流程，之前也找过不少流程，要么太老，要么太繁琐。</p><p>一篇好的指引教程很重要，所有这里特地记录一下，便于后续使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7410989416867364891">linux安装docker</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决el-tag等代码自动转成了图标的问题</title>
      <link href="/2024/08/24/%E8%A7%A3%E5%86%B3el-tag%E7%AD%89%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90%E4%BA%86%E5%9B%BE%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/24/%E8%A7%A3%E5%86%B3el-tag%E7%AD%89%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90%E4%BA%86%E5%9B%BE%E6%A0%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>某天打开新项目，意外的发现不对，<code>&lt;el-tag&gt;</code>这类标签居然变成图标了。</p><p>而且一开始还稍微费了些时间才搜到结果，这种配置问题我以为会很常见，但结果看来并不常见。</p><p>考虑到这是一个比较偏门的问题，所以特地转载记录一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次情况是vscode中开发前端项目中发现的。</p><h3 id="问题情况"><a href="#问题情况" class="headerlink" title="问题情况"></a>问题情况</h3><p>使用element框架，<code>&lt;el-tag&gt;</code>这类标签居然变成图标，我记得还有其他标签变成了图标。</p><p>具体情况如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a218e487bfad169059d5e523aac66352.png"></p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>打开vscode，首选项 -&gt; 设置 -&gt; 搜索iconify，然后把下面这个√去掉就OK了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enabled lconify inline annotations</span><br></pre></td></tr></table></figure><p>这不是插件的问题，是个配置的问题，这里稍微改一下。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来不太想记录这个问题的，但是当时搜的时候稍微费了一会儿功夫才查到，感觉还是记一下，稍微强化一下印象比较好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/this_zq/article/details/139961066">vscode代码片段自动转图标禁用（el-tag代码自动转成了图标问题排查）_el-tag 变成图标了-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决前端项目中npm包管理的常见问题</title>
      <link href="/2024/08/22/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/22/%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%ADnpm%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近新入职了新公司，然后要走熟悉的流程，安装npm包，启动项目。</p><p>只是，公司有些项目版本实在太老，且最近似乎又有新项目升级项目的考量，所以项目的包管理肯定是个问题。</p><p>所以，这里整合一些常见的命令，用来处理有问题的地方。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇文档主要是整理一些我在开发过程中常常遇到的npm问题，过程中顺便分享一些自己的理解和心得。</p><p>本文主要面对刚上路的前端新手，如果高手路过，还请评论区轻喷并指导一二。</p><h3 id="node环境管理"><a href="#node环境管理" class="headerlink" title="node环境管理"></a>node环境管理</h3><p>如果你的手里有数个周期达到3年以上的老项目需要维护，那么大抵会有一些包只有低版本的node环境才能适配。</p><p>早些年有人会用nvm来进行版本管理，但是新生代的有了很多平替产品，个人推荐volta，当然也有朋友推荐fnm。</p><p>这两者都是新生代的产品，随便选哪个都好，相对于nvm，volta和fnm的操作更简单方便。</p><h3 id="npm与pnpm"><a href="#npm与pnpm" class="headerlink" title="npm与pnpm"></a>npm与pnpm</h3><p>虽然我依然还在使用npm，但那是因为低版本项目不支持pnpm，如果你手里的项目平均超过18，可以尝试使用pnpm。</p><p>pnpm比起npm更能节约空间，大多数开发者手里的电脑都是1T容量的开发本，这种容量基本上遇到几个黑洞项目容量就开始捉襟见肘。</p><p>如果你需要再本地跑一些后端项目，再加上一些大型的文档，或者是一些设计图什么的，很难说自己的电脑那1T的可怜容量是否能够保证。</p><p>而pnpm可以把各个项目中的相同包放在一个地方管理，通过软连接的形式，各个项目包就只要下载一次即可。</p><p>比起传统的npm，这种方式更节省磁盘，也更节省下载时间。</p><h3 id="npm相关操作"><a href="#npm相关操作" class="headerlink" title="npm相关操作"></a>npm相关操作</h3><p>这里的常规操作，如果不清楚，各个推荐使用gpt或者其他AI来在线去问。</p><p>现在AI对于这种通用的操作的解释准确度，很多时候甚至比人整理的文档更准。</p><h4 id="切换镜像"><a href="#切换镜像" class="headerlink" title="切换镜像"></a>切换镜像</h4><p>很多开发中，会遇到下载依赖包迟迟下载不下来的问题，这个问题估计新手会很懵。</p><p>其实，只要冲浪强度稍微高一点的朋友，大概都猜到是国内网络环境的问题了，只要遇到类似于环境配置下载的问题，大概都是网络问题。</p><p>目前能解决的方案，一种是翻墙，另一种就是常见的切换镜像下载了。</p><p>而npm的包下载问题，常用的就是切换镜像下载。</p><h5 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h5><p>前面我们说了，国内因为环境特殊的问题，往往会遇到环境配置难搞的问题。</p><p>而国内的大公司为了下载方便，于是就做了一个服务器用来同步这些主流的环境和包。</p><p>比如，淘宝镜像环境往往每隔10分钟同步一次外网的npm库，将npm线上的包同步到国内的服务器，便于开发者下载。</p><p>因为这些内容是同步npm库的东西，像镜子一样，于是这种服务器就被称作镜像。</p><p>要在npm中切换镜像源，你可以使用<code>npm config set registry</code>命令来设置你想要的npm注册表镜像。</p><p>以下是一些常用的npm镜像源以及如何切换到它们的示例操作。</p><h5 id="使用淘宝镜像"><a href="#使用淘宝镜像" class="headerlink" title="使用淘宝镜像"></a>使用淘宝镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmmirror.com </span><br></pre></td></tr></table></figure><h5 id="切换回官方npm镜像"><a href="#切换回官方npm镜像" class="headerlink" title="切换回官方npm镜像"></a>切换回官方npm镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h5 id="查看当前配置的镜像"><a href="#查看当前配置的镜像" class="headerlink" title="查看当前配置的镜像"></a>查看当前配置的镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">pnpm config get registry</span><br></pre></td></tr></table></figure><h5 id="npmrc文件配置"><a href="#npmrc文件配置" class="headerlink" title=".npmrc文件配置"></a><code>.npmrc</code>文件配置</h5><p>（位于用户的主目录，负责管理npm包安装的一些偏好），添加或修改下面的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>以上这些命令可以在命令行中直接运行，无需进入项目目录。</p><p>运行这些命令后，你将使用指定的镜像源来安装npm包。</p><p>切换镜像类的命令，<code>pnpm</code>和<code>npm</code>是通用的。</p><h4 id="包安装及查看"><a href="#包安装及查看" class="headerlink" title="包安装及查看"></a>包安装及查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install 包 -g //全局安装</span><br><span class="line">npm install 包 -s -d  //安装到devDependencies </span><br><span class="line">npm install mockjs@1.0.0 //安装指定版本的包</span><br><span class="line"></span><br><span class="line">包 -v //检查版本</span><br><span class="line">npm root //查看包的安装路径</span><br></pre></td></tr></table></figure><h4 id="包卸载"><a href="#包卸载" class="headerlink" title="包卸载"></a>包卸载</h4><p>有些时候，我们卸载包重装，会遇到一些奇怪的问题。</p><p>我们可以先卸载包，然后再清除npm本地缓存，再安装，效果会好很多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 包   // 卸载</span><br><span class="line">npm cache clean // 清除npm本地缓存</span><br><span class="line">npm update // 更新模块</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来一开始只是想简单记录一些npm的相关操作，后来想了想，反正做都做了，干脆索性做个新手级的科普文档。</p><p>为了做这期文档，特意去了解了很多东西，没想到这次简单的整理让我了解了不少npm的相关知识。</p><p>不过，本篇文档是主要还是以整理工作中常用问题为主，所以对于太过基本的问题就不去科普了，推荐看我参考整理的几篇参考文档。</p><p>他们对npm的解释较为深刻，如果你有时间将这些看完，对于npm包管理这块，应该会有一个较为深刻的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7245201923506094140?searchId=20240822221329B4A35E92588CB1A6DB98">彻底了解npm——架构、进化史及原理解析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解defer与async</title>
      <link href="/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/"/>
      <url>/2024/08/05/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3defer%E4%B8%8Easync/</url>
      
        <content type="html"><![CDATA[<p>defer与async不怎么常用，而且这个涉及到<code>&lt;scrpit/&gt;</code>的基础使用方式，都是一些远古常识题，</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>async</code> 和 <code>defer</code> 是两种不同的JavaScript特性，它们的主要区别在于它们的执行顺序和时间点。</p><p>在正式进入二者的区别之前，我们需要先了解所有scprit的脚本对页面执行的阻塞的影响。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p> <strong>async</strong>属性是 HTML5 中的新属性</p></blockquote><ul><li><strong>async</strong>：可选，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li><li><strong>charset</strong>：可选。表示通过 src 属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。</li><li><strong>defer</strong>：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。</li><li><strong>language</strong>： 已废弃。原来用于表示编写代码使用的脚本语言（如 JavaScript 、 JavaScript1.2 或 VBScript ）。大多数浏览器会忽略这个属性，因此也没有必要再用了。</li><li><strong>src</strong>：可选。表示包含要执行代码的外部文件。</li><li><strong>type</strong>：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）。虽然 text&#x2F;javascript<br>和 text&#x2F;ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text&#x2F;javascript 。实际上，服务器在传送 JavaScript 文件时使用的<br>MIME 类型通常是 application&#x2F;x–javascript ，但在 type 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：<br>application&#x2F;javascript 和 application&#x2F;ecmascript 。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的值依旧还是<br>text&#x2F;javascript 。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text&#x2F;javascript 。</li></ul><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="内联形式"><a href="#内联形式" class="headerlink" title="内联形式"></a>内联形式</h4><p>这种方式指的是在 <code>html </code>文件中，添加一个<code>&lt;script&gt;&lt;/scritp&gt;</code>标签，然后将 <code>JavaScript</code>代码直接写在里面，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内联 JavaScript&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外置形式"><a href="#外置形式" class="headerlink" title="外置形式"></a>外置形式</h4><p>外置形式是将 <code>JavaScript</code> 代码写在外部的一个文件里面，在 <code>html</code> 文件中通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性引入,如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="两种引入形式的比较"><a href="#两种引入形式的比较" class="headerlink" title="两种引入形式的比较"></a>两种引入形式的比较</h4><p>对于这两种方式，毫无疑问，外置形式明显好于内联形式，主要表现为以下方面:</p><ul><li><strong>可维护性</strong>：外置 Javascript 文件可以被多个页面调用而不用在每个页面上反复地书写.如果有需要改变的部分,你只需要在一处修改即可.所以外置JavaScript 导致代码工作量减少,进而使得维护手续也更加方便。</li><li><strong>可缓存</strong>：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li><li><strong>关注点分离</strong>：将 JavaScript 封装在外部的.js文件遵循了关注点分离的法则.总体来说,分离 HTML,CSS 和 JavaScript 从而让我们更容易操纵他们.而且如果是多名开发者同步工作的话,这样也更方便。</li></ul><p>因此，在今后的开发中尽量使用外置方式的形式引入<code>JavaScript</code>。</p><h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><p>如果要谈<code>&lt;script&gt;</code> 标签加载顺序问题，首先要谈的就是标签的位置。</p><p>标签的位置对于<code>JavaScript</code>加载顺序来说有着很重要的影响。</p><p>很早之前，有个经典面试题，<code>&lt;script&gt;</code> 标签放在html头部和尾部，是否有区别？会不会有不同执行结果？</p><p>显然，是有区别的。</p><h4 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h4><p>标签的位置有两种，一种是方式<code>&lt;head&gt;</code>元素里面，另外一种就是放在<code>&lt;body&gt; </code>元素中页面内容的后面（就是页面内容结尾部分）。</p><h4 id="在-lt-head-gt-内"><a href="#在-lt-head-gt-内" class="headerlink" title="在&lt;head&gt;内"></a>在<code>&lt;head&gt;</code>内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一种比较传统的做法，目的就是把所有外部文件（包括 <code>CSS</code> 文件和 <code>JavaScript</code> 文件）的引用都放在相同的地方。</p><p>可是，在文档的<code>&lt;head&gt;</code>元素中包含所有 JavaScript 文件，意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到 <code>&lt;body&gt;</code> 标签时才开始呈现内容）。</p><p>对于那些需要很多 JavaScript 代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。</p><p>在早年前端体系不成熟的时候，有些开发者会喜欢把<code>&lt;script/&gt;</code>标签放在<code>&lt;head&gt;</code>标签中，造成页面白屏时间极长，显得极为卡顿。</p><p>很明显，这种做法有着很明显的缺点，特别是针对于现在的移动端来说，如果超过 1s 还没有内容呈现的话将是一种很差的用户体验。</p><p>为了避免这个问题，就有了下面这种加载方式。</p><h4 id="在-lt-body-gt-内"><a href="#在-lt-body-gt-内" class="headerlink" title="在&lt;body&gt; 内"></a>在<code>&lt;body&gt;</code> 内</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里放内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种方式，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中。</p><p>而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p><code>&lt;script&gt;</code>的每个属性设计来肯定都是有用的，下面我们就来说一说 defer 属性。</p><p>HTML 4.01 为 <code>&lt;script&gt;</code> 标签定义了 defer 属性。</p><p>这个属性的用途是表明脚本在执行时不会影响页面的构造。</p><p>也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</p><p>因此，在<code>&lt;script&gt;</code>元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/01.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/02.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/03.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，虽然我们把 <code>&lt;script&gt;</code> 元素放在了文档的 <code>&lt;head&gt;</code> 元素中，但其中包含的脚本将延迟到浏览器遇到 <code>&lt;/html&gt;</code> 标签后再执行。</p><p>HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 <code>DOMContentLoaded</code> 事件执行。</p><p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p><blockquote><p><strong>“在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。”</strong> </p><p>这段话是《JavaScript 高级程序设计（第三版）》中的一句话，纠结了很久。自己也尝试写了一些例子，但反馈的结果都是：如果引入的 <code>&lt;script&gt;</code>标签 都使用了 <code>defer</code> 属性，他们的执行顺序都是按照他们引入的顺序来的。</p><p>那么作者为什么会写上这一句话呢，个人感觉原因是：即使在 <code>HTML5</code> 规范中有这么一条，不一定所有的浏览器厂商都会遵照这个规定，可能某些浏览器厂商并没有实现这个规范，但支持 <code>defer</code> 属性，那么就会出现作者所描述的那种情况，所以为了安全起见，在开发中使用一个 <code>defer</code> 是非常有必要的。</p></blockquote><blockquote><p>还有一点需要注意的是，defer 属性只适用于外部脚本文件。</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>意味着函数或代码块会被异步执行。</p><p>当浏览器遇到带有 <code>async</code> 属性的资源时，它会立即开始下载该资源，同时继续加载页面。</p><p>这样可以避免由于同步执行而导致的页面加载阻塞问题。</p><p>然而，由于 <code>async</code> 并不保证具体的执行时间，所以如果在 <code>async</code> 代码中修改了 DOM（文档对象模型），可能会出现错误，特别是在依赖外部资源的场景下。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p><code>defer</code> 则是一种用于推迟执行的特性，这个属性在一些页面模板中会常见，在很多项目工程化的内容中，不常见。</p><p>它允许将脚本放置到页面的最后部分，直到其他所有资源都已加载完毕。</p><p>这样确保了在执行 <code>defer</code> 代码之前，页面已经完全准备好，从而减少了潜在的错误风险。</p><p>特别是对于那些依赖于外部资源的第三方脚本来说，使用 <code>defer</code> 可以提高应用的稳定性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>async</code> 更适合于不需要等待页面完整加载即可运行的第三方脚本，因为它提供了更高的灵活性，但可能伴随着一定的执行时机的不确定性。</p><p> <code>defer</code> 则是为了确保页面加载完成后才执行脚本，减少因页面未加载完全而引发的错误。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里算是直接搬运了其他的内容，稍微学习了一下，这是旁枝末节的内容，如果不是面试，我确实不怎么会看。</p><p><code>async</code>与<code>defer</code>的使用，算是旧时代的余声了，如有需要，按需自取。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000013615988">谈谈  标签以及其加载顺序问题，包含 defer &amp; async</a></p><p><a href="https://www.cnblogs.com/ltwlh/p/18003735">async与defer的区别</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何准备非大厂面试</title>
      <link href="/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/08/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E9%9D%9E%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>个人没有经历大厂的面试，毕竟个人学历不够，且项目经历，技术可能都不太不符合大厂的要求。</p><p>而且，我的年龄已经打了，按照目前的经历，技术还有就业大环境来看，我这辈子估计也无缘大厂了。</p><p>不过，人总是要生活的，进不了大公司，我们也尽可能的要在中小公司拿到高一些的工资。</p><p>毕竟，没有什么东西比金钱更令人安心了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从2024年4月，一直在面试，不断刷面试题，从4月到同年8月，期间，我不间断的整理自己的项目经历，技术体系，面试常考面试题等。</p><p>通过大量的面试经历，我大概整理出中小公司常规的面试流程。</p><p>这里将自己的大量面试经历流程进行整合，以供大家参考，大家按照自己的需求酌情准备面试吧。</p><h3 id="线上交谈"><a href="#线上交谈" class="headerlink" title="线上交谈"></a>线上交谈</h3><p>大多社招，首先是和HR线上交谈，这期间主要是让HR大概了解你的概况，同时你也要了解日常作息待遇，五险一金和薪资等。</p><p>我们线上交谈的流程，无外乎就两种结果：</p><ul><li>HR主动搭话，不断的追问你的意向，主动了解你的居住地和工作经历，同时可能也会看你的。</li><li>HR迟迟不回话，或者说话有一搭没一搭，大概是这家公司的暂时不缺人，又或者对方没有看上你。</li></ul><p>如果是第一种情况，我们尽可能的按照实话将自己有利的一面展示出来就可以了，哪怕对方是外包，需要你展示自己的学信网截图，就正常发就可以。</p><p>如果对方没有看上，也没什么可急的，确认好之后，换下一家就可以。</p><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><p>技术老大对你的印象与能力的认可，直接决定你是否能拿到offer,所以在技术老大面前多聊技术，别谈工作时间薪资待遇那些，那是人事面的流程。</p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>很多时候我们自我介绍的时候，总是简单的说一下个人信息就结束了。</p><p>实际上，这时候我们最好可以将自己的长处，技术栈，个人优势在开场这个时间都说一下，便于双方交换信息，省的面试官后续再问。</p><p>这是一种高效的沟通方式，不要问一句说一句，这样会让双方都很尴尬。</p><h5 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h5><p>包括你的姓名、籍贯、年龄、专业、毕业学校（这里如果哪一项是弱势，介绍的时候可以略过）</p><ol><li>技术能力，简单介绍自己的技术栈，告诉对方你会什么?并且最擅长的技术是什么?这可以让面试官对你的技术体系大概有个数，便于后续双方互动。所以，可以针对对方公司招聘岗位的岗位职责去重点突出自己的能力。</li><li>职业经验，说清楚自己往期的工作经验，待过哪些公司，具体做过什么，如果是应届毕业生，有实习经验说实习经验，没有的话也可以重点说自己在学校内接触过的项目经验。</li><li>当前状况，居住地，是否离职，这样便于面试官判断你是什么时候可以入职。</li><li>自我评价，个人评价这点比较鸡肋，如果技术和项目经历可以说的不多，那可以用这项进行补充。如果要说，记得主要说优势，别说缺陷，因为你是在推销自己。从沟通能力、学习能力、逻辑性等方面吹自己的优势，不过不要吹的太离谱。</li></ol><p>以我个人为例，这里我以个人为例，简单的写个模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫远川，江苏**人，XX年的，有五年左右的前端开发经验，之前都在XX公司任职。</span><br><span class="line">我的技术栈主要是Vue2/3的全家桶，对源码略有了解，也做过Uni-app相关，主要以微信小程序为主。</span><br><span class="line">之前在公司早期负责公司产品开发，封装通用的业务组件，通用的工具类方法，如PC和小程序的动态表单，动态表格，包括一些需要远程查询的数据字典选项。</span><br><span class="line">后续公司产品化之后，主导低代码平台开发，实现低代码流程+流程表单生成的流程，可以同步生成小程序和PC端的单表，后续拓展了主子表的生成，通过该平台极大程度缩减了代码的人力和时间。</span><br><span class="line">目前已离职，人在苏州。</span><br></pre></td></tr></table></figure><p><strong>当你做完自我介绍后，面试官正式开始提问，做好准备!</strong></p><h4 id="项目方面"><a href="#项目方面" class="headerlink" title="项目方面"></a>项目方面</h4><p>在进入项目问题这个阶段，大概是你已经通过了面试官的八股文的阶段。</p><p>毕竟，八股文都是为了试试基础水平而提问的，只要大概试一下，面试官大概就能猜出来你的水平。</p><p>大多数有经验的面试官，在面完八股文之后，如果看到你项目履历足够的丰富之后，肯定是会问一下相关的解决方案，确认你的经历是否真实。</p><p>另外，不要去想着伪装经历，项目经历这种东西是实打实的，简单的几个问题和稍微深入，都能让你没法回应。</p><p>如果面试官开始问你项目，这个问题很重要，建议从以下角度介绍。</p><ol><li><p>项目背景，让对方知道这个项目是做什么的</p></li><li><p>你在项目中的角色，在项目中，你负责了哪些工作?</p></li><li><p>项目难点与解决方案，能说出来，说明你善于总结，同时也有自己的一套解决方案。</p></li><li><p>项目成果，你负责的部分，你的解决方案有什么亮点，主要解决了什么方案。</p></li></ol><p>这里我就不放例子了，每个人可以按照在自己的项目经历，展开写一份面试备案。</p><h4 id="反问阶段"><a href="#反问阶段" class="headerlink" title="反问阶段"></a>反问阶段</h4><p>在八股文和项目经历大概都说明白了之后，面试官大概率会问问你有什么想想问的。</p><p>不要觉得没什么想问的，这是你了解这个团队和未来工作的唯一渠道，你可以从以下角度去反问面试官。</p><ol><li>主营业务，公司的主营业务是什么？是稳定期还是开荒期？你们招我来主要的方向是想做什么？</li><li>团队配置，公司是否有测试，设计，前后端团队，整体开发基建到了什么水准？后续团队的基建方向如何？</li><li>开发流程，平时如何实现一个新需求的开发？平时是否需要做需求评审？</li></ol><p>如果面试你的技术leader层级较高，你也可以侧面确认一下公司的待遇，五险一金，公积金缴费比例，平日加班是否频繁。</p><p>通过这方面的反问，大概率可以确认一个公司的工作内容，团队水平，平日待遇等。</p><p>这些内容，足够用来判断这份工作是否合适自己，以哪方面为准，这个可以按照自己的需求来判断。</p><h3 id="HR二面"><a href="#HR二面" class="headerlink" title="HR二面"></a>HR二面</h3><p>许多公司的面试环节，可能是HR先面，而后是技术组长，之后是技术leader再面试。</p><p>如果技术面结束之后，又是HR二面要你，那就要恭喜了，说明你很大程度是进入了HR定薪阶段。</p><p>HR面试，往往是对你的综合素质进行评判，通常会有以下提问:</p><p><strong>您对自己的未来职业规划是什么?</strong></p><ol><li>想做技术大佬：主要从两个方面出发，一个实近期规划(比如深入的学习前端面向对象)</li><li>想做项目leader：还有一-个是长远规划(未来5年都在前端技术方向，如何可以转产品或者管理等)</li></ol><p><strong>您的期望薪资是多少?</strong></p><p>答:这个可以根据当前岗位给定的范围，选择自己心仪的价格+1k左右。</p><p><strong>您当前的住址在哪？</strong></p><p>这个实际上是希望你离公司很近，便于上下班。</p><p>如果你住的特别远，你也可以表示自己很快就可以搬过来。</p><p><strong>你还有其他公司offer吗?什么时候可以入职?</strong></p><p>HR这样问是想知道能不能百分百拿下你，回答这个问题的尺度一定要把握好:</p><ol><li><p>不能吹嘘，说自己已经有很多offer，否则给HR造成你入职可能性不大的错觉。</p></li><li><p>也不要说一个也没有。更不要表现出对这家公司“迫切入职”，要学会欲擒故纵。</p></li></ol><p>不过，这种套路稍微用用用就可以，实际上没必要玩这种小把戏。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我本来是懒得去整理这些内容，但是早期面试总觉得自己准备的不够充分，明明自己的技术不差，但是就是表达的不够完美。</p><p>现在大环境太烂，我手牌太少，不得不精打细算，于此，便有整理了这篇文档。</p><p>夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也。多算胜，少算不胜，而况于无算乎！——《孙子兵法》</p><p>不打无准备之仗，不打无把握之仗，目前，也只能准备好每一次面试了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7163849862599933983">web前端面试技巧-如何自我介绍？如何应对hr？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Vue2与Vue3的diff算法的区别</title>
      <link href="/2024/07/29/%E6%B5%85%E6%9E%90Vue2%E4%B8%8EVue3%E7%9A%84diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/07/29/%E6%B5%85%E6%9E%90Vue2%E4%B8%8EVue3%E7%9A%84diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>关于vue2与vue3的区别，应该是今年最热门的面试题，如果问深了，diff算法的问题肯定会被问到。</p><p>Vue2的diff算法，市面上基本上算是说的烂大街了，而Vue3的diff算法，市面上并没有较为的解读。</p><p>本来都打算自己去手撕源码了，后来正好翻到了别人团队已经整理好的<a href="https://segmentfault.com/a/1190000042586883">文档</a>，这里特地转载过来。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇不算是全部转载，算是自己对原文的笔记，所以偏重会根据个人需求调整。</p><p>Vue2的diff算法我个人很熟悉，所以下文中可能提到的会少一些，大多数的倾向于解释Vue3的diff算法优化在哪。</p><h3 id="vue3的diff优化"><a href="#vue3的diff优化" class="headerlink" title="vue3的diff优化"></a>vue3的diff优化</h3><p>很多人都会提到Vue3的diff优化，这里很少有人提到具体优化在哪里，所以这里先统一整理下，让我们对优化的方向大致有个概念。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于Diff算法的优化，这里并非是必要的问题。</p><p>不过，我们要想构建一套自己的体系，那么这种边缘的问题最好还是了解一下比较好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000042586883">Vue2、Vue3的diff对比</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析pina与vuex的区别</title>
      <link href="/2024/07/29/%E6%B5%85%E6%9E%90pina%E4%B8%8Evuex%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/07/29/%E6%B5%85%E6%9E%90pina%E4%B8%8Evuex%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>无论是<code>vuex</code>还是<code>pina</code>，本质上都是为了解决项目中的全局数据存储的问题，没有什么更优或者更劣的说法。</p><p>不过，<code>vuex</code>主要是应用在vue2的项目，<code>pina</code>则是随着Vue3升级产生的社区产物。</p><p>pina由原vuex团队，为了配合vue3的升级，特意写的新工具，所以二者在使用上会有一定相似性。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在正式开始写这篇文档之前，稍微科普一下，<a href="https://vuex.vuejs.org/zh/guide/">vuex</a>和<a href="https://pinia.vuejs.org/zh/introduction.html">pina</a>都是一个团队开发的，所以这二者在使用上会有不少类似的地方。</p><p>随着vue3的推广，pina也逐渐开始在社区中推广，成了vue3的开源项目新宠儿。</p><p>早期也有很多开发者在vue2的项目中用pina，或在vue3的项目中用vuex。</p><p>不过，随着时间推移，vue2中使用vuex，vue3中pina，这成了社区约定的常规习惯，大多vue开源项目你都能看到他们这么用。</p><p>如果要问为什么，只是社区逐渐应用产生的习惯罢了，并没有什么特殊的讲究。</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><code>Vuex</code>设计为一个全局状态管理的单例模式，有一个中心化的存储来管理应用的所有状态。</p><p>它基于Vue 2的Options API，强调状态的集中管理和严格的规则，包括State、Getters、Mutations（用于同步更改状态）和Actions（可以处理异步逻辑）。</p><p>其使用与pinia的CompositionAPI 的写法还是略有不同的。 </p><h4 id="action和mutation的区别"><a href="#action和mutation的区别" class="headerlink" title="action和mutation的区别"></a>action和mutation的区别</h4><p>很多人早期在使用vuex的时候，可能有些分不清<code>action</code>和<code>mutation</code>的区别。</p><p>所以，在正式介绍<code>vuex</code>之前，我们先在简单介绍一下二者的区别。</p><ul><li><code>mutation</code>更专注于修改<code>state</code>，必须是同步执行（无法在mutation中使用异步方法）。</li><li><code>action</code>提交的是<code>mutation</code>，而不是直接更新数据，可以是异步的，如业务代码，异步请求。</li><li><code>action</code>可以包含多个<code>mutation</code></li></ul><h4 id="main-js文件"><a href="#main-js文件" class="headerlink" title="main.js文件"></a><code>main.js</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span> <span class="comment">// vuex是导入状态仓库,pinia是创建实例对象createPinia</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(store)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="store文件"><a href="#store文件" class="headerlink" title="store文件"></a><code>store</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">0</span>,<span class="comment">//计数状态</span></span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">//修改状态的方法</span></span><br><span class="line">  <span class="attr">increment</span>: <span class="function">(<span class="params">&#123; commit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// commit 提交一项修改 提交给mutations</span></span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有的状态修改都要经过mutations,只有mutations 可以修改状态</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    state.<span class="property">counter</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getter</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="attr">doubleCount</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">counter</span> * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除了读操作，对写操作十分严格</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(&#123;state,actions,mutations,getters&#125;) <span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a><code>App.vue</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>App.vue:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    count: &#123;&#123; store.state.counter &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   doubleCount: &#123;&#123;store.getters.doubleCount&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AppHeader</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">AppHeader</span> <span class="keyword">from</span> <span class="string">&#x27;./components/app-header.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> store=<span class="title function_">useStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//使用dispatch派出increment  action的方法</span></span></span><br><span class="line"><span class="language-javascript">  store.<span class="title function_">dispatch</span>(<span class="string">&#x27;increment&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>Pinia针对Vue 3设计，充分利用Composition API，提倡更简洁和直观的状态管理方式。</p><p>每个store在Pinia中都是独立的，同时为了兼容Vuex的写法Pinia仍然支持使用选项式API,也是现在主流的状态管理库。</p><h4 id="main-js文件-1"><a href="#main-js文件-1" class="headerlink" title="main.js文件"></a><code>main.js</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia=<span class="title function_">createPinia</span>()  <span class="comment">//创建pinia实例对象</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">.<span class="title function_">use</span>(pinia)   <span class="comment">// use这个实例对象</span></span><br><span class="line">.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="store文件-1"><a href="#store文件-1" class="headerlink" title="store文件"></a><code>store</code>文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>--;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123; count, increment, decrement, reset, doubleCount &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;store&#x27;</span>, </span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> someState=<span class="title function_">ref</span>(<span class="string">&#x27;hello Pinia&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">incrementSomeState</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      someState.<span class="property">value</span> += <span class="string">&#x27;!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; someState , incrementSomeState &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a><code>App.vue</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Counter: &#123;&#123; store.count &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Double:&#123;&#123; store.doubleCount &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.decrement&quot;</span>&gt;</span>decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;store.reset&quot;</span>&gt;</span>reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>String: &#123;&#123; hel.someState &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;hel.incrementSomeState&quot;</span>&gt;</span>+ ! <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123;useCounterStore,useStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/Pinia/counter.js&#x27;</span> <span class="comment">//引入定义好的状态库</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span>  <span class="title class_">Child</span> <span class="keyword">from</span>  <span class="string">&#x27;@/components/child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> store=<span class="title function_">useCounterStore</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> hel=<span class="title function_">useStore</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ol><li>相对于<code>vuex</code>,<code>pina</code>是用<code>tyepscript</code>完成的，所以，代码提示效果更好。</li><li>在<code>main.js</code>文件中，vuex使用的是导出的store仓库，而pinia是使用实例化对象。</li><li><code>pina</code>弃用了<code>mutation</code>,如果想要完成数据修改，可以直接用action操作就可以了。</li><li><code>pina</code>中不再使用modules，而是直接声明的对应的对象调用即可。</li></ol><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>如果项目比较大，使用单一状态库，项目的状态库就会集中到一个大对象上，显得十分臃肿难以维护。</p><p>所以Vuex就允许我们将其分割成模块（modules），每个模块都拥有自己state，mutations，action等。</p><h5 id="pina"><a href="#pina" class="headerlink" title="pina"></a>pina</h5><p>而Pinia每个状态库本身就是一个模块，<code>pinia</code>没有modules，如果想使用多个store，直接定义多个store传入不同的id即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeA = <span class="title function_">defineStore</span>(<span class="string">&quot;storeA&quot;</span>, &#123;...&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeB = <span class="title function_">defineStore</span>(<span class="string">&quot;storeB&quot;</span>, &#123;...&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> storeC = <span class="title function_">defineStore</span>(<span class="string">&quot;storeB&quot;</span>, &#123;...&#125;);</span><br></pre></td></tr></table></figure><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>一般来说每个module都会新建一个文件，然后再引入这个总的入口index.js中，这里为了方便就写在了一起</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; </span><br><span class="line">    <span class="attr">count</span>:<span class="number">1</span></span><br><span class="line">   &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="params">state, data</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> = data;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">getuser</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//全局state，类似于vue种的data</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">vuexmsg</span>: <span class="string">&quot;hello vuex&quot;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;xiaoyue&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    moduleA,</span><br><span class="line">    moduleB</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用moduleA</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">let</span> vuexStore = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vuexStore.<span class="property">state</span>.<span class="property">moduleA</span>.<span class="property">count</span>) <span class="comment">//1</span></span><br><span class="line">vuexStore.<span class="title function_">commit</span>(<span class="string">&#x27;setCount&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vuexStore.<span class="property">state</span>.<span class="property">moduleA</span>.<span class="property">count</span>) <span class="comment">//2</span></span><br><span class="line">vuexStore.<span class="title function_">dispatch</span>(<span class="string">&#x27;getuser&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一般我们为了防止提交一些mutation或者actions中的方法重名，modules一般会采用命名空间的方式 <strong>namespaced: true</strong> 如moduleA：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="params">state, data</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span> = data;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">getuser</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果我们再调用setCount或者getuser</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vuexStore.<span class="title function_">commit</span>(<span class="string">&#x27;moduleA/setCount&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">vuexStore.<span class="title function_">dispatch</span>(<span class="string">&#x27;moduleA/getuser&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li><code>store</code>仓库中的<code>actions</code>是提交修改方法名，而真正修改是通过<code>mutations</code>，<code>actions</code>就像是秘书，而<code>mutation</code>像是boss,你不能直接找到boss修改属性，而必须通过<code>dispatch</code>派出<code>increment  action</code>的方法,让<code>mutation</code>去修改这个值。</li><li>vuex中的<code>getter</code>是不需要引入computed这个方法的，他会自动一直监听内部的状态是否发生改变。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>pina和vuex的区别，算是vue3的常规面试题之一，我之前虽然大致整理过，但是没有系统性的梳理。</p><p>如今借着别人的文档仔细梳理了一遍，心里对二者的使用心得也是更上一层楼。</p><p>不过，随着vue3的逐渐推广，未来<code>pina</code>一定会在社区中提高占用比。</p><p>如果要是手里有新项目的朋友，最好还是在项目中使用<code>pina</code>，这也是对社区不断发展的一种适应。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://pinia.vuejs.org/zh/introduction.html">简介 | Pinia (vuejs.org)</a></p><p><a href="https://vuex.vuejs.org/zh/guide/">开始 | Vuex (vuejs.org)</a></p><p><a href="https://juejin.cn/post/7397285224379957298?searchId=20240804003348CBA7977A1276A0D3C285">vue3通信大全（三）—— 全局状态管理库pinia,vuex</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解Vue的深度选择器</title>
      <link href="/2024/07/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Vue%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2024/07/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Vue%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本文算是转载文章，本来打算自己写的，但是发现别人写的比自己号多了，还很完成。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>毕竟是转载他人的文章，这里留一下他的微信公众号：前端历险记。</p><p>整理了很多面试相关的文章，很不错。</p><h3 id="深度选择器"><a href="#深度选择器" class="headerlink" title="深度选择器"></a>深度选择器</h3><p>在Vue.js项目中，尤其是在使用组件化开发时，我们时常需要修改组件内部的样式，但Vue的样式封装特性（如<code>&lt;style scoped&gt;</code>）会阻止外部样式直接作用于组件内部。为了应对这一挑战，Vue社区引入了深度选择器（也称为穿透选择器或阴影穿透选择器），让我们能够跨越组件的封装边界，对内部元素进行样式定制。</p><p>本文将详细探讨<code>/deep/</code>、<code>&gt;&gt;&gt;</code>、<code>::v-deep</code>以及Vue 3 Composition API中的<code>v-deep()</code>的区别与使用方法。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>深度选择器允许我们从父组件中穿透到子组件内部，直接修改子组件的样式。这在需要定制第三方UI库组件样式时尤为有用。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="deep"><a href="#deep" class="headerlink" title="/deep/"></a><code>/deep/</code></h5><ul><li><strong>Vue 2.x中的用法</strong>：<code>/deep/</code>是Vue 2.x中用于穿透组件样式封装的一种方式，类似于Sass的<code>/deep/</code>或<code>/deep/</code>的别名<code>::v-deep</code>（但Vue 2.x官方文档中并未直接提及<code>::v-deep</code>）。</li><li><strong>兼容性</strong>：支持CSS预处理器（如Sass、Less）和CSS原生样式。</li><li><strong>注意</strong>：在Vue 3.x中，<code>/deep/</code>不再被官方直接支持，虽然一些构建工具或库可能仍然兼容，但推荐使用<code>::v-deep</code>。</li></ul><h5 id="gt-gt-gt"><a href="#gt-gt-gt" class="headerlink" title="&gt;&gt;&gt;"></a><code>&gt;&gt;&gt;</code></h5><ul><li><strong>CSS原生语法</strong>：<code>&gt;&gt;&gt;</code>是CSS原生中的深度选择器语法，用于穿透样式封装。但在Vue单文件组件（.vue）中，它并不总是被直接支持，因为Vue会将其视为普通CSS选择器的一部分。</li><li><strong>兼容性</strong>：仅在某些特定环境（如Webpack的css-loader配置中）和原生CSS中有效，Vue单文件组件中通常需要特定配置才能使用。</li><li><strong>注意</strong>：在Vue 3.x中，<code>&gt;&gt;&gt;</code>同样不再被推荐使用，应使用<code>::v-deep</code>。</li></ul><h5 id="v-deep"><a href="#v-deep" class="headerlink" title="::v-deep"></a><code>::v-deep</code></h5><ul><li><strong>Vue 3.x中的推荐用法</strong>：<code>::v-deep</code>是Vue 3.x中引入的官方深度选择器，用于替代Vue 2.x中的<code>/deep/</code>和原生CSS中的<code>&gt;&gt;&gt;</code>。</li><li><strong>兼容性</strong>：支持CSS预处理器和CSS原生样式，是Vue 3.x中推荐使用的深度选择器。</li><li><strong>优点</strong>：与Vue 3的其他新特性相兼容，提供了更好的开发体验。</li></ul><p><code>v-deep()</code></p><p>（Vue 3 Composition API）</p><ul><li><p><strong>特殊用法</strong>：在Vue 3的Composition API中，可以通过<code>v-deep()</code>函数在<code>&lt;style&gt;</code>标签中动态应用深度选择器。这不是CSS语法的一部分，而是Vue 3特有的模板编译特性。</p></li><li><p><strong>用法</strong>：通常在<code>&lt;style&gt;</code>标签的<code>scoped</code>属性下，结合<code>v-bind:class</code>或<code>v-bind:style</code>在模板中动态绑定样式时使用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123;&#x27;custom-class&#x27;: true&#125;&quot;&gt;</span><br><span class="line">    &lt;ChildComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// Composition API 逻辑</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.custom-class::v-deep(.child-class) &#123;</span><br><span class="line">  /* 样式规则 */</span><br><span class="line">&#125;</span><br><span class="line">/* 或者使用v-deep()函数（虽然不直接在&lt;style&gt;中，但说明其概念） */</span><br><span class="line">/* 注意：实际中v-deep()不直接用于&lt;style&gt;标签内，而是可能通过其他方式结合Composition API使用 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上面的<code>v-deep()</code>示例主要是为了说明概念，实际上在<code>&lt;style&gt;</code>标签内直接使用<code>v-deep()</code>函数是不支持的。在Composition API中，<code>v-deep()</code>通常与动态样式绑定结合使用，但这更多是在JavaScript层面而非CSS层面。</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="Vue-2-x"><a href="#Vue-2-x" class="headerlink" title="Vue 2.x"></a>Vue 2.x</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span> /deep/ <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>或者使用<code>&gt;&gt;&gt;</code>（需要配置支持）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span> &gt;&gt;&gt; <span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="Vue-3-x"><a href="#Vue-3-x" class="headerlink" title="Vue 3.x"></a>Vue 3.x</h5><p>在Vue 3.x中，推荐使用<code>::v-deep</code>作为深度选择器，因为它既清晰又符合Vue的官方规范。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;ChildComponent /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// Composition API 逻辑</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.parent</span>::v-deep <span class="selector-class">.child-class</span> &#123;</span><br><span class="line">  <span class="comment">/* 样式规则，这些规则将穿透到ChildComponent内部，并应用于具有.child-class类的元素 */</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>.parent::v-deep .child-class</code>选择器将确保<code>.child-class</code>的样式被应用到<code>&lt;ChildComponent /&gt;</code>内部的任何匹配元素上，即使这些元素被<code>&lt;ChildComponent /&gt;</code>的<code>&lt;style scoped&gt;</code>封装所包围。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>关于<code>v-deep()</code>在Composition API中的特殊说明:</p><p>需要注意的是，<code>v-deep()</code>并不是一个在<code>&lt;style&gt;</code>标签内直接使用的CSS选择器或函数。相反，它的概念更多地与Vue 3的Composition API和动态样式绑定相关。</p><p>然而，Vue官方并没有直接提供一个名为<code>v-deep()</code>的函数用于在Composition API中处理样式穿透。</p><p>在Composition API中处理样式穿透时，你通常会继续使用<code>::v-deep</code>选择器，但可能会通过JavaScript逻辑来动态绑定类名或样式，而不是直接使用一个名为<code>v-deep()</code>的函数。</p><p>例如，你可以使用<code>v-bind:class</code>或<code>v-bind:style</code>来根据组件的状态动态地添加或移除样式类。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><ul><li><code>/deep/</code>和<code>&gt;&gt;&gt;</code>在Vue 2.x中用于穿透样式封装，但在Vue 3.x中不再推荐使用。</li><li><code>::v-deep</code>是Vue 3.x中推荐的深度选择器，用于穿透组件的样式封装。</li><li><code>v-deep()</code>并不是Vue官方提供的一个函数，用于在<code>&lt;style&gt;</code>标签内或Composition API中直接处理样式穿透。相反，你应该使用<code>::v-deep</code>选择器，并结合Vue的模板和Composition API功能来实现动态样式绑定。</li></ul><p>通过正确理解和使用这些深度选择器，你可以更有效地在Vue项目中定制组件样式，而无需修改第三方组件的源代码。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来想自己整理一下Vue的深度选择器这块的内容，没想到有人整理的如此详细。</p><p>我对比了官网文档大致看了一下，整理的很好，于是这里就直接收录（化身懒狗）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/erBnyyuka5c6BI7ZbIe8VA">深度选择器探秘：&#x2F;deep&#x2F;、&gt;&gt;&gt;、::v-deep 与 v-deep() 的区别与用法 (qq.com)</a></p><p><a href="https://cn.vuejs.org/api/sfc-css-features.html#deep-selectors">单文件组件 CSS 功能 | Vue.js (vuejs.org)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解前端的图片格式</title>
      <link href="/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
      <url>/2024/07/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本篇博客转载：<a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a>。</p><p>关于图片，算是前端性能优化的一个核心，所以这里就不自己整理，而是尽可能的采用其他大佬整理好的标准答案了。</p><p>文中的内容我根据自己的经验确认了一下，基本没什么问题，可以放心食用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>前端开发中经常和图片打交道，那么熟悉各种图片格式的应用场景以及优劣势对于我们尤为重要。</p><p>基础的那些老古董问题让人心生烦躁，相比那些问题，图片这个问题虽然基础且老旧，但是在前端开发中确实频繁出现。</p><p>时至今日，在性能优化这里，图片的压缩依旧是一个避不开的问题。</p><p>关于网页中对图片的性能优化，后续会单独出一张内容，本次只是简单整理这些图片的格式，做个基础的了解。</p><h3 id="关于压缩"><a href="#关于压缩" class="headerlink" title="关于压缩"></a>关于压缩</h3><ul><li><strong>无损压缩</strong>：对文件的数据存储方式进行优化，采用某种算法表示重复的数据信息，能在保证图片的质量的同时降低图片的尺寸，png是其中的代表，但尺寸相比原图减少不多。<code>可以还原</code></li><li><strong>有损压缩</strong>：在压缩的时候，去除了人眼无法识别的图片细节，图片质量会下降，图片尺寸能得到很大程度的压缩。<code>不可还原</code></li><li><strong>无压缩</strong>：不会对图片进行任何压缩处理，能够精准的呈现原图片，例如：BMP。开发中我们考虑到加载性能问题，几乎不会考虑这种图片</li></ul><h3 id="GIF图"><a href="#GIF图" class="headerlink" title="GIF图"></a>GIF图</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>Gif图采用<code>LZW</code>压缩算法进行编码，采用<code>无损压缩</code>，这意味着图片在压缩后<code>质量不会受损</code>。</li><li>Gif图1987年提出的，距今发展了几十年了，<code>兼容性好</code>。</li><li><code>支持透明度</code>，GIF允许图像中的像素具有不透明和透明属性，这使得它在创建带有透明背景的图像时非常有用。</li><li><code>支持动画</code>，GIF支持简单的动画，可以用来创建循环播放的短动画，这在网页设计和用户界面方面非常有用。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>只能存储8位颜色索引，<code>色彩复杂、细节丰富的图片不适合</code>。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>适合简单的动画或者图标，例如：Logo、Icon、动图。</li><li>上报埋点时采用1 * 1像素的透明Gif图。<ul><li><code>避免跨域</code>，用图片上报而不是采用fetch或ajax去上报，用Image的src不会存在跨域行为并且也会触发请求</li><li><code>兼容性好</code>，所有浏览器都支持Image对象，即便浏览器不支持XMLHttpRequest(例如古董级的IE)，也能进行上报。相比与<code>navigator.sendBeacon</code>兼容性更好。</li><li><code>体积最小</code>，1*1的透明PNG是67字节，而Gif只需要43个字节。同样的性能比PNG图片减少35%的流量。</li><li><code>支持透明</code>，用Gif上报埋点最好是透明的，一是避免影响页面展示，而是可以不用存储颜色索引，减少图片大小。</li><li><code>避免请求取消</code>，ajax请求过程中离开页面会导致请求中断，最终导致上报失败。然而Image的src不会中断。</li></ul></li></ul><h3 id="PNG图"><a href="#PNG图" class="headerlink" title="PNG图"></a>PNG图</h3><p>PNG默认是PNG-24格式</p><h4 id="png-8"><a href="#png-8" class="headerlink" title="png-8"></a>png-8</h4><ul><li>png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。</li><li>非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。</li><li>这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。</li></ul><h4 id="png-24、png-32"><a href="#png-24、png-32" class="headerlink" title="png-24、png-32"></a>png-24、png-32</h4><ul><li>图片质量和bmp差不多，在尺寸是比bmp更小。</li><li>尺寸上比JPG、GIF更大，当然质量更高。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><code>支持透明度</code>：PNG支持透明通道，允许创建带有透明背景的图像。</li><li><code>无损压缩</code>：可以保持图片质量不损失细节。</li><li><code>广泛支持</code>：PNG是一种通用格式，计算机或移动设备都支持。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>复杂、色彩丰富图片尺寸大</li><li>不支持动画</li></ul><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><ul><li>适合图形设计，可以保存文本、线条图案等高质量、透明图像。</li><li>相机设备，适合后期对图片进行处理。</li></ul><h3 id="JPG图"><a href="#JPG图" class="headerlink" title="JPG图"></a>JPG图</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><code>有损压缩</code>:JPG格式具备出色的压缩性能，可以显著的减少图像文件的大小。这使得它在Web上显示一些质量要求不高的图像非常有用，减少加载时间</li><li><code>广泛支持</code>：是一种通用格式，在计算机以及手机设备上都广泛支持。</li><li><code>色彩丰富</code>：JPG支持24位颜色深度，因此可以显示百万种颜色。</li><li><code>可调质量</code>：用户可根据使用场景来调图片质量，较高的图片质量，会导致图片尺寸较大。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>不支持透明</code>：不能够创建带有透明背景的图像，PNG或GIF更适合这种情况。</li><li><code>损失性压缩</code>：JPG是有损压缩，而且一旦压缩无法还原，会丢失一些细节。</li><li><code>不适合带有文本或线条的图片</code>： JPG压缩在处理文本和线条方面不如其他格式好，可能会导致图像出现锯齿或模糊情况。</li><li><code>不适合Icon或者Logo</code>：相对于PNG或GIF图，在尺寸上没有优势</li></ul><h3 id="WEBP图"><a href="#WEBP图" class="headerlink" title="WEBP图"></a>WEBP图</h3><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>关于兼容性查询，想必大家或多或少都看过，这里我就不像他们那样放图浪费资源了。</p><p>想要查询图片的兼容性问题，直接访问：  <a href="https://link.zhihu.com/?target=https://caniuse.com/">Caniuse.com</a>，或者直接点击：<a href="https://caniuse.com/?search=webp">“webp” | Can I use… Support tables for HTML5, CSS3, etc</a>。</p><p>总之，IE11依然不支持Webp，需要额外引入一些JS工具来进行解决，如果你的项目需要兼容IE11，那么就要注意这个问题了。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当Web要求图片加载速度和图片显示质量时，可以适当的降低下图片质量减少图片尺寸来满足场景。</li><li>是用于要求<code>色彩丰富</code>的场景。</li></ul><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>WebP（Web Picture）是一种现代的图像格式，由Google开发，旨在提供高质量的图像压缩和更快的加载速度。WebP<code>支持有损和无损压缩</code>，以及<code>透明度</code>，是一种<code>灵活的图像格式</code>，适用于Web和移动应用程序。</p><p>对于前端来说，该图片格式常用于一种<code>优化网页加载速度</code>的手段之一。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><code>高压缩率</code>：WebP 图像通常具有更小的文件大小，相对于传统格式如JPEG和PNG，可以减少带宽使用和加速页面加载速度</li><li><code>高质量</code>：即使在较高的压缩率下，WebP 图像通常能够保持较高的图像质量，减少了压缩损失。</li><li><code>透明度</code>：WebP支持透明通道，可以用于创建带有透明背景的图像，类似于PNG格式。</li><li><code>动画</code>：WebP还支持动画图像，允许创建小型、高质量的动画。</li><li><code>广泛支持</code>：大多数浏览器都已经支持，但是目前低版本的Safri以及IE还不支持。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li><code>兼容性</code>：考虑到目前还不能完全放弃IE以及旧版本Safri，所以还不能完全切到该图片格式。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>WebP 格式适用于网页开发，特别是那些需要快速加载的网站和移动应用程序。</li><li>它适合用于图像库、图标、按钮、背景图像、动画以及需要高质量和小文件大小的图像。</li><li>WebP 的无损压缩特性使它适用于医学图像、卫星图像、地图和其他需要高质量和完整性的图像应用。</li></ul><h4 id="开发兼容"><a href="#开发兼容" class="headerlink" title="开发兼容"></a>开发兼容</h4><p>考虑到Webp格式还存在兼容性问题，开发中如何应用Webp图片格式？</p><ul><li>如果图片资源存储在服务端，可以设计一套通用方案，在<strong>服务端根据Accept请求头判断是否支持Webp格式，如果支持返回Webp格式，否则返回PNG格式</strong>。</li><li>如果你无法说服后端去实现上述方案还想采用Webp图片优化页面加载，可以考虑维护两个格式的图片，然后使用<strong>picture标签</strong>去实现</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> srcset=<span class="string">&quot;flower.webp&quot;</span>&gt;</span><br><span class="line">  &lt;source <span class="attr">type</span>=<span class="string">&quot;image/jpeg&quot;</span> srcset=<span class="string">&quot;flower.jpg&quot;</span>&gt;</span><br><span class="line">  &lt;img <span class="attr">src</span>=<span class="string">&quot;flower.jpg&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>整理图片格式这个面试题相对来说我倒不是那么抗拒，这个问题虽然基础但是在开发中，如果专注性能优化的朋友可能会很熟悉。</p><p>早年我在优化小程序的时候，曾经在处理图片问题上废了不少功夫，那时候对图片相关的知识了解了很多，但是不成体系。</p><p>如今花了些时间整理了一下，心理倒也颇为感慨。</p><p>只是时间不够，不然我大概率还会整理一下矢量图和像素图的区别，还有一些性能优化的点。</p><p>后续在整理性能优化的相关文章的时候，我会着重整理相关内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7298927261209329690?searchId=20240721180134F9ABCCEE91C8972098E5">聊聊几种常见的图片格式Webp、GIF、PNG、JPG</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解一些HTML的知识</title>
      <link href="/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/07/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9BHTML%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>从掘金的一篇文章中摘下来的部分问题，这种级别的面试题，问问三年前的新人还好，问现在的新人多少有点过时了。</p><p>而问我这种前端老登，如果不是为了找工作，放在以前我真会喷他。</p><p>这里没什么好说的，谁叫现在是为了找工作呢，统一整理出来看看吧，我实在想不懂问这些阴间问题的到底是哪些面试官想出来的，这些面试题显得你很会搜集面试题吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇基本上都是HTML5的冷门问题，HTML的知识，真的。。。我都麻了，在掘金上刷到还有面试官来问这种问题？</p><p>呵呵，放在两年前，问这种问题只会让我感觉到这个面试官水平不行。</p><p>这些问题中不乏一些偏到犄角旮旯的垃圾问题，有些甚至是我这个前端老登都感觉真他妈离谱，真想把一些问题拍在面试官的脸上。</p><p>你这些狗日的问题，你要不查文档，你自己能答的出来吗？你到底是从哪个题库中扒出来的？你弄这些东西到底对你自己的项目有什么促进作用？这些基础问题，要是你自己不花点时间准备，你到底能回答出来多少？</p><p>这些问题对业务上的促进作用是什么？你问这些问题你要不给个为什么，我真他吗的。。。。算了，人在屋檐下。</p><p>罢了，就当是听孔乙己说茴香豆的四种写法了，真你妈的离谱。</p><h3 id="DOCUTYPE作用"><a href="#DOCUTYPE作用" class="headerlink" title="DOCUTYPE作用"></a>DOCUTYPE作用</h3><p>DOCTYPE（‌文档类型声明）‌是HTML文档中的一个重要组成部分，‌它位于HTML文档的第一行，‌位于<code>&lt;html&gt;</code>标签之前。‌</p><p>这个声明用于指定当前文档所采用的HTML版本。‌</p><p>DOCTYPE不是HTML标签，‌而是一个指令，‌告诉浏览器当前页面采用了哪个HTML版本，‌以便浏览器按照相应版本的规范来解析和渲染页面。‌</p><p><code>&lt;!DOCTYPE html&gt;</code>声明的主要作用是规范浏览器行为，‌确保HTML文档的正确解析和渲染。</p><p>这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat。</p><ul><li>document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面、（默认）。</li><li>document.compatMode： CSS1Compat：标准模式、浏览器使用W3C标准解析渲染页面。</li></ul><p>如果你的页面添加了<code>&lt;!DOCTYPE html&gt;</code>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。</p><p>这就是<code>&lt;!DOCTYPE html&gt;</code>的作用。</p><p>如果你不加，浏览器如果按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式、很可能出现兼容问题。</p><p>这个问题基本上是最初那一代的前端开发者才会知道的问题，因为最初浏览器还没有定下W3C标准，各家浏览器都按照自家的标准做事，所以那时候才有了那么多恶心的兼容问题。</p><p>在W3C标准出现之前，彼时不同浏览器的内核是不统一，割裂极度严重，IE浏览器，火狐，还有谷歌，三家浏览器各搞各的，直到后续各家浏览器出来统一制定了W3C规则之后，统一进行页面的解析。</p><p>当然，在那之后，IE浏览器依旧不老实，还是坚持要搞自己的一些小动作，所以在18年~22年左右，依然有很多政府项目要求兼容IE。</p><p>不过随着时代的发展，这种项目估计除了银行之类的ToG的政府项目才会关心，实际上都不在关注这种问题了，毕竟现在都在使用W3C标准，而坚持自己个性标准的IE浏览器，在IE11之后就进了历史垃圾堆。</p><p>在这之后，微软也宣布推出了Edge，摆脱了原有的历史包袱，使用W3C标准。</p><p>所以，到现在<code>&lt;!DOCTYPE html&gt;</code>成了前端标准的兼容行为，这个操作太过基石，以至于没什么人会去关注。</p><p>这里稍微总结一下<code>&lt;!DOCTYPE html&gt;</code>的作用</p><ul><li><strong>规范浏览器行为</strong>：‌通过指定正确的DOCTYPE，‌可以确保浏览器按照相应版本的HTML规范来解析和渲染页面，‌从而避免出现兼容性问题。‌</li><li><strong>避免混杂模式</strong>：‌早期的HTML标准中，‌如果没有提供DOCTYPE声明或者提供了错误的声明，‌浏览器会进入混杂模式（‌Quirks Mode）‌，‌这可能导致页面显示不一致或出现兼容性问题。‌通过明确指定正确的DOCTYPE，‌可以避免进入混杂模式。‌</li><li><strong>支持新特性</strong>：‌随着HTML标准的不断更新和演进，‌新版本中引入了许多新特性和语法规则。‌使用适当的DOCTYPE声明，‌可以告诉浏览器当前页面采用了哪个HTML版本，‌并使其能够理解并支持该版本中新增加的功能和语法。‌</li><li><strong>提示验证工具</strong>：‌DOCTYPE声明还对验证工具起到提示作用。‌验证工具（‌如W3C的HTML验证器）‌可以根据DOCTYPE声明来判断文档是否符合相应版本的HTML规范，‌从而帮助开发者发现和修复代码中的错误。‌</li></ul><h3 id="META的作用"><a href="#META的作用" class="headerlink" title="META的作用"></a>META的作用</h3><p>这里放一段W3C的示例，结合实例稍微说一下作用，实际开发过程中，最多可能常用到控制缩放。</p><p>至于常规keywords，description，基本上都是SEO常用到的配置，而后台管理类项目，平常基本上没人在乎这个的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;免费的 Web 教程&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, JavaScript&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Bill Gates&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>meta 元素可以使用名&#x2F;值对定义元数据，为此需要用到其 name 和 content 属性。</p><table><thead><tr><th>name</th><th>content</th><th>描述</th></tr></thead><tbody><tr><td>charset</td><td>UTF-8</td><td>声明当前页面使用的字符集</td></tr><tr><td>keywords</td><td>HTML, CSS, JavaScript</td><td>搜索引擎关键字</td></tr><tr><td>description</td><td>Free Web tutorials for HTML and CSS</td><td>网页描述</td></tr><tr><td>author</td><td>John Doe</td><td>页面作者</td></tr><tr><td>viewport</td><td>width&#x3D;device-width, initial-scale&#x3D;1.0</td><td>控制设备上缩放效果</td></tr><tr><td>http-equiv&#x3D;”refresh”</td><td>30</td><td>每 30 秒刷新一次文档</td></tr></tbody></table><p>这里大概列举了一下，至于详情，这里就不列举了。</p><p>详情这里实在不想细说，有兴趣可以自行去看<a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a>。</p><h3 id="HTML5语义化"><a href="#HTML5语义化" class="headerlink" title="HTML5语义化"></a>HTML5语义化</h3><blockquote><p>语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。</p><p>不仅对自己来说，容易阅读，书写。</p><p>别人，甚至是网络爬虫机器看你的代码和结构也容易理解。</p></blockquote><p><strong>语义化简单讲就是根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</strong></p><p>在解释这个概念之前，应该先解释下“结构-表现-行为”。</p><p>如果说解耦合是代码的高境界，那么“结构-表现-行为”的原则就是前台的标杆。</p><p>前端代码是有HTML + CSS + JS来实现的。他们对应的就是负责“结构-表现-行为”。</p><p>不过，现在兴起的前端技术大多要求是用来处理后台，这时候把很多以前的PC应用搬到了浏览器上。</p><p>而应用就不怎么在乎浏览器器的语义化了，秉承着能用就行的原则，大多数后台应用类的网站的语义化要求被淡化，大多数都是div一把梭。</p><p>除了页面SEO，或者是静态新闻网站之外，大多数网页开发都不再在乎应用，感兴趣的可以看看这篇博客园的博客：<a href="https://www.cnblogs.com/iamspecialone/p/11178486.html">Html的语义化</a>。</p><h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p>2024年了，还是那些个新特性，这些东西没有什么可聊的，从H5标准出来到现在，作为浏览器的基石，这些规则基本都没有什么改变。</p><p>后续会稍微整理这些新特性的详情玩法，每个特性都很基础，但是深挖之后，都是深坑，我们这里就简单的了解一下概念，应对面试就可以。</p><ol><li>语义化标签，（hrader、footer等），使得页面的内容结构化，见名知义</li><li>增强型表单，拥有多个新的表单input输入类型，可提供更好的输入控制和验证</li><li>video和audio元素，提供了播放视频和音频文件的标准方法</li><li>canvas绘图， 画布功能，通过 JavaScript 来绘制 2D 图形。</li><li>svg绘图，SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>地理定位，Geolocation（地理定位）用于定位用户的位置</li><li>拖放API，在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放</li><li>web worker，web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。</li><li>web storage，使用HTML5可以在本地存储用户的浏览数据，cookie，local storage，sessionStorage。</li><li>WebSocket，WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</li></ol><p>以上十个新特性在现代开发中衍生出了很多内容，譬如websocket的聊天室，基于canvas画布实现的流程图和很多酷炫的图表。</p><p>哪怕是最基础的语义化形成的SEO，还有表单的提交增强，都是很强力的增强，这里后续我们会基于每个特性进行深入的了解。</p><h3 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h3><p>二者的区别，这里要从请求资源类型，解析方式，权重角度来分析。</p><h4 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h4><h5 id="href（Hypertext-Reference）"><a href="#href（Hypertext-Reference）" class="headerlink" title="href（Hypertext Reference）"></a>href（Hypertext Reference）</h5><p>作用指定超链接目标的URL，主要用来建立当前元素和href引用元素的链接关系。</p><p>href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。</p><p>常用link，a标签。</p><h5 id="Src（Source）"><a href="#Src（Source）" class="headerlink" title="Src（Source）"></a>Src（Source）</h5><p>作用是指向物件的来源地址，主要指向需下载的资源。</p><p>src将其指向的资源下载并应用到当前document中，并且替换当前元素。</p><p>常用标签script，img，iframe等。</p><h4 id="浏览器解析方式和权重的不同"><a href="#浏览器解析方式和权重的不同" class="headerlink" title="浏览器解析方式和权重的不同"></a>浏览器解析方式和权重的不同</h4><p>用 href时，加载到对应位置的时，不会暂停其他资源的下载或行为。</p><ul><li>权重思想： href链接的的是当前页面的一部分附属资源。</li><li>注意点：所以CSS样式可以放在html结构的头部优先加载（因为不影响页面的核心加载，只是HTML标签的对应样式表）</li></ul><p>用src时候，会暂停其他资源的下载，直到当前资源加载，编译，执行完成了，并且把当前资源替换到src引用处了。</p><ul><li>权重思想： src加载的是当前页面的一部分。</li><li>注意点：这就是为何js脚本一般回放到document底部加载而不是头部。</li></ul><h3 id="BFC-及其应用"><a href="#BFC-及其应用" class="headerlink" title="BFC 及其应用"></a><strong>BFC 及其应用</strong></h3><p>说了半天，这个算是一个比较正常的面试题，值得重点看看。</p><p>BFC(Blcok formatting context) 直译为“块级格式化上下文”。</p><p>他是一个独立的渲染区域，只有块级元素参与，它规定了内部块级元素的布局，并且与这个区域外部毫不相关，外部元素也不会影响这个渲染区域的元素。</p><blockquote><p>简单说：BFC 就是页面上的一个隔离的独立渲染区域，区域里边的子元素不会影响到外面的元素。外边的元素也不会影响到区域里面的子元素。</p></blockquote><p>以下是一些常见的创建 BFC 的方法：</p><ol><li>浮动元素：将一个元素设置为浮动（<code>float: left</code> 或 <code>float: right</code>）会创建一个 BFC。</li><li>绝对定位元素：将一个元素设置为绝对定位（<code>position: absolute</code>）会创建一个 BFC。</li><li>固定定位元素：将一个元素设置为固定定位（<code>position: fixed</code>）会创建一个 BFC。</li><li>具有 <code>overflow</code> 属性的元素：将一个元素的 <code>overflow</code> 属性设置为非 <code>visible</code> 的值（例如 <code>overflow: hidden</code>、<code>overflow: auto</code> 或 <code>overflow: scroll</code>）会创建一个 BFC。</li><li>具有 <code>display</code> 属性为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code> 或 <code>flex</code> 的元素：这些元素会自动创建一个 BFC。</li><li>根元素（<code>html</code> 元素）：根元素始终是一个 BFC。</li></ol><p><strong>BFC 可以解决那些问题</strong></p><ol><li>避免垂直方向的<code>margin</code>合并。问题：垂直方向上的，两个元素<code>margin</code>相遇，两元素间的距离并不等于两个<code>margin</code>之和。而是等于最大的<code>margin</code>。小的<code>margin</code>会被大的<code>margin</code>吞并。</li><li>清除浮动元素的影响。问题：如果父元素包含一个浮动元素，那么其他元素可能会受到浮动元素的影响，导致布局混乱。但是给父元素变成BFC，浮动元素对其他元素的布局不再产生影响。</li><li>防止高度塌陷。问题：父元素不写高度时，子元素浮动后，导致父元素会发生高度塌陷（造成父元素高度为0）。但是将父元素变成BFC，就不会造成高度塌陷，最简单的方法是，给父元素设置<code>overflow: hidden</code>属性。</li><li>垂直布局。问题：父元素包含多个子元素，并且这些子元素的高度不同，那么在没有创建 BFC 的情况下，这些子元素可能会在垂直方向上重叠。但是将父元素变成BFC，子元素在垂直方向上就能正确排列。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>真的是。。。越整理越感觉离谱，我都感觉自己人生中浪费了数个小时在整理这些冷门问题到底在干嘛。</p><p>实话实说，这些老古董问题，在我眼里除了AI应该知道之外，正常的前端开发都不需要知道，最多就大概了解一下就行，哪怕是专门拿来问都有点显得掉架子，正经的老开发很难去了解这些问题。</p><p>我实在想不通为什么有很多傻逼面试官会问到这种老古董的冷僻问题，他自己平时难道用得到吗？难道这些人平时自己就能用得到？就是为了考察所谓的基础？这些基础到底有什么用？</p><p>我不说别的，DOCUTYPE的作用这个，在这些年里真的会有人遇到这方面的问题吗？兼容IE11? 除非是银行项目，到底是哪些人还他妈的固执的在用IE11?</p><p>很多政府项目都不在要求兼容IE11了，偏偏这些人还在要求，这是否有点太离谱了？</p><p>只能说，内卷化的极端时间里，现在找个工作太难，导致这种不知道从哪抠出来的冷僻问题居然成了热门的面试题，真他妈的傻逼。</p><p>除了外行和新手，我真的想不懂这些问题对开发的意义，哪怕多问问项目实现的难点我都不会对这些面试官有意见。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7280007125999681588">我在公司是怎么做面试官的？</a></p><p><a href="https://www.cnblogs.com/tianmiaogongzuoshi/p/16341179.html">src和href的区别</a></p><p><a href="https://www.w3school.com.cn/tags/tag_meta.asp">HTML  标签 _meta(w3school.com.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue3相对于vue2的变化</title>
      <link href="/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2024/07/18/%E6%B5%85%E6%9E%90vue3%E7%9B%B8%E5%AF%B9%E4%BA%8Evue2%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>vue3与vue2的区别算是较为火热的面试题之一了，之前早就想整理一遍了，但是奈何没有太多时间去关注。</p><p>在两者的深度上，我个人一直觉得自己了解的较少，了解的越深就越不敢说自己深入了解。</p><p>经过两个月左右的整理，我应该可以勉强说自己算是略懂了。</p><p>这里放上自己的拙见，我尽可能的确认了自己理解的准确性，不过我仍然感觉自己似乎做的不到位，这就当是抛砖引玉，希望大家在评论区多多拍砖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这段时间看了很多相关的文档，自己也翻了很多遍<a href="https://cn.vuejs.org/">vue3的官网文档</a>，同时自己也在项目中重新按照自己的经验重新用了一遍Vue3的新写法。</p><p>在一段时间的使用之后，个人认为，Vue3与Vue2的区别，要从使用者和开发者的角度来看。</p><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><p>使用者，就是我们平时写业务的这些普通开发者。</p><p>大多数情况下，使用者不负责源码开发，仅仅只要知道有个新特性，然后按照新特性使用就行了。</p><p>就像是伐木工学会了用A型号的电锯，这时候电锯做了个升级，加入了一些特性，而我们只要知道如何用好这些新特性。</p><p>相对于Vue2，我认为Vue3的新特性如下。</p><ul><li>取消了根元素，每个组件不必再必须嵌套一个根元素标签了</li><li>响应式用法的改变，用reactive和ref取代了之前的data声明的变量的方式</li><li>新增了组合式写法，相对于传统的选项式更灵活，可读性更高，这种写法也支持</li><li>父子组件传参方式发生了些许改变，不过用法大致和Vue2的思路没差，<strong>defineProps</strong>，<strong>defineEmits</strong>，<strong>defineExpose</strong>这三个稍微看看用法就能很快上手</li><li>生命周期的写法和名称有些许改变，新增了setup，但是大致流程没有变化</li><li>v-if和v-for的优先级调整，以v-if的优先级更高，如果二者要在同一标签内使用，将v-for放在外边，不然v-if会直接覆盖掉v-for的效果</li><li>修饰符发生了一些改变，取消了.native，不过总的来说没有太大变化</li></ul><p>总之，Vue3相对于Vue2，虽然很多人说是有些破坏式更新，写法发生了巨大的改变，这是一次失败的更新。</p><p>但从使用者的角度来讲，我个人认为，这次更新并不算是一次破坏式更新，至少大部分写法和习惯都是保留好了。</p><p>这里浅谈一下争论最大的选项式与组合式。</p><h4 id="选项式？"><a href="#选项式？" class="headerlink" title="选项式？"></a>选项式？</h4><p>选项式就是V2的写法，选项式上手简单，且不容易出岔子，有这个基础架子的保证，新手只要不是特别离谱，写出来的代码至少具有一定的可读性。</p><p>但这种写法在代码量上去之后，可读性就会变得差。</p><p>主要原因就是变量和函数分开，不同块的变量混合在一起，每次翻阅代码的时候就要上下翻看，要么就要拆开面板去分开看，很麻烦。</p><p>而且，所有的变量都是在data中申明，全部指向了this。</p><p>指向this固然好用，但是随着后续模块的增多，这些this声明出来的变量会让人不知道这到底是哪个模块的内容，容易造成混乱。</p><p>而组合式确实解决了这个痛点。</p><h4 id="组合式？"><a href="#组合式？" class="headerlink" title="组合式？"></a>组合式？</h4><p>组合式写法其实就是回归了传统的script标签写法，声明了变量，然后按照传统的JS写法继续做就可以。</p><p>相对于V2的写法，V3的写法太过自由，可能很多人第一时间拿到手之后会有些不知所措。</p><p>不过经过几个项目铺垫之后，大概就能明白组合式的优势了。</p><p>组合式相对于选项式，可以更模块化的拆业务，通过<code>reactive</code>包裹不同的代码块之后，我们能够更有逻辑的去切割页面上的逻辑块。</p><p>在完成页面的代码块的切分之后，不同变量不会再全部指到this了，这样让我们更清楚这些变量是负责哪个代码块的。</p><p>这就是组合式，更模块化，更容易排查，更好的代码可读性。</p><h4 id="hooks？minxin？"><a href="#hooks？minxin？" class="headerlink" title="hooks？minxin？"></a>hooks？minxin？</h4><p>随着代码量的增加，还可以将多个页面的重复业务块拆出来，放入hooks中供全局使用（Vue2中也有minxin），但是二者实际使用后，就能明白二者的不同。</p><ul><li>hooks像是以前抽离出来的公用方法，抽离的是逻辑，我们将一段公用的逻辑方法封入Hooks中，这里可以封入一定的业务逻辑</li><li>minxin更像是抽离出一部分公用模板，抽离的是模板，我们将一些写烦了的公用方法封入minxin中，省的每次都写。</li></ul><p>当然，我这个说法还是有点怪，实际开发中，这二者的用法硬要用的话，可混为一谈的。</p><p>不过，我个人依旧推荐大家用hooks去封装逻辑，不要用来封装模板。</p><h3 id="开发者"><a href="#开发者" class="headerlink" title="开发者"></a>开发者</h3><p>开发者，就是指Vue框架的源码开发者。</p><p>源码开发者，大家平时其实很少接触到，不过部分使用者在常规业务开发到极度深入的时候，肯定会去了解相关内容。</p><p>尽管我们不去开发，但是用久了，肯定多少会要了解一些的。</p><p>相对于Vue2，Vue3在源码层面的特性变动如下</p><ul><li>整个框架用TS重写，对Vue3对TS有了更好的支持</li><li>重写了响应式的数据劫持方式，用proxy取代了vue2的Object.defineProperty()</li><li>重写了虚拟Dom的实现，编译模板优化，更高效的组件初始化效果</li><li>diff算法重写，参考<a href="https://segmentfault.com/a/1190000042586883">前端 - Vue2、Vue3的diff对比 - 哈啰技术 - SegmentFault 思否</a></li></ul><p>通过这些，开发者做到让Vue3具有了哪些优势呢？</p><h4 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h4><ul><li>Vue 3 的代码库已经全面采用 TypeScript 重写，提供了更好的类型推断和类型提示。</li><li>提供了更多的内置类型声明，使得开发时更容易发现代码错误和调试。</li></ul><h4 id="更好的响应式系统"><a href="#更好的响应式系统" class="headerlink" title="更好的响应式系统"></a>更好的响应式系统</h4><ul><li>Vue 3 使用了 Proxy 来重写响应式系统，相比 Vue 2 的 Object.defineProperty，更加直观和强大。</li><li>在 Vue 3 中，可以在更深的层次上追踪响应式变量的变化，使得开发者能够更准确地监听数据变化。</li></ul><h4 id="更灵活的组合式-API"><a href="#更灵活的组合式-API" class="headerlink" title="更灵活的组合式 API"></a>更灵活的组合式 API</h4><ul><li>Vue 3 引入了组合式 API，使得组件的逻辑可以更好地组织和复用。</li><li>组合式 API 提供了更直观、更灵活的方式来组织组件代码，使得代码更易读、易维护。</li></ul><h4 id="更快的渲染性能"><a href="#更快的渲染性能" class="headerlink" title="更快的渲染性能"></a>更快的渲染性能</h4><ul><li>Vue3 相比 Vue2 来说，Vue3 重写了虚拟 <code>Dom</code> 实现，编译模板的优化，更高效的组件初始化。</li></ul><h4 id="更小的体积"><a href="#更小的体积" class="headerlink" title="更小的体积"></a>更小的体积</h4><ul><li>Vue 3 的运行时核心相比 Vue 2 更小，这意味着更小的打包体积，减少了前端加载时间。</li><li>Tree-shaking 支持：Vue 3 代码更容易被 Tree-shaking 优化，因此可以更好地剔除不需要的代码。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>个人虽然是个vue老登了，但是在很多时候都是在自我学习，所以我整理的这些内容实在是过于浅薄，并未深入，让大家见笑了。</p><p>关于Vue2与Vue3的选择，我个人并不排斥任何一种选择，这需要我们根据实际情况来进行选择，很多老项目如果能不动，最好还是别动。</p><p>当然，从长远的角度来讲，我还是期望用Vue3的，毕竟Vue2已经停止了更新，而Vue3继承了2的特性，并且还在持续更新，显然Vue3更有潜力。</p><p>而且，社区内似乎有不少人开始追随Vue3的更新，同时也出现了<a href="https://vueuse.org/">VueUse</a>这种社区好物。</p><p>长远的来看，显然是Vue3的社区会更壮大。</p><p>这种不错的未来前景，是最值得追逐技术的理由之一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340676808436563987?searchId=20240718123318E0F013B86F459BBDBB95">vue3和vue2的区别，你知道多少 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7030992475271495711">vue3保姆级教程</a></p><p><a href="https://segmentfault.com/a/1190000042586883">前端 - Vue2、Vue3的diff对比 - 哈啰技术 - SegmentFault 思否</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue2与3的数据劫持区别</title>
      <link href="/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/07/14/%E6%B5%85%E6%9E%90vue2%E4%B8%8E3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>两年前在vue3在社区兴起之时，很多社区弄潮儿就在分析2与3源码区别，那时候很多人都以为是个新时代会到来。</p><p>可是两年过去了，vue3的新时代依旧在缓慢迭代。</p><p>对于大部分业务流选手，大家都不关心源码，大家更期望Vue3的相对于Vue2在工程上的亮点在哪，到底能否更爽快的开发，更好更稳定的替换当前工程。</p><p>除非是面试，这种源码级的改动几乎是一个必然的面试题。</p><p>很不巧，我现在刚好需要处理面试，于是这里整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文默认使用者都用过Vue2和Vue3的，如果您没有看过Vue2的响应式原理，推荐您最好先去了解Vue2的响应式原理，因为本文会直接略过很多内容，如果不清楚相关知识，看起来可能体验会很差。</p><p>好了，接下来就开始对V2与V3的数据劫持进行区分。</p><p>在正式进入对二者区别的分析前，我们需要先简单了解一下，什么是数据劫持。</p><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>在没有进入MVVM框架的时代时候，我们要操作DOM中的数据，就需要自己手动封装一套方法，获取对应节点的DOM，然后修改。</p><p>因为这样很麻烦，才诞生了前端时代的MVVM的各种响应式实现方式。</p><p>这里不展开细说其他框架的响应式原理，单说Vue这块的响应式，在实现响应式的第一步，就是要进行数据劫持。</p><p><strong>数据劫持是Vue数据响应式的核心和基础，通过添加代理来给属性的变化添加额外的操作的方式</strong></p><h4 id="Vue2方式"><a href="#Vue2方式" class="headerlink" title="Vue2方式"></a>Vue2方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Obejct</span>.<span class="title function_">defineProperty</span>(obj,prop,descriptor)</span><br></pre></td></tr></table></figure><p>这个方法可以精确修改对象的属性，decriptor有四个参数，分别是</p><ul><li>configurable：数据是否可删除，可配置，</li><li>enumerable：属性是否可枚举，</li><li>get:一个给属性提供 getter 的方法，如果没有 getter 则为 undefined，</li><li>set:一个给属性提供 setter 的方法，如果没有 setter 则为 undefined object.defineProperty()通过getter&#x2F;setter属性对数据进行监听，getter监听访问数据，setter监听修改数据，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取值&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置值&#x27;</span>)</span><br><span class="line">        value = qqq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">o.<span class="property">a</span> = <span class="string">&#x27;sss&#x27;</span> </span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>)</span><br><span class="line"><span class="comment">// 获取值</span></span><br></pre></td></tr></table></figure><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul><li><p><strong>只有getter&#x2F;setter属性无法监听属性的修改删除</strong>，在Vue 2.x赋值对象时，需要对对象进行初始化，否则需要使用$Set()进行设置</p></li><li><p>无法监听组数的数据变化，数组的长度发生变化的时候无法监听，这也是为什么我们直接根据下标改动数组内容时候会失效，vue2通过处理数组扩展方法（push、pop、shift、unshift、splice、sort、reverse这7个方法），通过这些方法，我们依然是可以对数组进行响应式的数组操作的。</p><p>这个核心原因就是在于遍历数组消耗的性能太大，Vue2如果要做数组的响应式，按照原有的实现方式实在是买椟还珠了。针对这点，Vue2也给出来了一些解决方案，比如$Set()方法解决数组内的数据改变无响应的问题</p></li><li><p>无法拦截对象属性的多层嵌套。vue 2.x表现，watch对多层对象的监听中会失效，也需要$forceupdate()来更新视图。</p></li></ul><h4 id="Vue3方式"><a href="#Vue3方式" class="headerlink" title="Vue3方式"></a>Vue3方式</h4><p>为了解决上面的缺陷，Vue3使用了ES6的proxy方法，直接对源数据进行代理操作。</p><p>通过建立一个新的实例对象，才操作原有对象，并且提供13种监听操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target,thisArg,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">construct</span>(target,args)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,name,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(target,name,value,receiver)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target,name,desc)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(target,name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, name)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(target)</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(target, prototype)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&quot;获取数组元素&quot; + key);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置数组&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1. 改变已存在索引的数据</span></span><br><span class="line">obj[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment">// result: 设置数组</span></span><br><span class="line"><span class="comment">// 2. push,unshift添加数据</span></span><br><span class="line">obj.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// result: 设置数组 * 2 (索引和length属性都会触发setter)</span></span><br><span class="line"><span class="comment">// // 3. 直接通过索引添加数组</span></span><br><span class="line">obj[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment">// result: 设置数组 * 2</span></span><br><span class="line"><span class="comment">// // 4. 删除数组元素</span></span><br><span class="line">obj.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>显然Proxy完美的解决了数组的监听检测问题，针对数组添加数据，删除数据的不同方法，代理都能很好的拦截处理。</p><p>另外Proxy也很好的解决了深层次嵌套对象的问题。</p><p>这里我们综合整理一下<code>proxy</code>的优势</p><ol><li><strong>性能提升</strong>：Proxy API 比 defineProperty API 在许多情况下具有更好的性能。Vue2使用 Object.defineProperty 方法来拦截对象属性的访问和修改，但它需要遍历每个属性进行拦截。而 Proxy API 允许拦截整个对象，可以更高效地捕获对对象的访问和修改。</li><li><strong>更全面的拦截能力</strong>：Proxy API 提供了更多的拦截方法，比 defineProperty API 更灵活、丰富。它支持拦截目标的各种操作，包括读取、设置、删除、枚举等，甚至还可以拦截函数调用和构造函数实例化。</li><li><strong>更好的数组变化检测</strong>：Vue 3.0 使用 Proxy API 改善了数组的变化检测机制。Proxy 可以直接拦截数组的索引访问和修改，使得对数组的变化更容易被监听到，从而提供了更可靠的响应式行为。</li><li><strong>更易于处理嵌套对象</strong>：Proxy API 能够递归地拦截对象的嵌套属性，而 defineProperty 无法自动递归处理嵌套对象。这使得在 Vue 3.0 中处理嵌套对象更加简单和方便。</li><li><strong>更好的错误提示</strong>：相比于 defineProperty，Proxy API 提供了更好的错误追踪和调试信息。当使用 Proxy API 时，如果访问或修改了一个不存在的属性，会直接抛出错误，从而更容易发现和修复问题。</li></ol><p>不过，如果硬要挑刺的话，总是能找到缺点的。</p><p>比如<code>proxy</code>属性毕竟是ES6的特性，如果有人要兼容低版本的IE10之类的说法，可能vue3这套响应式就不是很能玩得转了。</p><p>但是大多情况下，在现代浏览器环境中，V3的<code>proxy</code>代理确实是比V2的<code>Object.defineProperty()</code>实现方式更还好用</p><h5 id="reactive与ref"><a href="#reactive与ref" class="headerlink" title="reactive与ref"></a>reactive与ref</h5><p>我们在日常的工作中，估计已经非常熟悉二者的使用了，相对于Vue2中用data()声明之后即可简单实现响应式，Vue3提供的这两种方式对于Vue2的习惯用户来说简直是一种致命缺陷。</p><p>关于ref和reactive的使用方式优化，在前文<a href="https://crazystudent13.cn/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB/">浅析ref与reactvie的区别</a>一文中，我给出了一些相对好用的使用方案，至少能让开发者在开发项目的过程中有更好的开发体验。</p><p>不过，今天这次不再是简单的讲二者的使用，而是更深层的剖析他们的实现方式。</p><h5 id="reactive的缺陷"><a href="#reactive的缺陷" class="headerlink" title="reactive的缺陷"></a>reactive的缺陷</h5><ol><li>reactive只能用来处理引用类数据的响应式，不能处理基础类型的数据，这个是官方自己这么规定的且<code>proxy</code>也只适合代理对象罢了。</li><li>reactive声明的数据，解构赋值会导致响应式失效</li><li>引用式数据直接赋值会导致响应式失效，比如用reactive代理数组，代理对象，如果你直接赋值一个新数组或者新对象，都会导致响应式失效</li></ol><p>以上缺陷几乎是我们日常开发中经常遇到的问题，稍微有点经验的开发老手大概都能猜出来什么原因。</p><p>很简单，深拷贝改变了引用类型数据的位置，而引用类的数据都是要根据存储位置的指针去找源数据的存储地址的。</p><p>而引用类型数据直接赋值，会直接改变指存储地址，这个重新赋值的过程丢失了响应式自然不奇怪。</p><p>解构赋值也是同理，我们用解构赋值处理引用类型数据，也会改变数据存储位置，原理同上，所以这两种情况都会导致响应式失效。</p><h5 id="ref的本质"><a href="#ref的本质" class="headerlink" title="ref的本质"></a>ref的本质</h5><p>很多开发者在开发中都非常喜欢ref一把梭，虽然这都需要.value&#96;这个小尾巴去获取实际内容。</p><p>相对于reactive，ref不需要考虑数据类型，无论是引用类型和基础类型的数据都能用ref代理。</p><p>但，ref的本质实际上就是reactive。</p><p>很多新人朋友可能在这个过程可能会有点犯迷，为什么ref的本质是reactive？</p><p>ref不是比reactive多了一个基础数据类型代理吗？</p><p>既然ref既能处理基础数据类型，又能处理引用数据类型，为什么不用ref一把梭？</p><p>这里我们放一段在vue工程中随手声明的测试变量，看看这个输出结果吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="title function_">ref</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是基础类型test的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">_value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testObj  = <span class="title function_">ref</span>(&#123; <span class="attr">a</span>: test &#125;)</span><br><span class="line"><span class="comment">// 以下是引用类型数据testObj的输出结果：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">dep</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">__v_isShallow</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">_rawValue</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">_value</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>) &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;</span><br><span class="line">    <span class="attr">value</span>: (...)</span><br><span class="line">    [[<span class="title class_">Prototype</span>]]: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个复杂对象会有__v_isRef，__v_isShallow等属性，引用类型。</p><p>而我们将reactive包裹的对象输出，就没有该属性。</p><p>再结合上述示例的输出结果我们就能明白，<code>ref</code>实际上在处理基础数据的时，就是用普通的处理，将基础类型数据转换为一个<code>.value</code>的对象来完成响应式的处理。</p><p>而<code>ref</code>在处理引用类型数据时，通过输出结果，我们发现了<code>proxy</code>代理的数据，这和reactive输出的结果一模一样的。</p><p>显然，ref在处理对象的时候，本质上还是调用reactive。</p><p>根据__v_isRef的值去判断，如果是简单的数据，就有ref去处理，如果是复杂的数据，本质还是用reactive去代理。</p><p>所以，在处理引用类型数据时候，本质上还是<code>reactive</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，本次简单的说完了V2与V3的数据劫持方式的不同，不过我水平浅薄，没敢放自己对源码的解读，所以显得有点low。</p><p>不过，我尽可能保证自己说的内容都是查证和实验过了，所以准确性还是有保证的。</p><p>后续会持续整理更新V2与V3之后，也算是对得起自己这多年前端的经验。</p><p>如果您有更好的见解，欢迎在评论区留言，我会参考修正自己的认知。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6968657795977576455">Vue 2.x和Vue 3.x 数据劫持的实现和优缺点</a></p><p><a href="https://www.bilibili.com/video/BV1Lm4y1v72m/?share_source=copy_web&vd_source=a848031cce5c755167a3d6aa6bd87859">【Vue中修改了数组数值，为什么界面没有更新？】</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速，规则的意义</title>
      <link href="/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2024/07/11/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>为了让工程提速，我们制造了规则。</p><p>为了让工程提速，我们漠视了规则。</p><p>本文给新踏上开发之路的朋友，1~3年左右开发经验的朋友可以看看，虽然这不是实打实的开发技能，但这却是我这数年开发的实际心得，您看完了，或许会有所收获，也可能会莞尔一笑，不过无论如何，肯定都不算是耽误您人生中的些许时光。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在早期单打独斗的时候，从来没有在意规则，一个人想怎么写就怎么写。</p><p>不过为了让未来的自己读代码没那么累，于是我开始在代码中写入注释，并且开始了简单的语义化，不再简单使用<code>a,b,c,d</code>这种临时变量。</p><p>这是最开始的简单规则，一直到团队开发的时候，我开发人生中第一套规则才开始正式诞生。</p><p>而数年之后，我为公司打造了一套低代码工具，将工程化发挥到了极致。</p><p>遥遥回想过往，简直感觉一切简直是不可思议。</p><h3 id="开发规则"><a href="#开发规则" class="headerlink" title="开发规则"></a>开发规则</h3><p>在早年前后端分离的思潮刚刚诞生的时候，我入职的前端开发团队大约两人左右，那时后端也仅一人。</p><p>很多时候商量着来，就能完成。</p><p>而后来，随着业务量的增加，前后端数量开始增加，三人以上的前端团队，对接三人以上的后端，在没有统一规则的指导下，开发进度一言难尽。</p><p>大部分的时间，前后端为了对接接口而费劲了心思。</p><h4 id="情景复盘"><a href="#情景复盘" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>三个人的后端，写出了三种风格的接口，大小写不统一，中英文混写，接口传参方式混乱，传参方式不同，且接口变动频繁导致前端根本无法稳定对接。</p><p>大家可能不能想象，那我就说一点，增删改查这一套流程中，有人同样一个字段居然写出了四种命名，有的是拼音，有的是小驼峰的单词，有的是大驼峰的单词，有的还用下划线方式命名，传参的code甚至都能出现字符串和数字两种类型，判定接口成功的code：200，20000，且这个过程中还有两种类型。</p><p>后端一团乱麻，而前端也没好到哪里去。</p><p>样式写法混乱，不用公用样式，非要自己改权重，写入样式覆盖公用样式。</p><p>接口写入方式不同，明明有着开源框架的标准方式，却偏偏要自己手动引入<code>axios</code>写接口，导致<code>api</code>接口文件非常不便管理。</p><p>而且，当时那个时间大约是2019年，那时候，前后端分离方式的思潮还很新，部分前端依旧是习惯于<code>Jquery</code>操作<code>Dom</code>的写法，然后你可以在vue的项目中看到有人引入了<code>Jquery</code>的在线链接，然后在框架内写代码操作表格。</p><p>这种思潮时至今日我居然还能在部分新手代码中遇到，有些时候我甚至可以在vue3中看到Jquery操作表格的代码，我也是不得不感叹，世界真是太大了，大到会发生任何不可思议的事。</p><h4 id="整理问题"><a href="#整理问题" class="headerlink" title="整理问题"></a>整理问题</h4><p>毫无疑问，不规范的问题极大拖累了开发速度，我们两周后复盘了一下，近乎7成以上的事件浪费在这种毫无意义的调试上。</p><p>我们当时在做的是一个系统的翻新，之所以接口会出现频繁变动，是因为大多数后端对业务不熟悉，进而导致接口频繁变动，而我们需要快速翻新出成果。</p><p>为了追求快，我们放弃了规则，这是管理上的隐患。</p><p>公司当时用的是非常好上手的Vue2，写过Vue2的朋友大概率应该知道，这是一个非常好上手的新手框架，但是我们那时候简直能用出一坨屎。</p><p>我将这个开发过程中犯的毛病整理一下，权当一篇避雷指南了。</p><p>如果您现在的项目中中了以下几条，那您就必须要反思一下，您做项目到底将多少精力花在这些无意义的调试上了？</p><ul><li>管理上追求快，不做标准要求，按照要求的时间点开始倒排开发日期，导致开发无限期加班，精力极大程度的消耗在对接空耗上了</li><li>UI风格不统一确定，很多时候出成品，经常会有样式上的变动</li><li>前后端不做业务交流，双方都在一次会议之后，简单确认了任务，就毫无修正的朝着各自以为的目标推进</li><li>后端接口标准不统一，数种不同风格的接口导致前端难以适配，即便写统一处理字段的方法也没法讲中文字段转换成英文字段，这极大的拖累的开发进度</li><li>前后端未约定联调标准，导致传参方式适配难度极大，后端成功与失败的code都不统一，有的后端甚至不写接口报错捕获，所有的传参结果都是成功</li><li>前端未使用公用样式，导致样式管理极度混乱，无法统一修改部分公用样式</li><li>前端技术栈不统一，有人在项目中使用JQuery，加重了调试的心智负担</li><li>前端语义化命名不明显，在样式中多处使用<code>L1，R1，T1，B1</code>这类风格，scss样式嵌套加深之后，阅读极为困难，变量中更是重量级，基本上不用ES6，狂用ES5的写法，几乎不用ES6的新特性来处理数组，导致代码阅读极为困难</li><li>前端代码风格不同，导致不同格式化的代码风格经常冲突</li><li>前端不用VueX存储的公共数据来读取一些数据字典，反而每次都要请求一次接口去读数据，每次页面都要拉取很多接口</li><li>没有公共工具方法库，所有人判空，取整，时间格式化都是按照自己的想法来，八仙过海，各显神通</li></ul><p>综上，这是开发中问题，至于发布测试等方面的问题，这里先按住不表，因为后续更是重量级。</p><p>由于以上的问题，我们开发页面过程极度缓慢，翻新进度简直慢的发指。</p><p>四个简单的增删改查页面，前端后端6人，每天工作12小时以上，而且是时刻有交流条件的情况下，大家根本不交流。</p><p>然后，居然在一周内没有完成两个单表的增删改查。</p><p>而后续一个复杂的多字段表单，更是整整耗时一周，才勉强调通，且不能保证全流程完全走通。</p><p>是的，这就是我们的开发进度，6个人，做成这样，肉眼可见的丢人，但这就是那时的开发进度。</p><p>我们放弃了规矩，但是我们并未追求到进度。</p><p>在复数人员的开发情况下，一个混沌的开发体系，进度便是如此的可笑。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>幸亏管理也算是技术出身，且技术功底扎实，简单的商量之后，我们制定了以下的简单方案</p><ul><li>后端接口由管理负责，定好统一格式，后端全员按照接口格式开发</li><li>在正式确认业务之前，前后端都要过一遍业务，彼此确认业务的大致流程，同时后端在没有给定正式业务之前，要先给出确定字段的接口，便于双方确认（那时候我们还不会Mock数据）</li><li>制定统一风格，由管理人员确定一套风格，然后开发出最初的模板，之后尽可能使用<code>element-ui</code>框架来实现功能，避免前端使用自己手写的样式覆盖，如果一定要调整全局样式，那么需要报备，除非必须要求改动，否则就放弃修改</li><li>技术栈统一，放弃JQuery，全面拥抱Vue2的写法，每晚定期进行代码审查（草草检查，主要确认没有jquery）</li><li>公共接口抽离，将一些公用方法抽离出来，如上传，部分复杂的业务数据字典，</li><li>公共方法本地化封装，将一些判空之类的方法写在工具类中，省去每人手写工具方法的时间</li><li>命名语义化，尽可能减少无意义的变量命名</li><li>代码格式化插件统一，开发工具统一，保证所有人调试起来方便（笔者并不太会用webstorm的格式化，当时也没时间去研究，只能禁了那位组员的webstorm，让他用vscode）</li></ul><p>经过这些小手段，效果立竿见影。</p><p>开发进度确实有了些许提升，但是页面功能的稳定性显而易见的上升，同时每人的工作量大幅下降，勉强可以8点下班，至少不用彻夜彻夜的加班了（在这之前巅峰时间甚至能达到每天14小时以上的工作强度）。</p><p>可能大家会觉得，这并未提升多少，但是于那时的我们来说，在这之前，团队几乎是肉眼可见要崩塌，所有人都不觉得这样的团队能做成这个项目。</p><p>但是这些简单的规定做下来之后，虽然强度还在，但是工作目标至少可以量化了，同时任务终于可以拆解了，不再是将所有人都堆在任务中。</p><p>而团队工程化的路，就是从那时候开始的。</p><h3 id="运维发布"><a href="#运维发布" class="headerlink" title="运维发布"></a>运维发布</h3><p>因为团队一开始并不大，所以很多时候都是开发运维一把抓，然后在这个过程中，又诞生了一堆混乱至极的问题。</p><h4 id="情景复盘-1"><a href="#情景复盘-1" class="headerlink" title="情景复盘"></a>情景复盘</h4><p>那时，我们用的仍然是SVN进行版本管理，相对于git的分布式版本管理，SVN的集中管理有个弱势点，那就是版本管控必须要将代码文件提交到中心服务器。</p><p>而这就有个隐患，如果有人没有将自己的逻辑走完，那么为了版本管控，他也只能将代码提交到SVN，而客户几乎每天都会过来看一下进度。</p><p>如果有经验的人，想必此时已经发现哪里有隐患了。</p><p>因为有人会将未完成的功能提交到线上，那么发布到线上的时候，碰到演示这种未完成的功能时候，免不了会被客户一顿痛批。</p><p>部分公司为了解决这种问题，会选择再买个服务器，做一个测试版本，但我们当时是内网开发，客户表示只有这一个服务器，然后结果就很尴尬了。</p><p>这个过程，开发流程管理也很混乱，客户会经常在我们开发过程中插入一些新的要求，导致我们项目需求翻新的进度极度拖延。</p><h4 id="整理问题-1"><a href="#整理问题-1" class="headerlink" title="整理问题"></a>整理问题</h4><p>在我们刚解决了开发上的规范问题之后，我们就遇到了这种运维及需求沟通的问题上的问题。</p><h5 id="需求混乱"><a href="#需求混乱" class="headerlink" title="需求混乱"></a>需求混乱</h5><ul><li>翻新需求不明确，做无用功，很多旧版本的功能，在旧版时候明确不用了，但是项目Leader没有细细筛过需要翻新的功能，导致经常做了无用功</li><li>客户需求不评审，因为客户可以直接到现场催稿，导致经常会插入一些客户优先的功能，延误了正常工期排序</li><li>对业务不熟悉，导致返工。这个是最常见的事情，很多时候，我们评审业务，项目Leader没有说明白业务，进而导致开发者对业务的理解南辕北辙，不停翻新做无用功。</li></ul><p>针对这些问题，我们项目Leader只能将自己从开发序列中抽离，自己去整理业务对接客户。</p><p>因为他最懂这块的业务，所以只有他自己可以去，他将需求承接完成后，顶住客户的需求压力，按照排期给我们捋顺业务和开发进度。</p><p>之后，由他来作为团队大核，指导对业务不熟悉的我们，由我们负责具体的开发内容。</p><p>这之后的效果，也算是立竿见影，虽然项目Leader不用实际开发了，但我们的进度却并未落下，甚至质量再次提升，做无用功的情况越来越少，随着大家对业务的逐渐熟悉，所有人甚至可以对业务中不合理的地方及时预警。</p><h5 id="混乱发布"><a href="#混乱发布" class="headerlink" title="混乱发布"></a>混乱发布</h5><p>这是在需求没有整理之前的情况，我们的发布突出一个随心所欲，几乎所有小团队中能犯的错，我们这里都犯过。</p><ul><li>版本不指定，我们没有既定的版本，只是按照大致的感觉和客户的催命程度来发布，这时候我们和上版本相比有了什么进步只有项目Leader知道</li><li>功能不自测，因为经常翻新，为了追求演示效果，我们经常赶时间发布，这导致演示的时候经常翻车</li><li>人员不指定，所有人都可以发布，然后我们经常在发布的时候撞车（趁没有测出BUG悄悄发布，小团队这种事想必很多）</li><li>项目现场不指定，当时翻新的这个项目部分源码涉及到另一个项目现场，手动发布必然会有失误，经常忘记改配置，导致项目现场读取的内容错乱</li><li>日期不指定，因为没有固定的发布时间，所以客户经常回来催我们（后来由项目Leader去抗这个压力了）</li></ul><p>综上，我们提出了一系列的解决方案。</p><ul><li>定好版本发布规则，确认需求后，固化发布日期。除非客户强烈要求，否则不会加入新功能排期，按照周为单位进行迭代。</li><li>指定专门的运维人员，其他人不能碰发布服务器</li><li>前端开发打包版本插件，让代码可以根据时间自动生成版本，并抽离配置，减少手动发包导致项目现场错配的问题</li><li>安排运维人员书写运维文档，保证客户和开发人员都能明白我们要改什么，接下来要做什么</li></ul><h3 id="提速方向"><a href="#提速方向" class="headerlink" title="提速方向"></a>提速方向</h3><p>讲到这里，时间基本上挺接近现在了，我这里没有接触过更高标准的团队，但是就我打听的情况来看，大厂似乎也将工程化的流程走到顶点了。</p><p>我在面试过程中，发现很多团队实际上基本就是前者的形态了，很少有进入到这一步的，以下提到的这些需求，几乎是只有大型团队才会出现的需求。</p><p>这一步几乎是工程化的高标准状态了，大多数草创的开发团队，甚至是一些较为成熟的团队，他们几乎没有到这一步的意识和需求。</p><p>到了这一步，公司业务几乎固定，因为业务线的固定，也逐渐衍生出产品化的概念，自然也就有了产品迭代的需求。</p><p>于是，工程提速的玩法再次发生了改变。</p><ul><li>自动化发布</li><li>代码管控，自动生成发布日志</li><li>组件库</li><li>工具包</li><li>脚手架</li><li>前后端约定统一，技术栈固化</li></ul><p>集成以上方式之后，便有了终极形态，低代码。</p><p>在那时，我们几乎可以将一个两月交付的项目在一周内迭代出原型，供客户参考，然后在那基础上修改。</p><p>同时极大程度节约人力，不过受限于篇幅，这里就不展开说了，后续会随着自己的要求，逐步解释我们项目中为什么进行这些操作。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>开发规则的诞生，是一个几乎必然的过程，人人都在骂这种制度化，但是一旦走向了大型团队化，我们又不可避免的制度化。</p><p>有些时候，人真是有趣，讨厌一件事，理解一件事，融入一件事，成为这件事。</p><p>制度化，团队化，似乎是人类群体的必然性，这种过程似乎是大型团队的必然答案，也是一种趋同进化的趋势。</p><p>当然，扯远了，我们仅仅说的是工程，一个工程想要做的正常，并非一定要上大型工程的规则。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7390319475525107764">工程提速，规则的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS中的常用遍历</title>
      <link href="/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/"/>
      <url>/2024/07/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>最近写代码频繁写map，以至于想写for…of的时候，都忘记这块的讲究了，索性整理下，以备面试。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>常规开发中我们可能已经习惯性的使用map了，但我们肯定不能只会map。</p><p>这里我们索性通盘整理下，把前端开发中遍历的熟面孔遍历一遍。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code>循环是一种常用的遍历方法，特别适用于已知遍历次数的情况。</p><p>它由三个部分组成：初始化表达式、循环条件和循环迭代器。</p><p>这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = array.<span class="property">length</span>; i &lt; len; i++ )&#123; <span class="comment">//(初始化表达式; 循环条件; 循环迭代器)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环非常灵活，你可以根据需要自定义循环变量的初始值、循环条件和迭代方式。它适用于各种遍历需求，包括遍历数组、对象的属性等。</p><ol><li>通过<strong>continue</strong>中断当次循环</li><li>通过<strong>break</strong>中断整个循环</li><li>通过<strong>retrun</strong>中断函数执行</li></ol><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法用于对数组的每个元素执行指定的操作，并返回一个新的数组，新数组的元素是原数组经过操作后的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> modifiedElement;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>map</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行操作，并返回经过操作后的新值<code>modifiedElement</code>。</p><p><code>map</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的结果组成一个新的数组。</p><p>下面是一个使用<code>map</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123; <span class="comment">// 对每个元素执行操作，并返回新的值</span></span><br><span class="line">    <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>map</code>方法对数组<code>array</code>的每个元素进行操作，将每个元素乘以2，并将操作后的结果组成一个新的数组<code>newArray</code>。</p><p><code>map</code>方法是一种非常有用的方法，它可以方便地对数组的每个元素进行操作，并生成一个新的数组。</p><p> 需要注意的是</p><ul><li><code>map</code>方法不会修改原始数组，而是返回一个新的数组</li><li><code>map</code>方法无法遍历对象，仅适用于数组的遍历</li><li><code>map</code>方法不会对空数组进行检测</li><li><code>map</code>循环只能通过return中断当次循环</li></ul><h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for..in 和 for..of 的区别"></a>for..in 和 for..of 的区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h4><p>for…in是为遍历对象属性而构建的，它以任意顺序遍历一个对象的除Symbol以外的可枚举属性，可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 name age</span></span><br></pre></td></tr></table></figure><p>在JavaScript中，数组也是对象的一种，所以数组也是可以使用for…in遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2</span></span><br></pre></td></tr></table></figure><h4 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h4><p>for…of语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句（包括Array，Map，Set，String，TypedArray，arguments等等，不包括Object），可用break或者throw跳出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 obj is not iterable (obj不是可迭代的)</span></span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>无论是for…in还是for…of都是迭代一些东西。它们之间的主要区别在于它们的迭代方式</p><ul><li>for…in语句以任意顺序迭代对象的可枚举属性</li><li>for…of语句遍历可迭代对象定义要迭代的数据</li></ul><p>总之，for…in 循环主要是为了遍历对象而生，不适用于遍历数组</p><p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ufo</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0 1 2 ufo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 a b c</span></span><br></pre></td></tr></table></figure><h3 id="使用for…-of遍历对象的方法"><a href="#使用for…-of遍历对象的方法" class="headerlink" title="使用for….of遍历对象的方法"></a>使用for….of遍历对象的方法</h3><h4 id="遍历类数组对象"><a href="#遍历类数组对象" class="headerlink" title="遍历类数组对象"></a>遍历类数组对象</h4><p>使用Array.from()方法将对象转换为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="title class_">Array</span>.<span class="title function_">from</span>(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历普通对象"><a href="#遍历普通对象" class="headerlink" title="遍历普通对象"></a>遍历普通对象</h4><ul><li>给对象添加一个[symbol.iterator]属性，并指向一个迭代器。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(count&lt;keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">  onsole.<span class="title function_">log</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二（使用Generator函数生成迭代器）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*()&#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-和-forEach区别"><a href="#for-和-forEach区别" class="headerlink" title="for 和 forEach区别"></a>for 和 forEach区别</h3><ul><li>for循环可以使用break跳出循环，但forEach不能。</li><li>for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。</li><li>for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。</li></ul><h3 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h3><p><code>reduce</code>方法用于对数组的每个元素进行累积操作，并返回一个最终的累积结果。</p><p>以下是<code>reduce</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element, index, array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulatedValue;</span><br><span class="line">&#125;, initialValue);</span><br></pre></td></tr></table></figure><p>在<code>reduce</code>方法中，我们传入一个回调函数作为参数。该回调函数接受四个参数：累积值<code>accumulator</code>、当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们对每个元素执行累积操作，并将累积结果返回。<code>reduce</code>方法会遍历数组的每个元素，并将每个元素经过回调函数处理后的累积结果作为下一次迭代的累积值。</p><p>下面是一个使用<code>reduce</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, element</span>) &#123; <span class="comment">// 对每个元素执行累积操作，并返回累积结果</span></span><br><span class="line">    <span class="keyword">return</span> accumulator + element;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>reduce</code>方法对数组<code>array</code>的每个元素进行累积操作，将所有元素相加得到最终的累积结果。</p><p>需要注意的是:</p><ul><li><code>reduce</code>方法不会改变原数组。</li><li><code>reduce</code>方法可以接受一个可选的初始值<code>initialValue</code>作为第二个参数。如果提供了初始值，累积值<code>accumulator</code>的初始值将为该值；如果未提供初始值，则累积值将为数组的第一个元素，且从数组的第二个元素开始进行累积操作。</li><li>如果数组为空，且未提供初始值，则<code>reduce</code>方法会抛出一个<code>TypeError</code>。在处理可能为空的数组时，要确保提供了合适的初始值或进行适当的错误处理。</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于筛选数组中满足指定条件的元素，并返回一个新的数组。</p><p>以下是<code>filter</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element, index, array</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>filter</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否保留该元素。如果回调函数返回<code>true</code>，则该元素将被保留在新的数组中；如果返回<code>false</code>，则该元素将被过滤掉。</p><p>下面是一个使用<code>filter</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> newArray = array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否保留该元素</span></span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// 保留偶数元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">// 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>filter</code>方法筛选数组<code>array</code>中的偶数元素，并将满足条件的元素组成一个新的数组<code>newArray</code>。</p><p><code>filter</code>方法非常灵活，可以根据不同的条件筛选数组中的元素。回调函数应该返回一个布尔值，表示是否保留该元素。返回<code>true</code>表示保留，返回<code>false</code>表示过滤掉。</p><p>需要注意的是：</p><ul><li><code>filter</code>方法会返回一个新的数组，该数组包含满足指定条件的元素。请确保在回调函数中返回一个布尔值，表示是否保留该元素。</li><li><code>filter</code>方法不会对空数组进行检测。</li></ul><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p><code>some</code>方法用于检测数组中是否至少有一个元素满足指定条件。</p><p>以下是<code>some</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>some</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。如果回调函数返回<code>true</code>，则表示至少有一个元素满足条件；如果所有元素都不满足条件，回调函数返回<code>false</code>。</p><p>下面是一个使用<code>some</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>; <span class="comment">// 判断是否存在大于3的元素</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>some</code>方法检测数组<code>array</code>中是否存在大于3的元素。</p><p>由于数组中存在元素4和5满足条件，所以<code>some</code>方法返回<code>true</code>。</p><p><code>some</code>方法可以用于检测数组中是否满足某个条件的元素。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>some</code>方法在找到满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>some</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p><code>every</code>方法用于检测数组中的所有元素是否都满足指定条件。</p><p>以下是<code>every</code>方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在<code>every</code>方法中，我们传入一个回调函数作为参数。</p><p>该回调函数接受三个参数：当前元素的值<code>element</code>、当前元素的索引<code>index</code>和正在遍历的数组<code>array</code>。</p><p>在回调函数中，我们根据指定的条件判断是否满足条件。</p><p>如果回调函数对数组中的所有元素都返回<code>true</code>，则<code>every</code>方法返回<code>true</code>；如果有任何一个元素返回<code>false</code>，则<code>every</code>方法返回<code>false</code>。</p><p>下面是一个使用<code>every</code>方法的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> result = array.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">element</span>) &#123; <span class="comment">// 返回一个布尔值，表示是否满足条件</span></span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">0</span>; <span class="comment">// 判断是否所有元素都大于0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>every</code>方法检测数组<code>array</code>中的所有元素是否都大于0。由于数组中的所有元素都大于0，所以<code>every</code>方法返回<code>true</code>。</p><p><code>every</code>方法可以用于检测数组中的所有元素是否满足某个条件。它提供了一种简洁的方式来进行条件判断。</p><p>需要注意的是：</p><ul><li><code>every</code>方法在找到不满足条件的元素后会立即停止遍历，不会继续遍历剩余的元素。</li><li><code>every</code>方法不会改变原数组，会返回一个布尔值。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端遍历循环，最熟悉的陌生人。</p><p>平时开发的过程中，很多新人肯定会直接map或者for循环一把梭，这样固然简单有效，但是不够语义化，所以才有了这些api。</p><p>我们要尽可能的多用这些原生的API，减少日常开发中不够语义化的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://conistudy.club/interview/javascript.html#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB">JavaScript | Conistudy</a></p><p><a href="https://juejin.cn/post/7361809254044647465?searchId=20240710123929C9622D5B87737C588848">详解JavaScript遍历：掌握for、forEach、for in、for of和map等方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速，低代码的意义</title>
      <link href="/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2024/07/07/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>低代码在22~23年左右的时候，这个概念是最火的，同时期，若依开源项目也在这期间加入了低代码的功能。</p><p>之后，在23年低代码的风潮达到了鼎盛，但是之后就陷入了 各种声音的质疑中，最后陷入的沉寂。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>低代码的没落并非是低代码本身的没落，而是需求本身的没落。</p><h3 id="低代码平替"><a href="#低代码平替" class="headerlink" title="低代码平替"></a>低代码平替</h3><p>低代码并非万能银弹，在开发者的世界里，是不可能存在万能的银弹的。</p><blockquote><p>银弹，即<a href="https://baike.baidu.com/item/%E7%BA%AF%E9%93%B6/0?fromModule=lemma_inlink">纯银</a>质或<a href="https://baike.baidu.com/item/%E9%95%80%E9%93%B6/9937426?fromModule=lemma_inlink">镀银</a>质的子弹。在古老的欧洲民间传说、鬼怪题材的小说和电影，尤其是19世纪以来<a href="https://baike.baidu.com/item/%E5%93%A5%E7%89%B9%E5%B0%8F%E8%AF%B4/0?fromModule=lemma_inlink">哥特小说</a>风潮影响下，银色子弹往往被描绘成是<a href="https://baike.baidu.com/item/%E7%8B%BC%E4%BA%BA/24621?fromModule=lemma_inlink">狼人</a>和<a href="https://baike.baidu.com/item/%E5%90%B8%E8%A1%80%E9%AC%BC/64596?fromModule=lemma_inlink">吸血鬼</a>、<a href="https://baike.baidu.com/item/%E5%A5%B3%E5%B7%AB/2007?fromModule=lemma_inlink">女巫</a>以及其他怪物的克星，一发即可致命，并具有驱魔的效力。</p><p>后来在开发中，有人比喻为万能解法，因为很多西部片和小说中的不死邪魔经常都被一发银弹解决，这种不讲道理的方式，就被戏称为银弹，在戏剧中也有类似的玩法，叫做机械降神，不过这个就不细展开说了。</p><p>无论是银弹还是机械降神，都是比喻一种万能解法，而在开发者的世界中，这种万能的银弹是不存在的。</p></blockquote><p>低代码的诞生和火爆，离不开早些年互联网的火爆，各种<code>ToB（面向公司老板）</code>，<code>ToC（面向客户）</code>，<code>ToG（面向政府）</code>等业务的不断上扬和增加，这时候，不可避免的出现了N多的管理系统。</p><p>一旦管理系统落成，那么不可避免的，就要对表的增删改查。</p><p>这时候，很多开发者不可避免的要一遍又一遍的陷入前端写表单列表，后端写<code>curd</code>的接口，在这种重复业务中不断耽误时间，加班赶进度，却十分枯燥的情况。</p><p>针对这种情况，于是才有了低代码。</p><p>但是低代码，却绝非是现代才有的概念，而是很早之前就有的概念，早在现代低代码概念爆火之前，就有类似的说法。</p><p>说穿了，低代码就是配置化系统的变种，但是生成出来的代码又需要一定开发技术去按照需求修改，相对于传统的工具系统，这种低代码平台肯定更好用。</p><p>譬如ERP，CMS及等工具系统，对已经固定的业务线，仅仅需要配置就可以配置好一个系统，供用户使用，这应该就是最早的低代码系统。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>低代码并非是小型公司可以玩转的东西，这东西的诞生是为了解决特定的场景内的需求。</p><p>个人曾在公司有幸接触过相关业务，所以这里分享一下低代码的具体的应用场景及基础要求。</p><h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><p>注意，需要满足以下绝大多数条件的，可以考虑在公司产品中加入低代码的功能，否则开发用来造轮子的工作时间会远大于使用低代码这个轮子的节约的时间。</p><ul><li>重复的业务场景，需要消耗大量人力时间去写重复的增删改查工作量</li><li>业务线路稳定，不会频繁变动，多数业务逻辑可以拆分成简单的增删改查实现</li><li>表单关系简单，相互之间交互关系不大</li><li>UI风格稳定，需求方对UI不做大规模的变动要求，并且基于这个稳定的UI库，形成一套属于公司自己的风格</li><li>稳定的组件库，能够极大程度减少代码生成文件的代码量，便于改动</li><li>如果有双端适配的要求，那移动端也要有稳定的组件库和设计风格，同时业务量不要统一</li><li>前端基建相对稳定，脚手架，工具包，组件库都统一，并基建代码和业务代码能够并行推进，相互干扰程度小</li><li>稳定的权限管理功能，从路由到按钮级别的管理，不是一个混沌的权限管理系统（在很多中小厂中至今没有一个像样的权限管理系统）</li><li>前端负责人需要对公司业务有较为深层的了解，能够把控和预测公司接下来的发展方向，不会完全受制于设计或者后端，不至于一点话语权也没有。</li></ul><p>综上，我们会发现，这并非是个小公司使用的工具。</p><p>低代码的诞生，是一个团队的工作成果。</p><blockquote><p>稳定的UI，业务线，产品化的前后端框架，成熟的运维人员，几乎缺一不可。</p></blockquote><p>低代码热门的场景，大概是中型公司或者大厂业务部门中常用的工具，通过这东西，应该可以快速生成一些增删改查的表单，快速完成项目任务。</p><p>而小厂接到的业务，多数个性化要求较高，甚至是外包业务，根本就不在乎你用什么技术，混乱的项目管理根本不适合低代码的的使用。</p><h3 id="低代码优劣"><a href="#低代码优劣" class="headerlink" title="低代码优劣"></a>低代码优劣</h3><p>开发者固然要追求更新潮，更有趣的技术，这是一个开发者固有的技术素养。</p><p>但工程不能，工程是一个公司，一个团队的心血，工程要以稳定为主，你可以小步迭代，决不能贸然使用不稳定的技术。</p><p>毕竟，所有的技术诞生，都是为了解决某种特殊的需求，不要为了技术追星，去强上看上去很酷炫的技术。</p><p>这里我列举一下低代码的优劣，各位可以根据自己的需求权衡，是否在公司内使用</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>大量节省人力，原本一个项目至少需要一个熟手前端，后端同时协同开发数月才能完成一个项目，而使用低代码之后，简单的项目完全可以由一个运维人员通过简单的配置，生成一个系统，个性化的页面申请给开发部调整，将数月级别的项目缩减到两周。</li><li>可以快速迭代项目，很多时候需求方不清楚自己需要什么，而我们通过对表单的和列表的配置，很容易就能让客户明白自己的缺陷和需求，这样便于快速迭代，但是注意，不要被客户套进去。</li><li>使用简单，基本上一个运维人员通过培训，只要稍微有点项目经验和些许的开发经验，就可以覆盖一个项目现场，一旦完成交付后，还可以快速迭代到下一个项目现场。</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>技术固化。随着项目的不断推进，低代码系统涉及到的组件库必须得稳定维护，组件库会随着项目的增多而不断臃肿，随着时间的增加，低代码的尽头必然是需要前端组长花很大的力量去维护和平衡各个项目现场的需求。</li><li>项目臃肿。很多人在使用低代码的时候，简单生成了代码，后续这里不用之后，就隐藏废弃，代码也不会删除，时间长了之后，这种废弃代码就堆在业务系统中，久而久之，这项目就会很臃肿。</li><li>依赖管理困难。各个前端项目没有版本锁，当时Pnpm也没有流行开来，现在相对来说应该好的多，但是随着时间的推移，这种组件库的适配早晚也会在依赖管理上出问题的。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多大厂的为了做业绩，在那两年几乎把这玩意吹成了万能银弹，这是不对的。</p><p>在它的固有领域内，低代码能极大节省人力，减少开发者的业务工作量，让开发者更专注于自身的开发优势，不过这也让开发者更远离业务，难以进入业务管理层了。</p><p>总之，有利又有弊，是否使用低代码，需要根据自身情况做决定。</p><p>最后，给自己的掘金引个流：<a href="https://juejin.cn/post/7389077092136452148">工程提速，低代码的意义 - 掘金 (juejin.cn)</a>。</p><p>希望大家能关注我，多多点赞，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析const声明的ref，reactive变量为什么可以修改</title>
      <link href="/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/"/>
      <url>/2024/07/06/%E6%B5%85%E6%9E%90const%E5%A3%B0%E6%98%8E%E7%9A%84ref%EF%BC%8Creactive%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>事情发生在我看到Vue3的开源项目中，const声明的ref变量可以被修改。</p><p>当时我大受震撼，以为我看错了，当时忙着赶项目，没在意这个，也就跟着一起敲了，现在终于有时间了，索性梳理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>const</code>关键字用于声明一个变量，该变量的值在其生命周期中不会被重新赋值。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>我们都知道const声明的常量不可改变，但是为什么Vue3中的ref和reactive声明的变量就可以修改？</p><p>这里我们先看几个例子，我们会发现，不止是ref和reactive，const声明的引用类数据，都是会被改变的。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>对于基本数据类型（如数字、字符串、布尔值），<code>const</code>确保变量的值不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// num = 43;  // 这会抛出错误</span></span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于对象，仍然可以修改对象的属性，但不能重新赋值整个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> girlfriend = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;小宝贝&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">girlfriend.<span class="property">name</span> = <span class="string">&quot;亲爱的&quot;</span>;  <span class="comment">// 这是允许的，因为你只是修改了对象的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// girlfriend = &#123; name: &quot;亲爱的&quot; &#125;;  // 这会抛出错误，因为你试图改变obj的引用</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>对于数组，你可以修改、添加或删除元素，但不能重新赋值整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">4</span>;  <span class="comment">// 这是允许的，因为你只是修改了数组的一个元素</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">5</span>);  <span class="comment">// 这也是允许的，因为你只是向数组添加了一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr = [6, 7, 8];  // 这会抛出一个错误，因为你试图改变arr的引用</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在JavaScript中，<code>const</code>并不是让变量的值变得不可变，而是让变量指向的<strong>内存地址</strong>不可变。</p><p>换句话说，使用<code>const</code>声明的变量不能被重新赋值，但是其所指向的内存中的数据是可以被修改的。</p><p>使用<code>const</code>后，实际上是确保该变量的引用地址不变，而不是其内容。</p><p>其实，这就是一次浅拷贝，只要地址指向的位置不发生改变，你做什么操作都可以，关于深浅拷贝不清楚的，可以参考一下我的：<a href="https://crazystudent13.cn/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/">10分钟了解深浅拷贝</a>。</p><p>基础数据类型定死了内存地址，所以当你重新赋值的时候，自然就会报错。</p><p>而引用数据类型虽然也定死了内存地址，但是其中内容未完全定死，所以可以操作和修改，这就是为什么引用类的数据类型使用const修改不会报错，但是重新赋值就会报错的原因了。</p><p>当const<code>声明一个变量并赋值为一个对象或数组，这个变量实际上存储的是这个对象或数组在内存中的地址，形如</code>0x00ABCDEF&#96;（这只是一个示例地址，实际地址会有所不同），而不是它的内容。这就是为什么我们说变量“引用”了这个对象或数组。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>这种看似矛盾的特性实际上在开发中经常用到。</p><p>例如，在开发过程中，可能希望保持一个对象的引用不变，同时允许修改对象的属性。这可以通过使用<code>const</code>来实现。</p><p>考虑以下示例：</p><p>假设你正在开发一个应用，该应用允许用户自定义一些配置设置。当用户首次登录时，你可能会为他们提供一组默认的配置。但随着时间的推移，用户可能会更改某些配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line"><span class="keyword">const</span> userSettings = &#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&quot;light&quot;</span>,  <span class="comment">// 主题颜色</span></span><br><span class="line">    <span class="attr">notifications</span>: <span class="literal">true</span>,  <span class="comment">// 是否开启通知</span></span><br><span class="line">    <span class="attr">language</span>: <span class="string">&quot;en&quot;</span>  <span class="comment">// 默认语言</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时间点，用户决定更改主题颜色和语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateUserSettings</span>(<span class="params">newTheme, newLanguage</span>) &#123;</span><br><span class="line">    userSettings.<span class="property">theme</span> = newTheme;</span><br><span class="line">    userSettings.<span class="property">language</span> = newLanguage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用函数，将主题更改为&quot;dark&quot;，语言更改为&quot;zh&quot;</span></span><br><span class="line"><span class="title function_">updateUserSettings</span>(<span class="string">&quot;dark&quot;</span>, <span class="string">&quot;zh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userSettings);  <span class="comment">// 输出：&#123; theme: &quot;dark&quot;, notifications: true, language: &quot;zh&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个<code>userSettings</code>对象，它包含了用户的默认配置。</p><p>尽管我们使用<code>const</code>来声明这个对象，但我们仍然可以随后更改其属性来反映用户的新配置。</p><p>这种模式在实际开发中很有用，因为它允许我们确保<code>userSettings</code>始终指向同一个对象（即我们不会意外地将其指向另一个对象），同时还能够灵活地更新该对象的内容以反映用户的选择。</p><h4 id="为什么不用let"><a href="#为什么不用let" class="headerlink" title="为什么不用let"></a>为什么不用let</h4><p>以上所以案例中，使用let都是可行，但它的语义和用途相对不同，主要从这几个方面进行考虑：</p><ol><li><strong>不变性</strong>：使用<code>const</code>声明的变量意味着你不打算重新为该变量赋值。这为其他开发人员提供了一个明确的信号，即该变量的引用不会改变。在上述例子中，我们不打算将<code>userSettings</code>重新赋值为另一个对象，我们只是修改其属性。因此，使用<code>const</code>可以更好地传达这一意图。</li><li><strong>错误预防</strong>：使用<code>const</code>可以防止意外地重新赋值给变量。如果你试图为<code>const</code>变量重新赋值，JavaScript会抛出错误。这可以帮助捕获潜在的错误，特别是在大型项目或团队合作中。</li><li><strong>代码清晰度</strong>：对于那些只读取和修改对象属性而不重新赋值的场景，使用<code>const</code>可以提高代码的清晰度，可以提醒看到这段代码的人：“这个变量的引用是不变的，但其内容可能会变。”</li></ol><p>一般我们默认使用<code>const</code>，除非确定需要重新赋值，这时再考虑使用<code>let</code>。这种方法旨在鼓励不变性，并使代码更加可预测和易于维护。</p><p>由此，我们应该也明白，ref和reactive使用const声明，而非使用let了。</p><h4 id="避免修改"><a href="#避免修改" class="headerlink" title="避免修改"></a>避免修改</h4><p>如果我们想要避免修改<code>const</code>声明的变量，当然也是可以的。</p><p>例如，我们可以使用浅拷贝来创建一个具有相同内容的新对象或数组，从而避免直接修改原始对象或数组。这可以通过以下方式实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="attr">originalArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">;</span></span><br><span class="line">const <span class="attr">newArray</span> = [...originalArray]<span class="comment">; // 创建一个原始数组的浅拷贝</span></span><br><span class="line">newArray.push(4)<span class="comment">; // 不会影响原始数组</span></span><br><span class="line">console.log(originalArray)<span class="comment">; // 输出: [1, 2, 3]</span></span><br><span class="line">console.log(newArray)<span class="comment">; // 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>const</code>声明的变量之所以看似可以被修改，是因为<code>const</code>限制的是变量指向的内存地址的改变，而不是内存中数据的改变。</p><p>这种特性在实际开发中有其应用场景，允许我们保持引用不变，同时修改数据内容。</p><p>然而，如果我们确实需要避免修改数据内容，可以采取适当的措施，如浅拷贝。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7268087637239463997">const声明的变量还能修改？原理都在这了</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解nginx</title>
      <link href="/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/"/>
      <url>/2024/07/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3nginx/</url>
      
        <content type="html"><![CDATA[<p>nginx以前总是用的时候现查使用方法，能配到线上就行，毕竟以前都是赶时间。</p><p>等到后来公司走上正轨了，也没时间去折腾相关内容，因为有运维和后端接手了。</p><p>现在时间终于没那么赶了，索性系统性的学习下，理论上，nginx确实也是前端基建要了解的一环。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>nginx这东西，好用也不难学，学会了之后，对于前端来说，就可以自己操控服务器进行独立应用部署了。</p><p>学一学也好，简单又强大的东西，也是其成为新时代的开发宠儿的原因。</p><p>以前只是简单的用过，但是从来没有系统性的整理过，这次干脆花些时间简单整理一下。</p><h3 id="配置结构"><a href="#配置结构" class="headerlink" title="配置结构"></a>配置结构</h3><p><strong>第一部分 全局块</strong></p><p>主要设置一些影响 nginx 服务器整体运行的配置指令。</p><p>比如： worker_processes 1；worker_processes 值越大，可以支持的并发处理量就越多。</p><p><strong>第二部分 events块</strong></p><p>events 块涉及的指令主要影响Nginx服务器与用户的网络连接。</p><p>比如： worker_connections 1024; 支持的最大连接数。</p><p><strong>第三部分 http块</strong></p><p>http 块又包括 http 全局块和 server 块，是服务器配置中最频繁的部分，包括配置代理、缓存、日志定义等绝大多数功能。</p><ul><li><strong>server块</strong>：配置虚拟主机的相关参数。</li><li><strong>location块</strong>：配置请求路由，以及各种页面的处理情况。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attribute">error_log</span> log/<span class="literal">error</span>.log <span class="literal">debug</span>;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attribute">log_format</span> myFormat <span class="string">&#x27;<span class="variable">$remote_addr</span>–<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="variable">$request</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="variable">$http_referer</span> <span class="variable">$http_user_agent</span> <span class="variable">$http_x_forwarded_for</span>&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> mysvr &#123;   </span><br><span class="line">      <span class="attribute">server</span> <span class="number">127.0.0.1:7878</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">120</span>; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">4545</span>;   <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;   <span class="comment">#监听地址       </span></span><br><span class="line">        <span class="section">location</span>  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attribute">proxy_pass</span>  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attribute">deny</span> <span class="number">127.0.0.1</span>;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           <span class="attribute">allow</span> <span class="number">172.18.5.54</span>; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="nginx特性"><a href="#nginx特性" class="headerlink" title="nginx特性"></a>nginx特性</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理，就是代理服务器替客户端去访问目标服务器。</p><p>在用户去访问目标服务器的时，<code>nginx</code>所在的服务器通过正向代理，作为中介服务器，将用户的访问指到目标服务器。</p><p>正向代理，代理的对象是客户端。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理针对的是目标服务器。</p><p>反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。</p><p>客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。</p><p>反向代理，代理的对象是服务器。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>配合反向代理，将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p><p>这适合于一些大型应用，通过反向代理+负载均衡，我们可以将单个服务器的压力分散到多个服务器。</p><p>在这些被代理的服务器集群中，如果某个服务器上的后台应用挂了，那么这些被代理压力可以被转移到其他服务器，而这个过程中，用户不会有感知，这是目前大多数大型企业web应用面对多用户访问的标准解法之一。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>为了提高系统的可用性和容错能力，可以增加nginx服务器的数量，当主服务器发生故障或宕机，备份服务器可以立即充当主服务器进行不间断工作。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来负责解析，加快解析速度，降低原来单个服务器的压力。</p><p>简单的来说，就是静态的页面，代理到专门的静态页面处理</p><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><h5 id="实战一"><a href="#实战一" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器输入 <em><a href="http://www.abc.com/">www.abc.com</a></em> , 从 nginx 服务器跳转到 linux 系统 tomcat 主页面。</p><h6 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#/html目录</span></span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;  <span class="comment">#请求转向</span></span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;      <span class="comment">#设置默认页       </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实战二"><a href="#实战二" class="headerlink" title="实战二"></a>实战二</h5><h6 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h6><p>根据在浏览器输入的路径不同，跳转到不同端口的服务中</p><h6 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9000</span>;   </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址       </span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example1/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:5000;         </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  <span class="regexp">~ /example2/</span> &#123;  </span><br><span class="line">       <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;         </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>location</strong> 指令说明：</p><ul><li><strong>~ :</strong> 表���uri包含正则表达式，且区分大小写。</li><li><strong>~* :</strong> 表示uri包含正则表达式，且不区分大小写。</li><li><strong>&#x3D; :</strong> 表示uri不含正则表达式，要求严格匹配。</li></ul><h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="实战一-1"><a href="#实战一-1" class="headerlink" title="实战一"></a>实战一</h5><h6 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h6><p>在浏览器地址栏输入 <em><a href="https://link.juejin.cn/?target=http://192.168.4.32/example/a.html">http://192.168.4.32/example/a.html</a></em> ，平均到 5000 和 8080 端口中，实现负载均衡效果。</p><h6 id="具体配置-2"><a href="#具体配置-2" class="headerlink" title="具体配置"></a>具体配置</h6><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;   <span class="comment">#监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.4.32</span>;   <span class="comment">#监听地址</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span>  / &#123;       </span><br><span class="line">       <span class="attribute">root</span> html;  <span class="comment">#html目录</span></span><br><span class="line">       <span class="attribute">index</span> index.html index.htm;  <span class="comment">#设置默认页</span></span><br><span class="line">       <span class="attribute">proxy_pass</span>  http://myserver;  <span class="comment">#请求转向 myserver 定义的服务器列表      </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx 分配服务器策略</strong></p><ul><li><p><strong>轮询</strong>（默认）</p><p> 按请求的时间顺序依次逐一分配，如果服务器down掉，能自动剔除。</p></li><li><p><strong>权重</strong><br> weight 越高，被分配的客户端越多，默认为 1。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123;   </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span> weight=<span class="number">10</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ip</strong><br> 按请求 ip 的 hash 值分配，每个访客固定访问一个后端服务器。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    ip_hash;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fair</strong></p><p> 按后端服务器的响应时间来分配，响应时间短的优先分配到请求。比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver &#123; </span><br><span class="line">    fair;  </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.167.4.32:5000</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.4.32:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>nginx是运维人员常用的工具，严格意义上不是前端负责的区域。</p><p>但是随着最近面试难度的不断提升，再加上有时候人手紧缺，需要前端部署应用的时候，也许我们需要掌握这些技能，所以，有备无患，我梳理一下以前不成体系的知识框架。</p><p>不过，nginx这东西么，其实更多的都是想起来再用，个人感觉有点像前端开发中的UI工具库，平时很少有人会记着怎么用，一直都是到了使用的时候现场翻书。</p><p>所以，我后续可能不会对nginx太过深入吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7267003603095879714">写给前端同学的Nginx配置指南</a></p><p><a href="https://juejin.cn/post/6844904041542221832">从原理到实战，彻底搞懂Nginx</a></p><p><a href="https://juejin.cn/post/6844904046789132301">从原理到实战，彻底搞懂Nginx（高级篇）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解cookie，sessionStorage，localStorage</title>
      <link href="/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/"/>
      <url>/2024/07/01/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3cookie%EF%BC%8CsessionStorage%EF%BC%8ClocalStorage/</url>
      
        <content type="html"><![CDATA[<p>Cookie、sessionStorage和localStorage这些都是面试中问烂的问题，这里统一整理一下，便于后续</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Cookie、sessionStorage和localStorage都是Web存储机制，用于在用户的浏览器中存储数据。</p><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><ul><li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li><li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li></ul><h4 id="cookie-重要的属性"><a href="#cookie-重要的属性" class="headerlink" title="cookie 重要的属性"></a>cookie 重要的属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name&#x3D;value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td>**指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘**。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table><h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</strong></li></ul><p><img src="https://s2.loli.net/2024/07/01/cMNzOIbCZAT63LD.png" alt="QQ截图20240701225448"></p><h3 id="什么是localStorage"><a href="#什么是localStorage" class="headerlink" title="什么是localStorage"></a>什么是localStorage</h3><p>localStorage（本地存储） 允许你访问一个Document 的远端(Origin)对象的Storage；</p><p>Storage:Web Storage API的接口，Storage提供了访问特定域名下的会话存储(session storage)或本地存储(local storage) 的功能，例如可以添加、修改或删除本地存储的数据项。</p><p>localStorage 类似于sessionStorage。</p><p>localStorage：没有时间限制的数据存储，</p><p>seesionStorage：针对一个 session的数据存储即当页面会话结束，也就是说当页面被关闭时，数据存储在seesionStorage会被清除。</p><p>tips：无论数据存储在localStorage 还是sessionStorage，它们都特定于页面的协议，对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>localStorage相对于cookie，存储量大，一般的浏览器大概在PC在4M左右，手机端在2M左右</li><li>存储数据是永久的</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性</li><li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换</li><li>localStorage在浏览器的隐私模式下面是不可读取的</li><li>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>localStorage不能被爬虫抓取到</li></ol><h4 id="localStorage与sessionStorage的区别"><a href="#localStorage与sessionStorage的区别" class="headerlink" title="localStorage与sessionStorage的区别"></a>localStorage与sessionStorage的区别</h4><p>localStorage与sessionStorage的唯一区别就是localStorage属于永久性存储。</p><p>sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空</p><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><p>上边提了localStorage与sessionStorage的区别，这里干脆把三者的区别放在一起比较。</p><h4 id="存储位置与大小限制"><a href="#存储位置与大小限制" class="headerlink" title="存储位置与大小限制"></a>存储位置与大小限制</h4><p><code>Cookie</code>，存储在客户端，即用户的浏览器中。由于Cookie是通过HTTP请求头在服务器和浏览器之间传输的，因此它们的大小有限制，通常不超过 4KB。大多数浏览器限制在20个，有的可能50个。</p><p> <code>sessionStorage</code>，也是存储在客户端的，但它是一个临时会话存储对象。sessionStorage没有严格的大小限制，但它仅在当前浏览器窗口或标签页中有效，并且当窗口或标签页关闭时，存储的数据会被自动删除。 </p><p><code>localStorage</code>，同样存储在客户端，并且提供了比Cookie更大的存储空间。一般来说，浏览器对localStorage的支持可以达到 5MB，这使得它可以存储更多的数据。</p><h4 id="数据有效期与持久性"><a href="#数据有效期与持久性" class="headerlink" title="数据有效期与持久性"></a>数据有效期与持久性</h4><p><code>Cookie，</code>可以设置过期时间，从而决定其在浏览器中的有效期。一旦过期，Cookie将被删除。</p><p> <code>sessionStorage</code>，数据在页面会话期间保持有效，当页面会话结束（例如关闭浏览器窗口或标签页）时，数据会被清除。它提供了一种在单个会话中跟踪用户数据的方式。</p><p> <code>localStorage</code>，存储的数据没有过期时间，它们会一直保留在浏览器中，直到被手动删除或清除缓存。</p><h4 id="与服务端的通信"><a href="#与服务端的通信" class="headerlink" title="与服务端的通信"></a>与服务端的通信</h4><p><code>Cookie</code>，会在每次HTTP请求中发送到服务器，因此它们可以用于在客户端和服务器之间传递数据。这种特性使得Cookie成为处理用户身份验证和会话管理的常用机制。</p><p> <code>sessionStorage</code> 和 <code>localStorage</code>，不与服务器的通信。它们主要用于在客户端存储数据，以便在后续的页面请求或用户交互中使用。</p><h4 id="数据共享与独立性"><a href="#数据共享与独立性" class="headerlink" title="数据共享与独立性"></a>数据共享与独立性</h4><p><code>Cookie</code>，对于同一域名下的网站，可以共享Cookie数据。</p><p> <code>sessionStorage</code>，数据在不同的窗口或标签页之间不共享。 </p><p><code>localStorage</code>，在整个浏览器实例中共享数据，无论打开多少个窗口或标签页，都可以访问到相同的localStorage数据。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>Cookie</code>，适用于需要在客户端和服务器之间传递小量数据的场景，如身份验证和会话管理； </p><p><code>sessionStorage</code>，适用于在同一浏览器窗口或标签页中存储临时数据的场景；</p><p> <code>localStorage</code>，则适用于需要在客户端长期存储大量数据的场景。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次仅仅只是简单的按照面试题标准说了一下这三者之间的区别，后续会专门出一篇内容，详细整理cookie与session在项目开发中的实际作用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904034181070861?searchId=202407012223169FB3FBAFB1729A23E3CC">傻傻分不清之 Cookie、Session、Token、JWT</a></p><p><a href="https://juejin.cn/post/7350143110495518770?searchId=202407012223169FB3FBAFB1729A23E3CC">Cookie、sessionStorage和localStorage的区别详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择入职公司</title>
      <link href="/2024/07/01/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%A5%E8%81%8C%E5%85%AC%E5%8F%B8/"/>
      <url>/2024/07/01/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%A5%E8%81%8C%E5%85%AC%E5%8F%B8/</url>
      
        <content type="html"><![CDATA[<p>以前一家公司做到底，从来没考虑那么多事，现在出来找工作找了这么久，真是大开眼界。</p><p>我这种大专崽没法指望好公司了，因为学历卡着根本进不去，不过相对来说，我还是可以考虑避免垃圾公司的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我不知道什么是好公司，但是我在各地被毒打了这么久，我一定知道什么是垃圾公司。</p><p>目前在江浙沪区域内找工作找了很久，这里根据之前我自己和朋友的经历，我做了个汇总，给大家做个参考打个样。</p><p>参考我的整理，也许你可以规避这些有问题的公司。</p><h3 id="危险标准"><a href="#危险标准" class="headerlink" title="危险标准"></a>危险标准</h3><p>如果你碰到大概情况如下，要谨慎考虑，也许你的工作可能就危险了。</p><ul><li>拖欠或克扣工资，这种基本上是小地方的，一般大城市不会有这种情况，但是如果您到了山穷水尽的地步，一定要小心这种情况了。</li><li>五险没有一金，这种小地方常用的计俩，不会给你交一金，不为你的长远做着想的公司，很常见</li><li>不超过试用期辞退，你各方面可能干的都很好，但是不超过试用期就会被辞退，这种情况在小地方也很常见</li><li>项目赶工，强制占用下班时间，不服从就开除。</li><li>人事变动频繁，如果你了解到一家公司人员变动频繁，大概率可能会有你意向不到的问题。</li><li>办公环境差，有的地方办公环境整个楼层没有厕所（厕所放在办公室内），要么是楼层高度只有2m1左右（我一抬头就能看到天花板，很压抑），又或者仅有一个办公室，没有任何会议室之类，开会时候，办公环境极为嘈杂。（这都是中小公司凑活办公环境的问题）</li></ul><h3 id="公司配置"><a href="#公司配置" class="headerlink" title="公司配置"></a>公司配置</h3><p>我这里默认大家都是常规水平的开发人员，所以大家找的基本上都是成熟稳定的中小公司，而非那种大公司或者巨型公司。</p><p>这里分享一下我的辨识标准。</p><h4 id="人员规模"><a href="#人员规模" class="headerlink" title="人员规模"></a>人员规模</h4><table><thead><tr><th>规模（人）</th><th>备注</th></tr></thead><tbody><tr><td>0-20</td><td>初创公司，如果注册资本较低，且团队内没有成熟的开发人员，不要去，因为外行指导内行，很痛苦。</td></tr><tr><td>20-99</td><td>初具规模的初创公司，团队配置初步齐全，应该有了一定的业务线。</td></tr><tr><td>100-499</td><td>较为成熟的中大型公司，在地区可能叫得上名字了，能进去最好，不过未来晋升有压力，很可能做到项目经理就到头了。</td></tr><tr><td>499-1000</td><td>外包，纯纯的外包，不然这类公司定然都是国内叫得上名字的龙头企业。</td></tr></tbody></table><h4 id="是否双休"><a href="#是否双休" class="headerlink" title="是否双休"></a>是否双休</h4><ul><li>双休，最好的选择，这种工作在如今的环境中值得极度珍惜，哪怕是工资稍微少一些，因为空余的事件你可以用来自我精进，社交，养家，只要你有了自己的时间，你就可以做很多事。</li><li>大小周，勉强可以接受，前提是日常加班要少，这样虽然稍微辛苦一些，但是至少时间上只要规划好，也不至于损失太多。</li><li>单休，那你要考虑你的身体是否年轻，这笔钱是否能补得上这段时间的身体损失，单休。</li><li>月休，这种我们称之为黑奴</li></ul><h4 id="五险一金"><a href="#五险一金" class="headerlink" title="五险一金"></a>五险一金</h4><ul><li>五险很重要，如果没有五险的长期工作，不要去。因为人难免保证自己的身体问题，五险中的医保最重要了，一旦出什么事，医保可以报销太多了。</li><li>一金就是公积金，这个较为重要，如果没有一金的公司，要么他的工资高于本地的平均水准，要么在其他方面的待遇能提上去。</li><li>缴费比例，如果按照当地最低工资缴，那也算是不失本分，如果按照满额缴费，那公司就是绝对的好公司了，一定要珍惜。</li></ul><h4 id="核心产品"><a href="#核心产品" class="headerlink" title="核心产品"></a>核心产品</h4><p>这里按照重要性进行排序，如果您有兴趣，可以按照自己的需求进行对比，看看自己进入的是哪条线。</p><ul><li>拳头产品，有数条盈利的项目线，为了同时兼顾这么多项目线，公司有自己的核心产品，这条线很少有外人进去</li><li>核心项目，活跃期的项目，特别挣钱，是领导最重视的一条线，甚至某种程度高于核心产品，尤其是在前中期，项目活跃，需要你维护项目的新特性和功能。</li><li>项目翻新，一些末期的项目因为技术栈的缘故，特别难以维护，于是公司想要进行翻新，这种项目如果你前期进入，成为核心的把控者，那么你未来说不定会进阶为这个项目的核心成员。一个项目从零开始的翻新，会有很多难以想象的经验，对于没经验的新手来说，这个项目经验很不错。</li><li>稳定项目，项目的稳定期，只是偶尔需要你维护处理一些BUG，虽然轻松，但是没什么晋升空间。</li></ul><p>以上，是个人和一些朋友闲聊之后，个人总览了所有人的项目经验得出的结论。</p><p>不过，这都是常规的公司项目，至于大厂的核心项目，那种一般都是凤毛麟角的天骄才会接触到，大多数普本大专，很难接触到那些大厂的核心项目。</p><h3 id="三不找"><a href="#三不找" class="headerlink" title="三不找"></a>三不找</h3><p>三不找，是我根据公司类型做的大致画像，如果你要进入以下类型的企业，请酌情考虑。</p><ul><li>临时工，纯恶心人的工作，没什么人权的工作。</li><li>外包，大多数没有什么团队主导权，主要去其他团队内做技术支持，项目做完会将人可能直接踢掉。</li><li>初创，比较赌运气，老板要是懂行的，就好做事，要是不懂行的，哪怕人好也不顶用。</li></ul><p>这三类工作基本上都是有坑的，不仅仅是因为工作性质的问题，更是因为待遇实在太过不人道。</p><p>当然，如果你当前真的是走投无路了，这三条路将会是你迫不得已的最后选择，没什么可挑的。</p><p>现在这个环境没什么好挑的，有个工作比什么都重要。</p><h4 id="外包"><a href="#外包" class="headerlink" title="外包"></a>外包</h4><p>是因为外包太过没有人权，前公司工作有些时候去其他公司做技术支持，待遇也就比外包好点，有时候看到一些纯正的外包连喝水都小心翼翼的。</p><p>说实话，这种感觉真是糟糕透顶，外包人员难道是劳改犯？连喝水都得小心？</p><p>这种不被当人的感觉，个中滋味我不好说，但是只要做过，懂的都懂。</p><p>不过现在大环境实在是烂，没有办法，可以先当一段时间黑奴，后续随着时间推移再看看吧。</p><h4 id="临时工"><a href="#临时工" class="headerlink" title="临时工"></a>临时工</h4><p>临时工其实就是外包的变种，只不过未必是专职的外包公司，公司明明白白的说着后续不会给你转正，就是让你干这三个月，就问你做不做。</p><p>之所以不找这种的，主要原因就是这些业务线太过赶工，在这个分秒必争的时间段里，过了几个月被裁员之后，说不定出来之后更难找，无异于饮鸩止渴。</p><h4 id="初创"><a href="#初创" class="headerlink" title="初创"></a>初创</h4><p>是指那些0-20人的团队规模，待遇看着像是画大饼，连稳定的业务线都没有的初创公司。</p><p>这里，我并非是指代所有的初创公司，如果注册资金水平高，或者公司的初创领导者具有相当的领导水准，可以尝试考虑加入，选择赌一把。</p><p>这种初创公司一旦起飞了，后续你就是功臣元老，一般不犯什么惊天大错，不会辞退你。</p><p>不过，大多初创公司的老板多数是脑子一热的外行突然进场耍耍，要么是有些人不甘心想创业翻身。</p><p>初创公司太过于草莽，如果薪资给高了，那么平时工时就很恶心了，如果工时不夸张，那么就是薪资跟不上，如果各方面都能跟得上，那你要小心了，一旦老板说要拖工资，立刻跑路。</p><p>总之，不够稳定，是初创公司的最大的问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多人都整理了技术类的文档，但是很少有人去整理这些基础的找工作教程。</p><p>不过，很多人大概一路很顺，从校招开始就没有变过，类似我这种疯狂的经历，怕是很少。</p><p>如果我中间没什么变动，想来也不会写出这篇文档，想想我这一路，有时候真有种造化弄人的感觉。</p><p>这两年环境是如此艰难，技术上的卷似乎很大程度已经无法再获得更高的成就。</p><p>人生路远，且行且珍惜。于此，我浅浅将自己的部分经历写出，希望能帮到一些初入职场的新人。</p><p>祝大家人生一路精彩，安好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解前端各种像素，em，rem等概念</title>
      <link href="/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/06/30/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%90%84%E7%A7%8D%E5%83%8F%E7%B4%A0%EF%BC%8Cem%EF%BC%8Crem%E7%AD%89%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>前端经典的em,rem，还有像素概念的问题，我发现很多说法都不统一，怎么说的都有，搞得我都有点不好抄统一的面试回答了。</p><p>干脆这里结合自己的理解，统一整理下，以便防止面试时候混乱。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于像素问题，几乎提到移动端适配这方面，这些基础概念就是在面试中绕不开的。</p><p>看了很多面试中都提到相关的问题，各种说法混乱无比，索性自己这里一把梭，把所有的概念都整理一下。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>我们实际开发中常说分辨率，但开发中说的内容可能指向的是不一样的内容。</p><h4 id="物理分辨率"><a href="#物理分辨率" class="headerlink" title="物理分辨率"></a>物理分辨率</h4><p>指的是显示屏的最高分辨率，又称标准分辨率。</p><p>屏幕实际存在的像素行数乘以列数的数学表达方式，是显示屏固有的参数，不能调节，其含义是指<strong>显示屏最高可显示的像素数</strong>。</p><p>我们实际使用过程，分辨率是可以改变的，比如我们手动将1920 * 1080的屏幕换成1600 * 900的分辨率，屏幕会按照你调整的要求，重新将屏幕切割为1600 * 900的像素点阵，形成新的分辨率。</p><p>不过，此时屏幕实际的物理分辨率依然还是1920 * 1080，这是屏幕自己固有的设备像素大小，并非我们可以手动调整的。</p><p>我们平时说的时候习惯性的说的分辨率，多数情况下都是指代最高分辨率，没什么人提你当前屏幕的分辨率是多少。</p><h4 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h4><p>正常来说，像素越大肯定是越清楚，但是这前提是要加个限定条件，那就是屏幕实际的大小要一样。</p><p>不然，物理分辨率同样是1920 * 1080的屏幕，一个尺寸是32寸，一个屏幕是100寸，实际显示效果确实一样的话，这怎么可能呢？</p><p>这里，就要引入一个概念：<strong>像素密度，ppi（pixels per inch）</strong>。</p><p>像素密度，表示沿对角线每英寸长度的像素数目（单位是dpi），越大显示的越细腻。</p><p>通过上边的例子，我们应该很快就能明白，像素密度的含义。</p><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p><strong>物理像素</strong>(px:physical pixel)又可以称为<strong>设备像素</strong>(dp:device pixel)</p><p>我们以实际设备屏幕举例，我们说的1920 * 1080的屏幕，实际上就是在说：宽度方向有1920个像素点，长度方向有1080个像素点。</p><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><blockquote><p>设备尺寸 × 像素密度 &#x3D; 物理分辨率（设备像素）</p></blockquote><p>这里举个例子：</p><p>iphone6s 对角线长度为5.5 英寸，像素密度401 dpi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。</p><p>5.5 * 401 &#x3D; 2205.5</p><p>这里说明白了这三者的关系，我们才好说明白接下来CSS的像素概念，即逻辑像素。</p><h3 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h3><p>CSS 的像素单位，其尺寸大小是相对的，也有称其为独立像素的，这里为了避免大家混乱，下边统一称呼CSS的像素为逻辑像素。</p><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p>提到<strong>逻辑像素(logical pixel)<strong>，也可以称为</strong>设备独立像素(dip : device independent pixel）</strong>。</p><p>当然，这两个名词我们大多数开发者可能都会陌生，实际上这里就是我们平常用到的CSS样式的像素单位。</p><h4 id="物理像素与逻辑像素的关系"><a href="#物理像素与逻辑像素的关系" class="headerlink" title="物理像素与逻辑像素的关系"></a>物理像素与逻辑像素的关系</h4><p>很多人这时候估计平时没有遇到过相关概念，所以一时间会有些懵，难道物理像素和逻辑像素有什么不同吗？难道我写了个100 * 100 的box，在小屏幕上就不是100 * 100了？</p><p>答案是：不是的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比武我们这里写了一个100 * 100的box，假设在物理分辨率为100*100的屏幕上，它以100 * 100的方式展示，1个逻辑像素，用1 * 1个物理像素来表示。</p><p>而在 400 * 400 的屏幕上，我们同样让这个BOX达到充满屏幕的效果，那就需要4 * 4个物理像素来表示。</p><p>后者因为用更多的物理像素来展示，所以看起来更清晰，更精细。</p><h4 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h4><p>我上边这个例子说的有个问题，为什么在有点屏幕上要以物理像素：css逻辑像素 &#x3D; 1 ：1 的比例展示，有的要以 4： 1的概念展示呢？</p><p>这里要引入一个概念：<strong>设备像素比（dpr : device pixel ratio）</strong>。不过这个说法也很混乱，我看很多整理的说法，有的说缩放比，也有说缩放因子的。</p><p>实际上，这就是物理像素与逻辑像素的比例概念。</p><p>我们这里为了接下来不混淆概念，统一就叫设备像素比。</p><p>1个css的逻辑像素，用更多的物理像素表示，那当时是比例越高，越清晰喽，如下例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标清屏：dpr = 2 / 2 = 1</span><br><span class="line">高清屏：dpr = 4 / 2 = 2</span><br></pre></td></tr></table></figure><p>因此，设备像素比越高，我们看到的网页也就越清晰，这也是为什么有时候我们看到有些手机实际屏幕很小，但看到页面的效果却很清晰。</p><p>屏幕虽小，但是实际物理分辨率和大屏一样，因此同样的网页，在更高的设备像素比的设备上显然看着更清晰，更细腻。</p><p>我们经常在设计师手中拿到的UI稿件，肯定会看到@1X，@2X，@3X，实际上就是这个就是指设备像素比。</p><blockquote><p>tips：逻辑像素相对于设备像素的放大比例，可通过window.devicePixelRatio获得，pc上可以用个个性化来设置，但二者并不完全等同。</p></blockquote><h4 id="禁用缩放"><a href="#禁用缩放" class="headerlink" title="禁用缩放"></a>禁用缩放</h4><p>提到上边的设备像素比的概念，有人可能会有疑问，按照这么说，岂不是我把页面用手势捏一下，就能改动页面的设备像素比？</p><p>是的，用户在移动端可以随意通过手势缩放网页，为了防止用户随意控制，我们便有了如下的操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">width // 设置 viewport 的宽度，正整数/字符串 device-width</span><br><span class="line">height // 设置 viewport 的高度，正整数/字符串 device-height</span><br><span class="line">initial-scale // 设置设备宽度与 viewport大小之间的缩放比例，0.0-10.0之间的正数</span><br><span class="line">maximum-scale // 设置最大缩放系数，0.0-10.0之间的正数</span><br><span class="line">minimum-scale // 设置最小缩放系数，0.0-10.0之间的正数</span><br><span class="line">user-scalable // 如果设置为 no 用户将不能缩放网页，默认为 yes，yes / no</span><br></pre></td></tr></table></figure><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>因为不同设备的的dpi不同，有时候PC上看上去非常正常的页面，放在手机端可能就显得不正常。</p><p>为了做各端的适配，于是前端衍生出了一种概念，相对单位。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>上面提到，想让我们的网页在不同分辨率的设备（移动端）上正常显示，最好我们的元素长宽，外边距，内边距等都是动态的。</p><p>上面说到，我们在移动端一般这样设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width;initial-scale=1&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这个时候我们1px的大小就已知，iPhone6上为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1px</span> = <span class="number">1</span>/<span class="number">750</span>（分辨率） * <span class="number">2</span>（设备像素比） = <span class="number">1</span>/ <span class="number">375</span>。</span><br></pre></td></tr></table></figure><p>既然1px的大小固定了，那么我们只能动态改变一个元素设置的px了，比如说在iPhone8上是120px；而在iPhone6上需要是100px。</p><p>这时候我们可以用js去动态计算，根据屏幕大小。</p><p>但是显然很麻烦，需要对每一个元素的长宽，内边距，外边距都需要调整，这显然是一个巨大的工程。</p><p>这时候我们就可以用到em这个单位了，em单位的名称为相对长度单位，是根据它父元素的字体大小来计算的。</p><p>一般默认情况下：16px &#x3D; 1em，这里要插一嘴，有的远古面试官经常会问：为什么1em要等于16px？</p><blockquote><p>因为浏览器默认的字体大小都是16px，所以没有重新设置浏览器默认字体大小的话1em就等于16px。</p><p>在页面里要用到em作为单位的话，默认的<code>1em=16px</code>会使得在计算他们转换的值时非常不方便，比如我要把一个块里面的内容字体大小设置成18px，但我只想用em做为单位，那么情况就会这样，<code>1em=16px，1px=0.0625em</code>，得<code>18px=1.125em（0.0625em*18）</code>。</p><p>这太麻烦，所以为了简化px和em之间的换算，需要在body里定义<code>font-size:62.5%</code>，即将浏览器初始化为即<code>1em=10px</code>，这样的话，上面的<code>font-size:18px</code>就等于<code>font-size:1.8em</code>。</p></blockquote><blockquote><p>计算公式：1&#x2F;父元素font-size值*需要转换的px&#x3D;em值    (PS:父元素font-size的单位没有关系，无论px还是em)</p></blockquote><p>这是早期的适应方式，当所有单位都采用em时，我们只需要改变body的 font-size，那么其他子元素宽度就能动态变化了，显然方便很多。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem是CSS3新增的一个相对长度单位，它的出现是为了解决em的缺点，em可以说是相对于父级元素的字体大小，当父级元素字体大小改变时，又得重新计算。</p><p>rem出现就可以解决这样的问题，rem只相对于根目录，即HTML元素。</p><p>有了rem这个单位，我们只需要通过JS调整根元素html的font-size就能达到所有元素的动态适配了，这里附上一段常用适配代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ================================================</span></span><br><span class="line"><span class="comment">    *   设置根元素font-size</span></span><br><span class="line"><span class="comment">    * 当设备宽度为375(iPhone6)时，根元素font-size=16px; </span></span><br><span class="line"><span class="comment">    × ================================================</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">doc, win</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = win.<span class="property">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="keyword">var</span> resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> refreshRem = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientWidth = win.<span class="property">innerWidth</span></span><br><span class="line">                      || doc.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line">                      || doc.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clientWidth)</span><br><span class="line">    <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> fz;</span><br><span class="line">    <span class="keyword">var</span> width = clientWidth;</span><br><span class="line">    fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!doc.<span class="property">addEventListener</span>) <span class="keyword">return</span>;</span><br><span class="line">  win.<span class="title function_">addEventListener</span>(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">refreshRem</span>();</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">document</span>, <span class="variable language_">window</span>);</span><br></pre></td></tr></table></figure><h4 id="vh，vw"><a href="#vh，vw" class="headerlink" title="vh，vw"></a>vh，vw</h4><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。</p><p>vw 始终是针对窗口的宽，同理，<code>vh</code>则为窗口的高度。</p><p>这里的窗口分成两种情况</p><ul><li>在桌面端，指的是浏览器的可视区域</li><li>移动端指的就是布局视口</li></ul><p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素，而<code>vw</code>、<code>vh</code>相对的是指代当前窗口。</p><h3 id="适配方案分析"><a href="#适配方案分析" class="headerlink" title="适配方案分析"></a>适配方案分析</h3><p>无论是哪种方案，本质上都是为了解决移动端适配的问题。</p><p>这里本来打算自己整理一下各种方案的优劣，没想到有人已经整理好了，而且非常详尽：<a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a>。</p><p>虽然是数据大屏的方案整理，但是已经够用了。</p><table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>vw vh</strong></td><td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td><td>1.可以动态计算图表的宽高，字体等，灵活性较高 2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td><td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td></tr><tr><td><strong>scale</strong></td><td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td><td>1.代码量少，适配简单 2.一次处理后不需要在各个图表中再去单独适配</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况  2.当缩放比例过大时候，字体会有一点点模糊，就一点点  3.当缩放比例过大时候，事件热区会偏移。</td></tr><tr><td><strong>rem + vw vh</strong></td><td>1.获得 rem 的基准值 2.动态的计算<code>html根元素的font-size</code> 3.图表中通过 vw vh 动态计算字体、间距、位移等</td><td>1.布局的自适应代码量少，适配简单</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些基础概念，如果不是深入研究移动端适配的人，应该不会去深入了解，毕竟这都算是以前的老古董知识了。</p><p>实际开发中，移动端大多数中小厂商为了节省成本，应该是用Uni-app一把梭，直接用rpx完成移动端单位的适配。</p><p>甚至有些项目为了图省事的，直接用px糊弄了事，很少有人去实际操心适配的问题，毕竟多数都是为了赶工期。</p><p>这里今天整理一下，也算是梳理以前有些混乱的知识体系，把以前脑海中各种混乱的名称做了个整合，心情也算是颇为舒畅。</p><p>不过，关于移动端的适配，我这里只是浅浅聊了一下，后续有时间会逐步整理相关的知识，防止面试官去面试这些乱七八糟的考验广度的面试题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="px/em/rem%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8">px&#x2F;em&#x2F;rem的区别与应用</a></p><p><a href="https://juejin.cn/post/7125603588084072455?searchId=2024063013543065534144521E4587DF9D">【CSS】一文搞懂 em、px、rem、vh、vw 的区别！</a></p><p><a href="https://blog.csdn.net/qq_30811721/article/details/106326253">px&#x2F;em&#x2F;rem的关系与区别_不同分辨率的设备上,1px的大小是不一样的-CSDN博客</a></p><p><a href="https://juejin.cn/post/7163932925955112996">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速，工具文档托管</title>
      <link href="/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/"/>
      <url>/2024/06/28/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3%E6%89%98%E7%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>开发过程中，我们经常会整理一下业务文档或者工具文档供团队参考使用，这就是简单的前端基建工程。</p><p>以前是由公司运维来处理这活，现在脱离团队了，只能自己来了，正好这块不熟悉，统一整理一下吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次记录算是一个面向新手的简化版教程，这里默认大家都有一台服务器，一个简单的前端页面，都会用各自的SSH工具。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>为了保证大家都能顺利走完流程，这里先列一下需要用到的东西。</p><h4 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h4><ol><li>优先双核的服务器，虽然单核凑活也能用，但是如果同时访问人数一旦较多，单核的效率很容易产生卡顿，所以还是双核比较好</li><li>优先香港或者亚洲区服务器，不然域名绑定的时候，大陆服务器需要服务器备案，来回走流程会很麻烦</li><li>优先选择linux服务器，因为便宜，环境干净，而且相关的教程很多。当然，你也可以选择window服务器，不过同样的配置，window服务器更贵，且win系统因为自带图形界面，所以相对系统会吃掉更多的硬盘空间，所以，普遍推荐linux服务器。</li><li>优先选择腾讯云的服务器，控制台更简单更好操作，虽然安全配置不高，但是效果不错。如果经济条件允许，可选阿里云，会比腾讯云稍微贵一些。</li><li>新用户优先购买长期，所有的服务器供应商都喜欢新用户，优惠力度最大，如果你是新用户购买，能买多久就买多久，最好选个四核的，四核服务器甚至可以用来部署一些游戏的私服，并且体验相当不错。</li></ol><h4 id="SSH工具"><a href="#SSH工具" class="headerlink" title="SSH工具"></a>SSH工具</h4><p>SSH工具就是能够让你在本地电脑访问云服务器的工具。</p><p>因为linux不需要什么图形化界面，所以很多人都喜欢用SSH工具直连服务器，通过命令行操作。</p><p>我个人推荐<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，个人觉得它比FinalShell，Xshell，PUTTY这三个工具好用。</p><p>不过mobaxterm的免费版的连接数有上限，只能存10个服务器地址，如果一个人需要管理很多服务器，要么付费要么换一个吧。</p><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>一个有着<code>index.html</code>的前端页面，当然，名字并非是强制要求，只是大家都习惯了，于是约定俗成的以<code>index.html</code>为准。</p><h3 id="Nginx服务器安装"><a href="#Nginx服务器安装" class="headerlink" title="Nginx服务器安装"></a>Nginx服务器安装</h3><p>我们暂时先别管什么是Nginx，我们只要配置好Nginx，后续就可以将配置托管到服务器上。</p><p>服务器系统推荐centOS7.6，虽然这个版本的系统有点老，但是折腾的人最多，所以遇到什么问题都能找到对应的解决方案。</p><p>这里需要略懂一点linux的常规操作，如果不清楚的，推荐看文：<a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a>，这篇文章介绍的流程要比我目前的操作详细的多，我这里只是简洁版。</p><h4 id="vim编辑nginx-repo"><a href="#vim编辑nginx-repo" class="headerlink" title="vim编辑nginx.repo"></a>vim编辑nginx.repo</h4><p>输入以下指令，然后按回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>按<code>i</code>键进入编辑模式，底部出现“插入”则说明成功进入编辑模式</p><p>复制以下代码，粘贴进去（注意别用ctrl+v粘贴，在finalshell里点击鼠标右键，然后选择粘贴）</p><p>注意每行开头不能有空格，否则可能会报错（vim编辑器不适用左键改变光标位置，可以通过上下左右控制）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nginx-stable]</span></span><br><span class="line"><span class="attr">name</span>=nginx stable repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[nginx-mainline]</span></span><br><span class="line"><span class="attr">name</span>=nginx mainline repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p> 复制完确认没问题后，点击键盘上的esc退出编辑模式，然后输入:wq保存并退出 Vim 编辑器（注意输入法一定要是英文模式，不要因为<code>:</code>的中英文区别报错）</p><h4 id="输入指令安装nginx"><a href="#输入指令安装nginx" class="headerlink" title="输入指令安装nginx"></a>输入指令安装nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><h4 id="安装完之后查看nginx状态"><a href="#安装完之后查看nginx状态" class="headerlink" title="安装完之后查看nginx状态"></a>安装完之后查看nginx状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>如果控制台报的命令如下，这个说明nginx已经安装成功，但是未启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-5-centos#systemctl status nginx</span><br><span class="line">nginx.service -nginx-high performance web server</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)</span><br><span class="line">Active:inactive(dead)</span><br></pre></td></tr></table></figure><p>现在启动一下nginx，启动后再次查看nginx状态，出现active (running)说明启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p>查看80端口是否被nginx占用，然后在浏览器地址栏直接访问你的公网ip地址，如果出现nginx提示，则说明nginx已经配置OK。</p><blockquote><p>注意，80端口是http协议的默认端口，如果你没有配置好<code>https</code>，这里外部访问的时候，记得要用<code>http:// </code>开头访问，否则会访问无效。</p></blockquote><h3 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h3><p> 在你的电脑上新建一个文本文档，重命名为nginx.conf，用记事本打开，然后把以下内容粘贴进去</p><p>这里注意配置重点，下边这个配置是让你的目录设置，是为了让外部访问目录能指向你的服务器文件位置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/index.html</span><br></pre></td></tr></table></figure><p>就比如我上边用locahost本地的访问的<code>/index.html</code>，这个按照下方配置后，就是访问<code>/usr/local/dist/index.html</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /usr/local/dist<span class="comment">;</span></span><br><span class="line">    index index.html<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>root配置根目录，index配置入口文件。</p><p>打包好的文件需要放到usr下的local文件夹内，我这边前端打包生成的文件是dist,所以root配置为&#x2F;usr&#x2F;local&#x2F;dist。</p><p>我这里需要配置两个文档托管，于是就采用了根据次级域名转换到不同文件目录的方式，根据次级域名（也有叫二级域名的）不同而指向不同的资源，从而访问不同的内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line">user nginx<span class="comment">;</span></span><br><span class="line">worker_processes auto<span class="comment">;</span></span><br><span class="line">error_log /var/log/nginx/error.log<span class="comment">;</span></span><br><span class="line">pid /run/nginx.pid<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user <span class="section">[$time_local]</span> &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    sendfile            on<span class="comment">;</span></span><br><span class="line">    tcp_nopush          on<span class="comment">;</span></span><br><span class="line">    tcp_nodelay         on<span class="comment">;</span></span><br><span class="line">    keepalive_timeout   65<span class="comment">;</span></span><br><span class="line">    types_hash_max_size 2048<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types<span class="comment">;</span></span><br><span class="line">    default_type        application/octet-stream<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  cattools.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/dist<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line">        server_name  lintdoc.crazystudent13.cn<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">          root /usr/local/lintdoc<span class="comment">;</span></span><br><span class="line">          index index.html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">40</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html<span class="comment">;</span></span><br><span class="line">            <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers PROFILE=SYSTEM;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        location / &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入&#x2F;etc&#x2F;nginx目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br></pre></td></tr></table></figure><p>将目录下原有的nginx.conf拷贝一份（注意刷新一下才会显示）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> nginx.conf nginxCopy.conf</span><br></pre></td></tr></table></figure><p>备份旧配置（这一步不是必然，但是出于运维的好习惯，凡事留备份）</p><p>删除目录下的nginx.conf，然后将本地电脑上的nginx.conf上传到目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f nginx.conf</span><br></pre></td></tr></table></figure><h3 id="重启发布"><a href="#重启发布" class="headerlink" title="重启发布"></a>重启发布</h3><p>将静态文件发布到<code>/usr/local</code>目录下，因为我们直接配置的是dist文件夹，这里我们需要将dist整个文件夹发到<code>/usr/local</code>目录下。</p><p>发布完成之后，重启nginx，读取新的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>为了保险，我们可以查看一下发布之后的效果，有绿色的（active）代表发布成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>将下方的ip地址替换为自己的服务器地址，就可以访问到自己发布的前端页面了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip地址/index.html</span><br></pre></td></tr></table></figure><p>如果不想要用IP地址在外访问，我这里就用二级域名绑定了自己服务器IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://cattools.crazystudent13.cn</span><br><span class="line">http://lintdoc.crazystudent13.cn</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为前端基建的必然基石，像这种通用的工具文档部署是必然的需求。</p><p>团队化作战的过程中，我们肯定会在现代开发过程中遇到部署这些文档，这是一件绕不开的事。</p><p>这次是一次简单的部署，后续会持续集成，完成自动化部署的流程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7242502779469692984">十分钟教会你—从购买服务器到部署前端网页（适合新手或前端小白，云服务器可白嫖）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解link与import的区别</title>
      <link href="/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/27/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3link%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>朋友：最近听说你在整理面试题？那我考考你，css样式的引入，link和import有什么区别？</p><p>我：你他妈疯了？这哪怕是五年前也是很少有人问到的，现在都是直接打包压进去的，你问我这个？</p><p>朋友：这关系到你的基础牢不牢靠，万一面试官问了呢。</p><p>我：你他妈就是一个大傻逼。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>尽管这道面试题是五年前的老古董了，这个问题放在五年前都是冷门问题。</p><p>在当初已经盛行前端工程化的时代了，这种问题实在是没有必要放在嘴边，样式都拆到项目里边了，谁管你最后是怎么引入的呢。</p><p>但是，问都问了，索性看看整理一下吧。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>二者毫无问都是引入CSS样式，我们没必要找什么共性，直接看看区别吧。</p><h4 id="从属关系"><a href="#从属关系" class="headerlink" title="从属关系"></a>从属关系</h4><ul><li>link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 </li><li>@import是 CSS 提供的语法规则，只有导入样式表的作用；</li></ul><h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><ul><li>link标签引入的 CSS 被同时加载；</li><li>@import引入的 CSS 将在页面加载完毕后被加载。</li></ul><h4 id="兼容性区别"><a href="#兼容性区别" class="headerlink" title="兼容性区别"></a>兼容性区别</h4><ul><li>link标签作为 HTML 元素，不存在兼容性问题。 </li><li>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；</li></ul><h4 id="DOM可控性区别"><a href="#DOM可控性区别" class="headerlink" title="DOM可控性区别"></a>DOM可控性区别</h4><ul><li>可以通过 JS 操作 DOM ，插入link标签来改变样式；</li><li>由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</li></ul><h4 id="权重区别"><a href="#权重区别" class="headerlink" title="权重区别"></a>权重区别</h4><p>link引入的样式权重大于@import引入的样式。（相同的类名或者标签名，而不是含有!important之类的才生效）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>尽管现在我们不怎么需要关注了，但有时候项目工程化打包会遇到二者优先度或其他问题，这里备注下。</p><blockquote><p>@import一定要写在除@charset外的其他任何 CSS 规则之前，如果置于其它位置将会被浏览器忽略。</p><p>而且，在@import之后如果存在其它样式，则@import之后的分号是必须书写，不可省略的</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>2024年了，还问这种问题的面试官就是纯纯的大傻逼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903890832326664?searchId=2024062719174374BA1A8A291721F074D7">link和@import的区别 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解域名等级</title>
      <link href="/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/"/>
      <url>/2024/06/24/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8D%E7%AD%89%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>我：买了个新服务器，又得买个域名挂靠了，有点太费钱，有没有什么好办法？</p><p>朋友：为什么要买新域名？用二级域名处理一下就可以了。</p><p>我：什么是二级域名？</p><p>朋友：远川同学，你这块的知识有点水啊，你要不去补一下，以后面试可有点够呛。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近刚买了一个服务器，本想买新域名挂在服务器上，然后和朋友说了一下，他说你可以用二级域名。</p><p>关于二级域名这种说法，以前工作中偶尔听到，当时都是由运维的朋友来处理，我很少操心这些事。</p><p>自考有关计算机网络原理的部分，并未提及相关内容，于是我自考中也没了解过相关知识。</p><p>幸亏被朋友点了我一下，不然要是被面试官问到了，那还是真是愧对我这五年经验。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><h4 id="什么是DNS解析"><a href="#什么是DNS解析" class="headerlink" title="什么是DNS解析"></a>什么是DNS解析</h4><p>先说DNS解析，我们浏览器输入域名，就可以直接渲染出我们需要的页面。</p><p>做前端的都是知道，这其中有一个很重要的步骤：域名解析，又叫DNS解析，域名解析就是由域名查找到 IP 的过程。</p><p>域名解析的工作由DNS服务器完成。</p><p>简单了来说，域名实际上就是一个IP的昵称，我们通过DNS服务器去打听这个昵称是哪个IP，最后锁定IP，然后访问对应的机器。</p><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>已知一个域名，先会访问根域的DNS服务器，全球一共有13台根域名服务器，根域名服务器储存了负责每个顶级域（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>拿到顶级域名服务器地址后，访问得到二级域名的域名服务器地址信息，以此类推，直到最终确定某个 IP 地址。</p><p>常见的解析方式有三种：A记录解析、CNAME记录解析、MX记录解析。</p><p>如果我们新增、减少了 DNS 解析记录，正常情况下的 TTL 是10 min。</p><h3 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h3><p>前边我们提到了域名的根服务器，这里详细解释下根域名的定义。</p><blockquote><p>根域是指整个互联网的最高层级，位于所有的顶级域名之上。</p></blockquote><p>它没有任何域名前缀，只有一个点号。</p><p>例如，在某些场合，<code>www.baidu.com</code>被写成<code>www.baidu.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p>根域由互联网的根服务器组成，这些服务器负责解析所有的顶级域名（如.com,.xyz,.cn,.ren,.top等）解析的域名服务器的地址信息。</p><p>理论上，所有<a href="https://cloud.tencent.com/act/pro/domain-sales?from_column=20065&from=20065">域名查询</a>都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p><p><strong>根域名服务器</strong>是 13个 固定 <strong>ip</strong> 所组成服务器群的简称，它保存的只是所有<strong>一级域名服务器</strong>的 <strong>ip</strong> 地址信息。</p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>顶级域名，也叫一级域名。</p><p>域名最后面的那一部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 .com 就是顶级域名，又叫一级域名。</p><p>顶级域名分为国际顶级域名、国家顶级域名。</p><h4 id="国际顶级域名（gTLD）"><a href="#国际顶级域名（gTLD）" class="headerlink" title="国际顶级域名（gTLD）"></a>国际顶级域名（gTLD）</h4><p>这里列举一下我们常见的域名，如下这种指向各种机构的域名，共有700多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.com</td><td>工商企业</td></tr><tr><td>.net</td><td>网络提供商</td></tr><tr><td>.org</td><td>非盈利组织</td></tr><tr><td>.gov</td><td>政府网站</td></tr><tr><td>.edu</td><td>教育机构</td></tr></tbody></table><p>为了解决域名紧张的问题，后来也引入了一些其他的顶域</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.firm</td><td>公司企业</td></tr><tr><td>.store</td><td>销售公司或企业</td></tr><tr><td>.web</td><td>突出WWW活动的单位</td></tr><tr><td>.arts</td><td>突出文化、娱乐活动的单位</td></tr><tr><td>.rec</td><td>突出消遣、娱乐活动的单位</td></tr><tr><td>.info</td><td>提供信息服务的单位</td></tr><tr><td>.nom</td><td>个人</td></tr></tbody></table><h4 id="国家顶级域名（ccTLD）"><a href="#国家顶级域名（ccTLD）" class="headerlink" title="国家顶级域名（ccTLD）"></a>国家顶级域名（ccTLD）</h4><p>另一类是国别顶级域名（ccTLD），这种指向国家地域的域名，总共有300多个。</p><table><thead><tr><th>域名</th><th>指向</th></tr></thead><tbody><tr><td>.cn</td><td>中国</td></tr><tr><td>.us</td><td>美国</td></tr><tr><td>.jp</td><td>日本</td></tr><tr><td>.cc</td><td>科科斯群岛</td></tr></tbody></table><h3 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h3><p>一级域名左侧的部分，比如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a>。 baidu 就是二级域名。</p><p>国际顶级域名下二级域名，一般是指域名注册人选择使用的网上名称，如：<a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 中的 baidu 。</p><p>国家顶级域名下二级域名，一般是指类似于国际顶级域名的表示注册人类别和功能的标志，例如com，edu，gov，net等如：<a href="https://link.juejin.cn/?target=https://www.moe.gov.cn">www.moe.gov.cn</a> 中的 gov，其实可以发现 <a href="https://link.juejin.cn/?target=https://www.baidu.com.cn">www.baidu.com.cn</a> 也是可以访问到的，这个时候的二级域名就是 .com ，但是会被重定向到 <a href="https://link.juejin.cn/?target=https://www.baidu.com">www.baidu.com</a> 。</p><p>这里的二级域名并不是朋友说的二级域名，这里的二级域名，实际上是我们买的域名，譬如我个人的博客域名：<a href="https://crazystudent13.cn/">crazystudent13.cn</a>，这里的crazystudent13就是二级域名。</p><h3 id="三级域名"><a href="#三级域名" class="headerlink" title="三级域名"></a>三级域名</h3><p>三级域名可以当做是二级域名的子域名，比如：<a href="https://link.juejin.cn/?target=https://naotu.baidu.com">naotu.baidu.com</a> ，对于使用者而言，三级域名都是二级域名的附属物而无需单独费用，四级域名等依次类推即可。</p><p>又如：<a href="https://link.juejin.cn/?target=http://www.neea.edu.cn/">www.neea.edu.cn</a> 中的 neea (教育考试网)。</p><p>所以严格意义上，朋友说的二级域名的说法是不对的，正常的来说，应该是三级域名了，也有说法叫次级域名。</p><h3 id="域名风险"><a href="#域名风险" class="headerlink" title="域名风险"></a>域名风险</h3><p>这个知识属于拓展了，因为我们偶尔访问一些页面失效的时候，经常会听网上传言说是DNS污染或者DNS劫持。</p><p>那这里干脆顺便讲一下，就当是相关知识拓展。</p><h4 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h4><p>DNS又称<strong>域名服务器缓存投毒</strong>，是指一些刻意制造或无意中制造出来的域名服务器数据包，把域名指往不正确的IP地址。</p><p>一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。</p><p>简单的来说，就是域名服务器内IP和域名的指向被其他人投了错误的数据包，导致指向错误了，就像一个人的昵称和本人对不上，这样自然会导致访问错误。</p><p>一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。</p><p>这种污染基本上是大范围的，批量的，并不是针对某个网站，而是某片网域的污染。</p><p>通常对于DNS污染，一般除了使用代理服务器和VPN之类的软件之外，我们并没有什么还办法，大多数人只能干等域名供应商将污染的数据恢复。</p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>了解了域名的一些知识，我们经常听到的一个名词：域名劫持（DNS 劫持）。</p><p>正常的流程应该是我们根据域名，访问正确的 DNS 解析服务器来获取我们最终的 IP。但如果让用户访问到的错误的 DNS 解析服务器上，返回错误的 IP，让用户展示攻击者指定的页面，这就是域名劫持了。</p><p>经典案例就是有的年久不用的网站，被他人恶意劫持，指向了某个黄色网站，这类事情发生的很多，尤其是国内很多政府网站，早年没有什么网安，也没人关注这类门面网站，发生这种事很常见。</p><p>相对于DNS污染那种大范围破坏来说，DNS劫持目标更单一，就是针对某个网站的恶意行为。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个不算面试题，只是个普通知识拓展，后续随着计算机网络知识的了解，会不断丰富相关知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904192868352007">域名等级、DNS域名解析</a></p><p><a href="https://cloud.tencent.com/developer/article/1147777">根域名的知识</a></p><p><a href="https://developer.baidu.com/article/detail.html?id=2594936">域名解析：顶级域名、根域&#x2F;二级域名、一级域名&#x2F;子域名解析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决git SSL certificate problem</title>
      <link href="/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/"/>
      <url>/2024/06/24/%E8%A7%A3%E5%86%B3git-SSL-certificate-problem/</url>
      
        <content type="html"><![CDATA[<p>提交项目代码到github上的时候，突然就报了这个问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实是个很简单的问题，只是以前没遇到过，所以不知道怎么处理。</p><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>这个错误表明Git在尝试通过HTTPS进行通信时，遇到了SSL证书验证问题。</p><p>具体来说，Git客户端无法获取到用于验证本地颁发者证书的信息。</p><p>这通常发生在Git客户端没有正确配置或者没有本地证书文件的情况下，尤其是在自签名的证书或者是过期的证书文件缺失的情况下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git SSL certificate problem: unable to get local issuer certificate</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一：忽略验证"><a href="#方案一：忽略验证" class="headerlink" title="方案一：忽略验证"></a>方案一：忽略验证</h4><p>使用Git的配置选项来忽略SSL证书验证（不推荐，因为这会降低通信的安全性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><h4 id="方案二：更新CA证书库"><a href="#方案二：更新CA证书库" class="headerlink" title="方案二：更新CA证书库"></a>方案二：更新CA证书库</h4><p>确保系统中安装了正确的CA证书。</p><p>在Linux系统中，你可以通过更新CA证书库来解决问题。</p><p>如果是自签名的证书，你可以将服务器的证书添加到Git的信任列表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslCAInfo /path/to/certificate.pem</span><br></pre></td></tr></table></figure><p>如果你使用的是代理服务器，请确保代理服务器的SSL证书是有效的，或者配置Git以跳过代理的SSL验证。</p><p>更新Git到最新版本，以确保包含最新的证书信息。</p><p>如果问题仍然存在，可以考虑使用SSH方式克隆或者拉取远程仓库，从而绕过HTTPS的SSL验证问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个常规的CA证书验证问题，但是平时很少遇到，所以这里记录一下，如果后续遇到，方便排查。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_44014995/article/details/109900149">解决：git SSL certificate problem: unable to get local issuer certificate</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年，第一回在徐州破防了</title>
      <link href="/2024/06/23/2024%E5%B9%B4%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%9C%A8%E5%BE%90%E5%B7%9E%E7%A0%B4%E9%98%B2%E4%BA%86/"/>
      <url>/2024/06/23/2024%E5%B9%B4%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%9C%A8%E5%BE%90%E5%B7%9E%E7%A0%B4%E9%98%B2%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>在徐州呆了快三个月，基本可以确定徐州就是一个根本不能待的垃圾城市。</p><p>自行车被偷只是我爆发的一个诱因，总的来说，破防的原因是多方面的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说实话，以前很多觉得无所谓的事情，在徐州这边真的是被成倍的放大。</p><p>我做梦都没想到徐州已经烂成这个样子了。</p><h3 id="中介套路深"><a href="#中介套路深" class="headerlink" title="中介套路深"></a>中介套路深</h3><p>到一个地方肯定要租房，因为对地方不熟，所以还是得找中介。</p><p>安居客上边的中介，放着好看的房照，然后实际带你过去，那地方烂的要死，这也是常态，没什么可说的。</p><p>按照套路，中介人又会带你看几个缺陷比较明显的房子，要么很贵，要么地方很偏，要么周围住宿人员素质低。</p><p>这时候肯定你会打听有没有性价比更高的房子，然后他会说平台上的房子已经没了，但他手里有一些房子，你有没有兴趣。</p><p>这也是熟悉的套路了，没啥好说的，然后跟着去看了一下。</p><p>说实话，他手里的这些房源一个比一个烂不说，他要价还特别不老实，和我目前住的地方差不多的水平，要价800，在徐州，这个水平多少有点坑人了。</p><p>然后连续看了几个，我感觉他介绍的房子都不行，然后我打算走了。</p><p>这时候，我没料到的套路来了，中介说他带我看了这么久，多少要有点辛苦费吧？不多，给个500就行。</p><p>我：？？？？不是，哥们儿这就是你的工作啊？我没看上你手里的房源，你还问我要幸苦费？你多少有点过了吧？</p><p>他还不是那种油腻中年人，就是普通的00后小年轻，这个态度几乎让我以为自己碰到了哪来的油腻中年人了。</p><p>我感觉自己遇到讹人的了，然后就打算报警，然后他又改口说自己这不算是辛苦费，就是一个推荐费，后续有好的房源还是回通知我的。</p><p>呵呵，多少有点不讲理了，为此差点和他掐了起来，说实话这是头一回在外边遭遇这种中介。</p><h3 id="城市基建极度不合理"><a href="#城市基建极度不合理" class="headerlink" title="城市基建极度不合理"></a>城市基建极度不合理</h3><p>从老城区到工作地方并不远，差不多近4公里，开车和骑车差不多要半小时才能到。</p><p>在人流量最大的地方，车道居然是双车道（火车站老城区大马路），这种环境，这样的通勤状态可想而知。</p><p>不仅如此，很多大型CBD根本没有合理的安排，周围的停车位，不说供机动车停了，电动车的停留位置都不够。</p><p>那肉眼可见的稀少车位，我都不知道设计者一开始是怎么想的。</p><p>每回上下班，看着停车位上一排排的电动车，简直难蚌。就这，密度还是小了，一栋楼近40层的楼到底能容纳多少人，这当时做规划估计也没人去算，现在周围就放这么点停车位，不知道的还以为是供苍蝇趴窝呢。</p><p>车道，停车位，还有之前提到的不合理的小吃街，更糟心的就是那稀少的公厕，河道两岸那些不明排泄物，到底是人还是狗排，懂的都懂。</p><p>新城区我还没去逛，本来打算骑自行车去的，这下自行车也丢了，简直把我整笑了。</p><h3 id="人流太杂"><a href="#人流太杂" class="headerlink" title="人流太杂"></a>人流太杂</h3><p>平均几步路一个足浴店，足浴店里边的姑娘挺年轻，这种还有二楼的，一眼看着就不是什么正经地儿我就不说了。</p><p>还有周围喧闹嘈杂的环境，老城区毕竟还是落寞了，我没什么好说的。</p><p>但是再怎么落寞，这街上还有打架的，还有那种撒泼的疯子（真的是神经不正常的那种疯）。</p><p>不过，也不全是这种人，也有很多漂亮的妹子，年轻的正经小哥。</p><p>大马路附近，大规模的待业工人在街上像是需要被挑选的牲口（可能我有些极端化了，但是说实话，当你看到这些人在阴凉地等工作的时候，真的就是这么个感觉）。</p><p>这种混杂的人员，给我一种莫名的荒诞感，徐州就是这么个朋克的城市吧。</p><h3 id="平均工资低"><a href="#平均工资低" class="headerlink" title="平均工资低"></a>平均工资低</h3><p>基本上大多数人的工资基本只能勉强够活。</p><p>根据目前的观察，3-4k是大多数人的常规工资，基本上只是是服务生一类的工作就可以做到。</p><p>如果高于4000，那么偶尔可以改善生活，如果高于5000，那么相对滋润一些。</p><p>高于6000，大概是人，勉强可以有一些娱乐的资本。</p><p>如果高于7000，大概就是T1，人上人的入门水准。</p><p>如果高于8000，那就是正经的人上人了。</p><p>虽然徐州整体物价低，但是我这个技术水平放在徐州居然只能值这个价格，真的挺浪费的。</p><h3 id="自行车被偷"><a href="#自行车被偷" class="headerlink" title="自行车被偷"></a>自行车被偷</h3><p>妈的，老子从老家骑车107公里，好不容易骑到徐州的车！！</p><p>这年头了居然还有人偷自行车，真他吗的神经病！</p><p>我就他妈的一天没锁车，车就丢了！！</p><p>奶奶的，以后再也不再徐州骑车了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以前还想着在外地钱差不多挣够了，就回老家买个差不多的房子，然后日子就定在这里，也不是不行。</p><p>这一猛子给我锤醒了，我这边再也不考虑在徐州这个地方落户了，这地方，狗都不呆。</p><p>从小到大的经历豁然间苏醒，我真是瞎了眼，对老家有这种滤镜。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解spa,ssr,seo</title>
      <link href="/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/"/>
      <url>/2024/06/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3spa-ssr-seo/</url>
      
        <content type="html"><![CDATA[<p>因为最近被一个新人模拟面试折腾的高血压又犯了，以前我是碰都不会碰这类基础面试题的，这种常识还有人不会？</p><p>结果还真有人不会，为了给新手开开眼，于是特意整理了这篇文档。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近有个刚入行的新手问我什么是SPA，我说就是单页面应用。</p><p>他又问什么是单页面应用，我寻思这是来考我了？</p><p>然后我就认真回了一下：就是一次加载前端所有资源，然后由前端的JS脚本来控制用户的交互行为。这样做的好处是可以在客户端处理掉所有的交互，减小服务器的压力，但是坏处是服务器做SEO时候，不好做数据抓取，相对于传统的SSR不太好。</p><p>然后，新人又问：什么是SEO?SSR不是抽卡吗，和这个有什么关系？</p><p>我：。。。你他妈的就是来找茬的？新生代的前端都这么没常识的吗？</p><h3 id="单页面应用（SPA）"><a href="#单页面应用（SPA）" class="headerlink" title="单页面应用（SPA）"></a><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">单页面应用（SPA）</a></h3><p>单页面应用这个面试题从我入行的时候就在问，因为那时候还是jquery刚刚倾倒的时刻，vue，ng，react三大框架刚刚兴起，对于那时候的人来说，这个概念很新鲜。</p><p>如今都他妈快5到6年了，还在问这个问题，我只能说社会进步还是挺缓慢的。</p><p>我这里懒得自己写定义了，引用一下vue官方的说法。</p><blockquote><p>一些应用在前端需要具有丰富的交互性、较深的会话和复杂的状态逻辑。</p><p>构建这类应用的最佳方法是使用这样一种架构：Vue 不仅控制整个页面，还负责处理抓取新数据，并在无需重新加载的前提下处理页面切换。</p><p>这种类型的应用通常称为单页应用 (Single-Page application，缩写为 SPA)。</p></blockquote><p>说的简单点，就是以前页面切换等操作，每次都需要向服务器发送请求，抓取新的页面资源，到了本地重新解析资源，压力都在服务器端。</p><p>为了缓解服务器的渲染压力，也为了开发提速，于是就有了单页面应用（SPA）的处理方式。</p><p>这样避免每次切换页面对服务端造成压力，也不需要前端页面在服务器渲染，进一步削弱了服务器的压力。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>减小了后端开发心智负担，使后端更专注业务开发，前端来处理交互逻辑。SPA必然伴随着前后端解耦，传统开发需要后端调试前端的写的页面逻辑，比如JSP交互，如今将交互逻辑分离出来，页面及跳转之类的交互逻辑全部由前端开发，使后端更专注于业务逻辑的开发。</li><li>增加开发速度，因为前后端逻辑解耦，各自负责自己的部分，可以并行安排开发任务，双方通过接口进行联调，相对于传统的开发模式，不需要后期全部由后端挑大梁。</li><li>减小对服务器的压力，SPA是一次性加载所有资源到本地，由用户本地的浏览器来处理交互逻辑，在后续的人机交互过程中，除了需要请求接口数据，几乎不需要请求大量的页面资源，也不需要再服务端渲染，故而极大程度的减小的服务器的压力。</li><li>页面之间的切换非常快，用户体验好。因为全部由前端处理交互，不需要过服务器的渲染，不会受限于服务器的性能造成处理问题，所以相对传统的服务器端渲染页面，SPA能够更快的完成前端页面交互效果。</li></ol><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，由此衍生出了很多首屏优化的要求。</li><li>不方便SEO。SEO是根据每个页面的固定内容进行抓取，而SPA是一次性加载所有资源，故而这种方式不利于SEO抓取。</li></ol><h3 id="搜索引擎优化（SEO）"><a href="#搜索引擎优化（SEO）" class="headerlink" title="搜索引擎优化（SEO）"></a>搜索引擎优化（SEO）</h3><p>既然提到了SEO，这里就先讲SEO。</p><p>这里引用一下百度百科给的定义，虽然百科不怎么正规，但是它这部分说的还是相对来说较为严谨的。</p><blockquote><p>SEO（Search Engine Optimization）：汉译为搜索引擎优化。</p><p>是一种利用<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/104812?fromModule=lemma_inlink">搜索引擎</a>的规则提高网站在有关搜索引擎内的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%8E%92%E5%90%8D/2092669?fromModule=lemma_inlink">自然排名</a>的方式。目的是让其在行业内占据领先地位，获得<a href="https://baike.baidu.com/item/%E5%93%81%E7%89%8C/235720?fromModule=lemma_inlink">品牌</a>收益。</p><p>很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。</p></blockquote><h4 id="搜索引擎工作原理"><a href="#搜索引擎工作原理" class="headerlink" title="搜索引擎工作原理"></a>搜索引擎工作原理</h4><p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。</p><p>随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。</p><p>反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。</p><p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。</p><p>在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。</p><p>这样一个过程我们称之为SEO。</p><h4 id="SEO与SEM的区别"><a href="#SEO与SEM的区别" class="headerlink" title="SEO与SEM的区别"></a>SEO与SEM的区别</h4><p>讲到两者的区别时候，先放一下SEM的定义，我看了一下百科的定义，个人感觉不够直白，这里自己干脆重写一下。</p><blockquote><p>SEM一般指竞价推广，在搜索引擎后台账户投钱，使广告获取相关的排名，一般搜索页面上会展现“广告”的标签。</p></blockquote><p>这里我们从不同维度去比较一下两者的区别。</p><table><thead><tr><th>维度</th><th>SEO</th><th>SEM</th></tr></thead><tbody><tr><td>关键词前置条件</td><td>需要网站有权重基础，小站无法做热词，不能随时增减关键词</td><td>不需要网站基础，任何关键词都可以投放</td></tr><tr><td>关键词收费</td><td>相对较低，随着SEO优化好，收费会降低</td><td>关键词越多，收费越高，随着同类站点竞争激烈，收费越高</td></tr><tr><td>见效时长</td><td>3-5月以上</td><td>立刻见效</td></tr><tr><td>持续性</td><td>停止SEO，效果可以持续很久</td><td>停止SEM，立刻失效</td></tr></tbody></table><p>如果你们老板实际开发官网，希望你能优化一下官网的SEO排名，我个人建议，在国内的话，直接找个靠谱的厂商去买关键字竞价吧。</p><p>现在搜索排名靠前的全部都是广告，搜不出什么正经的东西，你各种花里胡哨的操作，都不如直接去买关键字权重。</p><p>我之前呆的一家公司，甚至没做SSR的优化，直接用vue弄了个单页面应用，硬是靠着关键字排名砸到了前排，SEO总归是商业行为，技术角度总归只是辅助，了解一下就行。</p><p>当然，也并非说国内完全没有做seo的价值，详情可以参考这篇文：<a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a>，讲的很不错。</p><p>另外，在国内的网站最好还是备案一下，虽然<strong>备案不影响SEO的优化</strong>，但在国内有备案的网站终归更具有可信度。</p><h4 id="白帽SEO与黑帽SEO"><a href="#白帽SEO与黑帽SEO" class="headerlink" title="白帽SEO与黑帽SEO"></a>白帽SEO与黑帽SEO</h4><p>在市面上，按照各种操作行为，大致可以分为白帽SEO和黑帽SEO。</p><p><strong>白帽SEO</strong>：起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。</p><p><strong>黑帽SEO</strong>：利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。</p><p>我们常规的技术手段，大概就是白帽SEO，具体手段参考：<a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a>，实际开发过程中，我们主要做如下操作。</p><ol><li>SSR服务器渲染</li><li>预渲染prerender-spa-plugin</li><li>对网站的的title、description、keywords精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</li><li>网站内容优化：内容与关键字的对应，合理增加关键字的密度；</li><li>饰性图片必须加alt</li><li>在网站上合理设置Robots.txt文件；</li><li>语义化化的HTML代码，符合W3C规范</li><li>增加外部链接，到各个网站上宣传；</li><li>向各大搜索引擎提交收录自己的站点</li><li>少用iframe：iframe中的内容是不会被抓取到的</li></ol><p>详细的操作手段这里就不说了，我后续会专门整理一篇文档，毕竟从零开始弄一个网站，然后通过SEO优化打到前排这种操作我也没做过，公司都是直接用钱砸关键字权重的，只能说钱多任性。</p><p>后续我会尝试做个简单的玩具网站，试试能不能通过白帽SEO把排名打上去，如果打不上去，我这里介绍的再怎么花哨也没什么用。</p><h3 id="服务器端渲染（SSR）"><a href="#服务器端渲染（SSR）" class="headerlink" title="服务器端渲染（SSR）"></a>服务器端渲染（SSR）</h3><p>这里依旧放一下百度百科的定义。</p><blockquote><p>服务器端渲染（Server-Side Rendering）是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p></blockquote><p>SSR没什么好说的，就是传统的服务端页面，因为页面的接口都是在服务端完成拼接处理，当浏览器的请求资源的时候，已经是完整的DOM结构。</p><p>故而，SSR相对于传统的SPA更适合搜索引擎抓取关键字，所以SEO效果会更好。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了</li><li>更好的SEO，将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源</li><li>一些常用的浏览器API可能无法正常使用，比如<code>window</code>、<code>docment</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂</li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致</li></ol><h4 id="SSR常用框架"><a href="#SSR常用框架" class="headerlink" title="SSR常用框架"></a>SSR常用框架</h4><ul><li>React 的 <a href="https://link.juejin.cn/?target=https://nextjs.org/">Next</a></li><li>Vue.js 的 <a href="https://nuxt.com/">Nuxt3</a></li></ul><h4 id="Nuxt静态化"><a href="#Nuxt静态化" class="headerlink" title="Nuxt静态化"></a>Nuxt静态化</h4><p>因为个人之前是用Nuxt来做官网的，而且本人的技术栈主要也是vue全家桶，所以这里主要也就讲一下Nuxt3。</p><p>静态化是Nuxt.js打包的另一种方式，算是Nuxt.js的一个创新点，部署到服务器上之后，这种页面加载速度很快。</p><p>这里再次放一下Nuxt3官网的关于服务端渲染的说法。</p><h5 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title=" 服务器端渲染"></a><a href="https://nuxt.com/docs/getting-started/introduction#server-side-rendering"> 服务器端渲染</a></h5><p>默认情况下，Nuxt具有内置的服务器端渲染（SSR）功能，无需自己配置服务器，这对Web应用程序有很多好处</p><ul><li><strong>更快的初始页面加载时间：</strong>Nuxt将完全呈现的HTML页面发送到浏览器，该页面可以立即显示。这可以提供更快的感知页面加载时间和更好的用户体验 （UX），尤其是在速度较慢的网络或设备上。</li><li><strong>改进的 SEO：</strong>搜索引擎可以更好地索引 SSR 页面，因为 HTML 内容可以立即使用，而不需要 JavaScript 在客户端呈现内容。</li><li><strong>在低功耗设备上具有更好的性能：</strong>它减少了需要在客户端下载和执行的 JavaScript 数量，这对于可能难以处理繁重的 JavaScript 应用程序的低功耗设备非常有益。</li><li><strong>更好的辅助功能：</strong>内容在初始页面加载时立即可用，从而提高了依赖屏幕阅读器或其他辅助技术的用户的可访问性。</li><li><strong>更轻松的缓存：</strong>页面可以缓存在服务器端，这可以通过减少生成内容并将其发送到客户端所需的时间来进一步提高性能。</li></ul><p>总体而言，服务器端渲染可以提供更快、更高效的用户体验，并改善搜索引擎的优化和可访问性。</p><blockquote><p>注意：在Nuxt.js执行 generate静态化打包时，动态路由会被忽略。</p></blockquote><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>纯静态文件，访问速度超快</li><li>对比SSR，不涉及到服务器负载方面问题；</li><li>静态网页不宜遭到黑客攻击，安全性更高。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>动态路由（params传参），参数多的时候，Nuxt不适用</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些常识类的东西，虽然对开发没什么作用，但是作为见识拓展一下比较好。</p><p>这些问题也不是什么新鲜问题，基本上都是老古董的问题了，这里整备一下，省的哪天被别人面试挖了犄角旮旯的问题拉出来拷打。</p><p>假如上级布置了一个SSR开发任务，不会闹出来SSR抽卡用的词的笑话，多了解一点，总归是没什么错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7205604505647792185">2023年了，做SEO还有必要吗？</a></p><p><a href="https://juejin.cn/post/7300118821532778511?searchId=20240623132011EB5FEB974913729653EF">一文带你弄懂 前端SEO优化</a></p><p><a href="https://juejin.cn/post/7230303948925665341?searchId=20240623132441364A0B270D1932943462">挑战15分钟了解SEO、SMO、SPA、SSR可以吗？</a></p><p><a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html#single-page-application-spa">使用 Vue 的多种方式 | Vue.js (vuejs.org)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速,vue3项目代码书写规范整理</title>
      <link href="/2024/06/20/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-vue3%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
      <url>/2024/06/20/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-vue3%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本次是基于最近工作团队协作中，不同风格的代码书写风格放在一个项目中，导致整个项目的打包变得异常闹心。</p><p>这种问题也是老生常谈了，为了让团队能够更协调的推进项目，这里遵守约定大于配置的规则，整理一套相对宽松的前端规范，以便于所有组员开发。</p><p>本次项目以vue3为主，所以这里前端代码风格的核心是偏向vue3的，大家酌情自取。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>传统的代码规范文档可能会从HTML，CSS，JS这种顺序来进行细数。</p><p>但是考虑到团队内的开发者大多不是专职的前端开发，且本次项目翻新不需要太多的HTML和样式文件的书写，这里就按照当前团队内最不规范的部分开刀。</p><h3 id="GIT规范"><a href="#GIT规范" class="headerlink" title="GIT规范"></a>GIT规范</h3><p>因为所有人开发水平参差不齐，这里暂时不考虑自动化检测，后续大家习惯逐渐统一之后，会加入代码提交自动检测的。</p><h4 id="提交内容规范"><a href="#提交内容规范" class="headerlink" title="提交内容规范"></a>提交内容规范</h4><ol><li><strong>避免空文件的提交！！绝对避免！！</strong></li><li>不要提交空信息，每次提交用最简单的话写明白自己做了什么。</li><li>多文件修改不要一次性提交，尽可能分开提交文件，将自己每次修改了什么单次提交。</li><li>做有意义的提交，每次提交尽可能是一次工作完成的节点，通过撤回上次提交来修改每次提交进度的内容。</li><li>每次提交之前进行代码格式化，让风格大体统一，保证编译不报错。</li></ol><p>这里我逐个解释一下原因。</p><ol><li>避免空文件，是为了避免打包时候，vite打包会报错，空文件导致vite无法编译。</li><li>空信息不便于排查，数个月之后排查对应代码，没有清晰的信息，很难排查对应的错误。</li><li>多文件一次性提交，同样不利于排查，如果本次提交导致报错，会加大排查的工作量。</li><li>无意义提交太多，同样也会增加排查的工作量，所以尽可能让每次提交都是一个功能的闭环。</li><li>暂时因为所有人的开发水平不一致，所以这里不考虑使用代码提交格式检测，但是尽可能的保证每次代码的规范性。</li></ol><h3 id="组件拆分规范"><a href="#组件拆分规范" class="headerlink" title="组件拆分规范"></a>组件拆分规范</h3><p>组件拆分是很重要的一环，vue3相对于v2做了很多解耦的便捷性改动，我们必须利用好这些特性。</p><h4 id="拆分思路"><a href="#拆分思路" class="headerlink" title="拆分思路"></a>拆分思路</h4><ol><li>常规列表的增删改查，尽可能的项目中封装好的动态表单和表格来实现，不要用<code>element-plus</code>的自己写</li><li>如果页面有弹窗操作，先看看这类弹窗操作是否在原项目中多次复用，如多次复用，需将该类弹窗操作封装成公用业务组件，通用业务组件代码统一放在<code>src/component/business</code>文件夹下，命名规则为大驼峰命名法。</li><li>如果群内有其他人完成开发，则可以考虑直接复用他人组件。</li><li>如果是普通的新增或编辑弹窗操作，命名<code>MoudleAction</code>新开一个文件夹进行书写。</li></ol><h3 id="JS规范"><a href="#JS规范" class="headerlink" title="JS规范"></a>JS规范</h3><p>因为本次开发以Vue3技术栈为主，所以这里有些规范会偏向于vue3的书写思路。</p><h4 id="组合式优先"><a href="#组合式优先" class="headerlink" title="组合式优先"></a>组合式优先</h4><ol><li>template标签放在最上方，不要把script标签放在上方</li><li>直接在script标签中添加setup，不要在内额外使用<code>setup()</code>函数增加额外的代码行数</li><li>不推荐用ref包裹业务变量，ref应该用来去包裹一些非业务的，界面操作性质的变量。</li><li>不推荐用react的函数式写法去写组件</li><li>使用reactive成块的包裹业务块，成块的分割逻辑，便于代码逻辑的阅读</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/**<span class="doctag">@table</span> - 用reactive包装,将变量和方法都封在这一个逻辑块中，这块的是最核心的代码*/</span></span><br><span class="line"><span class="keyword">const</span> table = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">column</span>:[],</span><br><span class="line">    <span class="attr">data</span>:[],</span><br><span class="line">    <span class="attr">listLoading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">request</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 封装请求，这里我们赋值也不需要从.value什么的拿，直接用table.data就能获取列表的值，简直方便，省的ref那种搞法了。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>:<span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">action</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 这里存放增删改查的逻辑</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">delete</span>:<span class="function">() =&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 日常开发时优先采用这种命令式直接写业务逻辑，不要包裹到table中，便于特殊处理，如果业务逻辑过于复杂，就抽离到一个单独的TS文件中*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 钩子这块直接放置所有需要触发的机制*/</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    table.<span class="title function_">request</span>()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="尽可能的削减代码行数"><a href="#尽可能的削减代码行数" class="headerlink" title="尽可能的削减代码行数"></a>尽可能的削减代码行数</h4><ol><li>在不需要代码换行的时候，尽量避免换行，比如动态表单和动态表格，都尽量避免换行；</li><li>优先考虑三目运算符，但谨记不要写超过3层的三目运算符；</li><li>多使用扩展运算符<code>...</code>和解构赋值，在接口提交参数的时候放出去；</li><li>接口放在api文件下统一处理，减少甚至避免在vue文件中用url写入原生的url；</li></ol><h4 id="使用async-await获取数据"><a href="#使用async-await获取数据" class="headerlink" title="使用async await获取数据"></a>使用async await获取数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 接口请求 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> req 接口api </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> params 参数 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">const</span> table = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="title function_">async</span>(<span class="attr">params</span>:any) =&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">req</span>(params) </span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="坚持函数功能单一原则"><a href="#坚持函数功能单一原则" class="headerlink" title="坚持函数功能单一原则"></a>坚持函数功能单一原则</h4><p>函数内仅做该函数应该做的，尽量避免通过传入标记控制不同行为；</p><p>通过命名语义化减少代码阅读的难受程度。</p><ol><li>request，将代码接口请求逻辑封装在此类命名的方法中，避免使用</li><li>action，代表操作逻辑的聚合，减少非操作的业务逻辑的聚合</li></ol><h4 id="使用-代替src"><a href="#使用-代替src" class="headerlink" title="使用/@代替src"></a>使用<code>/@</code>代替src</h4><p>在vue-cli 脚手架使用架自带的指向 src 开发目录的 ‘&#x2F;@’ 符号引入文件资源.</p><p>当然，这点可以通过代码智能提示自动引入，平时搭建不用太过关注。</p><h4 id="统一使用单引号"><a href="#统一使用单引号" class="headerlink" title="统一使用单引号"></a>统一使用单引号</h4><p>简单的来说就是业务中的JS代码字符串之类的，用单引号而非双引号。</p><p>不过，这个有eslint规范会自动格式化的，大家平时用不着记。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>命名规范是为了解决代码目录阅读速度慢的问题，这里做的规定尽量做。</p><p>不然后续排查起成百上千的文件夹，实在太过麻烦。</p><h4 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h4><ul><li>业务文件目录命名 按照小驼峰命名，首字母小写（如：projectName）</li><li>组件目录命名 按照大驼峰命名，如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-- components</span><br><span class="line">| |-- <span class="title class_">ProjectName</span></span><br><span class="line">| | | -- <span class="title class_">ProjectName</span>.<span class="property">vue</span></span><br><span class="line">| | | -- index.<span class="property">js</span></span><br></pre></td></tr></table></figure><p>小驼峰命名的业务文件，便于日常翻阅。</p><p>而大驼峰对应的组件，则可以避免全局引入的时候出现代码混淆的问题。</p><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><ol><li>按照路由的路径进行命名，存放在views目录中。</li><li>非路由的文件，尽可能的复用原项目的名称，如果原项目文件名太过冗长，可适当缩短。</li><li>按照小驼峰命令，英文单词过长或超出2个以上，可缩略至前四位。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务统计 </span></span><br><span class="line">approvalStatistical </span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩略 </span></span><br><span class="line">approvalStat</span><br></pre></td></tr></table></figure><h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>这里尽量按照原本的代码进行处理即可。</p><p>按照小驼峰命名法，可使用常见动词约定；</p><ul><li><code>can</code> 判断是否可执行某个动作，函数返回一个布尔值。true：可执行；false：不可执行</li><li><code>has</code> 判断是否含有某个值， 函数返回一个布尔值。- true：含有此值；false：不含有此值</li><li><code>is</code>： 判断是否为某个值，函数返回一个布尔值。true：为某个值；false：不为某个值</li><li><code>get</code>： 获取某个之，函数返回一个非布尔值</li><li><code>set</code>： 设置某个值，无返回值、返回是否设置成功或者返回链式对象 load 加载某些数据,无返回值或者返回是否加载完成的结果</li></ul><p>语义化英文命名，仅组件内部使用方法前加上_（下划线）区分，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共方法的定义，可以提供外面使用</span></span><br><span class="line">publicbFunction () &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法，下划线定义，仅供组件内使用。多单词，注意与系统名字冲突！</span></span><br><span class="line">_privateFunction () &#123;&#125; </span><br></pre></td></tr></table></figure><h5 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h5><p>首字母大写的驼峰法命名。推荐使用 ES6 的方式引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Article</span> <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ArticleDetail</span> <span class="keyword">from</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>使用驼峰式命名，优先使用<code>let</code>、<code>const</code>、避免使用<code>var</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="title function_">ref</span>(<span class="string">&#x27;luffy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfo = <span class="title function_">reactive</span>(&#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;luffy&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>字母全部大写，以下横线<code>_</code>划分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Api</span> = &#123; </span><br><span class="line">  <span class="variable constant_">ITEMS_OFONE_TYPE</span> = <span class="string">&#x27;***&#x27;</span>, <span class="comment">// 获取事项分类 </span></span><br><span class="line">  <span class="variable constant_">SOLUTION_LIST</span> = <span class="string">&#x27;***&#x27;</span>,, <span class="comment">// 获取事项列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用词"><a href="#常用词" class="headerlink" title="常用词"></a>常用词</h4><p>这里常用的增删改查可能之前大家各有习惯，这里推荐使用</p><h4 id="常用动词"><a href="#常用动词" class="headerlink" title="常用动词"></a>常用动词</h4><table><thead><tr><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>get\set</td><td>取值\给值</td></tr><tr><td>add\remove</td><td>增加\移除</td></tr><tr><td>show\hide</td><td>显示\隐藏</td></tr><tr><td>view</td><td>查看</td></tr><tr><td>browse</td><td>浏览</td></tr><tr><td>modify</td><td>修改</td></tr><tr><td>save</td><td>保存</td></tr><tr><td>delete</td><td>删除</td></tr><tr><td>find</td><td>查询</td></tr><tr><td>undo</td><td>撤销</td></tr><tr><td>redo</td><td>重做</td></tr><tr><td>clean</td><td>清除</td></tr><tr><td>index</td><td>索引</td></tr><tr><td>observe</td><td>观察</td></tr><tr><td>send\receive</td><td>发送\接收</td></tr><tr><td>refresh\synchronize</td><td>刷新\同步</td></tr></tbody></table><ol><li>常用缩写</li></ol><table><thead><tr><th>数据类型&#x2F;标签</th><th>简写后缀</th></tr></thead><tbody><tr><td>object</td><td>obj</td></tr><tr><td>array</td><td>arr</td></tr><tr><td>json</td><td>json</td></tr><tr><td>function</td><td>fn</td></tr><tr><td>message</td><td>msg</td></tr><tr><td>button</td><td>btn</td></tr></tbody></table><h4 id="样式命名"><a href="#样式命名" class="headerlink" title="样式命名"></a>样式命名</h4><p>这里不做强制要求，但是样式命名尽可能的语义化，不要<code>-l,-r,-t,-b</code>这种简写无限嵌套，这种很读起来很伤神的。</p><p>样式，尽可能的少些甚至不写，用自带组件的样式解决就可以，不要非得去还原样式。</p><p>class命名以小写字母开头，小写字母、中划线和数字组成。不建议使用驼峰法命名 class 的属性。</p><p>以下是一些常用到的 class的名字：</p><ul><li>包裹层: .xx-wrap;</li><li>列表: .xx-list;</li><li>列表项: .xx-list-item; </li><li>左边内容: .xx-left; </li><li>中间内容: .xx-middle; </li><li>右边内容: .xx-right; </li><li>某个页面: .xx-page;</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="及时删除log调试日志"><a href="#及时删除log调试日志" class="headerlink" title="及时删除log调试日志"></a>及时删除log调试日志</h4><p>一旦代码合并到正式分支中，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;路由&#x27;</span>: 文件路由, <span class="string">&#x27;打印简述&#x27;</span>: 打印数据) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(打印数据, <span class="string">&#x27;1111&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>双斜线后应跟空格，且缩进与上下文的代码保持一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些说明... </span></span><br><span class="line"><span class="keyword">const</span> userID = <span class="number">24</span>; </span><br></pre></td></tr></table></figure><h4 id="多行注释（不推荐）"><a href="#多行注释（不推荐）" class="headerlink" title="多行注释（不推荐）"></a>多行注释（不推荐）</h4><p>一般用于注释难以理解的、可能存在错误的、逻辑强的代码，且缩进一致；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 针对下方代码的说明 </span></span><br><span class="line"><span class="comment">* 第一行太长写第二行 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>；</span><br></pre></td></tr></table></figure><h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><p>如果特别重要的方法，且复用度很高才推荐使用）写明传入参数名称，类型，推荐完整注释以下格式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 加入购物车</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> lint </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 2020-09-08</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; goodId 商品id </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Number&gt;</span>&#125; specs sku规格 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; amount 数量 </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; remarks 备注</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns</span> &lt;Promise&gt; 购物车信息 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">apiProductAddCard = <span class="function">(<span class="params">goodId, specs, amount, remarks</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;***&#x27;</span>, &#123; goodId, specs, amount, remarks &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h3><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>标签语义化，切忌清一色的 div 元素。列表可以使用 ul li，文字使用 p 标签，标题使用 h* 标签，等等。 </p><p>HTML5 推出了语义化的标签，建议使用：section，aside，header，footer，article，等 HTML5 布局标签。</p><h4 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h4><p>推荐使用自闭合标签的写法(自闭合标签不使用连线方式）。</p><p>不用记，格式化工具会自动处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponents</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="多特性分行写"><a href="#多特性分行写" class="headerlink" title="多特性分行写"></a>多特性分行写</h4><p>不用记，格式化工具会自动处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">scroll</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">ref</span>=<span class="string">&quot;scrollWrap&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">class</span>=<span class="string">&quot;home-scroll-warp&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:data</span>=<span class="string">&quot;homeData&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:pullDownRefresh</span>=<span class="string">&quot;true&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">:pullUpLoad</span>=<span class="string">&quot;true&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">pullingDown</span>=<span class="string">&quot;pullingDownGetNewData&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      @<span class="attr">pullingUp</span>=<span class="string">&quot;pullingUpGetMore&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h4><p>在模版中使用表达式，复杂情况使用计算属性或函数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;getLimitData(data)&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   ... </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;data.type !== &#x27;dir&#x27; &amp;&amp; dzqz &amp;&amp; hasBtn &amp;&amp; attrs.mode !== &#x27;ended&#x27;&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">   ... </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="代码嵌套"><a href="#代码嵌套" class="headerlink" title="代码嵌套"></a>代码嵌套</h4><p>尽可能的保证代码行缩减，避免半个标签占一行的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  test-title  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  test-text  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h4><p>避免过多重复代码，如果超过三行类似的代码，配置数据再循环遍历</p><h4 id="活用v-show-v-if"><a href="#活用v-show-v-if" class="headerlink" title="活用v-show, v-if"></a>活用v-show, v-if</h4><p>v-show，v-for，v-if不要同时出现在一个标签上。</p><ul><li>v-show不会改变dom树，也就是说不会导致重排。</li><li>v-if会改变dom树，会导致重排。</li></ul><p>比如，我们在查询表单的页面上，不要用v-if，用v-show会减少页面性能的开销。</p><h4 id="注释规范-1"><a href="#注释规范-1" class="headerlink" title="注释规范"></a>注释规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单行注释 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 组件注释 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">CustomTable</span> <span class="attr">ref</span>=<span class="string">&quot;customTableRef&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 其他注释 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- </span><br><span class="line">  多行注释</span><br><span class="line">  多行注释</span><br><span class="line">--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h3><p>推荐使用UnoCSS引擎进行原子化CSS开发 推荐使用scss预编译 由于样式的情况比较多也比较复杂  做出如下规范</p><h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ul><li>避免使用标签选择器。因为在 Vue 中，特别是在局部组件，使用标签选择器效率特别低，损耗性能，建议需要的情况，直接定义 class；</li><li>非特殊情况下，禁止使用 ID 选择器定义样式。有 JS 逻辑的情况除外；</li><li>避免使用important选择器；</li><li>避免大量的嵌套规则，控制在3级之内，对于超过4级的嵌套，考虑重写或新建子项；</li><li>避免使用ID选择器及全局标签选择器防止污染全局样式；</li></ul><h4 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h4><ul><li>提取公用样式进assets文件styles里，按模块&#x2F;功能区分；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|assets</span><br><span class="line">|-- styles</span><br><span class="line">| |-- common 放置公用样式，如重置，混合，复写element样式等 </span><br><span class="line">| |-- modules 放置模块样式</span><br></pre></td></tr></table></figure><ul><li>推荐使用直接子选择器；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 推荐 */</span> </span><br><span class="line">.<span class="property">jdc</span> &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> li &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> li p&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐 */</span> </span><br><span class="line">*&#123;&#125; </span><br><span class="line">#jdc &#123;&#125; </span><br><span class="line">.<span class="property">jdc</span> div&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 scoped 关键字，约束样式生效的范围</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;scss&quot;</span> scoped&gt;</span><br><span class="line">.<span class="property">app</span>-wrapper &#123;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>使用变量 可复用属性尽量抽离为页面变量，易于统一维护</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css */</span> </span><br><span class="line"><span class="selector-class">.class-name</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border-color</span>: red; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* scss */</span>  </span><br><span class="line">$<span class="attribute">color</span>: red; </span><br><span class="line"><span class="selector-class">.class-name</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: $color;</span><br><span class="line">  <span class="attribute">border-color</span>: $color; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h4><p>CSS 属性书写顺序：先决定定位宽高显示大小，再做局部细节修饰，推荐顺序（可以提升浏览器渲染 <code>dom</code> 的性能）：</p><p>定位属性(或显示属性，display)-&gt;宽高属性-&gt;边距属性(margin, padding)-&gt;字体，背景，颜色等，修饰属性的定义，这样定义为了更好的可读性，让别人只要看一眼就能在脑海中浮现最终显示的效果。</p><ol><li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li><li>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient … 以下给出常用的定义示例：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">class</span>-name &#123;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">top</span>: 100px; </span><br><span class="line">  <span class="attr">left</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">right</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attr">display</span>: block; </span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%; </span><br><span class="line">  <span class="attr">height</span>: <span class="number">100</span>%;</span><br><span class="line">  <span class="attr">margin</span>: 10px; </span><br><span class="line">  <span class="attr">padding</span>: 10px; </span><br><span class="line">  font-<span class="attr">size</span>: 14px; </span><br><span class="line">  <span class="attr">color</span>: #<span class="number">000</span>; </span><br><span class="line">  background-<span class="attr">color</span>: red; </span><br><span class="line">  border-<span class="attr">radius</span>: 2px; </span><br><span class="line">  line-<span class="attr">height</span>: <span class="number">1.42</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="样式覆盖"><a href="#样式覆盖" class="headerlink" title="样式覆盖"></a>样式覆盖</h4><p>组件内部需要覆盖UI框架样式，必须在最外层组件加类名</p><h4 id="注释规范-2"><a href="#注释规范-2" class="headerlink" title="注释规范"></a>注释规范</h4><p>以&#x2F; 注释内容 &#x2F;格式注释，前后空格，嵌套子类需要一个回车分割开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注释内容 */</span></span><br><span class="line">.<span class="property">pha</span>-element &#123;</span><br><span class="line">  <span class="attr">width</span>: 20px;</span><br><span class="line">  <span class="comment">/* 这里需要换行 */</span> </span><br><span class="line">  .<span class="property">pha</span>-element-l &#123; </span><br><span class="line">    <span class="attr">color</span>: blue </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>代码规范这套并非是越严格越好，而是要根据团队的特性不断调整修改。</p><p>随着团队的逐渐磨合，这样开发效率会逐渐提高。</p><p>当本次代码规范磨合完成并证实确实可行有效之后，会在掘金上整合出一份代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7331714933388525580?searchId=20240620205348AEFE866814D0411E41DB">前端代码规范（vue篇）</a></p><p><a href="https://crazystudent13.cn/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB">浅析ref与reactvie的区别</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解vue修饰符</title>
      <link href="/2024/06/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2024/06/19/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3vue%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>本来没想整理的，基本上是用到的时候现查为主。</p><p>然后刷到一个面试题要求随便举几个例子，虽然磕磕绊绊的说出来了一些，但是这实在不符合一个老前端应有的知识储备。</p><p>索性这里统一整理下，反正也不是太麻烦的事情。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>事件修饰符Vue框架本身提供的事件语法糖，无论是V2还是V3，大部分都是通用的。</p><p>这里就不详细去分析他们的原理，仅收集供面试和平时开发时使用。</p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在正式进入事件修饰符事件之前，我们需要先简单了解一些概念，不然新人直接看这些修饰符可能会懵。</p><h4 id="事件相关内容委托"><a href="#事件相关内容委托" class="headerlink" title="事件相关内容委托"></a>事件相关内容委托</h4><p>众所周知，我们平时写的页面是由DOM树不断嵌套堆叠而成的，当我们与DOM交互的时候，实际上是要穿透这一层层DOM结构，触发到对应节点的事件。</p><p>早年这里会考个面试题，如果每层节点都绑定事件，那么这是这每层事件的执行顺序是怎样的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const &#123; createApp, ref &#125; = Vue</span><br><span class="line">  createApp(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const count = ref(0)</span><br><span class="line">        return &#123; count &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      test(num)&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div @click=&quot;test(1)&quot;&gt;</span><br><span class="line">        &lt;div @click=&quot;test(2)&quot;&gt;</span><br><span class="line">            &lt;div @click=&quot;test(3)&quot;&gt;</span><br><span class="line">            测试</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">  &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 输出结果：</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>看到这个结果，我们可能会疑惑，为什么最外层的绑定的事件反而最后才触发？</p><p>由此，我们需要明白两个基础概念：<strong>事件冒泡</strong> 与 <strong>事件委托</strong>。</p><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p><code>事件冒泡（dubbed bubbling）</code>：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 <code>window</code> （注意这里传递的仅仅是事件，例如<code>click、focus</code>等等这些事件， 并不传递所绑定的事件函数。）</p><p>事件源 &#x3D;&gt;根节点（由内到外）进行事件传播。</p><p>所以我们会发现，这次的事件触发结果，实际上就是由内而外的执行。</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p><code>事件捕获（event capturing）</code>： 当鼠标点击或者触发<code>dom</code>事件时（被触发<code>dom</code>事件的这个元素被叫作事件源），浏览器会从根节点 &#x3D;&gt;事件源（由外到内）进行事件传播。</p><p>事件捕获与事件冒泡是比较类似的，最大的不同在于事件传播的方向。</p><p>这里我们不再用vue讨巧举例了，因为vue的事件本质上就是封装了事件注册方法：<code>addEventListener(&#39;click&#39;,() =&gt;&#123;&#125;, false)</code>。</p><p>事件注册：<code>addEventListener</code>，通过控制最后一个传值，我们就能决定触发的方向是由内向外还是由外向内。</p><p>我们将三个div，由外到内命名为：big，center，small，再看一结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">big.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big----事件捕获&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">center.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;center----事件捕获&#x27;</span>)</span><br><span class="line">&#125;，<span class="literal">true</span>)</span><br><span class="line">small.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;small----事件捕获&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">big.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big----事件冒泡&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">center.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;center----事件冒泡&#x27;</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">small.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;small----事件冒泡&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// big----事件捕获</span></span><br><span class="line"><span class="comment">// center----事件捕获</span></span><br><span class="line"><span class="comment">// small----事件捕获</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// small----事件冒泡</span></span><br><span class="line"><span class="comment">// center----事件冒泡</span></span><br><span class="line"><span class="comment">// big----事件冒泡</span></span><br></pre></td></tr></table></figure><p>这里我们就会发现，两者的触发方向完全不一样。</p><ul><li>事件冒泡：由内向外。</li><li>事件捕获：由外向内。</li></ul><h5 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h5><p>当点击页面的表格内的按钮时候，有时候我们会触发行点击事件，这时候我们希望仅仅点击按钮，那么我们必然要阻止这种事件传播的问题。</p><p>阻止事件传播，常用的有两种方法：</p><ul><li><code>event.stopPropagation()</code> 阻止事件传播，<code>不会</code>阻止同一元素上的其他的事件处理程。</li><li><code>event.stopImmediatePropagation()</code> 阻止事件传播，<code>会</code>阻止同一元素上的其他的事件处理程。</li></ul><p>当然也不仅仅局限于此，有时候，表单被提交时默认的submit事件，我们不希望触发，这里我们也可以通过这种方式阻止这些默认事件。</p><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p><code>事件委托</code>也称为<code>事件代理</code>。</p><p>就是利用<code>事件冒泡</code>，把子元素的事件都绑定到父元素上。</p><p>如果子元素阻止了事件冒泡，那么委托就无法实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><p>现在要为每一个<code>li</code>添加一个事件，假设<code>li</code>有100个，于是就需要为每一个<code>li</code>添加一个事件，这样会占用100个内存。</p><p>因此，如果使用事件委托的话，可以利用事件的冒泡机制，为<code>ul</code>绑定一个事件，那么点击任意一个<code>li</code>的时候，都会将事件触发到父元素<code>ul</code>上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用<code>event.target</code>获取到点击的元素，<code>event.target.innerHTML</code>获取到点击的元素的内容。 如下代码，当你点击<code>li</code>时，会添加一个红色的背景，再次点击，会将背景变为白色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ulE = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ulE.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ulE event&#x27;</span>, event.<span class="property">target</span>, event.<span class="property">target</span>.<span class="property">innerHTML</span>)</span><br><span class="line">  <span class="keyword">const</span> target = event.<span class="property">target</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">style</span>.<span class="property">backgroundColor</span> !== <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">    target.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单的来说，就是事件的目标源委托给父级元素，减少性能的损耗。</p><p>故此，使用<code>事件代理/委托</code>可以提高性能，减少注册的事件。</p><h4 id="v-on事件修饰符"><a href="#v-on事件修饰符" class="headerlink" title="v-on事件修饰符"></a><code>v-on</code>事件修饰符</h4><p>vue官方提供了很多处理事件的修饰符，主要我们平时很多用不到，所以并未深入了解。</p><p>我这里简单的按照使用频率，将事件修饰符分为通用修饰符和特殊修饰符，特殊修饰符我会单独讲一下它们的应用场景。</p><h5 id="通用修饰符"><a href="#通用修饰符" class="headerlink" title="通用修饰符"></a>通用修饰符</h5><p>这些修饰符有些在vue2中，Vue3就没有了相应的修饰符，所以这里会备注一下支持的版本。</p><table><thead><tr><th>修饰符名称</th><th>支持版本</th><th>事件</th><th>备注</th></tr></thead><tbody><tr><td><code>.native</code></td><td>v2</td><td>监听组件根元素的原生事件</td><td></td></tr><tr><td><code>.prevent</code></td><td>v2,v3</td><td>阻止事件的默认动作</td><td>比如表单默认的submit按钮会刷新页面，我们用这个就可以阻止刷新页面</td></tr><tr><td><code>.once</code></td><td>v2,v3</td><td>仅触发一次</td><td>可用来避免用户重复点击导致多次提交表单</td></tr><tr><td><code>.stop</code></td><td>v2,v3</td><td>阻止事件传播&#x2F;冒泡</td><td>避免事件冒泡触发了父元素的方法</td></tr><tr><td><code>.self</code></td><td>v2,v3</td><td>只当事件是从侦听器绑定的元素本身触发时才触发回调。</td><td>通过事件委托的形式，减少页面性能小号</td></tr><tr><td><code>.passive</code></td><td>v2,v3</td><td>滚动事件的默认行为 (scrolling) 将立即发生而非等待 <code>onScroll</code> 完成</td><td>移动端常用处理滚动监听，PC端很少用</td></tr><tr><td><code>.capture</code></td><td>v2,v3</td><td>指向内部元素的事件，在被内部元素处理前，先被外部处理</td><td>采用了捕获的方式，可以调整执行顺序</td></tr></tbody></table><blockquote><p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。</p><p>因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为</strong>。</p><p>而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p></blockquote><h5 id="passive修饰符"><a href="#passive修饰符" class="headerlink" title=".passive修饰符"></a>.passive修饰符</h5><p><code>.passive</code> 修饰符一般用于触摸事件的监听器，可以用来<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">改善移动端设备的滚屏性能</a>，详情参考CSDN的这篇：<a href="https://blog.csdn.net/weixin_43524214/article/details/136574108">Vue事件处理:.passive修饰符与应用场景</a></p><blockquote><p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。</p><p>如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告。</p></blockquote><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p><code>.&#123;keycode | keyAlias&#125;</code> </p><p>键盘中每个按键都有自己对应的keycode，vue提供的语法糖，让我们可以直接使用对应事件绑定，也可以用对应的keycode绑定。</p><p>这里，我们以常用的回车事件为例子，我们按键加入enter修饰符，代表我们点击回车时，可以触发<code>test()</code>事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> @<span class="attr">keypress.enter</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span> @<span class="attr">keypress.13</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- enter事件的keycode对应13，所以这两个例子都是回车触发按钮。 --&gt;</span> </span><br></pre></td></tr></table></figure><p>这里我们就可以发现，使用keycode和修饰符都可以达到对应的效果。</p><p>vue官方提供了很多便利性的事件，如果您需要将方法绑定对应的按钮，不妨参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/keyCode">MDN的KeyCode码表</a>，这样绑定会方便很多。</p><table><thead><tr><th>修饰符名称</th><th>事件</th></tr></thead><tbody><tr><td><code>.enter</code></td><td>回车</td></tr><tr><td><code>.delete</code></td><td>Delete或Backspace</td></tr><tr><td><code>.ctrl</code></td><td>ctrl按键</td></tr><tr><td><code>.alt</code></td><td>alt按键</td></tr><tr><td><code>.shift</code></td><td>shift按键</td></tr><tr><td><code>.tab</code></td><td>tab按键</td></tr><tr><td><code>.esc</code></td><td>esc按键</td></tr><tr><td><code>.space</code></td><td>space空格按键</td></tr><tr><td><code>.up</code>,<code>.down</code>,<code>.left</code>,<code>.right</code></td><td>上下左右方向键</td></tr><tr><td><code>.meta</code></td><td>win键&#x2F;mac的commond键</td></tr><tr><td>[<code>.exact</code>](<!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --> &lt;button @click.ctrl&#x3D;”onClick”&gt;A</button> <!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --> &lt;button @click.ctrl.exact&#x3D;”onCtrlClick”&gt;A</button> <!-- 仅当没有按下任何系统按键时触发 --> &lt;button @click.exact&#x3D;”onClick”&gt;A</button>)</td><td>修饰符允许精确控制触发事件所需的系统修饰符的组合。</td></tr></tbody></table><blockquote><p>注意：如果多个组件注册了键盘事件，最好销毁，保证键盘事件的唯一性，不然有时候会导致整个页面出现一些意料之外的问题。</p></blockquote><p>另外，有人可能对exact的描述有些迷惑，这里放一下官方的例子，一看就明白，就是为了精确操作使用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span><br><span class="line">&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure><h4 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h4><p><code>@click</code>鼠标事件，没什么好说的。</p><table><thead><tr><th>修饰符名称</th><th>事件</th></tr></thead><tbody><tr><td><code>.left</code></td><td>左键</td></tr><tr><td><code>.right</code></td><td>右键</td></tr><tr><td><code>.middle</code></td><td>中间</td></tr></tbody></table><h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><a href="https://cn.vuejs.org/api/built-in-directives.html#v-bind">v-bind</a></h4><p>v-bind的修饰符我们几乎很少用，这里推荐大家看看，知道有这么回事儿就行。</p><table><thead><tr><th>修饰符名称</th><th>备注</th></tr></thead><tbody><tr><td><code>.prop</code></td><td>强制绑定为 DOM property</td></tr><tr><td><code>.attr</code></td><td>强制绑定为 DOM attribute</td></tr><tr><td><code>.camel</code></td><td>将短横线命名的 attribute 转变为驼峰式命名</td></tr><tr><td><code>.sync</code></td><td>vue2支持，vue3不支持了。</td></tr></tbody></table><p>这里直接放一下官方的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绑定 attribute --&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名 --&gt;</span><br><span class="line">&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src=&quot;imageSrc&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src=&quot;src&quot; --&gt;</span><br><span class="line">&lt;img :src /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名的缩写 --&gt;</span><br><span class="line">&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定对象形式的 attribute --&gt;</span><br><span class="line">&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop” 必须在子组件中已声明。 --&gt;</span><br><span class="line">&lt;MyComponent :prop=&quot;someThing&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传递子父组件共有的 prop --&gt;</span><br><span class="line">&lt;MyComponent v-bind=&quot;$props&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- XLink --&gt;</span><br><span class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><table><thead><tr><th>修饰符名称</th><th>备注</th></tr></thead><tbody><tr><td><code>.trim</code></td><td>去除输入框首尾字符串</td></tr><tr><td><code>.number</code></td><td>将用户输入的类型由string型转为number型</td></tr><tr><td><code>.lazy</code></td><td>使得用户在输入数据之后，当数据失去焦点或点击回车时，才会进行数据的更新</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事件修饰符平时用的不多，最多就是输入框判空，表单单次提交，键盘回车等常用事件的使用，平时没有别的用法。</p><p>关于事件冒泡和事件捕获，这个就更是远古面试题了，如今在梳理修饰符时候刷到，属实有点老乡见老乡了。</p><p>如今仔细梳理了一番，感觉自己确实受益匪浅。</p><p>虽然依然用的场景可能不太多，但是相对以前，可能在开发中会更得心应手一些？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/guide/essentials/event-handling.html#exact-modifier">Vue3-事件处理</a></p><p><a href="https://juejin.cn/post/7327686547809124386">浅谈js的事件机制，事件冒泡、事件捕获、事件代理(事件委托)</a></p><p><a href="https://juejin.cn/post/7192584563799883832?searchId=20240620234605BBB5CDD54E47D434F762">JS中的事件冒泡、事件捕获、事件委托</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%EF%BC%9F">MDN_什么是事件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3生命周期</title>
      <link href="/2024/06/19/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2024/06/19/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>因为今天用vue3写代码，新版的触发钩子已经不再是destory的，这导致我写业务的时候错误排查耽误了些许时间。</p><p>故此，整理此文，增强一下自己的对vue3生命周期的使用熟悉度。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>vue3的生命周期相对于前者没有什么太大的区别，多了一个setup，然后就是钩子函数稍微改了一下名字，别的并无任何修改。</p><p>这里默认大家都清楚vue2的生命周期中的钩子函数，这里就不展开与vue2比较了，直奔主题。</p><blockquote><p>钩子函数（hook）：一种在系统或程序处理消息时被自动调用的函数。</p><p>个人理解，因为这种机制就像是牵动钩子拉起一串程序，因为被称作钩子函数，很形象。</p></blockquote><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><p>相对于vue2多了setup，并且组合式的写法名字有所变化，同时destroy换为了unmount。</p><table><thead><tr><th>选项式</th><th>组合式</th><th>备注</th></tr></thead><tbody><tr><td></td><td><code>setup</code></td><td>setup执行在所有钩子函数之前。</td></tr><tr><td><code>beforeCreate</code></td><td></td><td>创建实例之前调用，此时实例的数据观测、事件等还未初始化。</td></tr><tr><td><code>created</code></td><td></td><td>创建实例后调用，此时实例的数据观测、事件等已经初始化完成。</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount()</code></td><td>挂载实例之前调用，此时模板已经编译完成，但是还未挂载到DOM。</td></tr><tr><td><code>mounted</code></td><td><code>onMounted()</code></td><td>挂载实例后调用，此时实例已经挂载到DOM，可以进行DOM操作。</td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate()</code></td><td>数据更新之前调用，此时可以进行状态的最后更改。</td></tr><tr><td><code>updated</code></td><td><code>onUpdated()</code></td><td>数据更新后调用，此时DOM已经完成更新，可以进行DOM操作。</td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount()</code></td><td>卸载实例之前调用，此时实例仍然完全可用。</td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted()</code></td><td>卸载实例后调用，此时实例已经完全卸载。</td></tr></tbody></table><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>这里放了一下官方的汉化图，看的更清楚一些。</p><p><img src="https://s2.loli.net/2024/06/18/vTxqXj6D1EQOnUo.png" alt="QQ截图20240618201244"></p><h3 id="选项式与组合式"><a href="#选项式与组合式" class="headerlink" title="选项式与组合式"></a>选项式与组合式</h3><p>在组合式 API 中，<code>beforeCreate</code> 、<code>created</code> 生命周期由 setup 函数代替。</p><p>即在 <code>beforeCreate</code> 、<code>created</code> 生命周期选项中编写的代码，都可以写在 setup 函数中。</p><p>同一个生命周期，同时用选项式 API 和组合式 API 中注册，组合式 API 中的生命周期函数会先于选项式 API 中的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 后输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;mounted1&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 先输出</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;mounted2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// mounted2 会比 mounted1 先输出。</span></span><br></pre></td></tr></table></figure><h3 id="其他钩子"><a href="#其他钩子" class="headerlink" title="其他钩子"></a>其他钩子</h3><blockquote><p>关于所有生命周期钩子函数，推荐看这个大佬整理的问：<a href="https://juejin.cn/post/7352075662453702694?searchId=20240618195833939AD610B79031D8EF9E">一文吃透 Vue3 组件的 16 个生命周期</a></p></blockquote><p>这些钩子函数点陌生，以前可能大多没见过，这里看到有大佬做了整理，这里我引用一下</p><p>其中有一部分钩子函数很眼熟的。</p><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><table><thead><tr><th>选项式</th><th>组合式</th><th>备注</th></tr></thead><tbody><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured()</code></td><td>注册一个钩子，在捕获了后代组件传递的错误时调用。</td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked()</code></td><td>注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用</strong>。</td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered()</code></td><td>注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用</strong>。</td></tr><tr><td><code>activated</code></td><td><code>onActivated()</code></td><td>仅针对 KeepAlive 包裹的组件。注册一个回调函数，当组件被插入到 DOM 中时调用。<strong>这个钩子在服务器端渲染期间不会被调用</strong> 。</td></tr><tr><td><code>deactivated</code></td><td><code>onDeactivated()</code></td><td>仅针对 KeepAlive 包裹的组件。注册一个回调函数，当组件从 DOM 中被移除时调用。<strong>这个钩子在服务器端渲染期间不会被调用</strong> 。</td></tr><tr><td><code>serverPrefetch</code></td><td><code>onServerPrefetch()</code></td><td>仅在服务端渲染期间使用，用于注册一个异步函数，在组件实例在服务器上被渲染之前调用。可用于在服务器上请求后台接口数据，它比在客户端上请求后台数据更快。</td></tr></tbody></table><blockquote><p>有关 <code>onErrorCaptured()</code> 更多详细信息参考这个大佬写的另一篇文章：<a href="https://juejin.cn/post/7329033936956260362">深入源码，剖析 Vue3 是如何做错误处理的</a></p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在组合式 API 中，<code>beforeCreate</code> 和 <code>created</code> 生命周期函数已经被 setup 函数取代了，很多时候我们在写组合式的API的时候，并不考虑使用create相关的两个生命周期方法。</p><ul><li><code>beforeCreate</code> 生命周期函数会在组件实例初始化完成并且 props 被解析后立即调用。</li><li><code>created</code> 生命周期函数在组件实例处理完所有与状态相关的选项后调用。</li><li><code>beforeMount</code> 生命周期函数在组件被挂载之前调用</li><li><code>mounted</code> 生命周期函数在组件被挂载之后调用</li><li><code>beforeUpdate</code> 生命周期函数在组件即将因为响应式状态变更而更新其 DOM 树之前调用。</li><li><code>updated</code> 生命周期函数在组件因为响应式状态变更而更新其 DOM 树之后调用</li><li><code>beforeUnmount</code> 生命周期函数在一个组件实例被卸载之前调用</li><li><code>unmounted</code> 生命周期函数在一个组件实例被卸载之后调用</li></ul><blockquote><p><code>beforeUnmount</code> 和 <code>unmounted</code> 用于替代被废弃的 <code>beforeDestroy</code> 和<code>destroyed</code> 生命周期函数</p></blockquote><ul><li><code>errorCaptured</code> 生命周期函数在捕获了后代组件传递的错误时调用</li><li><code>renderTracked</code> 生命周期函数在组件渲染过程中追踪到响应式依赖时调用</li><li><code>renderTriggered</code> 生命周期函数在响应式依赖的变更触发了组件渲染时调用</li></ul><blockquote><p><code>renderTracked</code> 和 <code>renderTriggered</code> 生命周期函数仅在 DEV 模式下可用</p></blockquote><ul><li><code>activated</code> 生命周期函数与 KeepAlive 组件有关，当组件被插入到 DOM 中时调用</li><li><code>deactivated</code> 生命周期函数也与 KeepAlive 组件有关，当组件从 DOM 中被移除时调用</li><li><code>serverPrefetch</code> 生命周期函数在组件实例在服务器上被渲染之前调用，仅在服务器渲染期间调用。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vue3的生命周期钩子虽然多了一些，但实际开发过程中，大多人主要应该也是用组合式写一下onMounted就可以，没必要太过深入。</p><p>至于选项式API，在vue3的时代中，估计未来很少有人使用。</p><p>官方之所以提供选项式的写法，估计也是为了大部分人能够习惯过渡一下，所以这里就不细说选项式与组合式写法的优先级问题了。</p><p>本文受限于现阶段开发的见识不足，后续如有新的认知，会视情况更新。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html">生命周期钩子 | Vue.js (vuejs.org)</a></p><p><a href="https://juejin.cn/post/7352075662453702694?searchId=20240618195833939AD610B79031D8EF9E">一文吃透 Vue3 组件的 16 个生命周期</a></p><p><a href="https://juejin.cn/post/7329033936956260362">深入源码，剖析 Vue3 是如何做错误处理的</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue路由概念及实现逻辑</title>
      <link href="/2024/06/17/%E6%B5%85%E6%9E%90vue%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/"/>
      <url>/2024/06/17/%E6%B5%85%E6%9E%90vue%E8%B7%AF%E7%94%B1%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p>面试官：您能说说vue的路由模式吗？</p><p>我：hash和history，hash相对于传统模式不够美观，是spa独有的类型，无法服务端渲染，history是传统的方式，更符合平时的使用直觉，大概是这样。</p><p>面试官：您能更详细的说说吗？</p><p>我：行。。。。你故意找茬是吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这种问题其实算是很早之前刷过的面试题了，但是实际开发过程中基本没细研究过，除了在服务端渲染的时候稍微了解了一下，后续确实没有深入了解。</p><p>而这也是三年前端必须要掌握的基础功能了，我这里没有深入了解，确实显得基础不扎实了。</p><h3 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h3><p>在正式了解vue实现逻辑之前，我们先了解一下路由的一些概念。</p><h4 id="后端路由（传统路由）"><a href="#后端路由（传统路由）" class="headerlink" title="后端路由（传统路由）"></a>后端路由（传统路由）</h4><p>传统的 Web 应用都是由多个页面组成，页面之间通过链接的方式进行跳转。</p><p>每切换一个页面，就由浏览器发起页面请求，后端服务器接收到请求，对这个地址进行匹配，找到这个地址对应的逻辑，解析地址及参数，最终返回这个地址对应的页面 HTML。</p><p>这个对请求地址进行匹配的逻辑就被称为路由，它是在后端发生的，因此也叫<strong>后端路由</strong>。</p><p>对后端路由来说，每一个页面对于前端代码来说都是全新的，前端代码在页面加载的时候开始运行，在页面关闭或者跳到下一个页面的时候结束运行。</p><p>这种类型的路由便于网络爬虫抓取，便于搜索殷勤收录，所以这种路由模式更适合一些官网或展示类页面。</p><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><p>前端路由的概念是随着单页面应用（Single Page Application）的流行而产生的。</p><p>单页面应用，是指整个 Web 应用只有一个页面。</p><p>由浏览器发起请求再由后端返回页面 HTML 这样的过程只会在第一次访问时发生。</p><p>在第一次请求完毕后，后面的页面逻辑都由前端进行控制。</p><p>好处是一旦用户完成第一次页面加载，在后续的使用中，用户都不会看到页面加载的过程，从而获得更流畅的使用体验，也减少了服务器的压力。</p><p>坏处在于，失去了 Web 应用最核心的特性 <code>URL</code>。</p><p>一个典型的前端路由在单页面场景下大概需要关注以下几个问题：</p><ol><li>定义路由表，即各种 URL 分别对应哪些逻辑（一般来说就是对应界面的渲染）。</li><li>获取当前访问的 URL，并根据路由表匹配中对应的逻辑并调用它（渲染对应的界面）。</li><li>处理链接跳转，如果链接地址是在单页面应用的范围内，则不能使用浏览器导航，而是直接完成新 URL 对应的界面的渲染，并将浏览器中显示的 URL 更新为新界面对应的 URL。</li><li>监视 URL 的变更，当用户手工更改 URL 或者有其它逻辑更改了 URL 之后，需要重新进行路由匹配并完成界面的渲染。</li></ol><p>一般来说，</p><p>（1）是纯计算逻辑，不需要什么特别的处理，（2）可以由 location 这个 API 进行获取，因此前端路由中值得关注的核心问题主要就是 （3）和 （4），简单地归纳就是更新浏览器 URL 和监视浏览器 URL 改变。</p><p>单页面应用因为不需要关注网络搜索引擎的收录，所以更适合用在管理系统中。</p><p>而且，相对于传统模式，这种前端路由不需要服务器进行渲染处理，所以可以大幅减少服务器压力，在现代开发中更推荐使用。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>这里的vue模式，主要是针对<a href="https://router.vuejs.org/zh/">Vue-Router</a>推出的两种模式做个总结，我个人对react不是很熟，所以不清楚react是否也有类似的路由组件。</p><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>对于一个 URL 如：<code>/home#/hello/world</code>，其中的 hash 部分就是<code>#/hello/world</code>。</p><p>当我们在单页面应用中切换到另一个页面时，修改 hash 即可。</p><p>hash 部分在浏览器导航的时候并不会被传给后端服务器，也可以方便地用 JavaScript 修改，并且修改它时也不会发生重新导航的情况，因此对于单页面应用来说，非常适合用来作为前端路由的方案。</p><p>对于 hash 模式下 URL 的监听：</p><ul><li>老旧的浏览器，使用定时器，定时获取浏览器的 URL，并与之前的结果比对</li><li>较新的浏览器提供了 hashchange 事件，直接监听这个事件即可</li><li>更新的浏览器提供了 popstate 事件</li></ul><p>hash 模式的缺点：</p><ul><li>不符合用户的固有认知，也不太美观</li><li>hash 部分不会被传递给后端服务器，导致没有办法进行服务端渲染，进而影响搜索引擎的收录</li><li>和a元素的锚点跳转的功能冲突，导致a元素的锚点跳转无法使用</li></ul><h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><p>在单页面应用下，这个模式的核心在于 history.pushState(state, title, url) 这个 API，它的含义是向浏览器的历史栈（即前进后退的栈）中压入一个新的状态，从逻辑上相当于跳转到了一个新的页面，但是并不真的重新加载或重新导航。</p><p>使用这个 API 很方便地修改浏览器中的 URL，并正确地处理前进 &#x2F; 后退的问题。</p><p>该模式下对 URL 的监听使用 popstate 事件。</p><p>当用户进行导航动作（前进 &#x2F; 后退等）或有 history.back()、history.forward() 之类的调用时，popstate 事件就会发生。</p><h3 id="占位组件"><a href="#占位组件" class="headerlink" title="占位组件"></a>占位组件</h3><p>Vue-Router 的作用不仅是管理路由，还需要配合 Vue 完成路由对应界面的渲染，Vue 本身是声明式渲染的，而 Vue-Router 通过声明组件（<code>&lt;router-view&gt;</code>）的方式来接管渲染。</p><p>当开发者使用 Vue-Router 时，<code>&lt;router-view&gt;</code> 组件会被全局注册，但它并没有具体的内容可渲染，当渲染到 <code>&lt;router-view&gt;</code> 时，就会由 Vue-Router 来决定这个组件的位置应该渲染哪个界面，从而实现从 URL 到路由匹配再到渲染对应界面的过程。</p><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>这里主要讲vue-router源码的实现逻辑，这里就是简单看看，没必要深入。</p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>Vue.use() 是 Vue 提供的用来安装插件的方法，它要求参数提供一个 install() 方法，Vue 会调用这个 install() 方法完成安装。</p><p>vue-router 的 install() 方法位于一个单独的文件，即 src&#x2F;install.js。</p><p>install() 方法主要做了这么几件事情：</p><ul><li>声明了 beforeCreate() 和 destroyed() 两个 mixin，这样在 Vue 实例的生命周期中能够处理 vue-router 相关的逻辑。</li><li>声明了两个属性 router和router 和 router和route，分别指向了 this._routerRoot 对象上的_router 和_route。</li><li>将_route 变成响应式数据，这样当它变更的时候就会触发组件的重新渲染。</li><li>声明了两个全局组件 RouterView 和 RouterLink，这正是我们经常使用的 <code>&lt;router-view&gt;</code> 和 <code>&lt;router-link&gt;</code>。</li></ul><h4 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h4><p>声明 VueRouter 类，代码位于 src&#x2F;index.js，new VueRouter() 时调用。</p><p>初始化时主要有这样几件事情：</p><ul><li>创建了用于进行 URL 匹配的路由表。路由表用来存储定义好的路由与对应的页面组件（用于在 <code>&lt;router-view&gt;</code> 中渲染）的关系。</li><li>根据 mode 配置项决定使用 hash 模式还是 history 模式。</li><li>根据对应的模式，选择负责管理历史记录和 URL 的 History 子类，初始化后赋值给 this.history。</li></ul><p>VueRouter 类中 通过<code>this.matcher = createMatcher(options.routes || [], this)</code>创建路由表。</p><p><code>createMatcher</code>方法源码位于 src&#x2F;create-matcher.js 。</p><p>使用名称或 URL 匹配路由表中定义好的路由，参数解析（如解析 &#x2F;foo&#x2F;:bar），子路由处理，别名 alias 处理，都是通过 <code>createMatcher</code> 处理的。</p><p>最后会返回Route对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">route</span>: <span class="title class_">Route</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: location.<span class="property">name</span> || (record &amp;&amp; record.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">meta</span>: (record &amp;&amp; record.<span class="property">meta</span>) || &#123;&#125;,</span><br><span class="line">  <span class="attr">path</span>: location.<span class="property">path</span> || <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">hash</span>: location.<span class="property">hash</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  query,</span><br><span class="line">  <span class="attr">params</span>: location.<span class="property">params</span> || &#123;&#125;,</span><br><span class="line">  <span class="attr">fullPath</span>: <span class="title function_">getFullPath</span>(location, stringifyQuery),</span><br><span class="line">  <span class="attr">matched</span>: record ? <span class="title function_">formatMatch</span>(record) : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一说的是，传入一个路由的时候，路由会被编译成一个正则表达式进行参数解析（rc&#x2F;create-matcher.js&#x2F;matchRoute）。</p><p>如传入一个路由 &#x2F;foo&#x2F;:bar：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = [];</span><br><span class="line"><span class="keyword">const</span> regexp = <span class="title function_">pathToRegexp</span>(<span class="string">&quot;/foo/:bar&quot;</span>, keys);</span><br><span class="line"><span class="comment">// regexp = /^\/foo(?:\/([^\/#\?]+?))[\/#\?]?$/i</span></span><br><span class="line"><span class="comment">// keys = [&#123; name: &#x27;bar&#x27;, prefix: &#x27;/&#x27;, suffix: &#x27;&#x27;, pattern: &#x27;[^\\/#\\?]+?&#x27;, modifier: &#x27;&#x27; &#125;]</span></span><br></pre></td></tr></table></figure><p>如果有参数则将参数从匹配的结果中取出，最终放到 Route 对象中的 params 属性中。</p><h3 id="路由模式的实现"><a href="#路由模式的实现" class="headerlink" title="路由模式的实现"></a>路由模式的实现</h3><p>路由模式的处理源码在 src&#x2F;history 目录下，hash 模式的处理逻辑在 hash.js， history 模式在 html5.js中，两个类的接口很相似。</p><p>路由模式的实现主要任务点在，更新浏览器 URL（ensureURL 方法） 和监视浏览器 URL 改变（setupListeners 方法）。</p><p>处理完之后回到VueRouter 类的 init 方法修改 _route, _route 是一个响应式数据，当它发生变更的时候，组件会重新渲染。</p><h3 id="RouterView-和-RouterLink"><a href="#RouterView-和-RouterLink" class="headerlink" title="RouterView 和 RouterLink"></a>RouterView 和 RouterLink</h3><h4 id="RouterView"><a href="#RouterView" class="headerlink" title="RouterView"></a>RouterView</h4><p><code>RouterView</code>的主要作用就是将当前匹配的路由的组件渲染出来，因为当前是哪个组件是会动态变化的，因此 Vue-Router 选择了使用 render() 方法来实现。</p><p>首先从路由中取出对应的组件，然后使用 h() 方法（即 createElement() 方法）返回组件的虚拟 DOM，后续跟 Vue 中的组件渲染一样。</p><h4 id="RouterLink"><a href="#RouterLink" class="headerlink" title="RouterLink"></a>RouterLink</h4><p><code>RouterLink</code>主要是对链接的事件做了拦截，当点击链接的时候，会尝试调用 router.push() 或者 router.replace() 方法来完成导航，并阻止浏览器默认的导航，从而使这些链接也变成前端路由接管。</p><p>如果我们查看页面渲染的出来的H5源码，我们也会发现，<code>routerLink</code>会完成</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vueRouter实现的很精妙，极大的方便了我们日常切换不同功能模块的需求。</p><p>如今，vueRouter几乎已经是开发中必须的插件，对其略作深入的了解也是必须的，虽然出在面试题中不算合理，但是也是考量了开发者的了解广度。</p><p>虽然，我仍然觉得意义不大，不过确实算是扩充了一些熟悉的知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7380241307116765194">Vue-Router 前端路由原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解set,map,weakset,weakmap</title>
      <link href="/2024/06/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3set,map,weakset,weakmap/"/>
      <url>/2024/06/17/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3set,map,weakset,weakmap/</url>
      
        <content type="html"><![CDATA[<p>面试官（朋友）：看简历上，您对JS很熟悉，您了解set和map吗？</p><p>我：set我常用来做数据去重，map没了解过。</p><p>面试官（朋友）：哈哈哈，您真是太幽默了，欢迎那您来参加面试，后续人事会通知您面试结果的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于set和map的面试题，我个人确实没怎么看，除了一开始翻过ES6的书，记得要用set去重数组之外，后续就没有深入了解了。</p><p>我甚至记不得weakset和weakmap这两种。</p><p>这里今天朋友客串了一把面试官，然后狠狠地嘲笑了我一顿，想想真是糟糕。</p><h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h3><p>Set和Map是ES6新增加的数据类型。其中Set被称作“集合”，Map被称作“映射”。</p><p>新增的这两个数据结构提供了更灵活和强大的方式来处理和存储数据。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是一个简单值的集合，类似于数组。Set的特点：Set成员的值都是唯一的，不允许重复。</p><p>通过Set这一特性，可以运用Set进行去重操作。</p><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><p>通过数组的解构和Set无重复值的特性，可以产生一个数组去重的小妙招。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> newArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br><span class="line"><span class="comment">// 结果:[1,2,3]</span></span><br></pre></td></tr></table></figure><h6 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h6><p>数组可以通过Set特性去重，而且数组还有join方法可以将数组转换成字符串，这样我们可以联想到字符串去重的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abcabcaaa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> newStr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr);</span><br><span class="line"><span class="comment">// 结果：abc</span></span><br></pre></td></tr></table></figure><h5 id="Set常用方法"><a href="#Set常用方法" class="headerlink" title="Set常用方法"></a>Set常用方法</h5><p>通过<code>new Set()</code>初始化Set对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//或从一个数组创建</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br></pre></td></tr></table></figure><p>调用<code>add(value)</code>方法向 set 集合 中添加指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>调用<code>has(value)</code>方法检查集合中是否存在指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>调用<code>delete（value）</code>方法删除集合中的指定元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>调用<code>clear()</code>方法清空集合内所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p>set对象中的<code>size</code>属性可以返回集合中元素的数量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>)<span class="comment">//1(不存在重复值)</span></span><br></pre></td></tr></table></figure><h5 id="Set的遍历方法"><a href="#Set的遍历方法" class="headerlink" title="Set的遍历方法"></a>Set的遍历方法</h5><ol><li>调用<code>keys()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素的键。</li><li>调用<code>values()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素的值。</li><li>调用<code>entries()</code>方法返回一个新的迭代器对象，该对象包含Set对象的每个元素（值和键）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// SetIterator &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3, 4 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure><h5 id="遍历Set的方法"><a href="#遍历Set的方法" class="headerlink" title="遍历Set的方法"></a>遍历Set的方法</h5><p><code>forEach</code>方法</p><p>和数组一样，Set也有forEach方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果为：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果为：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="Set的优缺点"><a href="#Set的优缺点" class="headerlink" title="Set的优缺点"></a>Set的优缺点</h5><ul><li>优点：<ol><li>Set中的元素都是唯一的，不会重复的值。</li><li>因为Set中的值是唯一的，所有查找、删除和添加的操作执行得更快。</li></ol></li><li>缺点：<ol><li>在ES6中，Set保持了插入顺序，但是存在兼容问题。</li><li>与数组不同，Set不能通过索引来访问Set中的元素。</li></ol></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>在普通对象中，对象的键名的类型都是字符串，如果不是字符串类型也会被转换为字符串类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [n]: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">n</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    [[<span class="string">&#x27;测&#x27;</span>]]: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="comment">// 结果：&#123;123: 1, n: 1, name: &#x27;张三&#x27;, &quot;测&quot;: &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>这里我们注意到了，二维数组也被转为了空字符串。</p><p>然而随着需求的不断增加，出现了对象中的键名需要是其他类型的需求，因此JavaScript提供了Map这一数据结构。</p><p>Map这一数据结构允许使用任何值作为键。</p><blockquote><p>注意：不要将数组的map方法和Map数据结构记混。</p></blockquote><h5 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h5><p>通过<code>new Map()</code>初始化Map对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure><p>调用<code>set(key,value)</code>方法向Map中添加一个键值对。</p><p>注意：不要和上面的Set数据结构搞混喽。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>get(key)</code>方法根据提供的键名返回对应的值，如果不存在该键名则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>has(key)</code>方法可以检查是否包含指定的键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>如果包含就返回true，如果不包含就返回false。</p><p>调用<code>delete(key)</code>方法可以删除指定的键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure><p>调用<code>clear()</code>方法可以删除所有键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p>Map的属性<code>size</code>可以返回键值对数量。（注意size不是方法，而是属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h5 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h5><p>与Set的遍历方法相似。</p><ol><li><code>keys()</code>:返回一个新的迭代器对象，其中包含Map的所有键名。</li><li><code>values()</code>:返回一个新的迭代器对象，其中包含Map的所有键值。</li><li><code>entries()</code>:返回一个新的迭代器对象，其中包含Map的所有键值对。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;1&#x27;</span>], <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;1&#x27;, Array(1)&#125;</span></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;2&#x27;, &#x27;1&#x27;&#125;</span></span><br><span class="line"><span class="comment">// MapIterator &#123;&#x27;1&#x27; =&gt; &#x27;2&#x27;, Array(1) =&gt; &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="遍历Map的方法"><a href="#遍历Map的方法" class="headerlink" title="遍历Map的方法"></a>遍历Map的方法</h5><p><code>forEach</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 张三</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"><span class="comment">// gender 男</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name 张三</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"><span class="comment">// gender 男</span></span><br></pre></td></tr></table></figure><h5 id="Map的优缺点"><a href="#Map的优缺点" class="headerlink" title="Map的优缺点"></a>Map的优缺点</h5><ul><li>优点：<ul><li>Map可以存储任何类型的键和值</li><li>Map的键也是唯一的，不存在重复的键</li><li>Map内的顺序和插入顺序一致</li></ul></li><li>缺点：<ul><li>Map不能和数组一样通过索引直接访问</li><li>存在兼容IE的问题</li></ul></li></ul><h5 id="Map的应用场景"><a href="#Map的应用场景" class="headerlink" title="Map的应用场景"></a>Map的应用场景</h5><p><code>Map</code>因为是一组键值对的结构，具有极快的查找速度。</p><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure><p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p><p>这里我们用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.<span class="keyword">get</span>(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>，<code>Map</code>具有以下方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure><h3 id="弱引用和强引用"><a href="#弱引用和强引用" class="headerlink" title="弱引用和强引用"></a>弱引用和强引用</h3><p>WeakSet和WeakMap都是弱引用。</p><p>首先了解一下什么是弱引用。</p><p>弱引用是不能确保其引用的对象不会被垃圾回收器回收的引用，而强引用是确保其引用的对象不会被垃圾回收器回收的引用。</p><p>也就是说，JavaScript引擎在执行代码时，对象通过变量直接赋值形成的引用会被视为强引用，垃圾回收器就不会回收这类对象；</p><p>通过<code>WeakMap</code>和<code>WeakSet</code>建立的引用会被视为弱引用，这类引用无法阻止垃圾回收器的回收。</p><p>当一个变量被设置为<code>null</code>时，会断开该变量与原对象间的引用，该对象就会变成垃圾回收器的回收目标。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = [person]; </span><br><span class="line">person = <span class="literal">null</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); </span><br></pre></td></tr></table></figure><p>创建一个叫<code>person</code>的对象，并将该对象存储到<code>person1</code>中；</p><p>然后将<code>person</code>设置为<code>null</code>，断开引用，但是因为变量<code>person1</code>存在对<code>person</code>对象的强引用，所以该对象不会被垃圾回收器给盯上。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line">person1.<span class="title function_">set</span>(person, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">person = <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 等待垃圾回收后 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); </span><br></pre></td></tr></table></figure><p>创建一个<code>weakMap</code>对象<code>person1</code>和一个对象<code>person</code>，并且将该对象作为键，键值为<code>&quot;张三&quot;</code>添加到<code>person1</code>中；</p><p>然后将变量<code>person</code>设置为<code>null</code>，断开了变量与对象的引用，然而<code>person1</code>对<code>person</code>是弱引用，所以垃圾回收器可以回收<code>person</code>对象。</p><h4 id="WeakSet和WeakMap"><a href="#WeakSet和WeakMap" class="headerlink" title="WeakSet和WeakMap"></a>WeakSet和WeakMap</h4><h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>WeakSet和Set非常相似，但是有一些不同之处：</p><ol><li>成员类型：WeakSet的成员只能是Symbol值和对象，不能是其他的数据类型；Set的成员可以是任意数据类型。</li><li>引用类型：WeakSet是弱引用；Set是强引用。</li><li>方法和属性：WeakSet不支持迭代，所以没有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，并且也没有<code>size</code>属性；Set有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，也有<code>size</code>属性。</li><li>作用：WeakSet可以实现自动清理回收；Set可以通过元素的唯一性用于实现去重工作。</li></ol><h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><p>WeakMap和Map也非常相似，但是也是有一些不同：</p><ol><li>键的类型：WeakMap的键类型只能是对象和Symbol值；Map的键类型可以是任意数据类型。</li><li>引用类型：WeakMap是弱引用；Map是强引用。</li><li>方法和属性：WeakMap不支持迭代，所以没有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，并且也没有<code>size</code>属性；Map有<code>forEach</code>, <code>values</code>, <code>keys</code>, <code>entries</code>方法，也有<code>size</code>属性。</li><li>作用：WeakMap也可以实现自动清理回收；Map提供需要高效键值对的操作。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>set和Map是常用的数据去重的类型，我个人平时没怎么用过去重的方法，所以接触的不深。</p><p>今天了解了一下，依然感觉没什么太广阔的用途，作为知识点了解下吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7377635432967192585?searchId=20240616145532E914394B07D15EA32D34">ES6数据结构深度解析：Set, Map, WeakSet 和 WeakMap</a></p><p><a href="https://juejin.cn/post/7080066742642278407?searchId=2024061721181220C10D42B076B557B9A0">Map和Set的应用场景（搬运）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于生产力极大发展的浅思</title>
      <link href="/2024/06/16/%E5%85%B3%E4%BA%8E%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%9E%81%E5%A4%A7%E5%8F%91%E5%B1%95%E7%9A%84%E6%B5%85%E6%80%9D/"/>
      <url>/2024/06/16/%E5%85%B3%E4%BA%8E%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%9E%81%E5%A4%A7%E5%8F%91%E5%B1%95%E7%9A%84%E6%B5%85%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>人是一根会思考的芦苇——帕斯卡。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文是长久的思索的阶段性结论，我个人认为，生产力极大发展之后，人将不会再是人，至少不是现在人类。</p><p>人类，只是人类文明在漫长时间长河中，一段无足轻重的注脚罢了，未来人类，绝对不是现在人类想象中的那样。</p><p>在正式开始之前，先简单叠个甲。</p><p>我不过一介凡人，从未觉得不凡，在我成长的人生路上，早已经习惯了自己的平凡，可是随着时间的推移，我渐渐地发现了有些不对。</p><p>很多人放弃了对于宏大想法的思索，他们曾有数学系的天才，我曾在秀的算法面前感到一阵头皮发麻，也见过三天之内突击，现场暴打蓝桥杯的竞赛的怪物。</p><p>我见过在团队中的多面手，一人可以解决数种问题，同时能够高度抗压，完美带领团队。</p><p>也见过儒商一般的精英天才，数次创业不断盈利，硬生生将公司从普通的小公司带到数百人的规模，并且辉耀至极。</p><p>无数的天骄英才在我这短暂的生命中滑过，看着这些辉耀的人生，我常常感到自己人生真是不虚此行，真实跟这些共事，是我的荣幸。</p><p>我一直觉得自己很平凡，从未觉得自己有什么不同的地方。</p><p>直到这脱离人群的数年内，我渐渐感觉到自己的不同了，我渐渐地觉得，我这个平凡的家伙，似乎真有点不同，不是那种利他性的不同。</p><p>我的想法，太不合群了。</p><h3 id="脱离群体"><a href="#脱离群体" class="headerlink" title="脱离群体"></a>脱离群体</h3><p>我的想法，是从什么时候逐渐脱离人群的呢？记不清了，在高中大学混沌时刻，我并未有这么多古怪的想法，而随着工作的不断增长，我愈发的发现，我的思维开始脱离群体。</p><p>我不习惯用社会的既有规则去融入，面对既有的社会分工，我总感觉有种说不出的古怪。</p><p>在摆脱了生存的危机之后，直至去年在家的空闲期，我的思维愈发的发散。</p><p>我居然在思考整个社会的走向和未来人类社会的形态。</p><p>该怎么说呢？这种想法太过傲慢，也太过无用了。</p><p>只是，脱离人群之后，人的思想会逐渐变得怪异，不合群便会诞生一些奇怪的想法，这种想法我个人感觉不是被大众接受的，不利于群体使用的，不合规矩，不能经世致用的瞎想。</p><p>因为这些想法并不能带来什么收益，所以很少有人去关注这些。</p><p>一开始，我以为我的这些瞎想太过抽象，也太过无趣，在我身边的那些精英们大多应该早就思考过，他们思考过，所以他们选择了自己的道路。</p><p>我一度质疑我这种想法肯定有很多人都有类似的想法，但是后来发现不是的，并非所有人都有类似的想法。</p><p>经过漫长的生活，我发现没有人去思考这个社会。</p><p>大众在迫于生存的压力中，放弃了自己的思考，为了生存和社会分工的规划，他们按照社会分配的角色，被社会完成了规划，成为了整个机器的运转的一环。</p><p>即便是思考这个社会形态的人，多数也只是思考这个社会如何能运转的更好。</p><p>这是一种很自利的利他想法，为了避免这台社会机器的崩塌，更多人选择放弃更深层的思考，让社会顶层的人代替自己思考。</p><p>在这种不断的推诿下，最终，统治阶级成型了。</p><p>只有这部分生产力极度富裕的人，他们才有着对未来思索的权力。</p><p>于是，我们发现了一个怪诞的情况，很多精英明明能力极强，但是想法却和大多数人的认知差不多，他们由于自己的认知或者生活的规训，不再关注和思索未来，只是不断专注于自己手中技能的打磨，在自己的专精领域内不断精深，而不再关注这种有些偏向于虚无的思索。</p><p>最终，居然只是我这种平凡的家伙，在思考这些怪诞的事？</p><h3 id="生存本质"><a href="#生存本质" class="headerlink" title="生存本质"></a>生存本质</h3><blockquote><p>生存的本质就是掠夺，对他人的掠夺，对外物的剥削，他人即地狱</p></blockquote><p>幸而有历史书的记录，我得以窥见人类的社会体制的不断进步，这里感谢一下人类社会体系中的史官，感谢他们的记录。</p><p>从原始奴隶制，到远古封建，继而后帝国封建，再后来是资本主义，国家资本主义的时代。</p><p>人类的社会，从远古的蛮荒到如今的文明，虽然看似剥削手段渐渐地温和，但是本质上将生存的矛盾转嫁到其他物种身上了。</p><p>我并非什么万物共产的那种傻逼，我只是点出来人类生存环境为何看起来变好的原因。</p><p>人类如今的生存，是建立在对整个生物圈的资源拓张，包括各种资源的开采，对其他生物的规模化体系化猎杀，人类之所以不再血腥，是因为这种血腥可以对外转嫁了。</p><p>因为脱离了对生存的基本威胁，为了更有效的获取资源，更好的生存，更稳定的生存，于是便有了社会这个需求。</p><p>社会的本质，是更好的利用人群为一部分人获取资源，是对他人的生存资源的掠夺。</p><p>即便现代文明社会采用了更温和的交换手段，但是受限于信息，地域，保存成本等因素，不可避免的，这仍然是一种掠夺，只是披上了一层温和的底色，社会的本质，仍然是对他人的掠夺。</p><h3 id="生产力大发展"><a href="#生产力大发展" class="headerlink" title="生产力大发展"></a>生产力大发展</h3><p>生产力大发展个人认为依然是一种掠夺，不过相对于之前那种原始的掠夺，这种方式能让被掠夺者也有一定的生存空间。</p><p>在基础生存条件的保证下，人类群体开始分化，无产阶级和资产阶级的群体分类开始逐渐明显。</p><p>这时候，人类内部发生了数次大规模战争，暴动，因为既有生产关系无法适应生产体系，为了适配新的掠夺体系，在不断的暴动和战争中，新生代的规则逐渐建立。</p><p>以下是个人的暴论，通过对科技发展史的窥探，个人得出了一部分结论，如果不正确，欢迎评论区指正。</p><ul><li>第一次蒸汽时代，随着纺织机和火车的出现，人类社会为了倾销，便有了各种对外战争和自由贸易搞垄断倾销，这可比做海盗赚的快的多了</li><li>第二次电气时代，随着内燃机和电力的兴盛，美国人在喝饱了枪火交易的红利，在内部搞西进运动圈地和杀人，之后大基建（虽然有逼不得已的成分），但无论是何等疯狂的方式，确实让人类的屠戮规模降了不少</li><li>第三次网络时代，随着网络的下方，人类的交流成本开始极大程度的缩减，这让人与人之间的信息获取方式便利，此前美苏冷战，此后续苏联解体，一直到现在次时代的中美贸易（个人感觉这是另一种类型的冷战），全球都在打代理人战争，核武保证了大规模的热战不会出现，但是非核的代理人战争开始逐渐兴盛。</li></ul><p>目前仍然没有第四次科技革命的苗头，所以生产力陷入瓶颈，阶级闭锁，进入历史内的垃圾时间。</p><p>纵观这段时间的科技史，我们大概可以窥探到，生产力大发展之后，为了保证新生时代的生产关系能够适配，自然也就会有流血冲突，为了保证能够大规模的铺开新生代的生产力，全面迭代，那么就需要一场世界级的战争。</p><p>这是人类无法自控的，是出于本能的，为了要生存，要更好的生存，就必须要伤害他人。</p><p>不，不是一两个人的伤害，而是要一群两群，甚至是一代两代人的伤害。</p><p>想要生产力大发展，就需要对另一群人进行掠夺，倾销，垄断，世界大战，代理人战争，总归是一个群体对另一个群里的掠夺，把对方的资源加入到己方手中。</p><p>虽然在这个过程中，人类社会逐渐变得越发精密化，分工合理化，但本质并未改变。</p><p>生存本质就是掠夺，大大小小的国家，都是为了掠夺和防掠夺而形成的团体。</p><h3 id="资本异化"><a href="#资本异化" class="headerlink" title="资本异化"></a>资本异化</h3><p>这是共产主义提到的，说资本主义对人的工具化，但是思考了一段时间后，我认为这说的还是肤浅了一些。</p><p>是生产关系对人类的本身的驯化，无关乎是什么主义，只要有体系，为了保证体系内的人都有用，就要想办法去让他们发挥作用，继而工具化。</p><p>这便是我开头提到的那些了，人是极为容易被塑造的，只要你手里有资本，在指定好规则后，便可以通过规则将人塑造成统治阶层想要的形状。</p><p>这点无关乎于是资本主义还是别的什么主义，只要掌握了生产资料，制定了生产关系，便会有对应的群体替你想办法，去规训整个群体，设计规则，工具化人类群体。</p><p>这里并不批判这种异化和规训是好还是坏，单纯就是想说明一点。</p><blockquote><p>思想，是很容易被改变的。</p></blockquote><p>这里举一些生活的例子，比如爱国。</p><p>什么是爱国呢？</p><p>在旧中国封建时代，是君要臣死臣不得不死，在日本最狂热的军国时代中，无数死士愿意为了他们的天皇板载冲锋，在早年的美国开国时代，美国人还是一个信奉天主教为主的国家，甚至搞出过禁酒令这种傻逼活动。</p><p>这些都是爱国。</p><p>然后，不过两百年的时间，发生了什么呢？</p><p>东亚地区的新中国和日本不再兴盛于个人崇拜，君王的光辉逐渐散去，那种为了君王而死的思想被摒弃，在美国，如今已经是极为开放，甚至开放到魔怔的时代，完全不再是当初天主教徒为主的保守模样。</p><p>这还是爱国吗？</p><p>答案仍然是爱国，因为新时代爱国的定义变了，只要你不危害国家，这本身就一种爱国，新生代的道德评价体系变了。</p><p>异化，是轻易而简单的，为了适配新时代的生产力，这种速度是极为快速的。</p><p>如果感觉是不明显，那我再用国内的彩礼体系举个例子。</p><p>彩礼的价格是多少？爱情到底应该是什么样子？这里仅从男性婚娶角度来思考。</p><p>70-90年代的中国人，结婚只有三大件要求，“手表、自行车、缝纫机”到“冰箱、彩电、洗衣机”，不过那时候还要求是城市户口。</p><p>2000年之后，随着改革开放的开始发力，逐渐要求房子，车子，存款，这是那个时代的三件套，那时候女方可能学历是大学生更吃香一些。</p><p>2010年之后，随着网络市场下沉，彩礼逐渐开始成为重头戏，江西的天价彩礼开始进入全国的视野，之后各地经济发展，彩礼价格开始提升，从1万逐渐提升至8万，此时各地并未超过10万，此时并未要求房子是否无贷款。</p><p>2020年之后，彩礼的标配已经开始提升至10-20万左右，房子要求工作地，最好要求无贷款，工作要求稳定或者是体质内，存款要求10万起步，且有了相貌的要求，这在大多数人眼中是正常现象。</p><p>从2010年-2020年，这个时代不过十年，结婚的成本整个翻了近十倍不止，但是社会的生产力并未跟上，只是之前房地产抬高了整个社会的经济活力，让所有人感觉这种财富增长的现象会是常态。</p><p>这里并不发散，我只是想说，在经济发展的数十年内，道德的工具化效果就很明显了，这是一种为了生存而形成的自发的规则化掠夺行为。</p><p>结婚发展史就是一种道德变化的要求，所谓的爱不爱，就是在不断抬高生存成本的一种规训。</p><p>这种规训，便是所谓的资本异化，无论是推翻既有的社会体系，还是重建一套体系，都无法避免这种东西的存在。</p><p>这就是人类社会底层逻辑：要掠夺，要通过既有的分配体系来掠夺，保证自己的生存。</p><p>彩礼的标配，与其说是彩礼的定义，倒不如说是这个时代对人类的定义，只要符合这个定义，才能使算作这个时代的人类，具有了繁衍资格。</p><p>不符合这个定义，却拥有人类的血统？</p><p>这种物种，在蜂群中有个很合适的定位：工蜂。</p><p>工蜂只能用来劳动，绝对不能用来思考和繁衍，他们只是个会说话的工具罢了，工蜂只能被用来消耗，不具有繁衍资格。</p><p>这一点，在人类漫长的历史中从未改变。</p><p>这点不仅仅在中国发生，是世界通用的，譬如福特也曾经说过：我明明只想雇一双手，为什么来了一个人？</p><p>只是需要工具，而非需要人类，这便为了掠夺效率最大化而产生的绝对逻辑，是人类社会对人类群体自我异化的必然性。</p><h3 id="共产主义？"><a href="#共产主义？" class="headerlink" title="共产主义？"></a>共产主义？</h3><blockquote><p>生产力水平极大提高，物资极度丰富，劳动成为人的第一需要，按需分配，国家消失，人人自由而平等。</p></blockquote><p>这是共产主义社会的特征，我曾经对此深信不疑，因为前时代，随着科技的兴盛和发展，我真的见识到了社会被科技改造的历程。</p><p>可是随着社会生产力的不断发展，随着生活阅历的不断丰富，我逐渐质疑起共产主义的可行性。</p><p>生产力极大富裕之后，真的会有有人自由平等吗？</p><p>如果真的平等，为什么会有地区差异。</p><p>如果真的平等，不同职业为什么收入差距会如此之大。</p><p>如果真的平等，为什么官僚体系内的收入福利会如此之多？</p><p>官方每次的回应总是说我们处于社会主义初级阶段，但是仔细看看，我始终不感觉统治阶层的老爷们和底层人是一个物种。</p><p>随着时代的进步，这些底层燃料被完成消耗之后，如果平稳进入了共产主义，那么共产主义时代的人，还会在意底层这些和他们完全不一样的旧人类吗？</p><p>共产主义，真的会养出来让所有人都平等的社会吗？</p><p>如果人类生存的本质是要掠夺，那么共产主义要如何破局？</p><p>这和传销所宣扬的所有人都能挣钱的结局有什么本质上的区别吗？</p><p>共产主义是假的，一场传销骗局。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我并不信奉任何主义，人类社会的本质，就是一场掠夺式的骗局。</p><p>共产主义，是梦幻的温柔乡。资本主义，是明牌的杀戮。</p><p>我认为，在生产力极度富裕的未来，无论是幻想中的共产主义，还是资本主义的终产个体，我都不认为会存在。</p><p>人类的思维始终被人类禁锢了，在那个时代的诞生时候，现有的人类制度将会随着现代人类彻底消亡。</p><p>必然会有新时代的人类随着新生代的而诞生，那种未来人类，不会禁锢于我们现有的道德规则，然后如同每次生产力革新时代的暴力运动一样，他们会横扫所有现时代所有的人类。</p><p>而那时的人类，那时的文明，便也许有了新的称呼。</p><p>或许，那就是，神。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《中国近代史》</p><p>《资本论》</p><p>《自私的基因》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速，选用volta的理由</title>
      <link href="/2024/06/15/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8volta%E7%9A%84%E7%90%86%E7%94%B1/"/>
      <url>/2024/06/15/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8volta%E7%9A%84%E7%90%86%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>我：开发环境node环境有点乱，下个nvm用用吧。</p><p>同事：也许你应该考虑放弃nvm，考虑一下这款好用的volta？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在公司的电脑环境上安装了自用的hexo博客，打算日常午休时候，可以稍微写点什么。</p><p>但是，hexo和公司电脑环境上的配置发生了冲突。</p><p>公司项目是<code>node20</code>版本的环境，hexo的环境是不支持的，本来打算用nvm处理一下算了，甚至算了一下时间，我都想放弃用公司电脑摸鱼写博客了。</p><p>但是后来朋友说，用<code>volta</code>，这是比nvm更好的node版本管控工具，能完美解决我的痛点。</p><p>我一开始不信，翻了一下<a href="https://docs.volta.sh/guide/#why-volta">volta官网</a>，也没明白到底好用在哪里，我承认我英语不好，但首页说明很简单，这点我还是看的明白。</p><blockquote><p>使用 Volta，您可以一次选择 Node 引擎，然后不再担心它。您可以在项目之间切换，而不必手动切换 nodejs 版本。</p><p>你可以在工具链中安装 npm 包，不必定期重新安装它们，或者弄清楚它们停止工作的原因。</p></blockquote><p>官网这话说的比较拗口，一开始我没明白什么意思，之后上手用了一下，我瞬间明白了。</p><p>这玩意能给项目锁node版本！每个项目在设置好自己的版本之后，不同项目可以同时运行。</p><p>这不需要像nvm一样，每次换项目都得手动命令行切换node版本。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>相信，我上边的例子已经让您明白到底什么样的环境适合使用<code>volta</code>工具了。</p><p>这里，个人总结一下适合的应用场景</p><ol><li>多项目，一台电脑上有多个需要开发的项目</li><li>node多版本，多个项目之间node版本跨度要求大，不能同时使用一个环境</li><li>需并行开发，要同时运行数个node环境不同的项目</li></ol><p>如果满足以上应用条件，不妨尝试一下使用<code>volta</code>。</p><p>除了无缝衔接，每个项目的无须手动切换外，它还有如下特点：</p><ul><li>速度，因为是用时下流行的rust重写的，所以运行速度很快</li><li>跨平台支持，包括 Windows 和所有 Unix shell</li><li>稳定的工具安装-无需每次升级都重新安装!</li></ul><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><p>因为个人是win系统，且win系统的操作相对繁琐，这里先说win系统的安装。</p><h4 id="win"><a href="#win" class="headerlink" title="win"></a>win</h4><p>对于 Windows，<a href="https://link.juejin.cn/?target=https://github.com/volta-cli/volta/releases/download/v1.1.1/volta-1.1.1-windows-x86_64.msi">下载并运行 Windows 安装程序</a>并按照说明操作。</p><p>Volta 的功能依赖于创建符号链接，所以你必须<a href="https://link.juejin.cn/?target=https://learn.microsoft.com/zh-cn/windows/apps/get-started/enable-your-device-for-development%23accessing-settings-for-developers">启用开发者模式</a>。</p><p>启用开发者模式的意思很简单，就是打开设置&gt;开发者选项，然后打开开发人员模式即可。</p><p>对了，这里要注意下，有时候VScode窗口命令行不支持的时候，把所有的VScode全部关掉再重开即可。</p><h4 id="mac与linux"><a href="#mac与linux" class="headerlink" title="mac与linux"></a>mac与linux</h4><p>这里我没有mac，所以我就不细说了，反正mac环境很干净，知道对应的目录敲一下命令就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.volta.sh | bash</span><br></pre></td></tr></table></figure><p>如其他开发的环境工具一样，安装完成之后，我们可以用如下命令确认是否安装成功。</p><p>如果安装完成后，敲命令无效，记得开个新终端重新输入命令确认一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volta --version</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>这里也不墨迹，直接与nvm使用方式的对比一下。</p><table><thead><tr><th>名称</th><th>volta</th><th>nvm</th></tr></thead><tbody><tr><td>下载</td><td>volta install node@16</td><td>nvm install @16.12.0</td></tr><tr><td>卸载</td><td>volta uninstall</td><td>nvm uninstall @16.12.0</td></tr><tr><td>使用node版本</td><td>–</td><td>nvm use</td></tr><tr><td>固定node版本</td><td>volta pin node@16</td><td>–</td></tr><tr><td>查看安装的版本</td><td>volta list</td><td>nvm list</td></tr><tr><td>查看可安装的版本</td><td>–</td><td>nvm list available</td></tr></tbody></table><p>注意，volta uninstall 命令似乎卸载不了已经安装node版本，这里我尝试过使用命令去安装和卸载，结论就是volta除了针对pnpm和nvm的安装卸载有效果，其他毫无作用。</p><p>可能这是一个bug，如果有人能正式用出来，可以再我的评论区说一下，我这边立刻改掉，反正我是没试出来。</p><p>正式的命令，可以参考这个：<a href="https://volta.jikun.dev/reference/">Volta 命令 | Volta (jikun.dev)</a>，这应该是同人做的官网文档中文翻译，不过，我参考这个卸载命令试了一下，还是不行。</p><p>总之，目前除了卸载，一切都算是正常。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>记得用个正常的网络环境去下载node，我遇到个网友下载node版本，一直说不行，给我整的不自信了。</p><p>后来排查了一下，他说是用他同事的网络，然后同事的网络做了拦截，最终导致下载失败。</p><p>所以，记得要有个正经的网络环境，这样对我们下载大大的有好处啊，人生宝贵，我们不该把时间浪费在下载的等待时间上。</p><h3 id="同类工具"><a href="#同类工具" class="headerlink" title="同类工具"></a>同类工具</h3><p>本来是没有这项的，在整理到一半的时候，在群友提示下，我才发现volta还有同类的工具——<a href="https://gitcode.com/Schniz/fnm/overview?utm_source=csdn_github_accelerator">fnm</a></p><p>这可真是铁板上烤鱿鱼——卷起来了啊。</p><p>和volta一样，fnm也是rust编写的，很快且支持项目固定node环境，而且也能稳定安装环境，同时wiki上也是中文。</p><p>感兴趣的可以参考这篇文档：<a href="https://blog.csdn.net/weixin_43288600/article/details/135073118">还在用nvm？来试试更快的node版本管理工具——fnm_fnm windows-CSDN博客</a>。</p><p>这博客虽然是在csdn上写的，但写的简单干脆，适合阅读，没啥车轱辘话，挺不错的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不得不说，真是江山代有人才出，明明一年没正式在开发团体中做事，就感觉现在前端圈子变了好多。</p><p>我们那个时候对于node版本管控需求不高，所以最多就一个nvm就够用了，而现在不同node版本的新旧项目叠在一起，如此环境，</p><p><code>volta</code>，确实好用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/691809574">软件丨node版本管理的神！ - 知乎 (zhihu.com)</a></p><p><a href="https://volta.jikun.dev/reference/">Volta 命令 | Volta (jikun.dev)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析解构赋值到底是深拷还是浅拷</title>
      <link href="/2024/06/13/%E6%B5%85%E6%9E%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7/"/>
      <url>/2024/06/13/%E6%B5%85%E6%9E%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7/</url>
      
        <content type="html"><![CDATA[<p>群友：听说你最近在刷面试题？要不我问一道题你看看你能不能回答？</p><p>我：没问题，我对面试八股文多少还是有点自信的。</p><p>群友：那，解构赋值到底是深拷贝还是浅拷贝？</p><p>我：你他妈是故意来找茬的吧？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>从来没想过的基础问题，一下子被干懵了，我个人在入行第二年的时候就通读了《ES6标准入门》这本书。</p><p>关于解构赋值这里，因为用的不熟悉所以特别多看了两眼，我记得文中从来没提过这事儿，而且我也从来没想过这茬子事情。</p><p>哎，这种题作为面试题，真把人干躺了也无所谓，就当是吃个经验教训。</p><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>明确一下深拷贝和浅拷贝的定义，或者说深拷贝和浅拷贝所应用于的数据类型。</p><ul><li>深拷贝：修改新变量的值不会影响原有变量的值。默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。</li><li>浅拷贝：修改新变量的值会影响原有的变量的值。默认情况下引用类型（object）都是浅拷贝。</li></ul><p>其实你只要理解透彻了这两句话就应该明白了解构赋值，甚至深拷贝的原理；</p><p>写两个例子，理解一下深拷贝和浅拷贝；</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>我们平时开发中，这种情况很常见的，直接用等号赋值就是深拷贝，如果没有新的内存空间存放变量，我们岂不是会直接修改元数据？</p><p>因此，此时对b的数值的修改并未影响a，所以基本数据类型赋值就是深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br><span class="line"><span class="comment">// 打印出：1,2</span></span><br></pre></td></tr></table></figure><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>所谓深浅拷贝，核心就是要不要用新的存储空间来存放变量，而且平时也主要是针对引用类型的数据。</p><p>这里直接用等号赋值，我们会发下，是浅拷贝赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="comment">// 打印出：&#123;name: &#x27;张三&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>其实这个时候，我们大概就能想明白一件事儿，那就是一门语言在面对这种大小不确定的引用类数据类型，底层原理上肯定是倾向于浅拷贝。</p><p>不然，各个都是深拷贝，那就得开辟大量的新空间用来存储，一旦全面铺开，将会有一笔很大的存储空间消耗。</p><p>如果是这样，那这门语言一定会得到最消耗内存的烂名声，任何一名语言设计者在设计之初的时候，肯定不会希望自己设计的语言大量消耗存储空间。</p><p>所以，大多语言，引用类型数据的默认赋值方式，大概率都会是浅拷贝。</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>在上边赋值的时候，我们已经注意到了，</p><p>ES6的解构赋值，大家应该都清楚，本质上其实就是一种语法糖，可以快速取出数组或者对象中的值，这里放个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, marriage&#125; = a;</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;name1&#x27;</span>;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">marriage = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"><span class="comment">// 打印出：&#123; name:&#x27;name&#x27;,age:18, marriage: false &#125;</span></span><br></pre></td></tr></table></figure><p> 发现a的数据并没有被改变，解构赋值好像是深拷贝啊？？？？？</p><p>我们再改一下上面的例子看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">addr</span>: &#123; <span class="attr">province</span>: <span class="string">&#x27;sichuan&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;chengdu&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, age, marriage, addr &#125; = a</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;myname&#x27;</span></span><br><span class="line">age = <span class="number">26</span></span><br><span class="line">marriage = <span class="literal">true</span></span><br><span class="line">addr.<span class="property">province</span> = <span class="string">&#x27;shanghai&#x27;</span></span><br><span class="line">addr.<span class="property">city</span> = <span class="string">&#x27;shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, marriage, addr) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我直接将结果放在这里，感兴趣的可以直接用上述代码运行</span></span><br><span class="line"><span class="comment">// 打印出:myname 26 true &#123;province: &#x27;shanghai&#x27;, city: &#x27;shanghai&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 打印出: </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">addr</span>: &#123;<span class="attr">province</span>: <span class="string">&#x27;shanghai&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line"><span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">marriage</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 发现解构赋值出来的对象将原对象a中的addr的数据修改了，这样看还是浅拷贝；</p><p>这里我们根据上述情况，可以简单的</p><blockquote><p>解构赋值，如果所解构的原对象是一维数组或对象，其本质就是对基本数据类型进行等号赋值，那它就是深拷贝；</p></blockquote><p>如果是多维数组或对象，其本质就是对引用类型数据进项等号赋值，那它就是浅拷贝；</p><p>最终的结论就是：解构赋值是浅拷贝（因为它确实不能对多维数组或对象达到深拷贝的作用）；</p><h3 id="深拷贝本质"><a href="#深拷贝本质" class="headerlink" title="深拷贝本质"></a>深拷贝本质</h3><p>这里我们放一套常规的深拷贝赋值方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">source</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> targetObj = source.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;; <span class="comment">// 判断复制的目标是数组还是对象</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> keys <span class="keyword">in</span> source)&#123; <span class="comment">// 遍历目标</span></span><br><span class="line">    <span class="keyword">if</span>(source.<span class="title function_">hasOwnProperty</span>(keys))&#123;</span><br><span class="line">      <span class="keyword">if</span>(source[keys] &amp;&amp; <span class="keyword">typeof</span> source[keys] === <span class="string">&#x27;object&#x27;</span>)&#123; <span class="comment">// 如果值是对象，就递归一下</span></span><br><span class="line">        targetObj[keys] = source[keys].<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        targetObj[keys] = <span class="title function_">deepClone</span>(source[keys]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 如果不是，就直接赋值</span></span><br><span class="line">        targetObj[keys] = source[keys];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现了吗？其实深拷贝本质上还是将对象拆开为基本数据类型进行赋值。</p><p>所以，解决问题的本质就是让复杂问题简单化，所谓的深拷贝，本质上无非就是加强版的基础类型赋值罢了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是，就直接赋值</span></span><br><span class="line">targetObj[keys] = source[keys];</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然是非常基础的一个问题，但是却让我颇有受益。</p><p>所有语言开发之初，肯定对相关问题都有过优化，如今项目工程越来越繁杂，这种曾经精妙的设计确实也落入了尘埃，到底也是时代的眼泪了。</p><p>当然，感叹归感叹，但依然是实际开发中用不到的知识，不过确实有趣。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/blessYou/p/13038566.html">ES6的解构赋值与深拷贝和浅拷贝 - 前端随笔 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年第一次长途骑行</title>
      <link href="/2024/06/12/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/"/>
      <url>/2024/06/12/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>我从未想过有一天，自己会如此的落魄，我也从未想到过有一天，自己会如此的坚强。</p><p>从老家骑自行车到徐州，一路107公里，用时约莫11个小时，我熬过来了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>相比于去年惬意而安定的日子，今年这个时间简直是雪上加霜。</p><p>本篇并非一篇技术性的文，单纯是个人一点儿小小的感伤。</p><p>一切实在是太有趣了。</p><p>因为现在身上背着债，所以很多地方都不是很敢花钱，原本我不说，我还以为家里都有钱，结果现在我需要的时候，家里个个都欠着外债，日子过的这么阴间的时候还是头一回。</p><p>之所以会有这次从老家骑车到徐州的经历，完全是生活所迫。</p><p>具体前因就不描述了，总之，这次骑行是逼不得已的下策，是人生最窘迫的时刻之一。</p><h3 id="107公里"><a href="#107公里" class="headerlink" title="107公里"></a>107公里</h3><p>从老家到徐州，约莫30公里的时候，途径邳州，如同以往的经验一样，此时极度饥饿，于是停下来，吃了一碗炒面。</p><p>一碗炒面只有9块钱，但是为了后续路上有劲骑车，我又让老板多加了3块钱的炒面，后续我再没有吃过任何一点儿饭，因为到了夜里，路上没有一家店开门，都打烊了。</p><p>饥饿不是最糟糕的感觉，缺水才是最糟的体验。</p><p>路上没有地方能接开水，一路上买水又消耗了不少钱，估摸着消耗了快20块钱左右。</p><p>毕竟，不可能只买矿泉水，也买了一点电解质水（其实就是盐水），防止自己路上流汗过多脱水。</p><p>一路上，顶着饥饿和缺水的debuff硬是骑车骑了约莫一半的路程，然后最坑的时刻来了。</p><p>省道没有灯，虽然也有路灯，但是根本不亮，很显然，这灯就是看个乐子，根本没什么用的。</p><h3 id="G311"><a href="#G311" class="headerlink" title="G311"></a>G311</h3><p>恐怕是这条路上最黑的一段时间了，因为没有等，再加上手机没有电，后半程约莫有50公里的路，我勉强靠月光和路上的车的灯光分清了道路的大致线路，不然我连路上的线都看不清。</p><p>我敢保证，我这次出门最大的问题，就是没把握的夜骑灯带上，不然这次骑行至少等提前一个小时结束。</p><p>饥饿，缺水，同时也不能停下。</p><p>手机快没有电了，于是只能关掉手机，保留最后百分之十五的电量。</p><p>没有夜骑灯，只能靠着视力和路过车辆的灯光，勉强分清路线。</p><p>G311，这条路直达我要到的徐州站，好处是，我确实不需要看导航就可以走了，坏处是，我感觉这路上自己遇到了鬼打墙。</p><p>每隔一段时间，我几乎都能看到路上标识的G311路牌。</p><p>尽管我知道，这代表我走过了不小的一段路，但是每当看到这似曾相识的路牌时候，我总觉得，自己似乎完全没有任何前进，只是在原地踏步的打转罢了。</p><h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><p>怎么说呢，在这段路上，如果我没有点什么想法，那肯定是不可能的。</p><p>在路上，我总有一种恍如隔世的感觉，因为前一段时间我还在送外卖，数天前我在办公室开发项目，两天前我在刷面试题，一天前我抱着猫在家里睡觉，听歌。</p><p>然后，今天，我在黑暗中一路狂飙。</p><p>而且，无人能帮我什么。</p><p>我此时也没有什么钱，只能在这条路上一路到底，说起来，骑到最难熬的时候，心里反而有种奇怪的宁静感。</p><p>嘿，真有趣。</p><p>当G311进入市区路段的时候，我反而懈怠了，就像我之前工作到迷惘了一般，我感觉那时候可以歇歇，因为目的地太近了，我感觉自己好像可以退休了。</p><p>离目的地只有十公里，但是我怕路上真睡着后，之后就不会再想走了，所以一路又骑了过去。</p><p>最后十公里，骑得并不顺利，市区有几条路有岔路口，徐州的市政规划非常不好，路线极其扭曲，立交桥和各种岔路搞得市区路线简直一坨屎。</p><p>每当遇到岔路，我就得开机看看地图，然后每次开启，掉2%的电量，等到回到宿舍的时候，只有3%的电量了。</p><p>就这么一路熬着，居然也熬到了终点。</p><p>当我回到宿舍的那一刻，心里虽然很激动，但是我却出乎意料的平静。</p><p>发说说（装逼），洗个澡，然后喝了些开水，打开电脑想了一会儿，本来想立刻写一篇文档，记录一下那时候的心情，但是最终还是放弃了。</p><p>太累了。</p><p>没有那种传说中的酸痛，但是胯和臀部几乎被磨破皮了，疼的坐不住。</p><p>很疲累却很精神，我几乎感觉不到自己的想睡觉，但是头疼的感觉又不断地强迫我去睡觉。</p><p>怎么说呢，真是一种有趣的经历，我已经记不清这是我人生中第几次绝境了，想着想着居然似乎也习惯了。</p><p>大概所谓的心态好，就是麻木吧。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不过不论怎么说，此次经历也算是心态上的一次历练，不过一段奇遇罢了。</p><p>忽然此时想到了觅长生，颇有种现实里的红尘奇遇感，人生可能会更好或者更差，但无须介怀。</p><p>人生不若一场倾盆大雨，汹涌来去。</p><p>纵因一钱落魄，然又何须介怀？</p><p>红尘百炼方显男儿本色，一切不过些许风霜罢了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速，选用pnpm的原因</title>
      <link href="/2024/06/09/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8pnpm%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2024/06/09/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F%EF%BC%8C%E9%80%89%E7%94%A8pnpm%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>本文并不针对仅仅面试，也是对过往遗憾的一段怀念，就是看到新公司选用pnpm，一时有些感慨。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>遥想起过往的时候，<code>pnpm</code>的风潮刚刚在社区里走起来，而自己一直没能在老公司推广<code>pnpm</code>。</p><p>如今，<code>pnpm</code>在很多公司项目中都通用了，我这个老年人也算是起了个大早，赶了个晚集。</p><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>关于pnpm，yarn，npm三者的发展历史，我这里不详细介绍了，详情可以自己去看：<a href="https://juejin.cn/post/7286362110211489855?searchId=2024061223325379085B7FEAC424101D04">pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 - 掘金 (juejin.cn)</a>。</p><p>关于三者的发展历史，无非就是从npm时代有了线上管理的方式，到了yarn时代拍平包依赖，版本锁定，然后被npm抄走。</p><p>之后为了解决多项目重复依赖的问题，于是就诞生了pnpm，至于之后会不会被npm抄走，也很难说。</p><p>三者现阶段也并非完全的你死我活状态，具体的使用场景，还是要根据自身环境来判断的。</p><p>本次不会花时间去讲三者的发展史，而是笔者根据自身经验，简单讲讲使用pnpm的场景。</p><h3 id="选用原因"><a href="#选用原因" class="headerlink" title="选用原因"></a>选用原因</h3><p>如果你有以下需求，可以考虑选择用<a href="https://pnpm.io/zh/installation">pnpm</a></p><ol><li>项目node版本不低于v20</li><li>大型项目，企业级管理系统，项目依赖包很多，且多同类型项目开现场开发，重复使用npm下载依赖包，导致硬盘内存占用过大</li><li>对npm依赖安装速度不满，且符合以上两个条件</li></ol><p>如果您有以上的需求，那就请选择<a href="https://pnpm.io/zh/installation">pnpm</a>吧。</p><p>之所以pnpm快，就是因为pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，这样可以做到不会出现重复安装。</p><p>如果你仔细观察的话，你会发现pnpm安装的依赖的<code>node_moudles</code>下边都是快捷方式类型的文件夹。</p><p>在项目中需要使用到依赖的时候，pnpm 只会安装一次，之后再次使用都会直接<strong>硬链接</strong>指向该依赖，极大节省磁盘空间，并且加快安装速度</p><blockquote><p>注：硬链接是多个文件名指向同一个文件的实际内容，而软链接（符号链接）是一个独立的文件，指向另一个文件或目录的路径</p></blockquote><p>首次安装的速度可能较慢，但是后续安装和删除<code>node_moudles</code>都会极快。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>npm、yarn和pnpm都是当下十分优秀的包管理工具，具体选择哪个，还是要根据团队项目情况和个人喜好来决定。</p><p>npm 是 Node.js 生态系统的一部分，yarn 提供了更快的依赖项安装和锁定文件功能，而 pnpm 则专注于减少磁盘空间的使用和安装时间。</p><table><thead><tr><th>功能</th><th>pnpm</th><th>Yarn</th><th>npm</th></tr></thead><tbody><tr><td>工作空间支持（monorepo）</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>隔离的 node_modules</td><td>✔️ - 默认</td><td>✔️</td><td>✔️</td></tr><tr><td>提升的 node_modules</td><td>✔️</td><td>✔️</td><td>✔️ - 默认</td></tr><tr><td>自动安装 peers</td><td>✔️</td><td>❌</td><td>✔️</td></tr><tr><td>Plug’n’Play</td><td>✔️</td><td>✔️ - 默认</td><td>❌</td></tr><tr><td>零安装</td><td>❌</td><td>✔️</td><td>❌</td></tr><tr><td>修补依赖项</td><td>✔️</td><td>✔️</td><td>❌</td></tr><tr><td>管理 Node.js 版本</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>有锁文件</td><td>✔️ - pnpm-lock.yaml</td><td>✔️ - yarn.lock</td><td>✔️ - package-lock.json</td></tr><tr><td>支持覆盖</td><td>✔️</td><td>✔️ - 通过 resolutions</td><td>✔️</td></tr><tr><td>内容可寻址存储</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>动态包执行</td><td>✔️ - 通过 pnpm dlx</td><td>✔️ - 通过 yarn dlx</td><td>✔️ - 通过 npx</td></tr><tr><td>辅助缓存</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>列出许可证</td><td>✔️ - 通过 pnpm licenses list</td><td>✔️ - 通过插件</td><td>❌</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章本来想多抄点别人整理的发展史，但是想了想，pnpm终归是工具，实在没必要在这种发展史上花太多时间。</p><p>而且，面试也很少有人去考你发展史，人家都是直接问你真实的使用经历，所以这里干脆直接捞干的来说。</p><p>总之，推荐企业级大型项目开发使用<code>pnpm</code>，尤其是多项目现场部署的那种。</p><p>至于个人级别的普通项目，依然推荐按照自己的习惯来做，普通的npm足够覆盖大多数人的普通项目开发需求了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7047556067877716004?searchId=20240612235251C4198614ACEA50122B6D">pnpm对比 npm&#x2F;yarn好在哪里</a></p><p><a href="https://juejin.cn/post/7286362110211489855?searchId=2024061223325379085B7FEAC424101D04">pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7316409548994625574?searchId=2024061223325379085B7FEAC424101D04">为什么 pnpm+monorepo 是组件库项目的最佳实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue2的虚拟dom与diff算法</title>
      <link href="/2024/06/09/%E6%B5%85%E6%9E%90vue2%E7%9A%84%E8%99%9A%E6%8B%9Fdom%E4%B8%8Ediff%E7%AE%97%E6%B3%95/"/>
      <url>/2024/06/09/%E6%B5%85%E6%9E%90vue2%E7%9A%84%E8%99%9A%E6%8B%9Fdom%E4%B8%8Ediff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这个也是较为常考的面试八股题，很早之前面试准备时候了解过，如今也算是捡起来重新看看了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇算是Vue响应式原理浅析那篇的补充，在响应式原理中，着重讲了vue实现响应式原理的核心思路，但是在针对页面渲染这块没怎么细说。</p><p>虚拟dom渲染这块，面试核心便是算法的思路，真让你手写实现，大概率也最多就是个伪代码的思路图，不可能真让大家去实现的。</p><p>所以，在本篇，本文并不深入探讨算法的源码实现，更多的是讲明白这个渲染的思路。</p><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>虚拟dom在响应式原理那边解释过，如果直接操作dom进行响应式的修改的话，对页面的性能开销会很大。</p><p>作为前端开发，我们都知道的，重排是比重绘性能开销大的多的操作，如果每个变动都要直接操作整个DOM树进行替换，那么毫无疑问，vue绝对会被扫入历史垃圾堆。</p><p>为了解决这么大的开销，vue在这里讨个巧，将对应的节点用JS封装成了<code>vnode</code>对象，通过对<code>vnode</code>对象的操作，进而一次性完成对dom的更改，减少了页面性能的消耗。</p><p>这样，便是所谓虚拟DOM了，如果看不懂，我们直接放个简单的例子，例子一看就能明白。</p><p>这是真实dom</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode = <span class="title function_">h</span>(<span class="string">&#x27;ul.list&#x27;</span>, [</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这里放个补充说明，平时我们开发中一定见过的。</p><p>上面的h函数大家可能有点熟悉的感觉但是一时间也没想起来,没关系我来帮大伙回忆; <code>开发中常见的现实场景,render函数渲染</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例1 vue项目中的main.js的创建vue实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例2 列表中使用render渲染</span></span><br><span class="line"><span class="attr">columns</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;操作&quot;</span>,</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;action&quot;</span>,</span><br><span class="line">        <span class="attr">width</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">render</span>: <span class="function">(<span class="params">h, params</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">                <span class="title function_">h</span>(<span class="string">&#x27;Button&#x27;</span>, &#123;</span><br><span class="line">                    <span class="attr">props</span>: &#123;</span><br><span class="line">                        <span class="attr">size</span>: <span class="string">&#x27;small&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">style</span>: &#123;</span><br><span class="line">                        <span class="attr">marginRight</span>: <span class="string">&#x27;5px&#x27;</span>,</span><br><span class="line">                        <span class="attr">marginBottom</span>: <span class="string">&#x27;5px&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">on</span>: &#123;</span><br><span class="line">                        <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                            <span class="variable language_">this</span>.<span class="title function_">toEdit</span>(params.<span class="property">row</span>.<span class="property">uuid</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">&#x27;编辑&#x27;</span>)</span><br><span class="line">            ]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里的render函数，实际上就是将虚拟的节点转换为真实dom加入到了dom树中，这样，我们就不需要更新整个dom数，而是只更新对应的节点即可。</p><p>这里关于虚拟dom的实现，这里就不贴源码了，感兴趣的可以自己去翻<a href="https://github.com/snabbdom/snabbdom">snabbdom</a>，vue2内部使用的虚拟DOM就是改造的Snabbdom。</p><p>哦，可能有的面试官会有个灵魂发问：虚拟dom更新一定就比真实dom更新来的快吗？</p><p>这个要看情况，如果dom数足够的复杂，用虚拟dom会自然会更快，但是简单操作一个dom节点的话，比如换换文字什么，这种肯定是真实dom操作更快一点。</p><p>不过，这个问题也就图一乐，为了这点性能开销单独写个dom操作一个不重要的节点，多少有点大可不必了。</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>重头戏了来了，虚拟dom只是个简单的开胃菜，重头戏还是得是diff算法。</p><p>如果你vue的开发者，现在你拿到了虚拟dom，你要如何知道前后两者发生了什么地方的改变呢？</p><p>有些朋友可能会说，这有什么难的，直接拿着每个节点挨个遍历比对就可以了，最暴力最直接的手法即可。</p><p>这种做法其实就是传统的diff算法，简单粗暴，直接有效。</p><p>不过，我们这里先看看vue是怎么实现虚拟dom的比对的。</p><p>本图来自于<a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337">B站思学堂UP</a>的整理，他的这张图是我目前看到整理的最清晰的图片，我大致回想了一下，和我以前看到的理解差不多，只要看懂了这张图，大致就明白vue的diff算法是这块是怎么一回事了。</p><p><img src="https://s2.loli.net/2024/06/09/BOETmXxVslHNjW5.png" alt="00325814-9fc9-490b-8b4d-34d765016118 (1)"></p><h4 id="vue的diff算法优化"><a href="#vue的diff算法优化" class="headerlink" title="vue的diff算法优化"></a>vue的diff算法优化</h4><p><a href="https://github.com/snabbdom/snabbdom">snabbdom</a>做的的优化，相对于传统简单粗暴的遍历法，根据dom的特性做了一个优化，那就是同级比对。</p><p>如果我对应的节点已经发生了改变，那这个节点之下的子节点我还有什么必要进行比对呢？这样的话，就省下了了很多性能，所以，vue2出道的时候，vue2这套diff算法也一度是热门面试题，只不过现在是2024年了，大家很少提及相关的事情了。</p><p>关于vue这套算法的特点，这里不细讲，这里稍微总结了一下，便于大家面试时候回答。</p><ul><li>Snbbdom根据DOM的特点对传统的diff算法做了<code>优化</code></li><li>DOM操作时候很少会跨级别操作节点</li><li>只比较<code>同级别</code>的节点</li></ul><h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>在上边的图中，我们注意到了一件事，那就是新旧节点比对，都有子节点，于是转入了<code>updateChildren()</code>的方法。</p><p>这里便是重点，前边的三种情况都好说，换文本，删除或新增节点，很干脆快速的就能完成。</p><p>但是如果之下还有子节点，要怎么继续判断才能最省性能的方式完成对dom的操作呢？</p><p>就是首尾指针法，这种方法个人认为非常切中我们平日操作数组的习惯，算是大幅提高效率的一种方法。</p><p>这里稍微浅谈一下所谓的首尾指针法，就是将数组分为首尾两个指针。</p><p>vue的在updateChildren的时候，会将新旧两个虚拟dom树做比对，这时候，取新旧两个dom树的数组首尾，于是得到了四个节点：新前，新后，旧前，旧后。</p><p>然后按照如下顺序执行：新前与旧前，新后与旧后，新后与旧前，新前与旧后。</p><p><img src="https://s2.loli.net/2024/06/12/3ItV52urUwX4aiN.png" alt="c134f0af-408f-4310-93bc-a83c89cc1979"></p><p>尚硅谷的<a href="https://www.bilibili.com/video/BV1v5411H7gZ?p=12&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【尚硅谷】Vue源码解析之虚拟DOM和diff算法</a>，我个人比较推荐他的视频，讲的很清楚。</p><p>我这里大致通过这张图，我们就很能明白比对的方式了，这里暂时就不按照其他讲解放箭头图了，总之，通过前后对比的方法，首尾指针接近，直至循环完成之后，将旧树中未命中的旧节点移除，将新树中的新增节点加入。</p><p>在比对完成之后，只需要操作一次真实dom，而且只操作没有key标记的DOM，这样可以最小限度的减少对dom树的破坏，减少页面开销，这也是我们在之前遇到的vue2如果不绑定Key的时候，为什么一部分dom更新会出问题的原因。</p><h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><p>这里，又联系到之前提到v-for相关的说法了，因为你给节点加了<code>key</code>，所以，虚拟dom在遍历的时候，就很容易能找到对应的节点不会找错，因此，更快更准。</p><p>而如果你用索引作为key，自然会出现一个问题，那就是索引不具有唯一性，因此索引作为key会导致渲染出BUG的原因便在于此。</p><ul><li>Diff操作可以<strong>更加快速</strong></li><li>Diff操作可以<strong>更加准确(避免渲染错误)</strong></li><li><strong>不推荐使用索引作为key，因为索引被修改后不具有唯一性</strong></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虚拟dom和diff算法，说破天，都是为了节省对dom操作的性能浪费而应对的办法，大多业务层面的前端开发者可以图个乐子了解一下。</p><p>面试中问到，其实也是可以理解的，毕竟这也是vue的看家本事之一，所以对自己的工具原理不稍微了解下，确实也说不过去。</p><p>不过，我们实际上其实用不到太多，做个大概得了解就可以，如果需要对源码进行深入拓荒的，可以尝试对源码层面进行了解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7000266544181674014?searchId=20240609164240AFF5E00BCB5E76BED20E">DIff算法看不懂就一起来砍我(带图)</a></p><p><a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337">6分钟彻底掌握vue的diff算法，前端面试不再怕！</a></p><p><a href="https://www.bilibili.com/video/BV1v5411H7gZ?p=12&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【尚硅谷】Vue源码解析之虚拟DOM和diff算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS垃圾内存回收机制</title>
      <link href="/2024/06/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%9E%83%E5%9C%BE%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/06/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%9E%83%E5%9C%BE%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>JS垃圾内存回收机制也是面试中常考的一道题了，虽然是现代开发者基本上不需要操心垃圾内存回收的事情了，毕竟这玩意是自动回收的。</p><p>但是作为基础，还是了解一下比较好，省的给面试官一种基础不牢的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下大多是文字版，看着容易犯困，个人推荐B站的视频：<a href="https://www.bilibili.com/video/BV1SD421L7Mz/?spm_id_from=333.788&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【JavaScript】代码的垃圾自动回收_哔哩哔哩_bilibili</a></p><p>这个UP讲的挺不错的，算是入门篇，若是进阶，推荐：<a href="https://www.bilibili.com/video/BV1o44y1z7bQ/?spm_id_from=333.337">19【JS深度指南】垃圾回收、变量声明周期、标记清除、引用计数</a>。不过这篇讲的太过深入，新人入门的话，不推荐观看。</p><p>我这里这篇文档最多只算是个人笔记，若有不对之处，还请指教。</p><p>不过，这篇视频依然介绍的是比较浅层的，如果遇到较真的面试官恐怕还是不够，个人更推荐这篇掘金的文档：<a href="https://juejin.cn/post/7173644980240515085?searchId=2024060823275097F9B1226394ED6AF2E3">一文让你彻底搞懂JS垃圾回收机制</a>，这个作者很厉害，不仅仅是这篇文，其他的文更是十分的推荐。</p><h3 id="什么是垃圾内存"><a href="#什么是垃圾内存" class="headerlink" title="什么是垃圾内存"></a>什么是垃圾内存</h3><p>在正式进入垃圾内存主题之前，先了解几个小概念。</p><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>不管什么样的编程语言,在代码执行过程中都是需要给它分配内存的,不同的是某些编程语言需要我们自己手动的管理内存,某些编程语言会可以自动帮助我们管理内存。</p><p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 <code>malloc()</code>和<code>free()</code>。</p><p>相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放，释放的过程称为垃圾回收。</p><h4 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h4><p>在JavaScript中的内存管理中生命周期分为三个阶段,当然其他语言也是一样的:</p><ol><li>分配内存:当我们申请变量、函数、对象的时候,系统会自动为它们分配内存;</li><li>内存使用:即读写内存,也就是使用变量、函数等;</li><li>内存回收:使用完毕,由垃圾回收机制自动回收不再使用的内存;</li></ol><p>通过下面的代码我们来简单分析一下整个内存管理的生命周期:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;moment&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&quot;18&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存</span></span><br><span class="line">foo.<span class="property">name</span> = <span class="string">&quot;xun&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存回收</span></span><br><span class="line">foo = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面这些<code>num，str，foo</code>就是就是<code>使用者</code>，我们都知道，JavaScript数据类型分为<code>基础数据类型</code>和<code>引用数据类型</code>:</p><ul><li><code>基础数据类型</code>：拥有固定的大小，值保存在<code>栈内存</code>里，可以通过值直接访问</li><li><code>引用数据类型</code>：大小不固定(可以加属性)，<code>栈内存</code>中存着指针，指向<code>堆内存</code>中的对象空间，通过引用来访问</li></ul><p>由此，我们可以发现，垃圾内存回收这个概念其实是针对于引用数据类型而产生的。</p><ul><li>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是<code>操作系统自动分配和释放回收的</code></li><li>由于堆内存所存大小不固定，系统<code>无法自动释放回收</code>，所以需要<code>JS引擎来手动释放这些内存</code></li></ul><h4 id="GC，垃圾内存回收"><a href="#GC，垃圾内存回收" class="headerlink" title="GC，垃圾内存回收"></a>GC，垃圾内存回收</h4><p><code>GC</code> 是 <code>Garbage Collection</code>，垃圾内存回收，程序过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不再使用的内存或者一些不可达的对象，而 <code>GC</code> 就是负责回收垃圾的，找到内存中的垃圾、并释放和回收空间。</p><p>在JS，JAVA，Python等语言中，都是有垃圾内存回收机制的，通过自动内存管理实现内存分配和闲置资源回收，所以开发者往往不会关注垃圾内存回收这块的机制。</p><p>而在 <code>C</code> 和 <code>C++</code> 等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。</p><p>整个过程是周期性的，即垃圾回收程序每隔一定时间或者说代码执行过程中某个预定阶段的收集时间就会自动运行。</p><p>垃圾回收过程是一个近似但不完美的方案，因为某块内存垃圾回收是否还有用，属于 <code>不可判定的</code> 问题，意味着靠算法是解决不了的。</p><h4 id="要进行垃圾内存回收的原因"><a href="#要进行垃圾内存回收的原因" class="headerlink" title="要进行垃圾内存回收的原因"></a>要进行垃圾内存回收的原因</h4><p>在弄明白了什么是垃圾内存之后，以及浏览器的一些简单做法之后，我们还是得了解一下为什么会要设计出垃圾内存回收的原因。</p><p>在Chrome中，V8被限制了内存的使用<code>（64位约1.4G/1464MB ， 32位约0.7G/732MB）</code>，为什么要限制呢？</p><ul><li>表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景</li><li>深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）</li></ul><p>前面说到栈内的内存，操作系统会自动进行内存分配和内存释放。</p><p>而堆中的内存，由JS引擎（如Chrome的V8）手动进行释放，当我们的代码没有按照正确的写法时，会使得JS引擎的垃圾回收机制无法正确的对内存进行释放（内存泄露），从而使得浏览器占用的内存不断增加，进而导致JavaScript和应用、操作系统性能下降。</p><h3 id="浏览器内存回收机制"><a href="#浏览器内存回收机制" class="headerlink" title="浏览器内存回收机制"></a>浏览器内存回收机制</h3><p>在浏览器的发展历史上，用到过两种主要的标记策略:<code>标记清理</code> 和 <code>引用计数</code>。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计算的核心思想是对每个值都记录它被引用的次数。</p><p>声明变量并给他赋一个引用值时,这个值的应用数为1，如果同一个值又被赋给另一个变量，那么引用数加 1。</p><p>类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。</p><p>垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p><p>引用计数有一个严重的问题,就是循环引用,所谓的循环引用,就是对象 <code>A</code> 有一个指针指向对象 <code>B</code>,而对象 <code>B</code> 也引用了对象 <code>A</code>,比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> A = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> B = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  A.<span class="property">foo</span> = B;</span><br><span class="line">  B.<span class="property">foo</span> = A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>A</code> 和 <code>B</code> 通过各自的属性相互引用，意味着它们的引用数都是<strong>2</strong>。</p><p>在 标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。</p><p>而在引用计数策略下，<code>A</code> 和 <code>B</code> 在函数结束后还会存在，因为它们的引用数永远不会变成<strong>0</strong>。如果函数被多次调用，则会导致大量内存永远不会被释放。</p><p>引用计数的优势:</p><ol><li>实现简单，垃圾对象便于辨识，当被引用数值为<strong>0</strong>时，对象在变成垃圾的时候就立刻被回收。</li><li>判定效率高，回收没有延迟性，‘程序’不会暂停去单独使用很长一段时间的GC，那么最大暂停时间很短。</li></ol><p>引用计数的缺点:</p><ol><li>需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li><li>时间开销大，因为引用计数算法需要维护引用数，一旦发现引用数发生改变需要立即对引用数进行修改;</li><li>最大的缺点还是无法解决循环引用的问题;</li></ol><p>看一个例子,很鲜明的表示了循环引用对计数法造成的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> A = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> B = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  A.<span class="property">foo</span> = B;</span><br><span class="line">  B.<span class="property">foo</span> = A;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p><code>foo</code>在执行完成之后理应回收<code>foo</code>作用域里面的内存空间,但是因为 <code>A</code> 里面有一个属性引用 <code>B</code>,导致<code>B</code>的引用次数始终为1，<code>B</code>也是如此,而又非专门当做<code>闭包</code>来使用，所以这里就应该使<code>A</code>和<code>B</code>被销毁。</p><p>因为算法是将<code>引用次数为0</code>的对象销毁，此处都不为0，导致GC不会回收他们，那么这就是<code>内存泄漏</code>问题。</p><p>一直手动解决的办法就是把变量设置为 <code>null</code> 实际上会切断变量与其之前引用值之间的关系。</p><p>当下次垃圾回收程序运行时， 这些值就会被删除，内存也会被回收。</p><h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p>在JavaScript中,最常用的是垃圾回收策略是 <code>标记清理</code>。</p><p>当变量进入上下文，比如在函数 内部声明一个变量时，这个变量会被加上存在于上下文中的标记。</p><p>而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。</p><p>当变量离开上下文时， 也会被加上离开上下文的标记。</p><p>标记清理分为两个阶段:</p><ol><li>标记阶段: 把所有活动对象做上标记;</li><li>清除阶段: 把没有标记或者说非活动对象销毁;</li></ol><p>给变量加标记的方式有很多种。</p><p>比如，当变量进入上下文时，反转某一位；</p><p>或者可以维护在 <code>上下文</code> 中和 <code>不在上下文中</code> 两个变量列表,可以把变量从一个列表转移到另一个列表。</p><p>标记过程的实现并不重要,关键是策略。</p><p>引擎在执行 <code>标记清除算法</code> 时,需要从出发点去遍历内存中所有对象去打标志,而这个出发点就是 <code>根对象</code>,在浏览器中你可以理解为 <code>windows</code>,整个标记清除算法大致过程就像下面这样:</p><ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记,假设内存中所有对象都是垃圾,全标记为0;</li><li>然后从 <code>根对象</code> 开始深度遍历,把不是垃圾的节点改成1;</li><li>清除所有标记为0的垃圾,销毁并回收它们所占用的内存空间;</li><li>最后把内存中的所有对象标志修改为0,等待下一轮垃圾回收;</li></ol><p>如下图,标记清除算法会把最下面的那两个<strong>小垃圾</strong>清除掉:</p><p><img src="https://s2.loli.net/2024/06/09/Wd9wBujtm6xNonS.png" alt="1789154f-bf8c-40a6-bfc4-1796122b433e (1) (1) (1)"></p><p>标记清除算法的优点:</p><ol><li>实现简单，打标记也就是打或者不打两种可能，所以就一位二进制位就可以表示;</li><li>解决了循环引用的问题;</li></ol><p>标记清除算法的缺点:</p><ol><li>内存碎片化(内存零零散散的存放,造成资源浪费);</li><li>再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端;</li><li>不会立即回收资源;</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管我已经明白了垃圾内存的回收机制，但是开发时候依然感觉很少用的到。</p><p>而且JS毕竟也是有垃圾内存自动回收机制的语言，实际开发过程中，心智负担其实没有那么严重。</p><p>而且，看到各路大佬提到V8引擎的中的垃圾内存回收机制。。。说实话，有点害怕，这水有点深。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management">内存管理 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://juejin.cn/post/7302112839733067812?searchId=2024060823275097F9B1226394ED6AF2E3">JavaScript垃圾回收机制：你的代码为何需要V8引擎的神秘清道夫？</a></p><p><a href="https://www.ruanyifeng.com/blog/2017/04/memory-leak.html">JavaScript 内存泄漏教程-阮一峰</a></p><p><a href="https://juejin.cn/post/6995706341041897486">赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！</a></p><p><a href="https://juejin.cn/post/7173644980240515085?searchId=2024060823275097F9B1226394ED6AF2E3">一文让你彻底搞懂JS垃圾回收机制</a></p><p><a href="https://www.bilibili.com/video/BV1o44y1z7bQ/?spm_id_from=333.337">19【JS深度指南】垃圾回收、变量声明周期、标记清除、引用计数</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解GET与POST的区别</title>
      <link href="/2024/06/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>GET</code>与<code>POST</code>这个面试题算是比较经典的面试题了，本来我不是特别感兴趣的，但是有群友问到了，我于是就回答了一下。</p><p>但是他说我回答的不够细致，面试时候会有隐患，于是我立刻查漏补缺，学习一个。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇文章算是转载，并非原创，仅供记录使用。</p><h3 id="GET请求不安全，POST请求更安全"><a href="#GET请求不安全，POST请求更安全" class="headerlink" title="GET请求不安全，POST请求更安全"></a><code>GET</code>请求不安全，<code>POST</code>请求更安全</h3><p><code>GET</code>请求参数会直接挂载在URL上，<code>POST</code>请求携带的参数在URL上看不见。</p><p><code>POST</code>请求记录不会被保存在浏览器历史或web服务器日志中，但是<code>GET</code>请求会。</p><p>当然，以上是相对的。这不表示<code>POST</code>请求就绝对安全，其实。</p><p>从数据传输的角度来说，<code>POST</code>和<code>GET</code>都不是很安全，因为http协议本身是明文传输。对内行人来说，抓包解析<code>GET</code>和<code>POST</code>都是一样的。</p><h3 id="GET请求可以缓存，POST请求不能缓存"><a href="#GET请求可以缓存，POST请求不能缓存" class="headerlink" title="GET请求可以缓存，POST请求不能缓存"></a><code>GET</code>请求可以缓存，<code>POST</code>请求不能缓存</h3><p><code>GET</code>请求一般用于数据和静态资源的获取。</p><p>有些<code>GET</code>请求不用和数据库交互，比如一些静态资源和固定的字典表，所以可以使用缓存，如下图两个例子所示。</p><p><img src="https://s2.loli.net/2024/06/08/dDgKbGE73wtnzSX.png" alt="image-20240608222352307"></p><p><img src="https://s2.loli.net/2024/06/08/5EFGCs4yL6tTpld.png" alt="image-20240608222428730"></p><p><code>POST</code>请求则更多用于数据的新增和修改，新增数据无法具备固定内容，所以很多浏览器都不支持缓存<code>POST</code>请求。</p><h3 id="GET请求有长度限制，POST请求没有长度限制"><a href="#GET请求有长度限制，POST请求没有长度限制" class="headerlink" title="GET请求有长度限制，POST请求没有长度限制"></a><code>GET</code>请求有长度限制，<code>POST</code>请求没有长度限制</h3><p><em><code>GET</code>请求本身是没有长度限制的</em>，但是URL有，不同的浏览器对于<code>GET</code>的长度限制也不一样。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">IE:对IE浏览器URL的最大长度为2083个字符。</span></span><br><span class="line"><span class="string">Firefox:对Firefox浏览器URL的最大长度为65536个字符。</span>   </span><br><span class="line"><span class="attr">Safari:</span> <span class="string">对Safari浏览器URL的最大长度为80000个字符。</span>   </span><br><span class="line"><span class="attr">Opera:</span>  <span class="string">对Opera浏览器URL的最大长度为190000个字符。</span></span><br><span class="line"><span class="string">Google(chrome):对Google浏览器URL的最大长度为8182个字符。</span>  </span><br></pre></td></tr></table></figure><p>所以，在需要兼容IE的情况下，URL请求的长度最长只能有2083个字符。</p><h3 id="GET只能传输字符串，POST可以传输多种类型数据"><a href="#GET只能传输字符串，POST可以传输多种类型数据" class="headerlink" title="GET只能传输字符串，POST可以传输多种类型数据"></a><code>GET</code>只能传输字符串，<code>POST</code>可以传输多种类型数据</h3><p>因为<code>GET</code>请求是挂载在URL上的，所以传输的数据类型只能是字符串，但是<code>POST</code>请求可以传输除字符串以外的数据，比如：视频，声音，图片，文档等。</p><h3 id="GET请求入参在URL上，POST请求入参在Request-body上"><a href="#GET请求入参在URL上，POST请求入参在Request-body上" class="headerlink" title="GET请求入参在URL上，POST请求入参在Request body上"></a><code>GET</code>请求入参在URL上，<code>POST</code>请求入参在Request body上</h3><p>这条就不放图了，反正平日大家开发过程中都明白，<code>POST</code>提交的数据一般都放在<code>request body</code>中</p><h3 id="GET只会发送一个数据包，POST有可能产生两个数据包"><a href="#GET只会发送一个数据包，POST有可能产生两个数据包" class="headerlink" title="GET只会发送一个数据包，POST有可能产生两个数据包"></a><code>GET</code>只会发送一个数据包，<code>POST</code>有可能产生两个数据包</h3><p>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）</p><p>对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok，如果第一个请求（header）失败，则data不进行发送。</p><p>但是，这并不代表我们要将<code>POST</code>请求全部替换为<code>GET</code>，这种做法显然是错误的。</p><ol><li><code>GET</code>与<code>POST</code>都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视，而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次</li></ol><h3 id="刷新和回退的时候，GET请求无害，POST数据会被重新提交"><a href="#刷新和回退的时候，GET请求无害，POST数据会被重新提交" class="headerlink" title="刷新和回退的时候，GET请求无害，POST数据会被重新提交"></a>刷新和回退的时候，<code>GET</code>请求无害，<code>POST</code>数据会被重新提交</h3><p>以前我一直没搞明白这一点区别的含义，怎么<code>GET</code>就无害了，<code>POST</code>就又会重新提交了？</p><p>后来我明白了，这点区别指向的是那些页面加载时候就默认执行的请求。</p><p>比如静态资源获取，刷新了就得重新加载。</p><p>如果是<code>GET</code>，<code>GET</code>主要用重新获取数据，因为是获取，请求不会对数据产生什么危害，何况有时候还直接返回的缓存，所以无害。</p><p>再说<code>POST</code>，<code>POST</code>主要用于数据的修改&#x2F;新增，针对默认执行的情况下，<code>POST</code>请求的每次执行都有可能改变数据库中的某一个值，比如重复提交表单。</p><p>刷新一下就会提示你是否要重复提交表单，这点在一些政务网站中比较常见。</p><p>所以这里说<code>POST</code>数据会被重新提交，涉及到增删改类的数据操作，确实显得有害。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试回答时候，我们没必要回答的那么繁琐，只要大概回答出以下几点即可。</p><ol><li><code>POST</code>请求相对安全，<code>GET</code>请求相对不安全</li><li><code>GET</code>请求可以缓存，<code>POST</code>请求不能缓存</li><li><code>GET</code>请求有长度限制，<code>POST</code>请求没有长度限制</li><li><code>GET</code>只能传输字符串，<code>POST</code>可以传输多种类型数据</li><li><code>GET</code>请求入参在URL上，<code>POST</code>请求入参在Request body上</li><li><code>POST</code>有可能产生两个数据包，<code>GET</code>只会发送一个数据包</li><li>刷新和回退的时候<code>GET</code>请求无害，<code>POST</code>数据会被重新提交</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个知识点确实是我之前欠缺了解了，不知道如今我的这份回答是否够详细，希望能入的了群友的法眼。</p><p>哎，面试要准备的题好多啊。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7219889814114975804?searchId=2024060822163406BD46FF4D377D57644B">GET请求和POST请求的区别，你还记得吗？ - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7127443645073981476?searchId=2024060822163406BD46FF4D377D57644B">面试突击71：GET 和 POST 有什么区别？ - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6908228497487953928">淦，原谅我一直理解错GET和POST的请求的本质区别！ - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7041899006728880158?searchId=2024060822163406BD46FF4D377D57644B">说一下 GET 和 POST 的区别？ - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue中v-for的使用技巧</title>
      <link href="/2024/06/08/%E6%B5%85%E6%9E%90vue%E4%B8%ADv-for%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/06/08/%E6%B5%85%E6%9E%90vue%E4%B8%ADv-for%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><code>v-for</code>是vue中最常用的指令，也是面试题中问到最多的，这里干脆都整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇并不算太麻烦，只是简单的整理一下即可。</p><h3 id="v-for与v-if优先级"><a href="#v-for与v-if优先级" class="headerlink" title="v-for与v-if优先级"></a>v-for与v-if优先级</h3><p>因为现在有vue3了，所以这里回答会和vue使用版本的不同有关。</p><blockquote><p>在vue2中，v-for的优先级高于v-if<br>在vue3中，v-if的优先级高于v-for</p></blockquote><h4 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h4><p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>上面的代码将只渲染未完成的 todo。</p><p>而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 [&#96;) 上。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-if=&quot;todos.length&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p v-else&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h4><p>当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。</p><p>这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> 这会抛出一个错误，因为属性 todo 此时</span><br><span class="line"> 没有在该实例上定义</span><br><span class="line">--&gt;</span><br><span class="line">&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;</span><br><span class="line">  &#123;&#123; todo.name &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>在外先包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;</span><br><span class="line">    &#123;&#123; todo.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="v-for与v-if不推荐混用"><a href="#v-for与v-if不推荐混用" class="headerlink" title="v-for与v-if不推荐混用"></a>v-for与v-if不推荐混用</h3><p>当面试官问到你为什么v-for与v-if不推荐混用的时候，按照下边的说法去回答就可以。</p><blockquote><p>节省性能，v-for与v-if混用，会导致每次渲染的时候都要进行条件判断，进而影响页面渲染的性能。</p></blockquote><p>当 Vue 处理指令时，<code>v-for</code> 比 <code>v-if</code> 具有更高的优先级，如果把 <code>v-for</code> 和 <code>v-if</code>写在同一元素上，举例。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span><br><span class="line">    <span class="attr">v-if</span>=<span class="string">&quot;user.isActive&quot;</span></span><br><span class="line">    :<span class="attr">key</span>=<span class="string">&quot;user.id&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>将会经过如下运算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.<span class="property">isActive</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假设 users 数组有 10000 项，但只有一个 user 是 isActive，也会遍历整个 users 数组。</p><p>这样对性能是极不友好的。</p><p>通过将其更换为在如下的一个计算属性上遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> user.<span class="property">isActive</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会获得如下好处：</p><ul><li>过滤后的列表<em>只</em>会在 <code>users</code> 数组发生相关变化时才被重新运算，过滤更高效。</li><li>使用 <code>v-for=&quot;user in activeUsers&quot;</code> 之后，我们在渲染的时候<em>只</em>遍历活跃用户，渲染更高效。</li><li>解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</li></ul><p>为了获得同样的好处，我们也可以把：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span><br><span class="line">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span><br><span class="line">    :<span class="attr">key</span>=<span class="string">&quot;user.id&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>更新为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span><br><span class="line">    :<span class="attr">key</span>=<span class="string">&quot;user.id&quot;</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>通过将 <code>v-if</code> 移动到容器元素，我们不会再对列表中的每个用户检查 <code>shouldShowUsers</code>。</p><p>取而代之的是，我们只检查它一次，且不会在 <code>shouldShowUsers</code> 为否的时候运算 <code>v-for</code>。</p><h3 id="v-for为什么要有key"><a href="#v-for为什么要有key" class="headerlink" title="v-for为什么要有key"></a>v-for为什么要有key</h3><p>这里，我们首先附上官方的说法。</p><blockquote><p><code>key</code> 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。</p><p>在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新&#x2F;复用相同类型的元素。</p><p>如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除&#x2F;销毁 key 已经不存在的元素。</p><p>同一个父元素下的子元素必须具有<strong>唯一的 key</strong>，重复的 key 将会导致渲染异常。</p></blockquote><p>按照这套说法，key是唯一标识，如果你操作数组中的元素，没有key来进行唯一标识，就会出现渲染混乱的情况。</p><blockquote><p>key 在这里是一个通过 v-bind 绑定的特殊 attribute。请不要和在 v-for 中使用对象里所提到的对象属性名相混淆。</p></blockquote><p>以前有人反驳我，说即便是不用key，v-for还是会正常渲染，只是代码提示报错。</p><p>这里，我们附上一个小例子来反驳这类说法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;</span><br><span class="line">        &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item, i) in list&quot;&gt;</span><br><span class="line">          &lt;input type=&quot;checkbox&quot; /&gt; &#123;&#123; item.name &#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &quot;&quot;,</span><br><span class="line">        newId: 3,</span><br><span class="line">        list: [</span><br><span class="line">          &#123; id: 1, name: &quot;李斯&quot; &#125;,</span><br><span class="line">          &#123; id: 2, name: &quot;吕不韦&quot; &#125;,</span><br><span class="line">          &#123; id: 3, name: &quot;嬴政&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add() &#123;</span><br><span class="line">        // 注意这里是unshift</span><br><span class="line">        this.list.unshift(&#123; id: ++this.newId, name: this.name &#125;);</span><br><span class="line">        this.name = &quot;&quot;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;  </span><br></pre></td></tr></table></figure><ol><li>vue中列表循环需要加<code>:key=&#39;唯一标识&#39;</code>，唯一标识尽量是id，目的是为了高效地更新虚拟DOM</li><li>key主要用于dom diff算法，diff算法为同级比较，比较当前标签上的key还有他当前的标签名，如果key和标签名都一样时只移动，不会重新创建元素和删除元素</li><li>没有key地时候默认使用<strong>就地复用</strong>策略。如果数据的顺序被改变，vue不是移动DOM元素来匹配数据项的改变，而是简单复用原来位置的每个元素，在进行比较时发现标签一样值不一样时，就会复用之前的位置，将新值直接放到该位置，以此类推，最后多出一个就会把最后一个删除掉。</li></ol><h3 id="v-for不推荐index作为key"><a href="#v-for不推荐index作为key" class="headerlink" title="v-for不推荐index作为key"></a>v-for不推荐index作为key</h3><p>尽量不要使用索引值index作key值，一定要用唯一标识的值，如id等。</p><p>这在很多前端开发人员眼中是常识，但很少有人深究，若是细究不用index作为key的原因，其实很简单。</p><p>数组中，<code>index</code>作为数组中元素的唯一标识，在没有数据改变的情况下，用来当做<code>v-for</code>渲染的key其实是没有问题。</p><p>若是数据有所改变，此时仍用索引index为key，当向数组中指定位置插入一个新元素后，因为这时候会重新更新index索引，对应着后面的虚拟DOM的key值全部更新了，这个时候还是会做不必要的更新，就像没有加key一样，因此index虽然能够解决key不冲突的问题，但是并不能解决复用的情况。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>v-for这篇本质上其实牵涉到了diff算法等vue渲染的底层原理，但本篇内容长度，就不深入细说。</p><p>后续会专门就渲染和diff算法专门出一篇文档。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7069004247651581989?searchId=20240608191934C50F03616D122F39C7C0">详解v-for中:key属性的作用 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7259582611181813817?searchId=20240608180954770D7D94948E023CC92A">vue2、vue3中的v-if和v-for的优先级问题 - 掘金 (juejin.cn)</a></p><p><a href="https://v2.cn.vuejs.org/v2/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8">vue2列表渲染 — Vue.js (vuejs.org)</a></p><p><a href="https://cn.vuejs.org/guide/essentials/list.html#maintaining-state-with-key">vue3列表渲染 | Vue.js (vuejs.org)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue2中computed和watch</title>
      <link href="/2024/06/08/%E6%B5%85%E6%9E%90vue2%E4%B8%ADcomputed%E5%92%8Cwatch/"/>
      <url>/2024/06/08/%E6%B5%85%E6%9E%90vue2%E4%B8%ADcomputed%E5%92%8Cwatch/</url>
      
        <content type="html"><![CDATA[<p>这依旧是一个经典的，几乎被问烂的面试八股文，只要是vue技术栈的前端开发者，在入门的时候都会刷到相关面试题。</p><p>但是看到知乎上总有人挑刺，于是这里就花点时间整理一下，省的有人说我回答的不全面。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>虽然这次的问题比较简单，但是按照惯例，还是从写法上稍微看看。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        姓： &lt;input type=&quot;text&quot; v-model=firstName&gt; 名：</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=lastName&gt; 姓名：</span><br><span class="line">        &lt;span&gt;&#123;&#123;fullname&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;fullnameTest&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &#x27;z&#x27;,</span><br><span class="line">            lastName: &#x27;s&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            // 常规写法</span><br><span class="line">            fullname() &#123;</span><br><span class="line">                return this.firstName + this.lastName</span><br><span class="line">            &#125;</span><br><span class="line">            // 完整写法</span><br><span class="line">            fullnameTest : &#123;</span><br><span class="line">                set(val)&#123;</span><br><span class="line">                console.log(&#x27;这里获取到了数据&#x27;,val)</span><br><span class="line">       &#125;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    console.log(&#x27;这里处理好了了数据&#x27;,this.firstName + this.lastName)</span><br><span class="line">                    return this.firstName + this.lastName</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="命名唯一性"><a href="#命名唯一性" class="headerlink" title="命名唯一性"></a>命名唯一性</h4><p>computed是data中的变量的一个补充，很多教程和面试题中，都没有提到一点，那就是computed中声明的变量，在data中是不能用同名变量的。</p><p>因为不管是 computed 属性名还是 data 数据名还是 props 数据名 都会被挂载在 vm 实例上，因此这三个都不能同名。</p><h4 id="支持数据缓存"><a href="#支持数据缓存" class="headerlink" title="支持数据缓存"></a>支持数据缓存</h4><p>这里很多面试八股的时候，都会说提一嘴支持数据缓存，那什么是数据缓存呢？这里今天会着重讲一下，这也是computed的核心用法。</p><p>比如，我们在页面中用到了一次computed的数据渲染，那这个时候，computed渲染数据的方法就调用了一次，那如果页面用到两次呢？</p><p>对的，就是这样的，页面中如果用到了两次，依然只是执行了一次，因为数据本身是被缓存起来的，只要没有什么数据更新的话，这里的computed属性依然只进行了一次计算，多次渲染。</p><p>这里是需要和<code>methods</code>属性做比较的，很多开发者可能不知道，<code>methods</code>中声明的方法，实际上也可以返回一个数据，然后在页面渲染中使用，只是很少有人这么用罢了。</p><p>那么，methods中的方法，在页面渲染中多次使用，methods会被调用多少次呢？</p><p>答案很显而易见，会被多次调用，因为methods并不支持缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：render响应最小更新的颗粒度是组件而非指令，在vue1升级到vue2的时候有此类区别</span><br></pre></td></tr></table></figure><p>支持缓存的最大好处，就在于可以减少页面性能的开销，如果一个数据需要多次在页面中渲染，而且又涉及到颇多计算的时候，用computed渲染显然是一个好选择。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">computed计算出一个新属性，每个新属性对应一个computedwatcher，依赖数据更新时会把watcher中的dirty的值改成true，只有在render过程中读取新属性时进行判断，dirty为false返回原结果，dirty为true才进行计算，这就是数据缓存的基本原理，详情这里就不展开细说了。</span><br><span class="line">注意，computed计算缓存类型支持所有数据类型，并非只支持基本数据类型，数据对象这类引用类的数据类型也是支持的。</span><br></pre></td></tr></table></figure><p>以上是我早年对computed的理解，应该算是相对完善的回答，但是问的更深，我就答不出来了。</p><p>至于实现原理 ，我这里就不展开详细说明，因为太过久远，我梳理起来也费劲，个人推荐B站的一个视频：<a href="https://www.bilibili.com/video/BV1zY4y1X7Be/?spm_id_from=333.337">vue的computed为什么可以缓存数据？原理是什么</a>，对源码的解析相对较为不错，只不过似乎视频是别人公众号的，重复发的太多了，我就随便挑了一个。</p><h4 id="不支持异步"><a href="#不支持异步" class="headerlink" title="不支持异步"></a>不支持异步</h4><p>业务场景中常见的一个问题，有时候有人会想在computed中放一些异步函数获取数据，实际上则无法获取。</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        姓： &lt;input type=&quot;text&quot; v-model=firstName&gt; 名：</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=lastName&gt; 姓名：</span><br><span class="line">        &lt;span&gt;&#123;&#123;fullname&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &#x27;z&#x27;,</span><br><span class="line">            lastName: &#x27;s&#x27;,</span><br><span class="line">            fullname: &#x27;zs&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            firstName(newval) &#123;</span><br><span class="line">                this.fullname = newval + this.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            lastName(newval) &#123;</span><br><span class="line">                this.fullname = this.firstName + newval</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里就不说什么watch支持不支持缓存了，数据缓存+页面渲染，那时methods对标computed事情，和watch是没有关系的。</p><p>面试题时候提一嘴，算是给面子了，实际应用中，watch本来就和缓存不沾边，毕竟只是用来做数据监听的，肯定是数据一变化，watch这边就要响应。</p><h4 id="支持异步"><a href="#支持异步" class="headerlink" title="支持异步"></a>支持异步</h4><p>这是watch最常用的场景，一旦数据发生变化，立刻会有选择项的获取列表发生变化，这在实际开发中常用来做表单填写的监听判断。</p><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p><h4 id="是否调用缓存"><a href="#是否调用缓存" class="headerlink" title="是否调用缓存"></a>是否调用缓存</h4><p>computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取</p><p>watch在每次监听的值发生变化的时候都会执行回调</p><h4 id="是否调用return"><a href="#是否调用return" class="headerlink" title="是否调用return"></a>是否调用return</h4><p>computed中的函数必须要用return返回，</p><p>watch中的函数不是必须要用return。</p><h4 id="是否首次监听"><a href="#是否首次监听" class="headerlink" title="是否首次监听"></a>是否首次监听</h4><p>computed默认第一次加载的时候就开始监听；</p><p>watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（<code>immediate:true</code>）</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>computed：当一个属性受多个属性影响的时候，使用computed，经典的购物车结算类的操作。</p><p>watch：当一条数据影响多条数据的时候，且有异步计算相关的时候，使用watch，例如搜索框，或者表单中，一条数据会干扰多条数据的使用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里只是浅层的从应用层面说了一下，因为时间关系，自己这里就不涉及到源码进行详细解析了。</p><p>computed与watch，早年还有面试官提问哪个更优更劣的问题，这种问题就是纯粹的陷阱问题，又或者面试官本人水平很菜。</p><p>二者并无更优更劣的说法，只有谁更适合什么场景，脱离应用场景去说优劣就是没有理解开发的本质。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://v2.cn.vuejs.org/v2/api/#computed">API — Vue.js (vuejs.org) - computed</a></p><p><a href="https://v2.cn.vuejs.org/v2/api/#watch">API — Vue.js (vuejs.org) - watch </a></p><p><a href="https://www.bilibili.com/video/BV1jN4y1W78v/?spm_id_from=333.337.">computed缓存指的是什么意思?随便举几个例子就行</a></p><p><a href="https://juejin.cn/post/7089088014785183758?searchId=202405262351089A14E404E0491904E0A3">watch跟computed的区别</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue2中data是函数的原因</title>
      <link href="/2024/06/06/%E6%B5%85%E6%9E%90vue2%E4%B8%ADdata%E6%98%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2024/06/06/%E6%B5%85%E6%9E%90vue2%E4%B8%ADdata%E6%98%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>vue玩家的经典面试题，之前入职面试时候回答的还不错，但事后感觉我自己感觉不太详细，于是这里仔细整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实，所有的回答只绕着一句话来回答。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data是函数，是为了解决vue组件复用时，实例中声明的变量会混乱。</span><br></pre></td></tr></table></figure><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><blockquote><p>Vue 实例的数据对象。</p><p>Vue 会递归地把 data 的 property 转换为 getter&#x2F;setter，从而让 data 的 property 能够响应数据变化。</p><p>当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。</p></blockquote><p>说的挺明白的，但是毕竟不是自己的理解。</p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>在正式开始之前，我们先附上官网提供的经典例子，这个例子其实足够直观的可以让我们明白，为什么data必须是一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: 1 &#125;</span><br><span class="line"></span><br><span class="line">// 直接创建一个实例</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.a // =&gt; 1</span><br><span class="line">vm.$data === data // =&gt; true</span><br><span class="line"></span><br><span class="line">// Vue.extend() 中 data 必须是函数</span><br><span class="line">var Component = Vue.extend(&#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123; a: 1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="为什么不用属性"><a href="#为什么不用属性" class="headerlink" title="为什么不用属性"></a>为什么不用属性</h4><p>首先我们需要了解data两种不同的类型有什么区别：</p><ul><li>当我们组件中的data写成一个<strong>函数</strong>时，数据是以函数返回值形式定义的，这样每复用一次data，都会返回一份新的data，拥有<strong>自己的作用域</strong>，不会产生数据污染。</li><li>当我们组件中的data写成一个<strong>对象</strong>时，对象是引用数据类型，它就会共用一个内存地址，在多次使用该组件时，改变其中一个组件的值会影响全部使用该组件的值。</li></ul><p>使用函数就是用闭包独立了变量的作用域，在函数的作用域中声明的变量，自然不会混用，所以不会被修改。</p><p>而如果是属性，一个组件可能会被其他的组件引用，为了防止多个组件实例对象之间共用一个data，产生数据污染。</p><p>vue文件，在被编译后，每个vue文件都是声明出的实例，每个实例都有自己的作用域。</p><p>而在vue中将data定义成一个函数，每个组件实例在每次声明之后，都会用函数声明自己的独立作用域，每个实例相互独立，不会相互影响initData时会将其作为工厂函数都会返回全新data对象。 </p><h4 id="为什么不用箭头函数"><a href="#为什么不用箭头函数" class="headerlink" title="为什么不用箭头函数"></a>为什么不用箭头函数</h4><p>箭头函数的作用域是指向上级对象，本质上还是会将声明的变量指到实例根部。</p><p>data通过箭头函数声明出来，实际上和直接挂在vue实例上没什么区别，依旧会造成数据污染。</p><p>因此，我们拒绝使用箭头函数的原因，实际上和对象如此。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是一个经典面试题，经典到从vue出来的时代中就会被问到，只要对前端稍微熟练的开发者，都能明白怎么回答。</p><p>但是经典不代表没有花样，我这里也是根据自己的理解浅浅写了一下，可能说的不够简单，希望轻喷。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://v2.cn.vuejs.org/v2/api/#data">vue2官网_data属性</a></p><p><a href="https://juejin.cn/post/7110588076824461343?searchId=2024060721205558C2276150F2AEC5618F">组件中的 data 为什么必须是一个函数呢？</a></p><p><a href="https://www.bilibili.com/video/BV1ve4y1b7MB/?spm_id_from=333.337">前端面试：vue组件中data为什么是函数？对象不行吗？你应该这么说……</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解dom和bom</title>
      <link href="/2024/06/06/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3dom%E5%92%8Cbom/"/>
      <url>/2024/06/06/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3dom%E5%92%8Cbom/</url>
      
        <content type="html"><![CDATA[<p>面试官：您既然说了dom，那不妨说说什么是dom？</p><p>我：啊？什么是bom？</p><p>面试官：哈哈哈，您真幽默，后续会通知您面试的结果的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我以为我对浏览器的大多数情况都挺清楚了，没想到在这种基础问题上翻车了。</p><p>我这个前端老油条是真的不知道什么叫BOM。</p><h3 id="什么是BOM和DOM？"><a href="#什么是BOM和DOM？" class="headerlink" title="什么是BOM和DOM？"></a>什么是BOM和DOM？</h3><ul><li>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性</li><li>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器</li></ul><p>Javascript 由三部分构成，ECMAScript，DOM和BOM。</p><p>根据宿主（浏览器）的不同，具体的表现形式也不尽相同，ie和其他的浏览器风格迥异,IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象。 </p><table><thead><tr><th>ECMAScript(核心)</th><th>描述了JS的语法和基本对象</th></tr></thead><tbody><tr><td>DOM，文档对象模型</td><td>处理网页内容的方法和接口。是W3C 的标准（所有浏览器公共遵守的标准）</td></tr><tr><td>BOM 是浏览器对象模型</td><td>提供与浏览器交互的方法和接口。各个浏览器厂商根据 DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]</td></tr></tbody></table><h4 id="DOM的介绍"><a href="#DOM的介绍" class="headerlink" title="DOM的介绍"></a>DOM的介绍</h4><p>DOM 全称是 Document Object Model，也就是文档对象模型。</p><p>DOM是针对XML的基于树的API,描述了处理网页内容的方法和接口，是HTML和XML的API，DOM把整个页面规划成由节点层级构成的文档。</p><p>这个DOM定义了一个HTMLDocument和HTMLElement做为这种实现的基础,就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素）。</p><p>我们把这个 HTML 看做一个对象树（DOM树），它本身和里面的所有东西比如 <div></div> 这些标签都看做一个对象，每个对象都叫做一个节点（node），节点可以理解为 DOM 中所有 Object 的父类。</p><h4 id="BOM的介绍"><a href="#BOM的介绍" class="headerlink" title="BOM的介绍"></a>BOM的介绍</h4><p>BOM 是 Browser Object Model，浏览器对象模型。</p><p>刚才说过 DOM 是为了操作文档出现的接口，那 BOM 顾名思义其实就是为了控制浏览器的行为而出现的接口。</p><p>浏览器可以做什么呢？比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数。</p><p>所以 BOM 就是为了解决这些事情出现的接口。</p><p>比如我们要让浏览器跳转到另一个页面，只需要location.href &#x3D; “<a href="http://www.xxxx.com";这个/">http://www.xxxx.com&quot;;这个</a> location 就是 BOM 里的一个对象。</p><h3 id="DOM和BOM的区别"><a href="#DOM和BOM的区别" class="headerlink" title="DOM和BOM的区别"></a>DOM和BOM的区别</h3><h4 id="DOM区域的"><a href="#DOM区域的" class="headerlink" title="DOM区域的"></a>DOM区域的</h4><p>工具栏之下的窗口，用于展示开发者的成果</p><h4 id="BOM区域的"><a href="#BOM区域的" class="headerlink" title="BOM区域的"></a>BOM区域的</h4><p>浏览器自带的工具栏。</p><ol><li>浏览器的标签页，地址栏，搜索栏，书签栏，窗口放大还原关闭按钮，菜单栏等等</li><li>滚动条scroll bar</li><li>浏览器的右键菜单</li><li>document加载时的状态栏，显示http状态码等</li></ol><h2 id="DOM和BOM的联系"><a href="#DOM和BOM的联系" class="headerlink" title="DOM和BOM的联系"></a>DOM和BOM的联系</h2><p>BOM的核心是Window，而Window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。</p><p>这意味着在网页中定义的任何对象，变量和函数，都以window作为其global对象。</p><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、embeds、anchors、images、links</p><p><img src="https://s2.loli.net/2024/06/06/dgMZ1qR8Ho57fiV.png" alt="image-20240606211717580"></p><p>从window.document已然可以看出，DOM的最根本的对象是BOM的window对象的子对象。</p><p>由于BOM的window包含了document，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。</p><p>因为document对象又是DOM（Document Object Model）模型的根节点。</p><p>光靠说可能不明显，我直接举个例子。</p><p>平时我们使用<code>document.getElementById()</code>之类的方法，实际上就是<code>window.document.getElementById()</code>，只是因为执行环境发生在浏览器中，所以我们不需要额外的声明<code>windonw</code>。</p><p>通过这个例子，我们可以非常明白，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象。</p><p>从BOM对象再访问到DOM对象，js可以操作浏览器以及浏览器读取到的文档。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总的来说，面试中，我们可以直接说BOM包含了DOM，BOM提供了浏览器的工具库，而DOM对象只是BOM中的主要工具对象。</p><p>BOM包含DOM，同时也提供了location、navigator、screen、history、frames等工具可供操作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903939008102413">最全的DOM和BOM的解释分析</a></p><p><a href="https://www.bilibili.com/video/BV1kN411j7Ao/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【JavaScript】什么是BOM、DOM？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析ref与reactvie的区别</title>
      <link href="/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/04/%E6%B5%85%E6%9E%90ref%E4%B8%8Ereactvie%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>最近新入职的公司需要使用Vue3做项目，所以我这个V3的排斥者也只能选择了这个方法。</p><p>对于V3，除了一年前我稍微了解了一下，后续就没有跟进，我个人对技术追星并未有太多的兴趣。</p><p>直到我见识了这家公司项目的写法，我只能说，V3确实有那么点的意思。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文虽说是探讨ref和reactive的区别，但不会深入探讨具体的源码解析，只更倾向于如何在项目中更好的使用。</p><p>毕竟，我们不是造轮子的，我们是用轮子的。</p><p>在现在这个前端大爆炸的时代里，我们已经不缺一个好用的框架，更缺的是一个用好框架的思路。</p><h3 id="refs与reactive的区别"><a href="#refs与reactive的区别" class="headerlink" title="refs与reactive的区别"></a>refs与reactive的区别</h3><p>不管怎么说，在正式讲使用心得之前，还是要简单说说二者的区别。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>响应式改变需要使用<code>变量.value</code>，被其包裹的变量可以是简单类型，也可以是引用类型。</p><p>在开发中，我们常用来包裹一些特殊的响应式变量，通用形式的变量我个人不喜欢用ref，如果是引用类型的话，更倾向于是用reactive()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">const count = ref(0)</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>同样的代码，reactive不需要用<code>变量.value</code>这种写法，可以直接引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>不过，reactive有一定的局限性。</p><ol><li><p><strong>有限的值类型</strong>：它只能用于对象类型 (对象、数组和如 <code>Map</code>、<code>Set</code> 这样的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections">集合类型</a>)。它不能持有如 <code>string</code>、<code>number</code> 或 <code>boolean</code> 这样的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">原始类型</a>。</p></li><li><p><strong>不能替换整个对象</strong>：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪</span></span><br><span class="line"><span class="comment">// (响应性连接已丢失！)</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>对解构操作不友好</strong>：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当解构时，count 已经与 state.count 断开连接</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state</span><br><span class="line"><span class="comment">// 不会影响原始的 state,这里的响应式无效</span></span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收到的是一个普通的数字</span></span><br><span class="line"><span class="comment">// 并且无法追踪 state.count 的变化</span></span><br><span class="line"><span class="comment">// 我们必须传入整个对象以保持响应性</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(state.<span class="property">count</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="refs与reactive的使用方式"><a href="#refs与reactive的使用方式" class="headerlink" title="refs与reactive的使用方式"></a>refs与reactive的使用方式</h3><p>二者都是V3提供的响应式语法糖，但在开发过程中，很多时候二者会混用，实际上，不该那么用。</p><p>个人参考了别人的案例，整理了一下规则</p><ol><li>只用<code>ref</code>声明响应式变量</li><li>只有当第三方库的操作对象需要具备响应性时，才使用<code>shallowRef</code></li><li>只有当逻辑块完整时，才使用<code>reactive</code>包裹住那块的业务</li></ol><h4 id="用ref声明响应式变量"><a href="#用ref声明响应式变量" class="headerlink" title="用ref声明响应式变量"></a>用<code>ref</code>声明响应式变量</h4><p>虽然<code>reactive</code>声明的变量也具备响应性，但是，想要将v3用的简单，不推荐混用ref与reactive。</p><p>因此，无论是对象、数组、数字、字符串、布尔值、HTML引用，都用<code>ref</code>来声明</p><ul><li><p>不推荐</p><p>将<code>ref</code>和<code>reactive</code>混着用，这样的响应式经常会无意识在使用变量时候要不要使用.value产生心智负担，影响开发效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableData = <span class="title function_">reactive</span>([]);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">ref</span>([])</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>推荐</p><p>只用<code>ref</code>声明响应式变量，这样，相关的变量我们直接就用.value来改变响应式的变量即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">ref</span>([])</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> str = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bool = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">const</span> nil = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> udf = <span class="title function_">ref</span>()</span><br></pre></td></tr></table></figure></li></ul><h4 id="用shallowRef操作第三方库的对象"><a href="#用shallowRef操作第三方库的对象" class="headerlink" title="用shallowRef操作第三方库的对象"></a>用<code>shallowRef</code>操作第三方库的对象</h4><blockquote><p>什么是第三方库的操作对象？指的是那些不是开发时声明出来的，而是第三方库API创建并暴露出来给你操作的对象。</p><p>比如Echart初始化之后会产生一个对象，允许你调用其<code>setOption</code>方法来更新图表，这个对象就属于第三方库的操作对象。</p></blockquote><p>通常情况下，对于第三方库的操作对象，是不需要添加响应性的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mychart = <span class="literal">null</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    mychart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElement</span>(<span class="string">&#x27;chart&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是在有些场景下，你需要让这个对象具备响应性：比如你需要以props的形式将这个操作对象传递给子组件，并且这个操作对象还可能发生变化，你希望子组件也能跟着变化。</p><p>那么这时候你应该只使用<code>shallowRef</code>这个API，为这些你不知道底细的第三方库产生的对象提供响应性支持</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mychart = <span class="title function_">shallowRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">createNewChart</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">createNewChart</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNewChart</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 销毁旧对象</span></span><br><span class="line">  <span class="keyword">if</span>(mychart.<span class="property">value</span>)&#123;</span><br><span class="line">      mychart.<span class="property">value</span>.<span class="title function_">dispose</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启用新对象</span></span><br><span class="line">  mychart.<span class="property">value</span> = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElement</span>(<span class="string">&#x27;chart&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么不能使用ref给这些对象提供响应性？因为<code>ref</code>和<code>shallowRef</code>的区别在于，<code>ref</code>会遍历整个对象，给对象的每个属性都创建响应性，无论是多深的对象，你给任何一个属性赋值，都会刷新界面。而<code>shallowRef</code>相反，<code>shallowRef</code>只有浅层的响应式处理，只有给其<code>.value</code>赋值时，才会触发界面刷新。</li><li>这就导致一些问题，当第三方库的操作对象也在监听内部数据自我更新时，就会产生一种：<strong>“你更新了，我监听到了，我更新；我更新了，你监听到了，你又更新；你又更新了，我监听到了，我又又更新…”的死循环中，然后导致页面崩溃。</strong></li><li>所以对于你不知道底细的对象（通常情况下也就只有第三方库会产生），直接使用<code>shallowRef</code>创建响应性。</li></ul><h4 id="用reactive包裹完成的逻辑块"><a href="#用reactive包裹完成的逻辑块" class="headerlink" title="用reactive包裹完成的逻辑块"></a>用<code>reactive</code>包裹完成的逻辑块</h4><blockquote><p>什么是 <em>组合式函数</em>，指的是那些将响应式变量封装起来的函数。官方文档传送门：<a href="https://link.juejin.cn/?target=https://cn.vuejs.org/guide/reusability/composables.html%23what-is-a-composable">组合式函数 | Vue.js (vuejs.org)</a></p></blockquote><p>组合式API最大的优势在于函数级别的复用，这也是最不同于V2的地方，V2想要复用一块完成的逻辑块，大多用mixinjs混合，但是很多情况下并非特别好用。</p><p>我看到项目中这套配合动态表单的组合式风格，简直是惊为天人。</p><p>这样的代码逻辑太过清晰易读，简直比之前V2写的低代码还牛逼。</p><ol><li><strong>逻辑模块聚合原则</strong>：相同逻辑的代码必须写在一起</li><li><strong>业务代码优先原则</strong>：在无复用的需求下，不需要将业务代码高度封装成组合式函数。</li><li><strong>核心模块保留原则</strong>：一个vue组件改动最频繁且无复用的逻辑代码，属于核心代码，应该保留在vue组件里而不是ts文件里。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@table</span> - 用reactive包装,将变量和方法都封在这一个逻辑块中，这块的算是最核心的代码*/</span></span><br><span class="line"><span class="keyword">const</span> table = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">column</span>:[],</span><br><span class="line">    <span class="attr">data</span>:[],</span><br><span class="line">    <span class="attr">listLoading</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">request</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 封装请求，这里我们赋值也不需要从.value什么的拿，直接用table.data就能获取列表的值，简直方便，省的ref那种搞法了。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>:<span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">edit</span>:<span class="function">()=&gt;</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">delete</span>:<span class="function">() =&gt;</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 日常开发时优先采用这种命令式直接写业务逻辑，不要包裹到table中，便于特殊处理，如果业务逻辑过于复杂，就抽离到一个单独的TS文件中*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> XX1模块 - 钩子这块直接放置所有需要触发的机制*/</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    table.<span class="title function_">request</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你是选项式的粉丝，你甚至可以这样玩：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@module</span> 模块1*/</span></span><br><span class="line"><span class="keyword">const</span> datasetMod = <span class="title function_">reactive</span>(<span class="title function_">useOptAPI</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">dataset</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">req2GetData</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@module</span> 模块2*/</span></span><br><span class="line"><span class="keyword">const</span> fileListMod = <span class="title function_">reactive</span>(<span class="title function_">useOptAPI</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">atvFile</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">fileList</span>:[],</span><br><span class="line">            <span class="attr">fileListRef</span>:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">filterFileList</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="title function_">atvFile</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">req2GetFileList</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">onNextFile</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">onPrevFile</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>当然，后边这个写法有点玩票的性质，前者的写法亲自体验之后，惊为天人，设计这套写法的人，抽的太干净了，稍微设计一下，几乎就是低代码的写法。</p><p>核心逻辑配合动态表单，所有的业务代码简直是快速生成的利器。</p><h3 id="选项式与组合式"><a href="#选项式与组合式" class="headerlink" title="选项式与组合式"></a>选项式与组合式</h3><p>以下这段话说的比较虚，并不像上边那么务实，算是这么长时间使用之后，个人的一点心得。</p><p>选项式写法，即传统V2写法，按照已经框好的代码块，变量和方法都被放在了规定的位置。</p><p><a href="https://cn.vuejs.org/guide/reusability/composables.html">组合式写法</a>，相对前者更为自由，没有V2规定好的变量块和逻辑块，更偏向于传统JS式的写法，开发者只要将对应的逻辑块组到一块就可以，这样更便于代码阅读。</p><p>这两种写法均被Vue3支持，可根据自己习惯而定。</p><p>根据之前项目踩坑的经验来看，如果团队的代码能力不足，不建议使用组合式写法。</p><p>不规范且不同习惯的组合式代码放在一起，在后期维护的时候会非常让人崩溃，vue2的写法虽然死板一些，但是某种意义上也增加了规范，至少有一定的可读性。</p><p>我个人认为，组合式的写法想要用的过瘾，需要以下几点</p><ol><li>团队有一定的前端开发基础，大体的开发人员水准不会太差，这样能保证组合式代码写出来的可读性不会太差。</li><li>有一份不错的动态组件库，直接用半个配置化写法整合所有的代码，这样可以大规模减少非业务的代码，减少代码阅读的心智负担</li><li>前端有一份通用的表单处理规范，这样阅读他人的代码逻辑时候，心智负担不会太高，再写好一个完美的个例之后，便于快速复用，其他人能很快读懂。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>为了避免认知混乱，基本上都使用<code>ref</code>进行声明响应式变量</li><li>为了避免页面卡死，对于那些你不知道层级结构的数据，使用<code>shallowRef</code>为它创建响应性</li><li><code>reactive</code>推荐用来包裹一些完整的逻辑块，在<code>reactive</code>中写方法引用变量会非常方便，而且也便于阅读</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vue3的升级，果然不仅仅是一次写法上的升级，动态组件库配合组合式写法，简直超神。</p><p>一篇业务模块的文件中，几乎没有多少业务代码，而且相对V2的难于抽离，V3的可以直接将弹窗封在子组件中，这种感觉真不错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7291468863396560957#comment">Vue的ref、shallowRef、reactive到底要怎么用！！？</a></p><p><a href="https://juejin.cn/post/7371253542245105698">我们团队是如何用好vue3 setup组合式API的？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解宏任务与微任务</title>
      <link href="/2024/06/04/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
      <url>/2024/06/04/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>面试官：您对异步了解吗？</p><p>我：多少懂一点，异步就是前端浏览器为了不阻塞主线程运行，采取的一种策略，可以将部分任务挂起，等到主任务队列执行完毕后，进入队列循环执行异步。</p><p>面试官：不错，那您应该也知道宏任务和微任务，这里您能说说吗？</p><p>我：哈哈哈哈，这个我以前了解过，现在忘了呢。</p><p>面试官：哈哈哈，您又开始幽默了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>宏任务和微任务的存在几乎是前端常见的面试题，我很早以前只是了解，但是没细看，如今被打脸确实算是咎由自取。</p><p>于是，今天我仔细翻看查阅了这块的资料，可以非常确信的说，宏任务的说法确实被取消了，搜不到宏任务这个说法了。</p><p>详情参考，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a></p><p>当然，官方的说法取消归取消，但是执行顺序的基本模型按照原来的那个思路理解是没问题的。</p><p>理解宏任务与微任务，本质上是要理解JS代码中执行顺序的队列，也就是所谓的事件循环机制。</p><p>本篇主要讲宏任务与微任务，并不涉及到DOM渲染，如果要是加入DOM渲染，个人参考这篇文档：<a href="https://juejin.cn/post/7064596910878752804?searchId=20240604222439A8E7D0B8987E592A096C">对于宏任务和微任务，你知道多少？</a>。</p><p>这篇文章讲的相对较为详细，配图很适合新人观看，而且个人仔细对比了其他几篇文档，这确实也不是胡说，是正儿八经的解析了一遍，可以参考。</p><h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h3><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li><li>AJAX</li><li>DOM事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">//正确答案是： script start, script end, setTimeout</span></span><br></pre></td></tr></table></figure><p>分析：JS运行主线程，碰到setTimeout放入宏任务队列等待执行，之后继续运行主线程，主线程执行完毕之后，去宏任务队列读取对应的函数，进入主线程执行。</p><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">//正确答案是： script start, script end, promise1, promise2</span></span><br></pre></td></tr></table></figure><p>分析：JS运行主线程，碰到Promise放入微任务队列等待执行，之后继续运行主线程。</p><p>主线程执行完毕之后，去微任务队列读取对应的函数，进入主线程执行。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是在一个任务队列</li><li>当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务。</li><li>二者没有什么优先级之说，只是进入了循环的机制中，有时候看着像是优先度高，实际上只是因为机制的原因。</li></ul><p>因此，我们要注意一些不完全正确的说法，很多人说什么微任务执行优先度高于宏任务，本质上是没有理解事件循环的模型。</p><p>在下边的练习中，我们会发现，如果微任务的执行优先度真的高于宏任务，那么按理来说，微任务应该全部优先宏任务出结果，但事实显然不是。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>进入练气之前，我们牢记这个规律：<strong>一次循环，宏任务执行一个，先清空微任务队列，再去执行下一个宏任务</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"><span class="comment">// 正确答案是：8, 1, 3, 4, 5, 6, 7, 2</span></span><br></pre></td></tr></table></figure><ol><li>首先执行主线程，主线程本身是宏任务，执行过程中遇到 <code>setTimeout</code>（宏任务），将其分配到宏任务队列中，继续执行主线程，执行过程中遇到第二个 <code>setTimeout</code>（宏任务），将其追加到宏任务队列中，继续执行主线程，首先输出<strong>6</strong>，主线程执行完毕。</li><li>去宏任务队列读取对应的函数，进入主线程执行，接着输出<strong>1</strong>，遇到一个 <code>setTimeout</code>（宏任务），将其分配到新的宏任务队列中，遇到一个 <code>promise</code> （微任务），但是构造函数中的代码为同步代码，接着输出<strong>3</strong>，则<code>then</code> 之后的任务加入到微任务队列中去，则第一个<code>setTimeout</code>（宏任务）执行完毕。</li><li>遵循事件循环机制，执行第一个<code>setTimeout</code>（宏任务）中碰到的<code>promise</code> （微任务），接着输出<strong>4</strong>。</li><li>继续从第一个宏任务队列读取函数，接着输出<strong>5</strong>，同理，微任务在当前宏任务队列执行完成后，优先下一轮的宏任务执行，清空队列，输出6，7。</li><li>执行第一个<code>setTimeout</code>（宏任务）中包含的<code>setTimeout</code>（宏任务），接着输出<strong>2</strong>。</li></ol><p>以上，我们会发现，微任务的优先度并未高于宏任务，只是因为在第二轮循环中，微任务要优先清空。</p><p>同时，因为一次循环中只会清空一个宏任务，所以5对应的<code>setTimeout</code>并进入第一轮的宏任务中，等到第二轮结束之后，再继续向下寻找，才进入了第三轮的任务循环，找到下一个宏任务，如此，直至完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript是一种单线程语言，所有任务都在一个线程上完成。</p><p>一旦遇到大量任务或者遇到一个耗时的任务，比如加载一个高清图片，网页就会出现”假死”，因为JavaScript停不下来，也就无法响应用户的行为。</p><p>为了防止主线程的阻塞，JavaScript 有了 同步 和 异步 的概念。</p><p>所以 JavaScript 便使用一套机制去处理同步和异步操作，那就是事件循环 (Event Loop)。</p><ul><li>所有同步任务都在主线程上依次执行，形成一个执行栈(调用栈)，异步任务则放入一个任务队列</li><li>当执行栈中任务执行完，再去检查微任务队列里的微任务是否为空，有就执行，如果执行微任务过程中又遇到微任务，就添加到微任务队列末尾继续执行，把微任务全部执行完</li><li>微任务执行完后，再到任务队列检查宏任务是否为空，有就取出最先进入队列的宏任务压入执行栈中执行其同步代码</li><li>然后回到第2步执行该宏任务中的微任务，如此反复，直到宏任务也执行完，如此循环</li></ul><p>当<code>Call Stack</code>，就是面试中提到的宏任务清空之后，首先<code>执行当前的微任务</code>，再去<code>尝试DOM渲染</code>，最后<code>触发EventLoop机制</code>，执行宏任务，如此反复循环。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然又是一道造火箭才会有用的题目，但是作为前端开发者，在面试中，这似乎成了段位升级的必考题。</p><p>我个人挺讨厌这种感觉的，不过，关于浏览器的基础常识，多懂一点也好，而且这也是要弄懂nextTick必须的点。</p><p>我找到的这篇文章相对写的较为准确，但是不够生动形象，个人更推荐看视频：<a href="https://www.bilibili.com/video/BV1pz421a7Sw/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">面试还不会判断宏任务和微任务的输出顺序？</a></p><p>这个UP的配图挺省心，而且例子也颇为形象，我个人很喜欢，简单易懂。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与 Javascript 运行时环境</a></p><p><a href="https://www.bilibili.com/video/BV1pz421a7Sw/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">面试还不会判断宏任务和微任务的输出顺序？</a></p><p><a href="https://juejin.cn/post/7064596910878752804?searchId=20240604222439A8E7D0B8987E592A096C">对于宏任务和微任务，你知道多少？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解this指向</title>
      <link href="/2024/06/03/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3this%E6%8C%87%E5%90%91/"/>
      <url>/2024/06/03/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>面试官：既然您熟悉JS，那您能简单说说JS中的this指向问题吗？</p><p>我：好的，正常浏览器环境中，this是指向window对象，node环境中指向global对象，对象中，谁调用它，this就指向了谁，箭头函数中，指向外层对象，大概是这样。</p><p>面试官：那继续详细说说？</p><p>我：这还能怎么详细？已经够详细了。</p><p>面试官：嗯，似乎也确实，一般确实没必要考的更深了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>JavaScript 中的 “this” 是一个令人迷惑但又十分重要的概念。</p><p>它的行为可能会随着代码的不同而变化，因此深入理解 “this” 对于成为一名优秀的 JavaScript 开发者至关重要。</p><p>本文将带您深入探讨 “this” 的工作原理以及如何在实际应用中正确使用它。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>在 JavaScript 中，”this” 表示当前执行代码的对象。</p><p>但是，它的具体指向取决于代码的上下文。</p><p>在全局作用域下，”this” 指向全局对象（在浏览器中通常是 “window” 对象）。在函数内部，”this” 的值取决于函数的调用方式。</p><h3 id="为什么要有this"><a href="#为什么要有this" class="headerlink" title="为什么要有this"></a>为什么要有this</h3><p>为了让对象中的函数有能力访问对象自己的属性，this可以显著的提升代码质量，减少上下文参数的传递，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 name is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + obj.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 Hello,John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 Hello,John</span></span><br></pre></td></tr></table></figure><ul><li>第一二段代码对比，为了让对象中的函数有能力访问对象自己的属性。</li><li>第二三段代码对比，this可以显著的提升代码质量，减少上下文参数的传递。</li></ul><h3 id="全局上下文下的-“this”"><a href="#全局上下文下的-“this”" class="headerlink" title="全局上下文下的 “this”"></a>全局上下文下的 “this”</h3><p>在全局作用域下，”this” 指向全局对象。</p><p>这意味着当在全局作用域下调用 “this” 时，它将指向 “window” 对象（或 在node环境中，指向”global” 对象，取决于执行环境）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p>用了严格模式 “use strict”，严格模式下无法再意外创建全局变量，所以 this 不为 window 而为 undefined。</p><p>注意：babel 转成 ES6 的，babel 会自动给 js 文件上加上严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="函数上下文中的-“this”"><a href="#函数上下文中的-“this”" class="headerlink" title="函数上下文中的 “this”"></a>函数上下文中的 “this”</h3><p>在函数内部，”this” 的值取决于函数的调用方式。</p><p>如果函数是作为对象的方法调用的，则 “this” 将指向调用该方法的对象。</p><p>这就是那句经典的回答：“谁调用了它，它就指向谁”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, John&quot;</span></span><br></pre></td></tr></table></figure><p>如果函数中的 this 是被上一级的对象所调用的，那么 this 指向的就是上一级的对象，如下示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">dog</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;cobyte&#x27;</span>,</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">animal.<span class="property">dog</span>.<span class="title function_">getName</span>() <span class="comment">// &#x27;cobyte&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="构造函数中的-“this”"><a href="#构造函数中的-“this”" class="headerlink" title="构造函数中的 “this”"></a>构造函数中的 “this”</h3><p>在构造函数中，”this” 用于引用将要创建的对象实例。</p><p>当使用 “new” 关键字调用构造函数时，”this” 将指向新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// 输出 &quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数中的-“this”"><a href="#箭头函数中的-“this”" class="headerlink" title="箭头函数中的 “this”"></a>箭头函数中的 “this”</h3><p>与常规函数不同，箭头函数中的 “this” 指向定义时的外部上下文，而不是调用时的上下文。</p><p>这使得箭头函数在访问外部作用域的 “this” 值时非常方便。</p><p>严格模式对箭头函数没有效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jane&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, Jane&quot;</span></span><br></pre></td></tr></table></figure><p><strong>说明：箭头函数没有this这个机制，写在箭头函数中的this也是它外层非箭头函数的this</strong></p><h3 id="this-的绑定规则"><a href="#this-的绑定规则" class="headerlink" title="this 的绑定规则"></a>this 的绑定规则</h3><p>在 JavaScript 中，”this” 的值是在函数执行时确定的，根据调用函数的方式不同，”this” 可以绑定到不同的值上。</p><p>下面是几种常见的绑定规则：</p><h4 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h4><p>当一个函数独立调用时，并且没有任何修饰符，”this” 将默认绑定到全局对象（在浏览器中通常是 “window” 对象）上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认绑定，this 指向全局对象</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, John&quot;</span></span><br></pre></td></tr></table></figure><p>在全局，通过<code>var</code>声明的变量相当于是在<code>window</code>对象上添加了一个属性，即  <code>window.name</code> ，因此<code>window.name == this.name</code>。</p><h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>当函数被作为对象的方法调用时，”this” 将隐式绑定到调用该方法的对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定，this 指向调用它的对象</span></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-隐式丢失"><a href="#3-隐式丢失" class="headerlink" title="3. 隐式丢失"></a>3. 隐式丢失</h4><p>隐式丢失：当一个函数被多个对象链式调用时，函数的this指向就近的那个对象（就近原则）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: sayHello  <span class="comment">// 引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Emily&quot;</span>,</span><br><span class="line">  <span class="attr">obj1</span>: obj1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">obj1</span>.<span class="title function_">greet</span>(); <span class="comment">// 输出 &quot;Hello, Bob&quot;</span></span><br></pre></td></tr></table></figure><p>这里，根据就近原则，输出Bob</p><h4 id="4-显示绑定"><a href="#4-显示绑定" class="headerlink" title="4. 显示绑定"></a>4. 显示绑定</h4><p>通过调用函数的 call、apply 或 bind 方法，可以显示地指定函数内部的 “this” 值。</p><h5 id="call-方法"><a href="#call-方法" class="headerlink" title="- call 方法"></a>- <a href="https://www.w3school.com.cn/js/js_function_call.asp">call 方法</a></h5><p><code>call</code> 方法允许您显式调用函数，并且可以指定函数内部的 <code>this</code> 值。</p><p>它接受一个参数列表，在调用函数时，将传递给函数作为参数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 call 方法调用函数，并指定 this 指向 obj，同时传递参数</span></span><br><span class="line">greet.<span class="title function_">call</span>(obj, <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用 <code>call</code> 方法将函数 <code>greet</code> 的 <code>this</code> 绑定到对象 <code>obj</code> 上，并且传递了一个额外的参数 <code>&quot;Hello&quot;</code>。</p><h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="- apply 方法"></a>- <a href="https://www.w3school.com.cn/js/js_function_apply.asp">apply 方法</a></h5><p><code>apply</code> 方法与 <code>call</code> 方法类似，但是它接受一个参数数组而不是参数列表。</p><p>这意味着您可以将参数作为数组传递给函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + punctuation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 apply 方法调用函数，并指定 this 指向 obj，同时传递参数数组</span></span><br><span class="line">greet.<span class="title function_">apply</span>(obj, [<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;!&quot;</span>]); <span class="comment">// 输出 &quot;Hi, Bob!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>apply</code> 方法将函数 <code>greet</code> 的 <code>this</code> 绑定到对象 <code>obj</code> 上，并传递了一个包含两个参数的数组 <code>[&quot;Hi&quot;, &quot;!&quot;]</code>。</p><h5 id="bind-方法"><a href="#bind-方法" class="headerlink" title="- bind 方法"></a>- <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind 方法</a></h5><p><code>bind</code> 方法创建一个新的函数，并将指定的 <code>this</code> 值绑定到函数内部。</p><p>与 <code>call</code> 和 <code>apply</code> 不同，<code>bind</code> 并不会立即调用函数，而是返回一个新的函数，您可以稍后调用它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 方法创建一个新的函数，指定 this 指向 obj</span></span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">bind</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用新的函数</span></span><br><span class="line"><span class="title function_">boundGreet</span>(<span class="string">&quot;Hey&quot;</span>); <span class="comment">// 输出 &quot;Hey, Charlie&quot;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用 <code>bind</code> 方法创建了一个新的函数 <code>boundGreet</code>，并将其 <code>this</code> 绑定到对象 <code>obj</code> 上。</p><p>然后，我们可以随时调用 <code>boundGreet</code> 函数，它将使用预先绑定的 <code>this</code> 值。</p><p><strong>上述三个方法也可不传参数使用。</strong></p><h4 id="5-new-绑定"><a href="#5-new-绑定" class="headerlink" title="5. new 绑定"></a>5. new 绑定</h4><p>当一个函数被使用 “new” 关键字调用时，它会创建一个新的对象，并将该对象绑定到函数内部的 “this” 上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;David&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出 &quot;David&quot;</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>“this” 是 JavaScript 中一个重要且经常被误解的概念。</p><p>通过深入理解 “this” 的工作原理，并根据不同的上下文正确使用它，您可以写出更加清晰、健壮的 JavaScript 代码。</p><p>希望本文能够帮助您更好地理解 “this”，并在实际项目中更加灵活地运用它。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7367290539983962150?searchId=20240603234706ED5DBD85811124E25806">搞懂this指向和规则，只需这一篇</a></p><p><a href="https://www.runoob.com/w3cnote/js-call-apply-bind.html">JavaScript 中 call()、apply()、bind() 的用法 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://juejin.cn/post/7105756630519644168">JavaScript 中的 this 实战例题总结分析</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程提速,Vscode插件整理</title>
      <link href="/2024/06/03/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-Vscode%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/"/>
      <url>/2024/06/03/%E5%B7%A5%E7%A8%8B%E6%8F%90%E9%80%9F-Vscode%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事必先利其器，整理一套好用的开发插件，就像是工匠在打磨自己的工具，johh要有自己的装备。</p><p>就算是差生也要文具多呢，出门在外，怎么能不整理一套属于自己的插件套装呢。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以前整理过一套，但是现在毕竟是VUE3的时代了，以前整理的那一套多少有点落伍。</p><p>所以，根据新的开发习惯，重新整理一套。</p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>必装，常规的开发插件，前端开发必装。</p><h4 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h4><p>工具的简中插件，早年很多人非得说要适应英语，我的评价是，别逞能了，是中国人肯定还是看中文来的亲切</p><h4 id="vscode-icons"><a href="#vscode-icons" class="headerlink" title="vscode-icons"></a>vscode-icons</h4><p>给不同的文件对应的icon，让开发者更形象的记住所有的文件。不过，你如果只记文件后缀的话，或许不需用。</p><h4 id="open-in-browser"><a href="#open-in-browser" class="headerlink" title="open-in-browser"></a>open-in-browser</h4><p>在浏览器打开当前文件，几乎是传统页面独立开发的必备工具，如果你喜欢用vscode手撸html的话，那这确实是个不错的插件。</p><p>不过，为什么不直接问问神奇的webstorm呢？</p><h4 id="Git-Graph"><a href="#Git-Graph" class="headerlink" title="Git Graph"></a>Git Graph</h4><p>VScode用的图形化git管理插件有不少，Git Graph和Git History都可以，二者随便选一个都可以。</p><h4 id="GitLens-—-Git-supercharged"><a href="#GitLens-—-Git-supercharged" class="headerlink" title="GitLens — Git supercharged"></a>GitLens — Git supercharged</h4><p>可以在行内提示本行代码由谁提交，非常便利的git版本排查管控插件。</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>必装，无论用什么框架都不影响。</p><h4 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a>Auto Close Tag</h4><p>html自动闭合标签</p><h4 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a>Auto Rename Tag</h4><p>html辅助修改标签，可以辅助修改闭合标签，省的开发者前后都要改一遍</p><h4 id="Color-Info"><a href="#Color-Info" class="headerlink" title="Color Info"></a>Color Info</h4><p>当您将鼠标悬停在CSS颜色上，会提示颜色信息</p><h4 id="Bracket-Pair-Color-DLW"><a href="#Bracket-Pair-Color-DLW" class="headerlink" title="Bracket Pair Color DLW"></a>Bracket Pair Color DLW</h4><p>函数方法括号颜色加深，清亮的颜色可以帮你在眼瞎的回调函数中增加发现BUG的几率，比原版的提示效果好不少</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>必装，这些工具算是大浪淘沙留下来比较实用的提示插件。</p><h4 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h4><p>智能路径提示，提示文件中的引用路径，必用的路径提示插件</p><h4 id="SVG-Viewer"><a href="#SVG-Viewer" class="headerlink" title="SVG Viewer"></a>SVG Viewer</h4><p>svg预览工具，可以右键选中，预览项目中的svg，如果项目中有很多SVG的icon，那么，这个插件就是很有必要的。</p><h4 id="filesize"><a href="#filesize" class="headerlink" title="filesize"></a>filesize</h4><p>可以告诉你写的文件有多大，虽然我们的代码终归会成为屎山，但是我们尽量还是要控制啊（笑）</p><h4 id="Element-Plus-Helper"><a href="#Element-Plus-Helper" class="headerlink" title="Element Plus Helper"></a>Element Plus Helper</h4><p>选择性安装，个人因为公司项目安装，此插件适用于 <a href="https://vue-admin-beautiful.com/admin-plus">Vue Admin Plus</a>、<a href="https://vue-admin-beautiful.com/shop-vite">Vue Shop Vite</a> 等基于 element-plus 开发的项目</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>选择性安装，我个人是习惯这套代码格式化+检测辅助，不过这套插件推荐根据项目习惯而选择性安装的，并非是必须安装的。</p><h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>检测js标准的工具，只是一个检测和提示插件</p><h4 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h4><p>自定义代码格式化工具，是用来做格式化配置的，建议配合上边的Eslint标准使用，这是一个格式化插件</p><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><p>传统的html和CSS的开发提示支持，这套提示插件现在似乎已经被vscode内置</p><h4 id="HTML-CSS-Support"><a href="#HTML-CSS-Support" class="headerlink" title="HTML CSS Support"></a>HTML CSS Support</h4><p>让 html 标签上写class 智能提示当前项目所支持的样式，新版已经支持scss文件检索，也支持vue。</p><h4 id="HTMLHint"><a href="#HTMLHint" class="headerlink" title="HTMLHint"></a>HTMLHint</h4><p>HTML格式提示，HTMLHint 工具内置 23 条规则，可以对 HTML 代码文件进行静态代码检查，从而提高 HTML 代码编写的规范和质量。</p><h3 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h3><p>如果主要以vue3开发为主的话，以下这套开发插件可以避免，选择性安装。</p><p>这套插件和vue3的相关插件有一定的冲突，如无VUE2项目的开发需求，则没必要装这些插件。</p><h4 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h4><p>主要是为vue提供快捷语法提示，非常好用，但是不建议使用作为格式化工具</p><h4 id="Vue-2-Snippets"><a href="#Vue-2-Snippets" class="headerlink" title="Vue 2 Snippets"></a>Vue 2 Snippets</h4><p>基于最新的 Vue 官方语法高亮文件添加了语法高亮，并且依据 Vue 2 的 API 添加了代码补全</p><h4 id="Vue-Peek"><a href="#Vue-Peek" class="headerlink" title="Vue Peek"></a>Vue Peek</h4><p>必装，即便是vue3里边，也可以装这个插件，用于查找vue组件文件</p><h4 id="VueHelper"><a href="#VueHelper" class="headerlink" title="VueHelper"></a>VueHelper</h4><p>vue代码提示插件，包括了vue2所有api，vue-router2和vuex2的代码提示。</p><h3 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h3><p>选择性安装，如果Vue3开发的倾向比较多，那么就用这套插件。</p><h4 id="Vue-VSCode-Snippets"><a href="#Vue-VSCode-Snippets" class="headerlink" title="Vue VSCode Snippets"></a>Vue VSCode Snippets</h4><ul><li>提供 Vue 3 相关的代码片段，方便快速输入常见代码结构。</li><li>支持 Vue 组件选项、指令、生命周期等。</li></ul><h4 id="Vue-Official"><a href="#Vue-Official" class="headerlink" title="Vue - Official"></a>Vue - Official</h4><ul><li>提供 Vue 文件的语法高亮。</li><li>支持 Vue 文件的智能感知和自动完成。</li><li>提供了 Vue 文件的格式化工具。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇文档并未有任何参考，纯粹是自己这几年开发整理出来的经验，因为个人擅长使用vue相关，所以本篇的工具更倾向于vue。</p><p>如果以后用react的话，我会考虑使再用react整一套。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解回调地狱</title>
      <link href="/2024/06/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/"/>
      <url>/2024/06/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/</url>
      
        <content type="html"><![CDATA[<p>回调地狱这个概念，单纯是古早时期写接口都是很多人用原生ajax写，然后不断嵌套之后太深，导致代码阅读极为麻烦。</p><p>这不是一个官方概念，而是很多开发者口口相传的概念，之后官方推出了Promise，用链式调用，解决了这种深层嵌套形成的问题</p><p>不过，<strong>回调地狱</strong>这个戏称便是一直留了下来，如同前端开发中的一个梗。</p><p>一般不会有面试官去面试这个，但是既然都了解到回调相关的事情了，就顺便整理一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong>回调地狱</strong>不是一个严肃的概念，仅做了解，不需要深入了解，因为JS进入了ES6的时代后，有了promise，这种代码逻辑的情况很少会存在。</p><p>所以，本篇并不做详细了解。</p><h3 id="什么是回调地狱"><a href="#什么是回调地狱" class="headerlink" title="什么是回调地狱"></a>什么是回调地狱</h3><p>在回调函数中，执行另一个函数，又在另一个函数中继续执行其它函数，如此层层嵌套，就会出现一个嵌套结构，就会形成<strong>回调地狱</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有多个异步任务，要求需要同时拿到所有异步任务的结果，下边就是用回调地狱</span></span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>, <span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">    conosle.<span class="title function_">log</span>(res1)</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&quot;url+res1&quot;</span>, <span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">        conosle.<span class="title function_">log</span>(res2)</span><br><span class="line">        $.<span class="title function_">get</span>(<span class="string">&quot;url+res2&quot;</span>, <span class="function">(<span class="params">res3</span>) =&gt;</span> &#123;</span><br><span class="line">            conosle.<span class="title function_">log</span>(res3)</span><br><span class="line">            $.<span class="title function_">get</span>(<span class="string">&quot;url+res3&quot;</span>, <span class="function">(<span class="params">res4</span>) =&gt;</span> &#123;</span><br><span class="line">                conosle.<span class="title function_">log</span>(res4)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码就是一个简单的回调地狱示例，这样的代码肉眼可见的维护性差，可读性也不好</p><h3 id="回调地狱的解决方案"><a href="#回调地狱的解决方案" class="headerlink" title="回调地狱的解决方案"></a>回调地狱的解决方案</h3><p>这种层层嵌套的处理逻辑，在有些场景中确实是存在的，虽然我们不能消灭它们，但是我们可以优化它们</p><h4 id="Promise-解决回调地狱"><a href="#Promise-解决回调地狱" class="headerlink" title="Promise 解决回调地狱"></a>Promise 解决回调地狱</h4><p><code>Promise</code>是一个对象里面保存着某个未来才会结束的事件就是一个异步操作的结果，从它可以获取异步操作的消息。</p><p>Promise对象的出现就是进行处理各种异步操作，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数也就可以用于解决回调地狱。</p><p>譬如我们项目任务中最常用的接口封装，就是一种最简单的回调地狱解决的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1秒后打印, res1&quot;</span>, res); <span class="comment">//1秒后打印 a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res + <span class="string">&quot;a&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2秒后打印, res&quot;</span>, res); <span class="comment">//2秒后打印 aa</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res + <span class="string">&quot;a&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3秒后打印, res3&quot;</span>, res); <span class="comment">//3秒后打印 aaa</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>第一个<code>then</code>方法传入的回调函数，返回的是另一个<code>Promise</code>对象。</p><p>这时，第二个<code>then</code>方法传入的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化，只有新的<code>Promise</code>对象状态改变了才会触发后面代码的执行。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数，这样就将异步操作以同步操作的流程表达出来了。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>解决回调地狱<strong>原理</strong> ： 在then方法中返回一个promise对象（链式语法嵌套，需要在上一个promise对象的then方法中返回下一个promise）</p><h4 id="ES6异步函数async与await"><a href="#ES6异步函数async与await" class="headerlink" title="ES6异步函数async与await"></a>ES6异步函数async与await</h4><p><code>async函数</code>是<code>ES2017</code>中引入的更为高级的异步处理机制,可以让异步的处理变的更加便捷，相当于是promise语法的 “高级写法”。</p><p>async和await异步函数 : 这两个关键字只能用于函数, 所以用的时候一定要放在函数里面用</p><ul><li><code>async</code>关键字: 修饰函数， 表示这个函数内部有异步操作。</li><li><code>await</code>关键字: 等待异步执行完毕。</li></ul><p>注意点：</p><ul><li>await 后面是promise对象, 左侧的返回值就是这个promise对象的then方法中的结果</li><li>await必须要写在async修饰的函数中，不能单独使用，否则程序会报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPromise</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(params)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getData = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data1 = <span class="keyword">await</span> <span class="title function_">getPromise</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(), data1)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> data2 = <span class="keyword">await</span> <span class="title function_">getPromise</span>(data1 + <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(), data2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> data3 = <span class="keyword">await</span> <span class="title function_">getPromise</span>(data2 + <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>(), data3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure><h4 id="Axios网络请求工具"><a href="#Axios网络请求工具" class="headerlink" title="Axios网络请求工具"></a>Axios网络请求工具</h4><p><strong>Axios是一个基于Promise对象的网络请求框架</strong>。</p><p>它只是一个网络请求工具并不是网络请求技术，依然是基于XHR开发封装的方式，只是比AJAX更好用。</p><p>前端网络请求技术有AJAX技术和JSONP技术以及Fetch技术，这个网络请求框架可以用于浏览器和node.js，AJAX，FETCH，AXIOS三者的关系可以看这篇：<a href="https://juejin.cn/post/6997784981816737800">有同学问我：Fetch 和 Ajax 有什么区别？ - 掘金 (juejin.cn)</a>。</p><p>这个框架网络请求依然不能解决跨域问题，需要代理服务器才能跨域请求。</p><p>多次网络请求需要嵌套时避免层层回调使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="title function_">axios</span>(<span class="string">&#x27;/ajax1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111111111</span>,data)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="string">&#x27;/ajax2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data2.<span class="property">data</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="string">&#x27;/ajax3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data3</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data3.<span class="property">data</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="string">&#x27;/ajax4&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data4</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data4.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h4><p>Fetch之前提过，是区别于传统AJAX的一项新方式，是XMLHttpRequest的升级版也是单独的一个前端网络请求技术。</p><p><strong>Fetch原理</strong>是使用Promise语法不使用回调函数，用于在JavaScript脚本里面发出HTTP请求，是浏览器自带的API，后端node.js不能使用。</p><p>在用法上，fetch()接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。fetch()接收到的数据需要先进行数据转码，来得到想要的数据。</p><p>多次网络请求需要嵌套时避免层层回调使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/ajax3&quot;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>()<span class="comment">//得到 JSON 对象</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)<span class="comment">//真正请求到的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇仅供了解，没有什么太大的作用，回调地狱的那段往事已经是上一代老油条开发的梗了，没必要深入了解的。</p><p>上一代的故事就让它停留在上一代吧，可以了解，但是没必要深入。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6997784981816737800">有同学问我：Fetch 和 Ajax 有什么区别？</a></p><p><a href="https://juejin.cn/post/7307469610424418319#heading-16">【JavaScript】【回调】回调函数 &amp;&amp; 回调地狱 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解回调函数</title>
      <link href="/2024/06/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2024/06/02/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>面试官：既然您提到了回调函数，能简单说一下回调函数吗？</p><p>我：就是将函数作为参数传递，让函数可以被其他函数使用。</p><p>面试官：能再详细说说吗？您作为一个老前端，相比理解的很透彻吧？</p><p>我：哈哈哈哈，不能。</p><p>面试官：哈哈哈哈哈，您真幽默，和您聊的很开心，回去等通知吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我真没想到，我会再次因为这种古董面试题被摆了一道，五年前我能说的头头是道的面试题，如今居然被卡了。</p><p>哎，面试失败之后，立刻回家重新整理了一下相关的文档。</p><h3 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h3><p><strong>回调函数</strong>是将一个函数作为参数传递给另一个函数，并且可以在传入的那个函数中接受参数和返回值</p><p><strong>回调函数和普通函数没有本质区别，没有本质区别，回调函数谁都可以用</strong></p><p>这里我们写个回调函数被调用的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myDisplayer</span>(<span class="params">some</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = some;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myCallback 就是回调函数的传参，我们还可以给回调函数传参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myCalculator</span>(<span class="params">num1, num2, myCallback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;得到结果：&#x27;</span>+sum);</span><br><span class="line">  <span class="title function_">myCallback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myCalculator</span>(<span class="number">5</span>, <span class="number">5</span>, myDisplayer);</span><br></pre></td></tr></table></figure><p>【注意点】</p><ul><li>函数作为参数传递时，不要使用括号<ul><li>正确: <code>myCalculator(5, 5, myDisplayer);</code></li><li>错误：<del><code>myCalculator(5, 5, myDisplayer());</code></del></li></ul></li></ul><h3 id="回调函数的作用和使用场景"><a href="#回调函数的作用和使用场景" class="headerlink" title="回调函数的作用和使用场景"></a>回调函数的作用和使用场景</h3><p>回调函数是一种常见的编程技术，他可以在异步操作完成后调用一个预定义的函数来处理结果。</p><p>回调函数通常用于处理事件、执行异步操作或响应用户输入等场景。</p><ul><li>作用：<ul><li>将<strong>代码逻辑分离</strong>出来，使得代码更加模块化和可维护</li><li>可以<strong>避免阻塞程序</strong>的运行，提高程序的性能和效率</li><li>可以实现<strong>代码的复用</strong>，因为他们可以被多个地方调用</li></ul></li><li>使用场景：<ul><li><strong>事件处理</strong>，例如鼠标点击、键盘输入，网络请求等</li><li><strong>异步操作</strong>，例如读取文件、发送邮件、下载文件等</li><li><strong>数据处理</strong>，例如对数组进行排序、过滤、映射等</li><li><strong>插件开发</strong>，例如WordPress插件等</li></ul></li></ul><blockquote><ul><li>异步编程：指在代码执行时不会阻塞程序运行的方式</li><li>事件驱动：指程序的执行是由外部事件触发而不是顺序执行的方式</li></ul></blockquote><h3 id="回调函数的优缺点"><a href="#回调函数的优缺点" class="headerlink" title="回调函数的优缺点"></a>回调函数的优缺点</h3><ul><li>优点<ul><li>提高代码的复用性和灵活性：回调函数可以将一个函数作为参数传递给另一个函数，从而实现模块化编程，提高代码的复用性和灵活性</li><li>解耦合：回调函数可以将不同模块之间的关系解耦，使得代码更易于维护和扩展</li><li>可以异步执行：回调函数可以在异步操作完成后被执行，这样避免了阻塞线程，提高应用程序的效率</li></ul></li><li>缺点<ul><li>回调函数嵌套过多会导致代码难以维护：如果回调函数嵌套层数过多，代码会变得非常复杂，难以维护</li><li>回调函数容易造成竞态条件：如果回调函数中有共享资源访问，容易出现竞态条件，导致程序出错</li><li>代码可读性差：回调函数的使用可能会破坏代码的结构和可读性，尤其是在处理大量数据时</li></ul></li></ul><blockquote><p>小结：代码灵活、易于扩展，但是不易于阅读、容易出错</p></blockquote><h3 id="回调函数与其它编程概念的关系"><a href="#回调函数与其它编程概念的关系" class="headerlink" title="回调函数与其它编程概念的关系"></a>回调函数与其它编程概念的关系</h3><h4 id="回调函数和闭包的关系"><a href="#回调函数和闭包的关系" class="headerlink" title="回调函数和闭包的关系"></a>回调函数和闭包的关系</h4><p>回调函数和闭包之间存在着紧密的关系。</p><p>回调函数是一个函数，在另一个函数中被作为参数传递，并在该函数执行完成后被调用。</p><p>闭包是由一个函数及其相关的引用环境组合而成的实体，可以访问函数外部的变量。</p><p>在某些情况下，回调函数需要访问到它所在的父函数的变量，这时就需要使用闭包来实现。</p><p>通过将回调函数放在闭包内部，可以将父函数的变量保存在闭包的引用环境中，使得回调函数能够访问到这些变量。同时，闭包还可以保证父函数中的变量在回调函数执行时不会被销毁，从而确保了回调函数的正确性</p><p>因此，回调函数和闭包是一对密切相关的概念，常常一起使用来实现复杂的逻辑和功能。</p><h4 id="回调函数和Promise的关系"><a href="#回调函数和Promise的关系" class="headerlink" title="回调函数和Promise的关系"></a>回调函数和Promise的关系</h4><p>C++回调函数和Promise都是异步编程的实现方式。</p><p>回调函数是一种将函数作为参数传递给另一个函数，在异步操作完成后执行的技术。在C++中，回调函数通常使用函数指针或函数对象来实现。当异步操作完成后，会调用注册的回调函数，以便执行相应的处理逻辑。</p><p>而Promise则是一种更加高级的异步编程模式，它通过解决回调地狱问题，提供了更加优雅和简洁的异步编程方式。</p><p>Promise可以将异步操作封装成一个Promise对象，并通过链式调用then()方法来注册回调函数，以及catch()方法来捕获异常。当异步操作完成后，Promise会自动根据操作结果触发相应的回调函数。</p><p>因此，可以说C++回调函数和Promise都是异步编程的实现方式，但是Promise提供了更加高级和优雅的编程模式，能够更好地管理异步操作和避免回调地狱问题。</p><h4 id="回调函数和观察者模式的关系"><a href="#回调函数和观察者模式的关系" class="headerlink" title="回调函数和观察者模式的关系"></a>回调函数和观察者模式的关系</h4><p>回调函数和观察者模式都是用于实现事件驱动编程的技术。</p><p>它们之间的关系是，观察者模式是一种设计模式，它通过定义一种一对多的依赖关系，使得一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</p><p>而回调函数则是一种编程技术，它允许将一个函数作为参数传递给另一个函数，在执行过程中调用这个函数来完成特定的任务。</p><p>在观察者模式中，当一个被观察的对象发生改变时，会遍历所有的观察者对象，调用其定义好的更新方法，以进行相应的操作。</p><p>这里的更新方法就可以看做是回调函数，因为它是由被观察对象调用的，并且在执行过程中可能需要使用到一些外部参数或上下文信息。因此，可以说观察者模式本身就包含了回调函数的概念，并且借助回调函数来实现观察者模式的具体功能。</p><h3 id="如何编写高质量的回调函数"><a href="#如何编写高质量的回调函数" class="headerlink" title="如何编写高质量的回调函数"></a>如何编写高质量的回调函数</h3><p>回调函数需要遵循以下几个原则</p><ol><li><strong>明确函数的目的和作用域</strong>。回调函数应该有一个清晰的目的，同时只关注与其作用范围相关的任务</li><li><strong>确定回调函数的参数和返回值</strong>。在定义回调函数时，需要明确它所需的参数和返回值类型，这样可以使调用方更容易使用</li><li><strong>谨慎处理错误和异常</strong>。回调函数可能会引发一些异常或错误，需要使用 try-catch 块来处理它</li><li><strong>确保回调函数不会导致死锁或阻塞</strong>。回调函数需要尽可能快地执行完毕，以避免影响程序的性能和稳定性。</li><li><strong>使用清晰且易于理解的命名规则</strong>。回调函数的命名应该清晰、简洁，并尽可能说明其功能和意义。</li><li><strong>编写文档和示例代码</strong>。良好的文档和示例代码可以帮助其他开发者更容易地使用回调函数，同时也有助于提高代码的可维护性和可重用性。</li><li><strong>遵循编码规范和最佳实践</strong>。 编写高质量的回调函数需要遵守编码规范和最佳实践，例如使用合适的命名规则、注释代码等。</li></ol><h4 id="回调函数的命名规范"><a href="#回调函数的命名规范" class="headerlink" title="回调函数的命名规范"></a>回调函数的命名规范</h4><p>回调函数的命名规范没有固定的标准，但是根据通用惯例和编码规范，回调函数的命名应该能够反映函数的作用和功能，让其他开发者能够快速理解并使用。</p><ol><li>使用动词+名词的方式来描述回调函数的作用，例如onSuccess、onError等。</li><li>如果回调函数是用于处理事件的，可以以handleEvent或者onEvent作为函数名。</li><li>如果回调函数是用于处理异步操作完成后的结果，可以以onComplete或者onResult作为函数名。</li><li>在命名时要注意保持简洁明了，不要过于冗长，也不要使用缩写或者不清晰的缩写。</li><li>尽量使用有意义的单词或者短语作为函数名，不要使用无意义的字母或数字组合。</li><li>与代码中其他的函数名称保持一致，尽量避免出现命名冲突的情况。</li></ol><h4 id="回调函数的参数设计"><a href="#回调函数的参数设计" class="headerlink" title="回调函数的参数设计"></a>回调函数的参数设计</h4><p>回调函数的参数设计取决于回调函数所需执行的操作和数据。一般来说，回调函数需要接收至少一个参数，通常是处理结果或错误信息。其他可选参数根据需要添加。</p><h3 id="回调函数使用"><a href="#回调函数使用" class="headerlink" title="回调函数使用"></a>回调函数使用</h3><h4 id="使用Function对象"><a href="#使用Function对象" class="headerlink" title="使用Function对象"></a>使用Function对象</h4><p>Function 对象是 JavaScript 中的一种基本数据类型，它可以表示一个函数。可以使用 Function 对象来实现回调函数。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callbackFunction</span>(<span class="params">param1, param2</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行回调函数的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将回调函数传递给另一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunction</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行异步操作</span></span><br><span class="line">  <span class="title function_">callback</span>(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数，并将回调函数传递给它</span></span><br><span class="line"><span class="title function_">asyncFunction</span>(callbackFunction);</span><br></pre></td></tr></table></figure><h4 id="使用arrow-箭头-函数"><a href="#使用arrow-箭头-函数" class="headerlink" title="使用arrow(箭头)函数"></a>使用arrow(箭头)函数</h4><p>arrow函数是 JavaScript 中的一种简化版本的函数表达式，它可以更简洁地定义函数。可以使用 arrow 函数来实现回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">callbackFunction</span> = (<span class="params">param1, param2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 执行回调函数的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将回调函数传递给另一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunction</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行异步操作</span></span><br><span class="line">  <span class="title function_">callback</span>(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数，并将回调函数传递给它</span></span><br><span class="line"><span class="title function_">asyncFunction</span>(callbackFunction);</span><br></pre></td></tr></table></figure><h3 id="回调函数中的this指向"><a href="#回调函数中的this指向" class="headerlink" title="回调函数中的this指向"></a>回调函数中的this指向</h3><ul><li><strong>在定时器<code>setInterval</code>和<code>setTimeout</code>中</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;my name is window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;my name is obj&#x27;</span>,</span><br><span class="line"> <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">     <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">     timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  <span class="comment">// my name is window</span></span><br><span class="line">     &#125;, <span class="number">1000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// my name is window</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们可以看出来，this的指向是<code>window</code></p><p>如果没有特殊指向，<code>setInterval</code>和<code>setTimeout</code>的回调函数中this的指向都是window，这是因为JS的定时器方法是定义在window下的。</p><p>但是平时很多场景下，都需要修改this的指向。这里总结了几种：</p><ul><li><p>最常用的方法：在外部函数中将<code>this</code>存为一个变量，回调函数中使用该变量，而不是直接使用<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;my name is window&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;my name is obj&#x27;</span>,</span><br><span class="line">     <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">         <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">         <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">         timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">name</span>);  <span class="comment">//my name is obj</span></span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// my name is window</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用bind()方法</strong>（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决）</p><p><code>bind()</code>的作用类似call和apply，都是修改<code>this</code>指向。</p><p>但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原来函数主体相同的新函数，新函数中的this指向传入的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;my name is window&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;my name is obj&#x27;</span>,</span><br><span class="line">     <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">         <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">         <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">         timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">name</span>);  <span class="comment">// my name is obj</span></span><br><span class="line">         &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">1000</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// my name is window</span></span><br></pre></td></tr></table></figure><p>在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。</p></li><li><p><strong>使用es6的箭头函数</strong>：箭头函数的最大作用就是this指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;my name is window&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;my name is obj&#x27;</span>,</span><br><span class="line">     <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">         <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">         <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">         timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  <span class="comment">//my name is obj</span></span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">obj.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><p><strong>箭头函数没有自己的this，它的this继承自外部函数的作用域</strong>。</p><p>所以，在该例中，定时器回调函数中的this，是继承了fn的this。</p><p>当然箭头函数也有兼容问题，要是兼容低版本ie，需要使用babel编译，并且引入es5-shim.js才可以。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>回调函数其实本质上不能算是JS的独有手法，只是一种入门的编程思想罢了。</p><p>虽然面试官让我详细说说我依然感觉很荒诞，但是我没能详细说说，确实不太符合老年程序员的身份。</p><p>如今回顾了一下，倒也是颇为感慨，我的确挖的不够深，大开眼界。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7307469610424418319">【JavaScript】【回调】回调函数 &amp;&amp; 回调地狱 - 掘金 (juejin.cn)</a></p><p><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/627181746">回调函数(callback)是什么？一文理解回调函数(callback)</a></p><p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/qq_42698326/article/details/111075519">一文告诉你什么是回调地狱，如何解决回调地狱？-CSDN博客</a></p><p><a href="https://juejin.cn/post/7127339659545772063">回调地狱以及解决回调地狱 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析vue的响应式原理</title>
      <link href="/2024/05/31/%E6%B5%85%E6%9E%90vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2024/05/31/%E6%B5%85%E6%9E%90vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>面试官：您能详细说说vue的双向绑定原理吗？</p><p>我：双向绑定是v-model的实现方式，我猜您问的不是那么简单的问题，也许您是想说vue的响应式原理？</p><p>面试官：对对，就是这个，您说一下Vue的双向绑定原理？</p><p>我：哈哈哈，我不会。</p><p>面试官：哈哈哈，您真幽默，和您聊得很开心，HR后续会通知您面试结果的。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为最近找工作，面试vue3相关的知识点多一些，所以这里更多看</p><p>本来想考虑自己看源码写一份文档的，但是同事推荐了几篇文档之后，我觉得自己还是不要出来丢人了。</p><p>看了市面上几位大佬的解析之后，我觉得自己的理解多少还是菜了些。</p><p>这里我就转载其中一篇文档，我个人倾向于<a href="https://juejin.cn/post/6850418111985352711#heading-0">vue响应式详解（重学前端-vue篇1） - 掘金 (juejin.cn)</a>这篇文档，因为我个人基础相对来说还可以，而且看了vue3的源码，所以这里更喜欢笼统的看个大概得思路，这样不乱。</p><p>不过，如果是新人，我更推荐看<a href="https://juejin.cn/post/6932659815424458760#heading-13">0年前端的Vue响应式原理学习总结1：基本原理 - 掘金 (juejin.cn)</a>，这篇文档写的会连带着实现动机解释的很明白，如果你之前没有看过VUE的源码，那么这篇文档能让新手非常顺滑的理解vue实现的动机和过程。</p><p>vue的原理确实不麻烦，但是思路很精妙，我们平日大概率是用不上的，所以这里只是拓充知识。</p><p>毕竟，大多数人不是底层的源码实现者，所以只能学习思路，至于平日代码实现，如果有机会实现，那确实厉害。</p><h3 id="什么是Vue响应式"><a href="#什么是Vue响应式" class="headerlink" title="什么是Vue响应式"></a>什么是Vue响应式</h3><blockquote><p>数据发生变化后，会重新对页面渲染，这就是Vue响应式</p></blockquote><p><img src="https://s2.loli.net/2024/05/31/2XGWTOD3uYEtJ6m.png" alt="image-20240531232228283"></p><h3 id="想完成这个过程，我们需要做些什么"><a href="#想完成这个过程，我们需要做些什么" class="headerlink" title="想完成这个过程，我们需要做些什么"></a>想完成这个过程，我们需要做些什么</h3><ul><li>侦测数据的变化</li><li>收集视图依赖了哪些数据</li><li>数据变化时，自动“通知”需要更新的视图部分，并进行更新</li></ul><p><strong>「它们对应专业俗语分别是：」</strong></p><ul><li>数据劫持 &#x2F; 数据代理</li><li>依赖收集</li><li>发布订阅模式</li></ul><h3 id="什么是发布订阅模式"><a href="#什么是发布订阅模式" class="headerlink" title="什么是发布订阅模式"></a>什么是发布订阅模式</h3><ul><li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的</li><li><strong>发布&#x2F;订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</li></ul><p><img src="https://s2.loli.net/2024/05/31/NsmjRFWEiDtSqwZ.png" alt="image-20240531232458202"></p><p>vue响应式采用的就是发布订阅模式，举个生活中的例子说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如小红最近在淘宝网上看上一双鞋子，但是联系到卖家后，才发现这双鞋卖光了。</span><br><span class="line">但是小红对这双鞋又非常喜欢，所以联系卖家，问卖家什么时候有货。</span><br><span class="line">卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你。</span><br><span class="line">所以小红收藏了此店铺。</span><br><span class="line">但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺，等来货的时候就依次会通知他们;</span><br></pre></td></tr></table></figure><p>如何实现发布–订阅模式?</p><ol><li>首先要想好谁是发布者(比如上面的卖家)。</li><li>然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺,卖家通过收藏了该店铺的一个列表名单)。</li><li>最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数</li></ol><h3 id="如何侦测数据的变化"><a href="#如何侦测数据的变化" class="headerlink" title="如何侦测数据的变化"></a>如何侦测数据的变化</h3><p>有两种办法可以侦测到变化：<br> 使用<code>Object.defineProperty</code>和ES6的<code>Proxy</code>，这就是进行数据劫持或数据代理。</p><h4 id="Object-defineProperty实现"><a href="#Object-defineProperty实现" class="headerlink" title="Object.defineProperty实现"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>实现</h4><p>Vue通过设定对象属性的 <code>setter/getter</code> 方法来监听数据的变化，通过<code>getter</code>进行依赖收集，而每个<code>setter</code>方法就是一个<code>观察者</code>，在<code>数据变更</code>的时候通知<code>订阅者</code>更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span> () &#123;</span><br><span class="line">  <span class="comment">// set的时候会走这里，重新渲染</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟视图渲染&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;浪里行舟&#x27;</span>,</span><br><span class="line">  <span class="attr">location</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请看下一节</span></span><br><span class="line"><span class="title function_">observe</span>(data)</span><br></pre></td></tr></table></figure><p>定义核心函数observe</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span> (obj) &#123; <span class="comment">// 我们来用它使对象变成可观察的</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      判断类型,obj可能是vue中的data对象，也可以是data中的某个属性值,</span></span><br><span class="line"><span class="comment">      例如:data:&#123; name: &#x27;浪里行舟&#x27;, location:&#123;  x: 100, y: 100 &#125; &#125;，这里的值可能是整个data，</span></span><br><span class="line"><span class="comment">      也可能是location的值，当location值也是对象的时候就需要再次监听location值对象。</span></span><br><span class="line"><span class="comment">      而属性name和location在监听data的时候就会监听这2个属性。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//监听对象的每个属性</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj, key, value) &#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    <span class="title function_">observe</span>(value)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//可枚举（可以遍历）</span></span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//可配置（比如可以删除）</span></span><br><span class="line">      <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, value) <span class="comment">// 监听</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">//如果赋值是一个对象，也要递归子属性</span></span><br><span class="line">        <span class="comment">//如果有新值</span></span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, newVal) <span class="comment">// 监听</span></span><br><span class="line">          <span class="title function_">render</span>() <span class="comment">//执行渲染逻辑</span></span><br><span class="line">          value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改变data的属性，会触发set；然后获取data的属性，会触发get</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="property">location</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1000</span></span><br><span class="line">&#125;         <span class="comment">//打印=》     set &#123;x: 1000,y: 1000&#125; 染</span></span><br><span class="line">data.<span class="property">name</span> <span class="comment">//打印=》   get 浪里行舟</span></span><br></pre></td></tr></table></figure><p><strong>上面这段代码的主要作用</strong></p><p>observe这个函数传入一个 <code>obj（需要被追踪变化的对象）</code>，通过遍历所有属性的方式对该对象的每一个属性都通过 <code>defineReactive</code> 处理,给每个属性加上<code>set</code>和<code>get</code>方法,以此来达到实现侦测对象变化。</p><p>值得注意的是，observe 会进行递归调用，因此我们需要设置一个递归出口。</p><p><strong>那我们如何侦测Vue中data 中的数据，其实也很简单</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="comment">/* Vue构造类 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_data</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="title function_">observer</span>(<span class="variable language_">this</span>.<span class="property">_data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只要 new 一个 Vue 对象，就会将 data 中的数据进行追踪变化。</p><p><strong>但是我们发现一个问题，上面的代码无法检测到对象属性的<code>添加或删除</code>(如data.location.a&#x3D;1,增加一个a属性)。</strong></p><p> 这是因为 Vue 通过Object.defineProperty来将对象的key转换成getter&#x2F;setter的形式来追踪变化，但getter&#x2F;setter只能追踪一个数据<code>是否被修改</code>，无法追踪<code>新增属性和删除</code>属性。</p><p>如果是删除属性，我们可以用<code>vm.$delete</code>实现，那如果是新增属性，该怎么办呢？</p><ol><li>可以使用 Vue.set(location, a, 1) 方法向嵌套对象添加响应式属性;</li><li>也可以给这个对象重新赋值，比如data.location &#x3D; {…data.location,a:1}</li></ol><p>Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写</p><h3 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者 Watcher"></a>观察者 Watcher</h3><h4 id="为什么引入Watcher"><a href="#为什么引入Watcher" class="headerlink" title="为什么引入Watcher"></a>为什么引入Watcher</h4><p>Vue 中定义一个 Watcher 类来表示<code>观察订阅依赖</code>。</p><p>至于为啥引入Watcher，《深入浅出vue.js》给出了很好的解释。</p><p>当<code>属性</code>发生变化后，我们要通知<code>用到数据</code>的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个<code>能集中处理</code>这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方。</p><p><strong>「依赖收集的目的」</strong> 将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中，形成如下所示的这样一个关系（图参考《剖析 Vue.js 内部运行机制》）。</p><p><img src="https://s2.loli.net/2024/06/02/7CrdP4YSnFBfkZs.png" alt="image-20240602230312707"></p><h4 id="Watcher的简单实现"><a href="#Watcher的简单实现" class="headerlink" title="Watcher的简单实现"></a>Watcher的简单实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">obj, key, cb</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">obj</span> = obj</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = obj[key]</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">obj</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">   <span class="comment">// 我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher ,然后执行 update 函数。</p><p><strong>「依赖的本质」</strong></p><p> 所谓的<code>依赖</code>，其实就是<code>Watcher</code>。</p><p> 至于如何收集依赖，总结起来就一句话:</p><p> 在<code>getter</code>中收集依赖（收集Watch当如Dep中），在<code>setter</code>中触发依赖。</p><p>先收集依赖，即把用到该数据的地方<code>收集起来</code>，然后等<code>属性发生变化</code>时，把之前收集好的依赖<code>循环触发</code>一遍就行了。</p><p>具体来说，当外界通过Watcher<code>读取数据</code>时，便会触发<code>getter</code>从而将<code>Watcher添加到依赖中</code>，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。</p><p>当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。</p><p>最后我们对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码,实现了一个简易的数据响应式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">defineReactive</span> (obj, key, value) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(value)  <span class="comment">// 递归子属性</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Dep</span>() <span class="comment">//新增</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">//可枚举（可以遍历）</span></span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">//可配置（比如可以删除）</span></span><br><span class="line">      <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, value) <span class="comment">// 监听</span></span><br><span class="line">     <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">     <span class="comment">// target挂载发生在new Watch的时候</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">         <span class="comment">// 新增Watch到dep的subs中，就是说new了哪个Watch就要把哪个Watch收集进来</span></span><br><span class="line">         dp.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">        <span class="comment">// 如果赋值是一个对象，也要递归子属性</span></span><br><span class="line">        <span class="comment">// 例如上面的location是一个对象，那么这个对象是要继续observe的</span></span><br><span class="line">        <span class="title function_">observe</span>(newVal) </span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, newVal) <span class="comment">// 监听</span></span><br><span class="line">          <span class="title function_">render</span>()</span><br><span class="line">          value = newVal</span><br><span class="line">         <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">          dp.<span class="title function_">notify</span>() <span class="comment">//新增</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_data</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="title function_">observer</span>(<span class="variable language_">this</span>.<span class="property">_data</span>);</span><br><span class="line">        <span class="comment">/* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟视图渲染&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 render function 被渲染的时候,<code>读取</code>所需对象的值，会触发 <code>reactiveGetter</code> 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。</p><p>之后如果<code>修改</code>对象的值，则会触发 <code>reactiveSetter</code> 方法，通知 Dep 类调用 <code>notify</code> 来触发所有 Watcher 对象的 <code>update</code> 方法更新对应视图。</p><p><strong>「完整流程图」</strong></p><p><img src="https://s2.loli.net/2024/06/02/iz95c1fnKS3FlqQ.png" alt="image-20240602230619901"></p><ul><li>在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是init 过程，在 这个过程Data通过Observer转换成了getter&#x2F;setter的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。</li><li>当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。</li><li>在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。</li></ul><h3 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h3><h4 id="为什么要收集依赖"><a href="#为什么要收集依赖" class="headerlink" title="为什么要收集依赖"></a>为什么要收集依赖</h4><blockquote><p>我们之所以要观察数据，其目的在于当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方。比如例子中，模板中使用了location 数据，当它发生变化时，要向使用了它的地方发送通知。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalData = &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;浪里行舟&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>: globalData</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>: globalData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果我们执行下面这条语句：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">globalData.text</span> = <span class="string">&#x27;前端工匠&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时我们需要通知 <code>test1</code> 以及 <code>test2</code> 这两个Vue实例进行视图的<code>更新</code>,我们只有通过<code>收集依赖</code>才能知道哪些地方依赖我的数据，以及数据更新时<code>派发更新</code>。那依赖收集是如何实现的？其中的核心思想就是“事件发布订阅模式”。接下来我们先介绍两个重要角色– <code>订阅者 Dep</code>和<code>观察者 Watcher</code> ，然后阐述收集依赖的如何实现的。</p><h3 id="Dep-Watcher的关系"><a href="#Dep-Watcher的关系" class="headerlink" title="Dep,Watcher的关系"></a>Dep,Watcher的关系</h3><p>Observer负责将数据转换成getter&#x2F;setter形式； Dep负责管理数据的依赖列表；是一个发布订阅模式，上游对接Observer，下游对接Watcher Watcher是实际上的数据依赖，负责将数据的变化转发到外界(渲染、回调)； 首先将data传入Observer转成getter&#x2F;setter形式；当Watcher实例读取数据时，会触发getter，被收集到Dep仓库中；当数据更新时，触发setter，通知Dep仓库中的所有Watcher实例更新，Watcher实例负责通知外界</p><ul><li>Dep 负责收集所有相关的的订阅者 Watcher ，具体谁不用管，具体有多少也不用管，只需要根据 target 指向的计算去收集订阅其消息的 Watcher 即可，然后做好消息发布 notify 即可。</li><li>Watcher 负责订阅 Dep ，并在订阅的时候让 Dep 进行收集，接收到 Dep 发布的消息时，做好其 update 操作即可。</li></ul><p>Vue的操作就是加入了<strong>发布订阅</strong>模式，结合<code>Object.defineProperty</code>的劫持能力，实现了可用性很高的双向绑定。</p><h3 id="订阅器-Dep"><a href="#订阅器-Dep" class="headerlink" title="订阅器 Dep"></a>订阅器 Dep</h3><p><img src="https://s2.loli.net/2024/06/06/mPr6veQfq2WDKSL.png" alt="image-20240606000301782"></p><p><strong>「为什么引入 Dep」</strong><br> 收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep,它用来<code>收集依赖</code>、<code>删除依赖</code>和<code>向依赖发送</code>消息等。<br> 于是我们先来实现一个<code>订阅者 Dep 类</code>，用于<code>解耦属性</code>的依赖收集和派发更新操作，<strong>「说得具体点」</strong>:它的主要作用是用来<code>存放 Watcher 观察者</code>对象。我们可以把Watcher理解成一个<code>中介</code>的角色，<code>数据发生变化</code>时通知它，然后它再通知<code>其他地方</code>。</p><p><strong>「Dep的简单实现」</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.<span class="title function_">update</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码主要做两件事情：</p><ul><li>用 addSub 方法可以在目前的 <code>Dep</code> 对象中增加一个 <code>Watcher</code> 的订阅操作；</li><li>用 notify 方法通知目前 <code>Dep</code> 对象的 <code>subs</code> 中的所有 <code>Watcher</code> 对象触发更新操作。 所以当需要<code>依赖收集</code>的时候调用 addSub，当需要<code>派发更新</code>的时候调用 notify。</li></ul><p>也就说，所有的Watch最终会存放到Dep的subs中，并且视图更新的流程是，Dep触发了subs中的每个Watch，执行了Watch更新逻辑，Dep的操作是绕不过Watch的，这就验证了上面说的，Watch是一个中介的角色。</p><p>调用也很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">dp.<span class="title function_">addSub</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">//依赖收集的时候</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;emit here&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">dp.<span class="title function_">notify</span>()<span class="comment">//派发更新的时候</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="先实现new-Vue的数据劫持"><a href="#先实现new-Vue的数据劫持" class="headerlink" title="先实现new Vue的数据劫持"></a>先实现new Vue的数据劫持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历data，进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(data, item, data[item])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">data</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//模拟vue源码，挂载data到Vue的_data上</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_data</span> = options.<span class="property">data</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 劫持传入的data项</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">_data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vue)<span class="comment">//data中属性已经被劫持了</span></span><br></pre></td></tr></table></figure><h4 id="劫持以后-vue-mount-关联Watch"><a href="#劫持以后-vue-mount-关联Watch" class="headerlink" title="劫持以后,vue.mount()关联Watch"></a>劫持以后,vue.mount()关联Watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">//遍历data，进行数据拦截</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(data, item, data[item])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置当前描述属性可被修改</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="comment">//----------4</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm <span class="comment">//----------5</span></span><br><span class="line">    <span class="title function_">fn</span>() <span class="comment">//----------6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">data</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_data</span> = options.<span class="property">data</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">_data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//--------------2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">render</span>) <span class="comment">//--------------3</span></span><br><span class="line">  &#125;</span><br><span class="line">  render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略一系列的渲染逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_data</span>.<span class="property">text</span> <span class="comment">//---------7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">vue.<span class="title function_">mount</span>() <span class="comment">//------------ 1</span></span><br></pre></td></tr></table></figure><p>Vue mount函数的功能是去<code>读取data中的属性</code>，<code>渲染</code>到页面上。</p><p>这里的关键一步是<code>读数据</code>。</p><p>那么，读数据最终是要进入数据劫持get方法的。这时我们可以创建一个Watch（观察者）作为中介，让它去进入get。</p><p>而mount起到的作用是渲染，自然，在构造Watch的时候需要传入渲染函数。</p><p>回到前面我们说的，Watch充当的是中介角色，那么，它是谁和谁之前的中介？实际上它是Observer和我们后面要讲的Dep的中介。</p><p>既然是中介，那么它就需要拿到双方的数据。又因为Observer需要观察data，所以这里我们需要将整个Vue构造函数挂载到Watch自身。</p><p><strong>整理下流程：</strong></p><p>执行<code>vue.mount()</code>渲染页面，需要在Vue定义渲染函数render，然后在mount通过中介Watch去执行定义在Vue的render函数。</p><p>创建中介Watch，执行传入的渲染函数，渲染肯定是需要根据页面绑定了哪些data属性去读取data的，这个时候就会触发get方法,</p><p>进入get拿到对应的值。</p><h4 id="添加dep后大概结构"><a href="#添加dep后大概结构" class="headerlink" title="添加dep后大概结构"></a>添加dep后大概结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//defineReactive是对Observer的抽离</span></span><br><span class="line">  <span class="keyword">const</span> defineReactive = <span class="keyword">function</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 以下代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Vue</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Vue&quot;</span>,<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">//打印1  Vue &#123;</span></span><br><span class="line">                  <span class="attr">_data</span>:&#123;</span><br><span class="line">                      <span class="attr">text</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">                      get <span class="attr">text</span>: ƒ <span class="title function_">get</span>()</span><br><span class="line">                      set <span class="attr">text</span>: ƒ <span class="title function_">set</span>(newVal)</span><br><span class="line">                    &#125;,</span><br><span class="line">                  <span class="attr">mount</span>: ƒ (),</span><br><span class="line">                  <span class="attr">render</span>: ƒ ()</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// 以下代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Watcher</span> = <span class="keyword">function</span>(<span class="params">vm, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Watcher&quot;</span>,<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">//打印3 Watcher  this是下面的Dep中subs的对象</span></span><br><span class="line">    <span class="comment">// 以下代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Dep&quot;</span>,<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">//打印2  Dep   &#123; </span></span><br><span class="line">                    <span class="attr">target</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">subs</span>: [</span><br><span class="line">                      &#123;        <span class="comment">//是一个Watcher实例</span></span><br><span class="line">                        <span class="attr">subs</span>: <span class="title class_">Array</span>(<span class="number">1</span>)</span><br><span class="line">                        <span class="number">0</span>: <span class="title class_">Watcher</span></span><br><span class="line">                        <span class="attr">vm</span>: &#123;    <span class="comment">//是一个Vue实例</span></span><br><span class="line">                            <span class="attr">_data</span>:&#123;</span><br><span class="line">                              <span class="attr">text</span>: <span class="string">&quot;123&quot;</span>,<span class="comment">//该属性有了get和set方法</span></span><br><span class="line">                              get <span class="attr">text</span>: ƒ <span class="title function_">get</span>(),</span><br><span class="line">                              set <span class="attr">text</span>: ƒ <span class="title function_">set</span>(newVal)</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="attr">mount</span>: ƒ (),</span><br><span class="line">                            <span class="attr">render</span>: ƒ ()</span><br><span class="line">                          &#125;,</span><br><span class="line"></span><br><span class="line">                        <span class="attr">addDep</span>: ƒ (dep),</span><br><span class="line">                        <span class="attr">update</span>: ƒ (),</span><br><span class="line">                        <span class="attr">value</span>: <span class="literal">undefined</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">depend</span>: ƒ (),</span><br><span class="line">                    <span class="attr">addSub</span>: ƒ (watcher),</span><br><span class="line">                    <span class="attr">notify</span>: ƒ ()</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  vue.<span class="title function_">mount</span>(); </span><br><span class="line">  vue.<span class="property">_data</span>.<span class="property">text</span> = <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h4><p>参考这个图，会了看的更清晰，注意看执行顺序，在new Vue的时候，就会按顺序，初始化各个构造函数</p><p><img src="https://s2.loli.net/2024/06/06/WITrDNomRdKs1qH.png" alt="image-20240606000442133"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 作用：</span></span><br><span class="line"><span class="comment"> * 劫持data的各个属性，挂载set和get方法</span></span><br><span class="line"><span class="comment"> * 在get中将Watch添加到dep的subs中</span></span><br><span class="line"><span class="comment"> * 在set中触发dep.notify更新视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Observer</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)   <span class="comment">//开始4 new Vue的时候就会执行</span></span><br><span class="line">    <span class="comment">// 循环修改为每个属性添加get set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(data, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defineReactive = <span class="keyword">function</span> (<span class="params">obj, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)    <span class="comment">//开始5 new Vue的时候就会执行</span></span><br><span class="line">    <span class="comment">// 局部变量dep，用于get set内部调用</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">    <span class="comment">// 获取当前值</span></span><br><span class="line">    <span class="keyword">let</span> val = obj[key];</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="comment">// 设置当前描述属性为可被循环</span></span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置当前描述属性可被修改</span></span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)<span class="comment">//开始10  开始19</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;in get&#x27;</span>);</span><br><span class="line">            <span class="comment">// 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系</span></span><br><span class="line">            dep.<span class="title function_">depend</span>();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)<span class="comment">//开始15</span></span><br><span class="line">            <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="comment">// 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，</span></span><br><span class="line">            <span class="comment">// 这里每个需要更新通过什么断定？dep.subs</span></span><br><span class="line">            dep.<span class="title function_">notify</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vue</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)<span class="comment">//开始1 new Vue的时候就会执行</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 将data赋值给this._data，源码这部分用的Proxy，这里我们用最简单的方式临时实现</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">data</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>)<span class="comment">//开始2  options.data是个函数，它返回了一个对象</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_data</span> = options.<span class="property">data</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载Dom函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mount</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">8</span>)  <span class="comment">//开始7  new Vue以后，执行vue.mount()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(self, self.<span class="property">render</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>) <span class="comment">//开始9 开始18  render函数执行后走到这里</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">_data</span>.<span class="property">text</span>;  <span class="comment">//这里取data值的时候，就会走get方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始3， 监听this._data</span></span><br><span class="line">    <span class="comment">//new Vue的时候就会执行,这里执行完，就表示new Vue的过程执行完了</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">_data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Watcher</span> = <span class="keyword">function</span> (<span class="params">vm, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)  <span class="comment">//开始8  执行vue.mount()以后会走到这里</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="comment">// 将当前Dep.target指向自己</span></span><br><span class="line">    <span class="comment">// 每次执行new Watch的时候，都会把当前的Watcher挂载到Dep.target</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 向Dep方法添加当前Wathcer</span></span><br><span class="line">    <span class="comment">// this.addDep = function (dep) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(11) //开始13  </span></span><br><span class="line">    <span class="comment">//     dep.addSub(self);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 更新方法，用于触发vm._render</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">update</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span>)<span class="comment">//开始17</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;in watcher update&#x27;</span>);</span><br><span class="line">        <span class="title function_">fn</span>(); <span class="comment">//Vue中的render函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里会首次调用vm._render，从而触发text的get</span></span><br><span class="line">    <span class="comment">// 从而将当前的Wathcer与Dep关联起来</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="title function_">fn</span>();   <span class="comment">//开始9  fn是Vue中的render函数，这里fn()在赋值的时候会执行</span></span><br><span class="line">    <span class="comment">// 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，</span></span><br><span class="line">    <span class="comment">// 造成代码死循环</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Watcher&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//开始6  new Vue》Observer》defineReactive》new Dep()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">13</span>)</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 收集目标，先把它置空</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存储收集器中需要通知的Watcher</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">    <span class="comment">// 当有目标时，绑定Dep与Wathcer的关系</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depend</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">14</span>)  <span class="comment">//开始11   开始20 走了get获取属性后，就要进行依赖收集 </span></span><br><span class="line">        <span class="comment">// targrt挂载发生在new Watch的时候</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">15</span>)<span class="comment">//开始12  </span></span><br><span class="line">            self.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为当前收集器添加Watcher</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">addSub</span> = <span class="keyword">function</span> (<span class="params">watcher</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">16</span>)<span class="comment">//开始14</span></span><br><span class="line">        self.<span class="property">subs</span>.<span class="title function_">push</span>(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知收集器中所的所有Wathcer，调用其update方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notify</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">17</span>) <span class="comment">//开始16</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; self.<span class="property">subs</span>.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            self.<span class="property">subs</span>[i].<span class="title function_">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vue.<span class="title function_">mount</span>(); <span class="comment">// 挂载dom，渲染页面</span></span><br><span class="line">vue.<span class="property">_data</span>.<span class="property">text</span> = <span class="string">&#x27;123&#x27;</span>; <span class="comment">// 修改属性值，触发set</span></span><br></pre></td></tr></table></figure><p><strong>「解析：」</strong></p><ul><li>一开始new Vue ，会走到46行执行Vue构造函数，打印6，然后判断传入的是否是个函数，从new Vue可以看出，传入的是个data()函数，然后将函数执行后返回的整个data对象挂载到vue的<code>_data</code>属性上（真实的vue也是这么操作的）</li><li>接着依次挂载<code>mount</code>和<code>render</code>函数。</li><li>然后 new Observer(this._data);</li><li>new Observer 的时候会走到第一行<code>Observer(关键函数)</code>，打印1。我们发现Observer实际就是给data数据都添加<code>上get和set</code>方法，只不过不添加的方法defineReactive给抽离出去了。</li><li>然后走到第9行，执行defineReactive，打印2。 defineReactive的作用：<ul><li>劫持<code>data</code>的各个属性，挂载<code>set</code>和<code>get</code>方法</li><li>在<code>get</code>中将<code>Watch</code>添加到<code>dep</code>的<code>subs</code>中</li><li>在<code>set</code>中触发<code>dep.notify</code>更新视图</li></ul></li><li>然后走到12行，new Dep的时候，会走到95行执行Dep，打印13。每次new Dep 的时候，都会<strong>置空target，this.target &#x3D; null</strong>，Dep函数剩下的代码都只是定义函数depend和addSub，notify，都不会执行，会跳出Dep函数。然后会到defineReactive函数第13行。</li><li>然后15行给每个<code>属性</code>加上<code>get和set</code>方法。注意：此时只是在挂载，还没有执行，因此不会进入get，set方法内部。也就是说defineReactive剩下的代码中的函数也不会执行，所以会回到Observer，再回到67行new Observer，即<strong>new Vue的过程走完了</strong>。</li></ul><h3 id="new-Vue执行完毕"><a href="#new-Vue执行完毕" class="headerlink" title="new Vue执行完毕"></a>new Vue执行完毕</h3><h4 id="开始执行vue-mount"><a href="#开始执行vue-mount" class="headerlink" title="开始执行vue.mount()"></a><strong>开始执行vue.mount()</strong></h4><ul><li>然后走到135行的vue.mount()，走到56行，打印8。执行new Watcher，进入Watcher构造函数打印10，然后<code>this.vm = vm; </code>，将vue实例挂载到Watch的vm属性上了。<strong>Dep.target &#x3D; this</strong>，将watch实例挂载到了Dep的target属性上，从而关联起来。然后挂载addDep和update方法，只是定义，没有执行。</li><li>接着89行this.value &#x3D; fn()：fn实际是传进来的<code>render</code>函数（Vue&#x3D;&gt;new Watcher(self, self.render)&#x3D;&gt;vm, fn），由于后面有()，所以会立即执行。然后走到60行的render函数，打印9，返回 <code>self._data.text</code>,然后回到Watch中<code>this.value</code>就是返回值data.text。然后，关键的来了：<code>self._data.text</code>这里读取了data中的text,那么，这一步就会触发<code>get</code>方法。</li><li>然后走到21行的get，打印3。</li><li>然后走到25行，执行dep.depend()，再走到104行，打印14。</li><li>这时候判断<code>Dep.target</code>，由于第8步将<code>watch</code>挂载到了<strong>Dep.target</strong>，这时候为true，所以打印15。然后执行<code>Dep.target.addDep(self)</code>，其实就是执行<code>Watch.addDep(self)</code>，然后执行<code>self.addSub(Dep.target)</code>。</li><li>然后进入<code>this.addSub</code>打印16，完成了依赖收集，<strong>subs中就有了Watch了</strong>。然后会回到get，执行最后一行，退出get，接着回到this.render，退出render函数，接着回到Watch中的<code>this.value = fn()</code>，继续往后走，<strong>Dep.target &#x3D; null</strong>，避免陷入死循环，然后Watch执行完了。</li></ul><h4 id="vue-mount-也执行完毕"><a href="#vue-mount-也执行完毕" class="headerlink" title="vue.mount()也执行完毕"></a>vue.mount()也执行完毕</h4><p><strong>开始执行修改操作</strong></p><ul><li>136行赋值操作了<code>vue._data.text = &#39;123&#39;</code>，这时候会走到28行的set，打印4，然后<code>设置值为新值</code>。</li><li>继续向下走，到36行，<code>dep.notify()</code>，然后走到119行，打印17。</li><li>会走到122行，<code>遍历Dep</code>中<code>subs</code>数组里面所有的<code>Watch</code>，触发Watch的<code>update</code>方法，走到82行，打印12。</li><li>执行<code>Watcher</code>中的<code>fn()</code>，即<code>Vue</code>中的<code>render</code>函数（new Watcher(self, self.render)时传入的render函数），走到60行，打印9。render函数中其实就可以做一些渲染的操作，例如：获取某个节点，将他的内容变成获取的值，就完成了页面的渲染。</li><li>走到63行，取data.text，会走get，走到21，打印3。</li><li>执行<code>dep.depend()</code>，走到Dep中的<code>this.depend</code>，打印14。但是由于<strong>Dep.target为null</strong>，15不会打印，也就是说到了这里，所有的流程执行完了。</li></ul><h4 id="全部执行完毕"><a href="#全部执行完毕" class="headerlink" title="全部执行完毕"></a>全部执行完毕</h4><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>响应式原理，大龄前端确实应该掌握的必需品，如今我才看确实有点晚。</p><p>不过，学习任何时候都不算晚，只是当初看着晦涩难懂的代码如今看起来居然如鱼得水，也真是奇怪。</p><p>而且，这并非工程化的核心，如果涉及到基础开发才会需要了解，平时我个人是仅作为拓展知识了解的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6850418111985352711">vue响应式详解（重学前端-vue篇1）</a></p><p><a href="https://juejin.cn/post/6932659815424458760#heading-13">0年前端的Vue响应式原理学习总结1：基本原理 - 掘金 (juejin.cn)</a></p><p><a href="https://www.bilibili.com/video/BV1G54y1s7xV/?spm_id_from=333.337.search-card.all.click">【尚硅谷】Vue源码解析之数据响应式原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年第一次过渡工作体验</title>
      <link href="/2024/05/29/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E6%B8%A1%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/"/>
      <url>/2024/05/29/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E6%B8%A1%E5%B7%A5%E4%BD%9C%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>徐州，可以游玩，但是不能久待，不然可能真的就翻不了身了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为生活上的种种问题，最近离职了，偏偏存款又有点不太够。</p><p>由于最近存款不多，但暂时又没有什么合适的工作，于是人就被卡在徐州了。</p><p>这时候想要换个城市，但因为不想欠款，所以此时也不想干一份新的前端工作。</p><p>于是，暂时不打算找其他工作了，先找个过渡工作弄点钱，后续再考虑新发展。</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>之前在徐州找了一份月薪八千左右的工作，双休，很不错，虽然公司技术烂了一点，但是相对来说，待遇不错。</p><p>但，一切都是假象。</p><p>小地方，怎么会有这么好的待遇？在我入职之前，没到半个月就开始各种问题了。</p><p>首先，是加班开始逐渐上强度，不定时的电话就不说了，周末双休开始逐渐被入侵，比起之前的工作尤其不如，工作和生活的边界感实在是模糊。</p><p>其次，工作的业务随着不断深入之后，我逐渐了解到了项目线的很多问题，比如我做的不是核心业务而是边缘业务，还有，这项目历史包袱太重，赶工痕迹太重，想要优化必须要付出很大的精力，但是公司偏偏又强压时间，想要让我短时间解决。</p><p>再次，公司的企业文化太蠢，以前我是不相信企业文化这种说法的，但是经历过几家公司的风格之后，我逐渐相信了这种说法，太恶心了。</p><p>每家公司的办事风格，基本上是他们团队业务经历的形成的独有风格，无法复刻，如同性格一般的刻印，比如这家公司就是典型的兽人开发模式。</p><p>这里随便点一下出问题的点，在我看来是很恶心的点</p><ol><li>粗犷的管理模式，基本上开发完全是一言堂，而且还是外行管理内行，不懂开发的人在任务排期时候，完全不顾及开发人员的说法，直接想当然的安排任务，自然会导致工期混乱</li><li>混搭的管理工具，阿里的云效平台，腾讯的tapd和企业微信，不统一平台的管理工具用起来很不爽，进一步拖慢了开发节奏，当然这个点其实我要求不高，这点大概率是可以忍受的。</li><li>管理人员没有对甲方压需求的仪式，只是个无作用的传声筒。</li><li>规矩太多，一天签到居然能达到4次，且每天日报要按照百分比的KPI来写，每周还得用纸质模式填写周报。</li><li>没有确认单的需求历史，很多任务需求只能找人去确认，偏偏上一任开发者已经光速开溜，很多地方只能自己按照自己的臆测去改，如果一定要碰到业务麻烦的地方，还得亲自和客户去确认，再次拖慢了开发进度。</li><li>对开发人员的牛马管理模式，我不说别的，开发人员需要每天去打扫卫生，这真是我头一回遇到，这还不算完，更重要的是，我打听了老开发人员的工资待遇，原本跟了4年的开发人员，是一路打拼上来的核心开发人员，说放弃就放弃了，这种留不住人的模式本来就说明了很多问题。</li><li>学历歧视，还是那个4年的开发人员，作为核心的开发者，提了涨薪的需求不被同意，他曾经是跟着老板度过初创期的核心时间，渡过了很多大强度加班的过往。在徐州，如此强度的工作和资历居然换不来一万的薪资，深入问了一下，才发现是被嫌弃学历了，明明是初创公司的核心，就算是为了维持人心，都不该放弃草创人员，这样的老板简直不值得跟随，太让人寒心。</li><li>五险没有一金，这不止这一家公司是这样，徐州大多数开发都是五险没有一金，这样的工资，偏偏连这种基础的五险一金都不能保证，简直可笑，纯纯的牛马待遇了。</li><li>没有晋升通道，前端在团队中居然根本不接近业务，因为对业务的不理解，所以做事很掣肘，很无趣。</li><li>技术栈混乱且老套，用着VUE2和3的架子，写着JQUERY的代码，好长时间才换回去，还有代码权限管理，不用ruoyi自带的模式，非得要用自己定的全局信息来管理，对了，全局信息没管理，每次用户信息调用居然直接用接口获取信息，这种混乱的代码让我见证了一个新手如何在混乱的工期管理下催生出来的。</li><li>团队执行力底下，因为团队人员的整体水平参差，且前一段时间加班的疲累，导致团队的向心力很低，这样的团队，在未来肉眼可见的战斗力底下，没意思。</li></ol><p>总的来说，哪里都是缺点，这个工作强度和潜力，想要我将自己卖到这个价格，我不太想留。</p><p>最可笑的是，面试我的时候，明明是面试了一堆乱七八糟的技术，但是到实际工作中。。。。。哎，有种面试造火箭，工作拧螺丝的可笑感。</p><p>总之，我对如今离职的并不后悔，即便这样对现在的后果很严重，我也不后悔。</p><h3 id="过渡工作"><a href="#过渡工作" class="headerlink" title="过渡工作"></a>过渡工作</h3><p>因为以前在大学送过外卖，那时候一个月很轻松的弄到手6000，还是作为兼职弄到手的，所以对外卖这行业我相对还是喜欢的。</p><p>事实证明，经验这事儿不能有路径依赖，过去的经验有时候并不适合未来。</p><p>送外卖，在现在是一条相当糟糕的路。</p><p>这里，我具体盘一盘糟糕的点。</p><ol><li>时间并不自由，我一开始之所以选择外卖，是为了自由支配时间，能获取更多的空闲时间去学东西，给自己充电，但现在送外卖要全天在系统指定地点挂机，而且派单都是一单单派单的模式，导致送单极为不挣钱且浪费时间的空转，所以，时间上并没有空闲。</li><li>新人工资太低，新人因为数据不好看，所以根本拿不到系统派单，进而导致只能用更多时间空转，导致时间更少，休息更少，单量更差，所以最后往往是空转一天14个小时，却最多只能赚不到90块（约莫30单，而且大多数新人不把强度拉满就跑不到30单，新人一单就3块），也就是一个月各种激励算下来，居然划不到一个月2500！在徐州，这个工资可谓是纯纯的牛马了。</li><li>贷款上班，车子和电池都是租用的，加上工服等费用，我还没正式开始上班就欠了近一千，而我自己还是租房的，这样在吃完之后，等于纯纯的付费上班。我甚至在这个月里边舍不得吃一碗炒面。</li><li>风险成本太高，常在河边走，没有不湿鞋，如果我一旦出了什么意外，对于现在的我来说，将会是毁灭性的损失，我必须要保证自己的安全。</li><li>周围人并不是那些开发人员，生活作风和习惯完全和我对不上号，时间久了，我感觉自己会被他们的习惯同化掉，这种开发人员的默认习惯一旦被同化了，是要花很长时间才能养回来的，我不喜欢这种被同化的感觉。</li></ol><p>虽然就我个人而言，我并不讨厌这份工作，车速拉到50码，在机动车道上飞速狂飙的感觉很爽，而且能看到很多有趣的事儿。</p><p>不过，终归是要吃饭的，没钱是没法过日子的。</p><h3 id="徐州"><a href="#徐州" class="headerlink" title="徐州"></a>徐州</h3><p>因为外卖这份工作，现在我对徐州了解颇多，了解的越多，就越是失望。</p><p>徐州是个朋克至极的城市，这个城市，先进与落后并存，穷困与极富并存，上下限差距太过于庞大，以至于让我想起了港片里边的九龙城寨。</p><p>赛博朋克风格的电影总喜欢用香港的九龙城寨做背景，闪烁的霓虹灯，混乱的城市规划及高物质低生活的感觉，一度是香港的标签。</p><p>但是，如今我在徐州送了一段时间的餐之后，我感觉，徐州才是更符合这种矛盾混乱调调的城市。</p><p>整个徐州的规划，在我看来就是没有规划，完全就是城市领导一拍脑袋就在那瞎想的，我这里随便点几个点。</p><ol><li>部分小区上下坡道陡峭就不说了，有些车库他妈的居然还有40度左右极度陡峭的车道。</li><li>火车站附近的核心街道坑坑洼洼，行人道和非行人道混合在一起，导致上下班高峰期，行车路线几乎瘫痪。</li><li>路边的店面窗口很不规范，各家店面乱七八糟，就像是风格不同的贴画强行拼在一起一样。</li><li>穷人区和富人区，老城区和新城区规划都是一样的糟糕，住宅区和商业区距离不对，有的太远，有的太近，车道和行人道都不开阔，而且商业区规划的也不行，混乱至极的商场排布。</li><li>洗脚店真他吗多，是不是洗脚，你猜？有的店面明面上是小吃店，实际上到晚上才开门，有个妹子在那一遍搞直播一遍揽客，真的，我头回见到这么奔放的，旁边的是一家刀削面的店。</li></ol><p>这座混乱无序的城市，在长久的生活中，逐渐衍变出了一套属于自己的秩序。</p><p>新旧混搭之下，能看到很多有趣的事儿，这里我先从好的开始说说吧。</p><p>物价极低，除了全国统一的25块大份黄焖鸡之外，其他的价格都还好，大多数一顿饭只要9-15元左右就能吃饱，而且还吃的相当不错。</p><p>房租相对较低，租个简单的房子大约不超过1000，但是要想租到不错的房子，价格也得1500左右，相对徐州这个地方，1500的精装房子有点太贵了。</p><p>这座城市整体节奏偏慢，很多地方能看到一些老派的娱乐方式，比如书法，象棋，打牌，唱戏，机车，也有很多前卫的娱乐方式，比如骑行，钓鱼，乐队。</p><p>在徐州有不少高等院校，虽然有些事职高，但是校区周边依然会有漂亮的妹子。</p><p>每当送餐经过那里，看到那些校门口的年轻人，一时间恍惚回到了过去，他们身上那种青春的气息真是让我这个老年人羡慕不已。</p><p>那些大学生，真的是青春，男孩儿朝气蓬勃，女孩儿时尚前卫，她们并不输于上海那些潮流妹妹，我之前还看到一个让我惊艳的汉服COSER，当时真想上去合影，但是害怕自己吓到人，所以没敢上去合影，现在想来真是后悔。</p><p>当然，这街边不仅仅是光鲜亮丽，说了好的也要说坏的。</p><p>新旧参差的城市建筑和规划，破落的民房和老旧的居民房，风景柔美的人工河道周围会飘过一种尿骚味道，因为路上厕所少，所以路边经常能闻到一种尿骚味儿上。。。。哎，总比数年前在河道边山的行人道上能看到屎好得多，现在相对来说干净了很多。</p><p>在街边有很多小摊贩，也有穿着破落的大妈和衣着寒酸的环卫工人，路上也有着不少水电瓦匠苦力，这种海量的廉价劳动力汇聚的感觉。。。哎，一言难尽。</p><p>还有，不少外表光鲜的新派商务大楼，但是内部高层里边甚至没有独属于自己的厕所，每个公司甚至要不得已在自己的办公室内设立单间来建立自己的厕所，说实话，这种事儿在我看来简直是可笑至极，这种大楼的设计者应该抓起来坐牢。</p><p>哎，个人总结，徐州是一个可以游乐，但是不能久居的朋克城市。</p><p>可以来玩，但是如果想要在这里久居，我觉得不行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时就先说这么多，这次送外卖的经历更是让我对徐州感到一种失望。</p><p>依然转回开发，这个时间，靠着苦力几乎无法再更近一步了，不同阶段的工资，差距没那么大，却仿佛是天堑。</p><p>这种差距，并非是对人，而是结构化的，整体性的，在徐州这个朋克的城市里，更是被无限的放大。</p><p>穷人几乎没有任何翻身的机会，毫无希望的未来，他们仿佛被剥夺思考的工具，只能用来负载顶层人类的思考。</p><p>我似乎逐渐明白了一切，这便是阶级。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析v-if与v-show的区别</title>
      <link href="/2024/05/26/%E6%B5%85%E6%9E%90v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/05/26/%E6%B5%85%E6%9E%90v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>典中典的面试题，属于我刚入门的时候在问，到现在几年了，还在问。</p><p>这么多年了，面试官真是一点进步都没有。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>无论是vue3还是vue2，关于这些个简单的vue指令变动都是不大的，这里就直接以v3的源码为例子，看看这块到底怎么个事儿。</p><h3 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h3><p>vue的大致渲染流程如下，这里不详细展开说，改天开单章细说。</p><ul><li>将模板<code>template</code>转为<code>ast</code>结构的<code>JS</code>对象</li><li>用<code>ast</code>得到的<code>JS</code>对象拼装<code>render</code>和<code>staticRenderFns</code>函数</li><li><code>render</code>和<code>staticRenderFns</code>函数被调用后生成虚拟<code>VNODE</code>节点，该节点包含创建<code>DOM</code>节点所需信息</li><li><code>vm.patch</code>函数通过虚拟<code>DOM</code>算法利用<code>VNODE</code>节点创建真实<code>DOM</code>节点</li></ul><h4 id="v-show原理"><a href="#v-show原理" class="headerlink" title="v-show原理"></a>v-show原理</h4><p>不管初始条件是什么，元素总是会被渲染。</p><p>这里我们看一下在<code>vue</code>源码是如何实现的。</p><p>代码很好理解，有<code>transition</code>就执行<code>transition</code>，没有就直接设置<code>display</code>属性</p><p>这里我们也看到了，v-show只是执行了挂载和更新的相关周期，所以并非是全生命周期的方法。。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">vShow</span>: <span class="title class_">ObjectDirective</span>&lt;<span class="title class_">VShowElement</span>&gt; = &#123;</span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params">el, &#123; value &#125;, &#123; transition &#125;</span>) &#123;</span><br><span class="line">    el.<span class="property">_vod</span> = el.<span class="property">style</span>.<span class="property">display</span> === <span class="string">&#x27;none&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : el.<span class="property">style</span>.<span class="property">display</span></span><br><span class="line">    <span class="keyword">if</span> (transition &amp;&amp; value) &#123;</span><br><span class="line">      transition.<span class="title function_">beforeEnter</span>(el)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">setDisplay</span>(el, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, &#123; value &#125;, &#123; transition &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transition &amp;&amp; value) &#123;</span><br><span class="line">      transition.<span class="title function_">enter</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, &#123; value, oldValue &#125;, &#123; transition &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeUnmount</span>(<span class="params">el, &#123; value &#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">setDisplay</span>(el, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v-if原理"><a href="#v-if原理" class="headerlink" title="v-if原理"></a>v-if原理</h4><p><code>v-if</code>在实现上比<code>v-show</code>要复杂的多，因为还有<code>else</code> <code>else-if</code> 等条件需要处理，这里我们也只摘抄源码中处理 <code>v-if</code> 的一小部分</p><p>返回一个<code>node</code>节点，<code>render</code>函数通过表达式的值来决定是否生成<code>DOM</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> transformIf = <span class="title function_">createStructuralDirectiveTransform</span>(</span><br><span class="line">  <span class="regexp">/^(if|else|else-if)$/</span>,</span><br><span class="line">  <span class="function">(<span class="params">node, dir, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">processIf</span>(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRoot) &#123;</span><br><span class="line">          ifNode.<span class="property">codegenNode</span> = <span class="title function_">createCodegenNodeForBranch</span>(</span><br><span class="line">            branch,</span><br><span class="line">            key,</span><br><span class="line">            context</span><br><span class="line">          ) <span class="keyword">as</span> <span class="title class_">IfConditionalExpression</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// attach this branch&#x27;s codegen node to the v-if root.</span></span><br><span class="line">          <span class="keyword">const</span> parentCondition = <span class="title function_">getParentCondition</span>(ifNode.<span class="property">codegenNode</span>!)</span><br><span class="line">          parentCondition.<span class="property">alternate</span> = <span class="title function_">createCodegenNodeForBranch</span>(</span><br><span class="line">            branch,</span><br><span class="line">            key + ifNode.<span class="property">branches</span>.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">            context</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>以下算是教科书的回答，个人觉得很经典，可以考虑再搭配一点场景来辅助记忆。</p><p>虽然 <code>v-if</code> 和 <code>v-show</code> 都可以用于根据条件展示元素，但它们背后的实现机制和适用场景有所不同。</p><p>当然，面试时候最好不要回答源码相关，除非你对源码有极深的理解，不然面试官会以为你对源码研究颇深，甚至以为你对源码有贡献。</p><p>一旦问题脱缰，装到了面试官擅长的领域，到时候容易控不住场，所以，要适度装逼。</p><ul><li><strong>渲染机制</strong>：<code>v-if</code> 是条件性地渲染元素，即如果条件不满足，元素甚至不会被添加到 DOM 中；而 <code>v-show</code> 元素无论条件如何始终会被渲染到 DOM 中，只是通过切换 <code>display</code> 属性来控制显示。</li><li><strong>性能考虑</strong>：因为 <code>v-if</code> 控制的元素不会被频繁切换或者在初始化时条件就不成立，使用 <code>v-if</code> 更为合适，避免了不必要的渲染成本。而 <code>v-show</code> 适用于需要频繁切换显示状态的场景，因为元素始终保持在 DOM 中，切换开销更小。</li><li><strong>编译过程</strong>：<code>v-if</code> 是真正的条件渲染，因为它确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。而 <code>v-show</code> 只是简单地切换元素的 <code>display</code> CSS 属性。</li><li><strong>使用场景</strong>：当你的条件很少改变时，推荐使用 <code>v-if</code>；如果需要非常频繁地切换，使用 <code>v-show</code> 会更好，但是实际开发过程中，大多数业务场景不缺这点性能，这种场景我们很难见到。</li></ul><h3 id="个人拓展"><a href="#个人拓展" class="headerlink" title="个人拓展"></a>个人拓展</h3><p>但是，实际开发过程中，大多数使用v-if来做处理问题。</p><ul><li>v-if因为将元素完成了移除，这样能够较为完全的注销子组件，这样，子组件内的生命周期是从created触发的，如果子组件中有什么方法一定要写在created中，那么这里就非常推荐使用v-if了。</li><li>v-show无法配合v-else做条件渲染，如果有多个条件渲染，v-if显然比v-show的适用面更广一些。</li><li>template支持v-if，但却不支持v-show，有些时候，可以使用template配合v-if来写组件切换的效果，有些组件库中也有很多template打头的插槽，这里推荐使用v-if来写，而不是v-show。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>v-show与v-if的区别，新手都知道的问题，但是将这种简单的问题回答的出彩，也很重要。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7105405430809296904?searchId=20240526224926348D259BDB85C84F4237">v-show和v-if的区别 以及应用场景 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————图床搭建</title>
      <link href="/2024/05/26/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/05/26/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>博客风格一直偏向于简约干净的，本来不打算用图片的，但是很多文档用图解似乎更清晰。</p><p>于是，就找了一篇简单易上手的图床攻略，目前上手试了一下挺好，这里转载一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为我写markdown文档一直用的是<a href="https://www.typoraio.cn/">typora</a>，因为用的效果不错，所以直接买了正版。</p><p>所以，图床的使用也更倾向于和typora官方推荐的PicGo，中间当然也考虑过其他的图床，但是想了一阵子，懒得折腾，干脆用最快最便捷的。</p><p>毕竟，hexo个人博客只是梳理个人知识体系的本地存档，不值得在这上边浪费太多精力。</p><p>我这篇文档只能算是要点总结，推荐看这篇：<a href="https://juejin.cn/post/6844904144575168519?searchId=202405260023309155B7AD4F4B36CFE0BF#heading-0">史上最强markdown编辑器typora图床功能教程</a>，写的很详细。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ol><li>typora版本达到0.9.86以上，该版本之后支持图床</li><li><a href="https://sm.ms/">sm.ms</a>注册一个账号，记住自己的账号密码</li><li>注册完成后，进入<a href="https://sm.ms/home/apitoken">token生成页面</a>，生成一个token</li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>点开<code>文件&gt;偏好设置&gt;图像</code>，点击打开配置文件，将这部分代码复制进去。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smms&quot;</span><span class="punctuation">,</span> <span class="comment">// 代表当前的默认上传图床为 SM.MS,</span></span><br><span class="line">    <span class="attr">&quot;smms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里面的token换成你上个页面的申请的token&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="comment">// 为插件预留</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置完成后，还是<code>文件&gt;偏好设置&gt;图像</code>，这里选择<code>插入图片时,上传图片</code>，这样我们在复制图片过来的时候，图片会自动上传的。</p><p>这时候验证图片上传选项，当然，也有可能不成功，实际上这个步骤已经成型了。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>这个图库毕竟不是自己的，如果图片隐私，那么不推荐放在这个图床上</li><li>最好后续还是要做好图库备份，毕竟第三方的图床总是会时不时的抽风，个别的甚至会直接消失</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>搭建图床是很早之前的想法，只是早期的文档大多数都不需要图解，后来就放弃了这种花哨的想法。</p><p>如今文档需要图解，那么，干脆就搞一个快速版本的图床搭建，能够快速实现效果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904144575168519?searchId=202405260023309155B7AD4F4B36CFE0BF#heading-0">史上最强markdown编辑器typora图床功能教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解跨域</title>
      <link href="/2024/05/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/"/>
      <url>/2024/05/23/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>面试官：请问您能说一下跨域的解决办法吗？</p><p>我：这种事儿为什么要前端来做？难道不是后端设置一下就行了吗？</p><p>面试官：和您聊得很开心，请您回去等通知吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在很早以前还是JSONP的解决方案里，跨域问题算是很经典的面试题。</p><p>但那是前端环境还处于蛮荒时代的解决手法，如今再问跨域，多少有点过期的感觉了。</p><p>不过，作为开发人员，跨域这个问题是必须要了解的。</p><p>在正式讲解跨域之前，先简单了解几个概念。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>协议（Protocol）</td><td><code>URL</code>的开头部分通常包含<code>协议</code>名称，例如“http:&#x2F;&#x2F;”、“https:&#x2F;&#x2F;”等，也有ftp等协议，这里不展开细说</td></tr><tr><td>主机名（Host Name）</td><td>指定了资源所在的主机（服务器）的<code>域名</code>或<code>IP地址</code></td></tr><tr><td>端口号（Port Number）</td><td>可选部分，用于指定<code>服务器</code>上接收请求的<code>端口号</code>。如果未指定，默认使用协议的<code>默认端口</code>（如80或443）</td></tr><tr><td>路径（Path）</td><td>指定了<code>服务器</code>上资源的<code>位置</code>，表示<code>资源</code>在服务器文件系统中的<code>路径</code>。</td></tr><tr><td>查询参数（Query Parameters）</td><td>可选部分，用于向<code>服务器</code>传递额外的<code>参数</code>，通常以<code>键值对</code>的形式出现，例如“?key1&#x3D;value1&amp;key2&#x3D;value2”</td></tr><tr><td>锚点（Fragment）</td><td>可选部分，用于指定资源内的<code>特定位置</code>（如页面内的锚点）</td></tr></tbody></table><p>以<code>http://192.168.0.1:8080/index.html</code> 为例子，我们可以得出如下结论。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http是协议，192.168.0.1是主机名，8080端口号，index.html是路径</span><br></pre></td></tr></table></figure><p>如果<code>http://www.test.com/index.html</code>这样的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http是协议，www.test.com是主机名，index.html是路径</span><br></pre></td></tr></table></figure><p>这里我们会发现，这里只有主机名而没有端口的构成。</p><p>这是因为，这种域名的形式的端口往往默认以80或者443的形式绑定在域名上，所以我们平时在正式的网址上，很少看到有域名加端口的形式。</p><p>关于URL我们这里就简单说一些，这里就不详细展开说。</p><p>如果想要深入了解URL的构成，可以参考<a href="https://www.runoob.com/html/html-url.html">菜鸟教程的HTML 统一资源定位器(Uniform Resource Locators)篇</a></p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>正式了解之前，我们先记住一点：<strong>同源策略是浏览器的策略，而非服务端的策略</strong>。</p><p>在记住这点之后，我们再正式了解同源策略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同源策略，它是由Netscape提出的一个著名的安全策略。</span><br><span class="line">现在所有支持JavaScript 的浏览器都会使用这个策略。</span><br><span class="line">所谓同源是指，域名，协议，端口相同。</span><br><span class="line">当一个浏览器的两个tab页中分别打开百度和谷歌的页面，当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的</span><br><span class="line">即检查是否同源，只有和百度同源的脚本才会被执行。</span><br></pre></td></tr></table></figure><p>总结，同源策略，是浏览器为了解决两个页面数据安全问题而提出的一种手段。</p><p>我们已经了解了URL的构成，所以这里我们很明显的就能看明白，资源文件同源到底是哪些地方要对应的。</p><p>同源策略，说到底，是<strong>浏览器</strong>为了隔离不同页面的获取资源的一种手段。</p><p>如果两个页面的<code>协议</code>，<code>域名</code>和<code>端口</code>都相同，则两个页面具有<strong>相同的源</strong>。</p><p>这里，我们以<code>http://www.test.com/index.html</code> 为例子，看一下。</p><table><thead><tr><th>URL</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/other.html">http://www.test.com/other.html</a></td><td>是</td><td>同源(协议、域名、端口相同)</td></tr><tr><td><a href="https://www.test.com/about.html">https://www.test.com/about.html</a></td><td>否</td><td>协议不同(http 与 https)</td></tr><tr><td><a href="http://blog.test.com/movie.html">http://blog.test.com/movie.html</a></td><td>否</td><td>域名不同(<a href="http://www.test.com与/">www.test.com与</a> blog.test.com)</td></tr><tr><td><a href="http://www.test.com:7001/home.html">http://www.test.com:7001/home.html</a></td><td>否</td><td>端口不同(默认的 80 端口与 7001 端口)</td></tr><tr><td><a href="http://www.test.com/main.html">http://www.test.com:80/main.html</a></td><td>否</td><td>同源(协议、域名、端口相同)</td></tr></tbody></table><p>由以上例子，我们应该大致明白了同源策略是怎么一回事儿了。</p><p>而不同源的请求去访问，就一种跨域，如下图所示。</p><p><img src="https://s2.loli.net/2024/05/26/3k9ZueSpNFKvz1U.png" alt="image-20240526165147032"></p><p>总结的来说，由于浏览器安全限制，数据是不可以直接请求不同源的资源，包括不同的根域名、二级域名、或不同的端口，除非目标域名授权你可以访问。</p><p>那么，想要解决同源策略下的不同源文件访问，就需要<strong>跨域</strong>。</p><p>我这里只是介绍我工作中经历过的三种方式，详细教程参考阮一峰老师的文章：<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a>。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>由上述的过程，我们已经讲明白了什么是同源策略，及同源策略造成的影响，这里就主要说一下我工作中的常用的四种跨域解决方式。</p><ol><li>JSONP跨域</li><li>nginx配置</li><li>webpack Server配置</li><li>后端接口请求头设置</li></ol><h4 id="JSONP是什么"><a href="#JSONP是什么" class="headerlink" title="JSONP是什么"></a>JSONP是什么</h4><p>JSONP本质是一种讨巧的解决方式。</p><p>早些年的时候，前端开发人员发现Web页面上调用js文件时则不受是否跨域的影响，不仅如此，有人还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如script,img,iframe等标签。</p><p>而有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，并被原生js支持。</p><p>所以实现跨域的方案就出现了。我们可以调用跨域服务器上动态生成的js格式文件,也就是调用JSON文件，获取自己需要的数据。</p><p>后来逐渐形成了一种非正式的传输协议，也就是JSONP。</p><p>该协议允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，客户端接收到响应后执行回调并且可以对数据进行各种需要的处理。</p><p>说到这里，我们来总结一下<strong>什么是JSONP</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过动态创建script标签，其scr指向非同源的url，并传递一个callback参数给服务端，服务器返回一个以callback参数作为函数名的函数的调用和一系列参数，页面接收到响应后执行回调并对数据进行处理。</span><br></pre></td></tr></table></figure><p>这里说起来不够明显， 我们直接看一下示例。</p><h5 id="实现JSONP"><a href="#实现JSONP" class="headerlink" title="实现JSONP"></a>实现JSONP</h5><p>首先，我们要有一个请求方和响应方。</p><p>请求方是一个网页的前端，也就是浏览器，响应方是另一个网页的后台，也就是服务器，两个网页是不同源的。</p><p>这里我们假设浏览器页面显示着一个数字100和一个<code>打钱</code>的按钮，服务器储存着页面显示的那个数字，要求在每按下<code>打钱</code>按钮的时候，浏览器显示的数字减一，并且服务端储存这个减后的数字，在下一次打开的时候显示减后的数字。这是一个跨域向非同源网站的服务器发送请求和接收响应的过程。<br> 请求方：<code>http://fang.com:8001</code><br> 响应方：<code>http://zeng.com:8002</code></p><p>先写好html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>您的账户余额为：100<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着就是写前端部分代码main.js，实现点击之后发送请求改变数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="line">    let script = document.createElement(&#x27;script&#x27;)// 创建script标签</span><br><span class="line">    let functionName = &#x27;fang&#x27; + parseInt(Math.random()*10000000,10)// 设置调用函数名</span><br><span class="line">    window[functionName] = function(result)&#123;</span><br><span class="line">      if(result === &#x27;success&#x27;)&#123;</span><br><span class="line">        amount.innerText = amount.innerText - 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `http://zeng.com:8002/pay?callback$&#123;functionName&#125; `</span><br><span class="line">    document.body.appendChild(script)// 将能实现发送跨域请求的script标签插入html</span><br><span class="line">    script.onload = function(e)&#123;</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName]</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = function()&#123;</span><br><span class="line">      alert(&#x27;fail&#x27;)</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName]</span><br><span class="line">    &#125;</span><br><span class="line">    // 完成传输后删除script标签</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>搭建好服务器，就可以实现功能了。这个就是一个利用JSONP发送跨域和响应的过程。</p><p>如果觉得不够详细，这里可以参考<a href="https://space.bilibili.com/383062034">零寂前端</a>的视频：<a href="https://www.bilibili.com/video/BV1KH4y1v7a9/?spm_id_from=333.1296.header_right.history_list.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">从HTTP与Restfull到Ajax全方位掌握-前端开发-JavaScript</a>，大佬在视频中很完美的演示了JSONP的跨域请求方式。</p><h5 id="JSONP的优点与缺点"><a href="#JSONP的优点与缺点" class="headerlink" title="JSONP的优点与缺点"></a>JSONP的优点与缺点</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>JSONP可以实现跨域传输，不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制</li><li>JSONP兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持</li><li>在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>它只支持GET请求而不支持POST等其它类型的HTTP请求，因为script标签的scr只能进行GET请求</li><li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li><li>JSONP在调用失败的时候不会返回各种HTTP状态码。</li><li>缺乏安全性。假如提供JSONP的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的,那么所有调用这个JSONP的网站都会存在漏洞,这样的话危险就不止在一个域名下。</li><li>JSONP仍然需要改动服务端代码，写好回调函数，工作量较大，本质上是一种从客户端获取服务端回调函数的东西</li></ul><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx代理是指使用Nginx作为反向代理服务器，接收客户端发来的请求，然后将这些请求转发到其他服务器上进行处理，并将处理结果返回给客户端。</p><p>Nginx是一种高性能的Web服务器和反向代理服务器，因其性能优异、配置简单而被广泛应用于互联网领域。</p><p>这在工作中，也是较为常用的方式，往往开发服务器会配置这个来做好本地的接口联调。</p><p><strong>实现</strong></p><p>编辑 Nginx 的配置文件（<code>nginx.conf</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       2222;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api &#123;</span><br><span class="line">        proxy_pass  http://127.0.0.1:3000;</span><br><span class="line">        add_header  Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>localhost:2222/api</code> 路径下的请求转发到<code>http://127.0.0.1:3000</code>来代理，并且添加响应头 <code>Access-Control-Allow-Origin *</code>，设置白名单，允许跨域请求，这里类似 Cors 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data =&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;Hello nginx-proxy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端提供数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(<span class="string">&#x27;http://localhost:2222/api&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>res.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端向 <code>http://localhost:2222/api</code> 发请求，将被 Nginx 反向代理到 <code>http://127.0.0.1:3000</code></p><p>所有工作准备完毕，点击按钮，拿到数据，成功解决跨域。</p><h4 id="Webpack-Server配置"><a href="#Webpack-Server配置" class="headerlink" title="Webpack Server配置"></a>Webpack Server配置</h4><p>这种方式不常见，但是偶尔有团队会在本地联调中用到，所以这里提一嘴。</p><p>大多数Vue项目的脚手架中，应该将webpack的配置集成到了vueConfig.js文件中，所以，大概的配置模式也是类似的。</p><p>譬如，只要按照如下配置，便可将路径为<code>/api</code>的接口代理到<code>http://localhost:3001</code>中，这样我们也能简单的实现一个本地的接口跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  output: &#123;...&#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: 3000,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &quot;/api&quot;: &#123;</span><br><span class="line">        target: &quot;http://localhost:3001&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="呼叫后端修改"><a href="#呼叫后端修改" class="headerlink" title="呼叫后端修改"></a>呼叫后端修改</h4><p>这个是工作中的现在常用解决方式，难度低，工作量小，且没什么后遗症。</p><p>毕竟大多数工作中常用的后端框架都是springboot搭建的，所以往往只需要后端配置一下<code>javax.servlet.Filter</code>即可。</p><p>当然，这里不清楚大家的工作框架，所以只是一家之言，如果有更好的解决方式还请细说，毕竟我不是专业的后端。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作为面试八股文的经典问答，这个问题几乎是很多新手前端的必问题目，但是在实际开发的过程中，往往是后端只要设置一下就行了。</p><p>但是很多面试官还是拿着经典面试答案来套话，说实话，有种刻舟求剑的美。</p><p>总的来说，跨域的经典问题，前端开发工程师可以了解但不必强求，实际开发过程中，前端和跨域处理的距离已经相当之遥远。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904024924225544">JSONP原理详解——弄懂JSONP及其实现方法</a></p><p><a href="https://juejin.cn/post/7106180372047593503#heading-18">JSONP 跨域原理及实现</a></p><p><a href="https://juejin.cn/post/7348275757800882191#heading-7">面试官：你是如何解决跨域的？</a></p><p><a href="https://juejin.cn/post/7253367284873461818?searchId=202405250030111B33BC21282A963FD75F">实现跨域请求：Spring Boot后端的解决方案</a></p><p><a href="https://juejin.cn/post/6999042691698786311?searchId=202405250030111B33BC21282A963FD75F">一篇文章让你搞懂如何通过Nginx来解决跨域问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解浏览器的进程</title>
      <link href="/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面试官：难道您没有了解过浏览器到底有哪些进程吗？</p><p>我：工作中用到的不多，所以没了解。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于进程与线程的事情说完了，但是浏览器到底有什么进程，这里我也比较好奇，所以也了解了一下。</p><p>虽然平时不怎么会用到，但也算是开拓眼界了。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是一个多进程架构设计，<strong>每打开一个标签页就会创建一个进程</strong>。当然浏览器内部也有着自己的优化，比如：当浏览器同时打开多个空白标签页的时候，会合并成一个进程。</p><p>浏览器到关闭到启动，至少开启四个进程：</p><ol><li><code>1个 browser进程</code></li><li><code>1个GPU进程</code></li><li><code>1个网络进程</code></li><li><code>1个渲染进程</code></li></ol><p>当新增其他标签页时，前面三个进程是可以共用的，不用重启。</p><p>默认情况下，每打开一个标签页，就会开启一个渲染进程。但是也会存在特殊的情况，就是如果打开的标签页在同一个站点下，会共享同一个渲染进程。</p><p>最新的浏览器进程主要包含：</p><ul><li>1个浏览器主进程</li><li>1个GPU进程（也可能存在多个，每个标签页都需要一个进程，用于绘制图形）</li><li>1个网络进程</li><li>多个插件进程（每个插件都会开启一个进程，因为防止一个插件崩溃，造成整个浏览器崩溃）</li><li>多个渲染进程（标签页需要独立的进程）</li></ul><h3 id="browser-进程（主进程）"><a href="#browser-进程（主进程）" class="headerlink" title="browser 进程（主进程）"></a>browser 进程（主进程）</h3><p>负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</p><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a>GPU 进程</h3><p>负责处理与图形渲染相关的任务。（着重在于<strong>图像</strong>）</p><ul><li>图形渲染</li><li>动画和过渡</li><li>3D 和 WebGL 渲染</li><li>视频播放和解码等</li></ul><h3 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h3><p>负责处理与网络相关的任务。它主要负责管理和维护网络连接，以及处理所有的网络请求和响应。</p><ul><li>管理网络连接</li><li>处理网络请求和响应</li><li>处理DNS解析</li><li>处理缓存</li><li>处理安全问题</li></ul><blockquote><p><strong>浏览器的网络进程和渲染进程的异步HTTP线程之间存在通信吗？</strong></p><p>在浏览器中，<strong>当用户在页面上发起一个网络请求时，该请求首先由渲染进程中的异步 HTTP 线程发起，异步 HTTP 线程会将该请求通过 IPC 传递给网络进程</strong>。网络进程收到请求后，负责管理和维护网络连接，发送请求并接收响应，最后<strong>将响应数据再通过 IPC 传递给渲染进程中的异步 HTTP 线程处理</strong>。</p><p>在这个过程中，网络进程和渲染进程之间需要频繁地进行通信，以协同完成网络请求和响应的处理。</p><p>例如，当请求被发送出去后，网络进程需要不断地监控连接状态和接收数据，并及时将收到的数据通过 IPC 传递给渲染进程中的异步 HTTP 线程，同时异步 HTTP 线程也需要不断地向网络进程查询请求状态和响应数据。 </p><p>浏览器通过 IPC（进程间通信）机制来实现这种进程间通信，IPC 是浏览器中进程间交换数据的标准方法，其通信方式包括消息传递、共享内存、管道等。</p><p>通过 IPC 机制，网络进程和渲染进程之间可以高效地传递数据和信息，保证了浏览器的正常工作和性能表现。</p></blockquote><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><p>用于处理浏览器插件的进程（每个插件，就会创建一个进程）</p><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>负责将 HTML、CSS 和 JavaScript 转换为可视化的页面。默认情况下，浏览器的tab就会创建一个渲染进程。</p><blockquote><p>针对前端，需要着重了解该进程。</p></blockquote><p>该进程包含：<code>GUI 渲染线程</code>、<code>JS 引擎线程</code>、<code>定时触发线程</code>、<code>异步 HTTP 线程</code>、<code>事件触发线程</code></p><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><p>负责页面的渲染和绘制；解析 HTML和CSS，构建 DOM树、CSSOM树 、 渲染树（Render 树） ，布局和绘制等。</p><p>重绘和重排也是发生在该线程中。</p><p>GUI 更新会被保存在一个队列之中，等到 JS 引擎线程空闲时，GUI 线程就会立即执行。</p><p><strong>「GUI 线程和JS引擎线程是互斥的」</strong></p><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><p>也称为 JS 内核，负责处理 JavaScript 脚本程序。</p><p>再次注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong> ，所以，如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><p>指的是计时函数：setInterval 和 setTimeout 两个函数。</p><p>由于 JS 引擎是单线程的，如果该线程处于堵塞状态，那么就会造成计时不准确，那么就需要单独一个线程来进行计时。</p><p>当计时完成之后，就会把事件回调（任务）添加事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="异步-HTTP-线程"><a href="#异步-HTTP-线程" class="headerlink" title="异步 HTTP 线程"></a>异步 HTTP 线程</h4><p>XMLHttpRequest 在连接后是通过浏览器新开的一个线程请求。</p><p>检测到状态发生变化之后，就会事件回调（任务）添加到事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>用来控制事件循环的（Event Loop）。</p><p>就比如上面的，</p><ul><li>定时器的任务通过事件触发线程添加到事件队列中，</li><li>异步请求的任务是通过事件触发线程添加到事件队列中</li><li>。。。（收集任务）</li></ul><p>事件触发线程还会周期性地检查事件队列中是否存在任务。当JS引擎线程空闲了，就会将其中的任务顺序交给 JS 引擎线程执行。</p><blockquote><p>这里的解释可能存在错误。</p><p>事件触发线程是连接事件的发生和任务执行的桥梁。它负责接收事件，并将对应的任务添加到事件队列中，然后主动触发 JavaScript 引擎线程来执行任务。</p></blockquote><h4 id="存储线程"><a href="#存储线程" class="headerlink" title="存储线程"></a>存储线程</h4><p>负责处理浏览器的各种存储机制，包括 cookie、localStorage、indexedDB 等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然面试时候感觉完全不太可能会提到，但是作为拓充知识涉猎一下也是不错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7287914116286201891">浏览器原理：进程与线程</a></p><p><a href="https://juejin.cn/post/6991849728493256741">深入理解浏览器中的进程与线程 - 掘金</a></p><p>[<a href="https://juejin.cn/post/7053974933931556900">前端进阶] - 搞懂浏览器进程和线程 - 掘金</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS的线程与进程</title>
      <link href="/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面试官：你能说一下线程和进程吗？</p><p>我：工作中用不到，我没了解过。</p><p>面试官：哈哈哈，你好，很高兴您来面试，请您暂时先回去等通知。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>大多数前端都知道前端的JS是单线程语言，但是JS为什么是单线程语言大多数人可能还是不清楚的。</p><p>线程与进程这个东西，虽然不影响日常开发，但这是程序员必会的基础知识，我没能完整的说出来，确实不太好。</p><p>因此，我这里整理一下相关的知识点。</p><h3 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h3><ol><li>查看人管理器，每个应用程序至少会启动一个进程，有的会启动多个进程</li><li>一个进程会占有一片独立的内存空间。</li><li>各个进程的内存空间相互独立，不能互相访问。</li></ol><h3 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h3><ol><li>是进程内一个独立执行的单元。</li><li>是进程内的一个独立的执行单元</li><li>是CPU的最小调度单元</li></ol><p>单线程与多线程的概念，是针对一个进程内的概念。</p><ul><li>一个进程内有多个线程，那这个进程对应的程序就是多线程的程序。</li><li>一个进程内只有一个线程，那么这个程序就是单线程的程序，并且，一个程序，如果只有一个主线程，那就是单线程。</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li>某个独立的模块(浏览器的JS引擎)必须运行在某个进程的某个线程上，不能直接运行在进程上。</li><li>一个进程中必须至少有一个线程，就是所谓的主线程。主线程是进程启动后自动创建的，要运行代码必须要创建线程。</li><li>一个进程可以同时运行多个线程，叫做多线程。</li><li>一个进程内的数据可心供其中多个线程直接共享使用</li><li>多进程之间的数据不能直接共享使用</li></ol><h4 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h4><p>单线程和多线程之间并无优劣之分，只是根据使用场景而确定的方案，譬如JS一开始之所以确定为单线程，就是为了提高执行效率。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:能有效提升CPU的利用率</span><br><span class="line">缺点:创建多线程开销，线程间切换开销，锁进制与状态同步问题</span><br></pre></td></tr></table></figure><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:代码顺序执行，编码更加简单</span><br><span class="line">缺点:效率低</span><br></pre></td></tr></table></figure><h4 id="关于cpu利用率"><a href="#关于cpu利用率" class="headerlink" title="关于cpu利用率"></a>关于cpu利用率</h4><p>单核cpu，某一个时刻肯定只能有一个线程在执行。但是却也能创建多线程，多线程是交替执行的，只是比较快，看着好像是同时执行的。<br>双核cpu，某一个时刻可以有两个线程在执行。单线程的就浪费了双核的能力了，另外一个核闲置了。</p><h4 id="异步与多线程的区别"><a href="#异步与多线程的区别" class="headerlink" title="异步与多线程的区别"></a>异步与多线程的区别</h4><p>异步和多线程都是处理并发任务的方式，但它们本质上是不同的。</p><p>多线程和异步编程之间的一个关键区别是，多线程涉及在一个进程内创建多个线程，而异步编程涉及以非阻塞方式执行任务。</p><p>另一个区别是，多线程需要显式地管理线程同步和通信，而异步编程可以使用编程构造（例如回调或承诺）来处理异步操作。</p><p>多线程和异步编程都可以用于实现计算机系统的并发和并行，但使用哪种取决于程序的具体要求以及底层硬件和软件基础设施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 执行方式：多线程是并行执行任务，即多个线程同时执行任务，而异步是串行执行任务，即一个任务执行完成后再执行下一个任务。</span><br><span class="line">2. 内存使用：每个线程都有自己的栈和内存，因此多线程会占用更多的内存。而异步则可以在一个线程中共享内存。</span><br><span class="line">3. 调度机制：多线程需要操作系统提供的线程调度器来进行线程之间的切换，而异步则是通过事件循环和任务队列的机制完成任务的调度。</span><br><span class="line">4. 错误处理：多线程中一个线程抛出异常时，其他线程不受影响，但异步中一个任务出错可能会影响后续的任务执行。</span><br></pre></td></tr></table></figure><p>总的来说，多线程适用于CPU密集型的任务（如计算），而异步则适用于IO密集型的任务（如网络请求），它们都有自己的优缺点，在选择使用时需要根据具体的场景进行判断。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>谈到异步多线程了，多少就顺手讲一下并行与并发的概念，这都算是计算机相关的基础名词，多少要做一个了解。</p><p><strong>并发</strong>是一个人同时吃三个馒头（时间点是相互独立的，在一个时间点只能吃其中馒头的一口）</p><p><strong>并行</strong>是三个人同时吃三个馒头（时间是重合的，三个人可以在同一时间吃馒头）</p><h4 id="并行-parallel"><a href="#并行-parallel" class="headerlink" title="并行(parallel)"></a>并行(parallel)</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><h4 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发(concurrency)"></a>并发(concurrency)</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p>这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><h4 id="关于CPU与二者的关系"><a href="#关于CPU与二者的关系" class="headerlink" title="关于CPU与二者的关系"></a>关于CPU与二者的关系</h4><p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p><p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端的基础知识，仅做内功修炼的一条，可以涉猎了解，但是没必要深入了解。</p><p>除非，是真正纯正的技术MAN。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1iw4m1R7Xr/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">JS进程与线程全解析-前端开发-JavaScript_哔哩哔哩_bilibili</a></p><p><a href="https://juejin.cn/post/7231391129945047096">异步和多线程的区别</a></p><p>[<a href="https://juejin.cn/post/7053974933931556900">前端进阶] - 搞懂浏览器进程和线程 - 掘金 (juejin.cn)</a></p><p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/scarificed/article/details/114645082">并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂_咋么又饿了的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS异步与同步</title>
      <link href="/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
      <url>/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>模拟面试，感觉自己JS异步同步自己回答的不够精彩，重新整理下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文仅算入门浅析，如有说错的部分，还请轻喷。</p><p>在正式了解Promise之前，我们需要先了解一些基础知识。</p><p>我们知道JavaScript的单线程的，这与它的用途有关。</p><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</p><p>这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所谓”单线程”，就是指一次只能完成一件任务。</p><p>如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p><p>这种模式好处坏处都很明显。</p><p>好处是实现起来比较简单，执行环境相对单纯；</p><p>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。</p><p>常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><p>ajax的同步请求就会导致浏览器产生假死，因为它会锁定浏览器的UI（按钮，菜单，滚动条等），并阻塞所有用户的交互，jquery中的ajax有这样一个同步请求的功能，一定要慎用，尤其是在请求的数据量很大的时候，要避免使用同步请求。</p><p>举几个栗子感受一下异步</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>javascript异步<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> myData = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//ajax请求</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>(<span class="string">&#x27;https://easy-mock.com/mock/5b0525349ae34e7a89352191/example/mock&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回成功&quot;</span>);<span class="comment">// handle success</span></span></span><br><span class="line"><span class="language-javascript">            myData = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(error); // handle error</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h3><p>JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为<strong>JS引擎线程</strong>，但是浏览器的渲染进程是提供多个线程的</p><ul><li>JS引擎线程</li><li>事件触发线程</li><li>定时触发器线程</li><li>异步http请求线程</li><li>GUI渲染线程</li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,应该没什么悬念</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 定时器d</span></span><br></pre></td></tr></table></figure><p>我们看一下执行顺序</p><ol><li>console.log(myData)</li><li>定时器，将定时器挂起（就是暂停了这个定时器）</li><li>继续执行第二个 console.log(myData);</li><li>没有可以执行的js代码，回头把挂起的任务继续执行下去</li></ol><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;(这是接口返回的数据，我们不必关心返回的具体内容，只要知道返回了就好，陌上寒注)</span></span><br></pre></td></tr></table></figure><h4 id="定时器与AJAX"><a href="#定时器与AJAX" class="headerlink" title="定时器与AJAX"></a>定时器与AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">//定时器</span></span><br></pre></td></tr></table></figure><p>两个异步函数相遇了，先执行谁？谁跑的快就先执行谁？</p><p>当遇到计时器、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程去处。</p><p>如定时器线程为setTimeout计时、异步http请求线程处理网络请求，而JS引擎线程继续后面的其他任务，这样便实现了 <strong>异步非阻塞</strong>。</p><p>定时器触发线程也只是为 <code>setTimeout(..., 1000)</code> 定时而已，时间一到，还会把它对应的回调函数(callback)交给 <strong>任务队列</strong> 去维护，JS引擎线程会在适当的时候去<strong>任务队列</strong>取出任务并执行。</p><p>JS引擎线程什么时候去处理呢？消息队列又是什么？</p><p>为了解决这个异步执行顺序的问题，JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制来解决这个问题。</p><h3 id="事件循环和任务队列"><a href="#事件循环和任务队列" class="headerlink" title="事件循环和任务队列"></a>事件循环和任务队列</h3><p>两个console.log(myData)是同步执行的，他们都在js的主线程上执行</p><p>在主线程之外还存在一个任务队列，任务队列中存放着需要异步执行的内容</p><p>当主线程运行完毕之后，就会去执行任务队列中的任务（不断的重复扫描）直到任务队列清空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,这没什么可解释的</span></span><br><span class="line"><span class="comment">// 1，3，2</span></span><br></pre></td></tr></table></figure><p>再看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出,但是后者次序依旧在上</span></span><br><span class="line"><span class="comment">// 2，1，</span></span><br></pre></td></tr></table></figure><p>console.log(2)在主线程中，先执行，</p><p>setTimeout(function(){console.log(1);}, 0)放在了任务队列中，只有在主线程执行完了才会去执行任务列队中的内容</p><p>只有主线程的任务执行完成才会执行</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>为什么主线程的任务执行完了后需要不断的扫描任务列队中的内容呢？</p><p>看这段代码，有助于你的理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// (10次输出)点击了</span></span><br><span class="line"><span class="comment">// ajax返回成功</span></span><br><span class="line"><span class="comment">// &#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="comment">// 点击了</span></span><br></pre></td></tr></table></figure><p>我们为button按钮添加了点击事件，在浏览器刷新的同时不停地对按钮进行点击操作（当然是手动点击）</p><p>这样是不是可以理解为什么主线程要去循环扫描任务列队了？</p><p>事件循环的每一轮称为一个tick（有没有联想到vue中的nextTick？）</p><p>当产生用户交互（鼠标点击事件，页面滚动事件，窗口大小变化事件等等），ajax，定时器，计时器等，会向事件循环中的任务队列添加事件，然后等待执行</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>在查找相关文档的时候，我发现有的笔者混淆了任务队列与消息队列，这两个名词虽然相近，但本质上并非是可以混为一谈的事儿，这次我们本次不做深入讨论。</p><blockquote><p>任务队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">2. 主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">3. 一但&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">4. 主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复，这种机制就被称为事件循环（event loop）机制。</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-595fdd0e4697bed589dc4b30f2c60aeb_r.jpg" alt="img"></p><p>JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制解决了异步时间执行顺序排序的问题。</p><p><strong>事件循环</strong> 机制和 <strong>任务队列</strong> 的维护是由事件触发线程控制的。</p><p><strong>事件触发线程</strong> 同样是浏览器渲染引擎提供的，它会维护一个 <strong>任务队列</strong>。</p><p>JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等…），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 <strong>事件触发线程</strong> 将异步对应挂起的 <strong>回调函数</strong> 重新加入到任务队列中，消息队列中的回调函数等待被执行。</p><p>同时，JS引擎线程会维护一个 <strong>执行栈</strong>，同步代码会依次加入执行栈然后执行，结束会退出执行栈。</p><p>如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从任务队列取出一个任务（即异步的回调函数）放入执行栈中执行。</p><p>这里关于线程的进程的说法比较模糊，后续我会单开一文着重复述一下<code>线程</code>与<code>进程</code>。</p><h3 id="前端异步场景分析"><a href="#前端异步场景分析" class="headerlink" title="前端异步场景分析"></a>前端异步场景分析</h3><ol><li>定时任务：setTimeout,setInverval</li><li>网络请求：ajax请求，img图片的动态加载</li><li>ES6中的Promise</li><li>事件绑定或者叫DOM事件。比如一个点击事件，我不知道它什么时候点，但是在它点击之前，我该干什么还是干什么。用addEventListener注册一个类型的事件的时候，浏览器会有一个单独的模块去接收这个东西，当事件被触发的时候，浏览器的某个模块，会把相应的函数扔到任务队列中，如果现在任务列队中是空的，就会直接执行这个函数。</li></ol><h3 id="需要异步的场景分析"><a href="#需要异步的场景分析" class="headerlink" title="需要异步的场景分析"></a>需要异步的场景分析</h3><p>到底什么时候需要异步呢？这里我们稍微分析一下平时的业务场景。</p><ol><li>在可能发生等待的情况</li><li>等待过程中不能像alert一样阻塞程序的时候</li><li>因此，所有的“等待的情况”都需要异步</li></ol><p>一句话总结就是需要等待但是又不能阻塞程序的时候需要使用异步</p><h3 id="异步和并行"><a href="#异步和并行" class="headerlink" title="异步和并行"></a>异步和并行</h3><p>千万不要把异步和并行搞混了</p><p>异步：单线程的,主线程的任务以同步的方式执行完毕，才会去依次执行任务列队中的异步任务</p><p>并行：两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>主题是JS异步，话题有点歪到JS的执行顺序机制里边了，而且自己似乎还没顺明白，这里有点差了。</p><p>温故而知新，今天扫了很多文档才知道，消息队列和任务队列原来是同一回事儿，早些年就没怎么关注这些东西。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/139967525">一篇搞定（Js异步、事件循环与消息队列、微任务与宏任务）</a></p><p><a href="https://www.cnblogs.com/c3gen/p/6170504.html">关于js中的同步和异步</a></p><p><a href="http://blog.sina.com.cn/s/blog_c112a2980102xlrh.html">异步和单线程——什么时候需要异步，前端使用异步的场景</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解常用的git命令</title>
      <link href="/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>git命令还是在刚毕业时为了面试学的，工作时常用图形化的工具处理。</p><p>如今新入职的公司又要手敲命令，简直有种重返猿人时代的美。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>只是一些常用的信息，并不涉及深层的内容。</p><h3 id="查看git用户信息"><a href="#查看git用户信息" class="headerlink" title="查看git用户信息"></a>查看git用户信息</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git config –global user.name</td><td>全局的用户名</td></tr><tr><td>git config –global user.email</td><td>全局的邮箱</td></tr><tr><td>git config user.name</td><td>当前项目的用户名</td></tr><tr><td>git config user.email</td><td>当前项目的邮箱</td></tr><tr><td>git config –list</td><td>查看所有配置信息</td></tr></tbody></table><h3 id="设置git用户信息"><a href="#设置git用户信息" class="headerlink" title="设置git用户信息"></a>设置git用户信息</h3><p>我们提交会附带个人的用户名和用户信息，如果某个项目你不希望提交的是这个用户信息，你可以自行在项目根目录下修改当前项目的用户名和邮箱。</p><p>当然，这些用户信息如果你不想用命令行去敲，也可以直接在项目中的<code>.git</code>目录下去修改对应的信息。</p><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git config –global user.name globalName</td><td>全局的用户名</td></tr><tr><td>git config –global user.email globalEmail</td><td>全局的邮箱</td></tr><tr><td>git config user.name myName</td><td>当前项目的用户名</td></tr><tr><td>git config user.email myEmail</td><td>当前项目的邮箱</td></tr></tbody></table><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git clone <url></td><td>clone远程版本库到本地</td></tr><tr><td>git init</td><td>初始化本地版本库</td></tr></tbody></table><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git diff</td><td>查看变更内容</td></tr><tr><td>git add .</td><td>添加所有改动文件到暂存区</td></tr><tr><td>git add <file></td><td>添加指定文件或目录到暂存区</td></tr><tr><td>git mv <old> <new></td><td>文件改名</td></tr><tr><td>git rm <file></td><td>删除指定文件或文件夹</td></tr><tr><td>git rm –cached <file></td><td>删除暂存区的文件追踪，不删除源文件</td></tr><tr><td>git commit -m “提交描述”</td><td>提交更新文件，并附带提交信息</td></tr><tr><td>git commit –amend -m “本次提交的描述”</td><td>将本次提交，加入到上次的提交中，并重写提交信息</td></tr></tbody></table><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/git/git-status.html">git status</a></td><td>查看状态（分支名称，与远程分支的关系，未暂存，未跟踪的文件）</td></tr><tr><td>git log</td><td>查看提交历史</td></tr><tr><td>git log -p <file></td><td>查看指定文件的提交历史</td></tr><tr><td>git blame  <file></td><td>以列表方式查看指定文件的提交历史</td></tr></tbody></table><h3 id="代码检出"><a href="#代码检出" class="headerlink" title="代码检出"></a>代码检出</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git checkout</td><td>核查工作区相对于版本库修改过的文件</td></tr><tr><td>git checkout  分支名</td><td>切换到对应的分支</td></tr><tr><td>git checkout -b 分支名</td><td>以当前分支的当前状态创建新分支并切换到新分支  -b 表示创建新分支</td></tr><tr><td>git pull <remote> <branch></td><td>将远程分支的代码拉取到本地分支</td></tr></tbody></table><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git branch</td><td>显示本地所有分支</td></tr><tr><td>git branch -r</td><td>查看本地仓库的远程分支</td></tr><tr><td>git checkout &lt;branch&#x2F;tag&gt;</td><td>切换到指定分支或标签</td></tr><tr><td>git branch <new-branch></td><td>创建新分支</td></tr><tr><td>git branch -d <branch></td><td>删除本地分支</td></tr><tr><td>git tag</td><td>显示本地所有标签</td></tr><tr><td>git tag <tagname></td><td>基于最新提交创建标签</td></tr><tr><td>git tag -d <tagname></td><td>删除标签</td></tr></tbody></table><h3 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git merge <branch></td><td>合并指定分支到当前分支</td></tr><tr><td>git rebase <branch></td><td>衍合指定分支到当前分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git fetch <remote></td><td>从远程库获取代码</td></tr><tr><td>git pull <remote> <branch></td><td>指定的远程仓库（<code>&lt;remote&gt;</code>）拉取指定分支（<code>&lt;branch&gt;</code>）的最新更改，并尝试合并到当前分支</td></tr><tr><td>git push <remote> <branch></td><td>把当前分支的更改推送到指定的远程仓库（<code>&lt;remote&gt;</code>）的指定分支（<code>&lt;branch&gt;</code>），并快速合并</td></tr><tr><td>git push <remote>  :&lt;branch&#x2F;tag-name&gt;</td><td>删除远程分支或标签</td></tr><tr><td>git push –tags</td><td>上传所有标签</td></tr><tr><td>git remote -v</td><td>列出当前仓库中已配置的远程仓库，并显示它们的 URL</td></tr><tr><td>git remote add <remote_name> <remote_url></td><td>添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中。</td></tr><tr><td>git remote rename <old_name> <new_name></td><td>将已配置的远程仓库重命名。</td></tr><tr><td>git remote remove <remote_name></td><td>从当前仓库中删除指定的远程仓库。</td></tr><tr><td>git remote set-url <remote_name> <new_url></td><td>修改指定远程仓库的 URL。</td></tr><tr><td>git remote show <remote_name></td><td>显示指定远程仓库的详细信息，包括 URL 和跟踪分支。</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时就先整理这么多，至于代码的冲突解决，暂时先不做了解。</p><p>毕竟，在大多数业务开发过程中，很难遇到代码冲突的情况。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7359833391192031273?searchId=20240512115740A18BB0AFCF72FB30AEA6">常用的Git命令指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解fetch</title>
      <link href="/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/"/>
      <url>/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/</url>
      
        <content type="html"><![CDATA[<p>朋友：也许面试官是问你什么是fetch呢？我：什么是fetch？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果不是刷面试题，我真的不知道有fetch这个东西。</p><h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><h4 id="基本历史"><a href="#基本历史" class="headerlink" title="基本历史"></a>基本历史</h4><p>远古时期，XMLHttpRequest对象的出现，JavaScript调用它就可以让浏览器异步地发http请求，然后这项异步技术就被称为Ajax。</p><p>之后jQuery封装了它，让异步结果更清晰的表现在一个对象的回调函数属性上，编写方式更简单，但出现了新的问题，回调地狱。</p><p>Promise为了解决异步编程的回调地狱问题诞生了。</p><p>随后有人把XHR对象用Promise封装了起来，它就是axios库(浏览器端)，axios在node.js环境是http模块的封装。</p><p>后来又出现了一个可以异步地发http请求的api，就是fetch()。</p><p>Fetch它并非是封装xhr对象的库，而是全新的JavaScript的接口。</p><p>而且Fetch的api天生就是自带Promise的，现在的Ajax就有了两种方式: XHR对象和Fetch()。</p><h4 id="Ajax，Axios，Fetch三者关系"><a href="#Ajax，Axios，Fetch三者关系" class="headerlink" title="Ajax，Axios，Fetch三者关系"></a>Ajax，Axios，Fetch三者关系</h4><ol><li>Ajax 是一种代表异步 JavaScript + XML 的模型（技术合集），所以 Fetch 也是 Ajax 的一个子集</li><li>在之前，我们常说的 Ajax 默认是指以 XHR 为核心的技术合集，而在有了 Fetch 之后，Ajax 不再单单指 XHR 了，我们将以 XHR 为核心的 Ajax 技术称作<strong>传统 Ajax</strong>。</li><li>Axios 属于传统 Ajax（XHR）的子集，因为它是基于 XHR 进行的封装。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代AJAX包含XHR和Fetch两种类型的常见接口请求方式，AJAX和AXIOS都是基于XHR做的封装。</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象</p><p>基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询参数直接通过 ?、&amp; 拼接</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err))</span><br></pre></td></tr></table></figure><p><code>fetch()</code>接收到的<code>response</code>是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Stream 对象</a>，<code>response.json()</code>是一个<strong>异步操作</strong>，取出所有内容，并将其转为 JSON 对象</p><p>使用 await 语法改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;http://example.com/movies.json&#x27;</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求</p><ul><li><code>fetch(url, options)</code></li><li>post、put、patch 用法类似</li><li>HTTP 请求的方法、标头、数据体都在<code>options</code>这个对象里面设置</li></ul><p>下面是一些示例：</p><p><strong>（1）POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br></pre></td></tr></table></figure><blockquote><p>此处的<code>body</code>指的是POST 请求的数据体</p></blockquote><p><strong>（2）提交 JSON 数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user =  &#123; <span class="attr">name</span>:  <span class="string">&#x27;John&#x27;</span>, <span class="attr">surname</span>:  <span class="string">&#x27;Smith&#x27;</span>  &#125;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type`的默认值是`&#x27;text/plain;charset=UTF-8&#x27;</span><br></pre></td></tr></table></figure></blockquote><p><strong>（3）提交表单</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>（5）直接上传二进制数据</strong></p><p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> canvasElem.<span class="title function_">toBlob</span>(resolve,  <span class="string">&#x27;image/png&#x27;</span>))</span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/image&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:  <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: blob</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="完整配置项"><a href="#完整配置项" class="headerlink" title="完整配置项"></a>完整配置项</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="comment">// 指定请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定请求体数据</span></span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="comment">// 指定 fetch() 请求的 referer 标头</span></span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 Referer 标头的规则</span></span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求的模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>, </span><br><span class="line">  <span class="comment">// 指定是否发送 Cookie</span></span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定如何处理缓存</span></span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 HTTP 跳转的处理方法</span></span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值</span></span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据</span></span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 指定一个 AbortSignal 实例，用于取消fetch()请求</span></span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于官网对于部分配置项没有中文翻译，以下列出全部配置项具体值及其说明</p><p><code>cache</code>：指定如何处理缓存，可能的取值如下：</p><blockquote><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误</li></ul></blockquote><p><code>mode</code>：指定请求的模式，可能的取值如下：</p><blockquote><ul><li><code>cors</code>：默认值，允许跨域请求</li><li><code>same-origin</code>：只允许同源请求</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求</li></ul></blockquote><p><code>credentials</code>：指定是否发送 Cookie，可能的取值如下：</p><blockquote><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送</li><li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie</li><li><code>omit</code>：一律不发送</li></ul></blockquote><p><code>redirect</code>：指定 HTTP 跳转的处理方法，可能的取值如下：</p><blockquote><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转</li></ul></blockquote><p><code>referrerPolicy</code>：用于设定<code>Referer</code>标头的规则，可能的取值如下：</p><blockquote><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名</li><li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头</li></ul></blockquote><h3 id="取消Fetch请求"><a href="#取消Fetch请求" class="headerlink" title="取消Fetch请求"></a>取消Fetch请求</h3><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象，流程如下：</p><ul><li>创建<code>AbortController</code>实例</li><li>配置对象的<code>signal</code>属性指定接收<code>AbortController</code>实例发送的信号<code>controller.signal</code></li><li>使用<code>controller.abort()</code>方法发出取消信号</li><li>发出取消信号后，会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>()</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: signal</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>))</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>()<span class="comment">// 取消fetch请求</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p><code>fetch()</code>请求成功以后，得到的是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Response">Response 对象</a>。它对应服务器的 HTTP 响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br></pre></td></tr></table></figure><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>Response 实例属性如下表：</p><table><thead><tr><th>属性</th><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><strong>ok</strong></td><td>布尔值</td><td>表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码</td></tr><tr><td><strong>status</strong></td><td>数字</td><td>表示 HTTP 回应的状态码（如：200，表示成功请求）</td></tr><tr><td><strong>statusText</strong></td><td>字符串</td><td>表示 HTTP 回应的状态信息（如：请求成功以后，服务器返回”OK”）</td></tr><tr><td><strong>url</strong></td><td>请求的 URL</td><td>如果 URL 存在跳转，该属性返回的是最终 URL</td></tr><tr><td><strong>type</strong></td><td>请求的类型</td><td><code>basic</code>：普通请求，即同源请求  <code>cors</code>：跨域请求  <code>error</code>：网络错误，主要用于 Service Worker  <code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值。表示发出的是简单的跨域请求 <code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值</td></tr><tr><td><strong>redirected</strong></td><td>布尔值</td><td>表示请求是否发生过跳转</td></tr><tr><td><strong>body</strong></td><td>ReadableStream 对象</td><td>暴露响应体内容</td></tr><tr><td><strong>headers</strong></td><td>与响应关联的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">Headers</a>对象</td><td>通过访问与响应关联的 Headers 对象，来操作 HTTP 响应头</td></tr></tbody></table><p><code>fetch()</code>发出请求以后，<strong>只有网络错误，或者无法连接时</strong>，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。这意味着服务器返回的状态码是<code>4xx</code>或<code>5xx</code>时，不会报错（Promise 不会变为 <code>rejected</code>状态）</p><p>以下两种方法可以判断是否发生错误：</p><ul><li>通过<code>status</code>属性，得到 HTTP 回应的真实状态码，判断请求是否成功</li><li>判断<code>ok</code>属性是否为<code>true</code></li></ul><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>()</span><br><span class="line">  <span class="keyword">if</span> (done) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块，其中：</p><ul><li><code>done</code>属性是一个布尔值，用来判断有没有读完</li><li><code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容</li><li><code>value.length</code>属性是当前块的大小</li></ul><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers 对象</a>，对应 HTTP 回应的所有标头</p><p>Headers 对象提供了以下方法，用来操作标头：</p><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加</li><li><code>Headers.append()</code>：添加标头</li><li><code>Headers.delete()</code>：删除标头</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数</li></ul><blockquote><p>方法具体用法请参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;…</a></p></blockquote><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法</p><ul><li><code>response.text()</code>：得到文本字符串</li><li><code>response.json()</code>：得到 JSON 对象</li><li><code>response.blob()</code>：得到二进制 Blob 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取图片文件flower.jpg，显示在网页上</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">myImage.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob)</span><br></pre></td></tr></table></figure><ul><li><code>response.formData()</code>：得到 FormData 表单对象</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>Stream 对象只能读取一次，这意味着，前五个读取方法，只能使用一个，否则会报错。Response 对象提供了克隆方法</p><ul><li><code>response.clone()</code>：创建<code>Response</code>对象的副本，实现多次读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flowers.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response2 = response1.<span class="title function_">clone</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBlob1 = <span class="keyword">await</span> response1.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myBlob2 = <span class="keyword">await</span> response2.<span class="title function_">blob</span>()</span><br><span class="line"><span class="comment">// 将同一张图片读取了两次</span></span><br><span class="line">image1.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob1)</span><br><span class="line">image2.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob2)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>fetch这种方法虽然才了解，但是感觉好像还行，看了很多文章介绍，感觉在文件读取这里似乎有不错的应用。</p><p>但是说到底，这终归不是工作中常用的，连面试题问到的似乎都很少，如果不是这里刷到，似乎都没什么人讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-30">一文熟悉Ajax</a></p><p><a href="https://juejin.cn/post/6997784981816737800">有同学问我：Fetch 和 Ajax 有什么区别？ - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解axios</title>
      <link href="/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/"/>
      <url>/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/</url>
      
        <content type="html"><![CDATA[<p>承接昨天的日志，问到ajax，怎么可能不问axios呢。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这虽然是一次模拟面试，但当模拟真的开始的时候，我开始汗流浃背了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官：能详细说说axios吗？</span><br><span class="line"></span><br><span class="line">我：项目中常用的一个工具库，封装接口请求的工具方法。</span><br><span class="line"></span><br><span class="line">面试官：很高兴面试您，如果后续有结果了，我们会通知您的。</span><br></pre></td></tr></table></figure><p>虽然知道今年很卷，但是比想象中要卷的多。</p><blockquote><p>本节为 Axios 常规使用，更多方法请看<a href="https://link.juejin.cn/?target=https://www.kancloud.cn/yunye/axios/234845/">Axios中文文档</a>、<a href="https://link.juejin.cn/?target=https://www.axios-http.cn/docs/intro">Axios中文文档(官方)</a>、开源API库：<a href="https://link.juejin.cn/?target=https://www.bootcdn.cn/index.html">BootCDN</a></p></blockquote><h3 id="Axios概念"><a href="#Axios概念" class="headerlink" title="Axios概念"></a>Axios概念</h3><p>Axios 是一个基于 promise 的网络请求库，作用于 node.js 和浏览器中，它是 isomorphic 的 (即同一套代码可以运行在浏览器和 node.js 中)。</p><p>在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequest</p><ul><li><strong>Axios 本质上是对原生 XMLHttpRequest 的封装</strong>，只不过它是 Promise 的实现版本，符合最新的 ES6 规范</li></ul><blockquote><p>Promise教程请参考：<a href="https://juejin.cn/post/7321996765977198611">juejin.cn&#x2F;post&#x2F;732199…</a></p></blockquote><p>主要特点：</p><ul><li>从浏览器创建 XMLHttpRequests、从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>超时处理</li><li>自动将请求体序列化</li><li>自动转换 JSON 数据</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>使用 npm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ul><li>使用 CDN</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>可以向 <code>axios</code> 传递相关配置来创建请求</p><ul><li><code>axios(config)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起一个get请求, 参数名和值会自动拼接到url</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起一个post请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>常用请求方法：</p><table><thead><tr><th>请求方法</th><th>操作</th></tr></thead><tbody><tr><td>GET</td><td>获取数据</td></tr><tr><td>POST</td><td>提交数据</td></tr><tr><td>PUT</td><td>修改数据（全部）</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>PATCH</td><td>修改数据（部分）</td></tr></tbody></table><p>为方便起见，为所有支持的请求方法提供了别名：</p><p>无 data 属性：</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[, config])</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.options(url[, config])</code></li></ul><p>有 data 属性：</p><ul><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config]])</code></li><li><code>axios.postForm(url[, data[, config]])</code></li><li><code>axios.putForm(url[, data[, config]])</code></li><li><code>axios.patchForm(url[, data[, config]])</code></li></ul><blockquote><p>别名中的data属性无需显式给出，只需传入一个对象即可</p></blockquote><p>下面是使用方法别名的示例：</p><ul><li>GET 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// data属性直接为一个对象, 无需显式给出</span></span><br><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>,</span><br><span class="line">    <span class="attr">orders</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="attr">photo</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#fileInput&#x27;</span>).<span class="property">files</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>Axios 支持以 fetch API 方式—— <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a> 取消请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/foo/bar&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">controller.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>以下是创建请求时可以用的配置选项只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>GET</code> 方法</p><blockquote><p>配置源于官网，已将常用配置移到最前</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// baseURL 自动加在url前，除非url是一个绝对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// params 是与请求一起发送的 URL 参数, 与 get 方法搭配使用</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data 是作为请求体被发送的数据 (PUT、POST、DELETE、PATCH)</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属: Stream, Buffer</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定请求超时的毫秒数, 超时则请求会被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 默认值是 0 (永不超时)</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// responseType 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// auth 示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 Authorization ，覆写掉现有的任意使用 headers 置的自定义 Authorization </span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span></span><br><span class="line">  <span class="comment">// 你可以修改请求头。</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span></span><br><span class="line">  <span class="comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span></span><br><span class="line">  <span class="comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span></span><br><span class="line">  <span class="comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span></span><br><span class="line">  <span class="comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// see https://axios-http.com/zh/docs/cancellation</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed </span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> <span class="comment">// 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>一个请求的响应包含以下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务器响应头, 所有的 header 名称都是小写, 而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: response.headers[&#x27;content-type&#x27;]</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// axios 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Axios默认配置"><a href="#Axios默认配置" class="headerlink" title="Axios默认配置"></a>Axios默认配置</h3><p>常规开源项目中的常见封装方式。</p><h4 id="全局默认配置"><a href="#全局默认配置" class="headerlink" title="全局默认配置"></a>全局默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="自定义实例"><a href="#自定义实例" class="headerlink" title="自定义实例"></a>自定义实例</h4><p>可以使用自定义配置新建一个实例：<code>axios.create([config])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例时配置默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例后修改默认值</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br></pre></td></tr></table></figure><h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p>配置将会按优先级进行合并</p><ul><li>优先级：<a href="https://link.juejin.cn/?target=https://github.com/axios/axios/blob/master/lib/defaults.js%23L28">lib&#x2F;defaults.js</a>默认值 &lt; 实例 <code>defaults</code> 属性 &lt; 请求 <code>config</code> 参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 使用库提供的默认配置创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 0</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写库的超时默认值 </span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写此请求的超时时间，因为该请求需要很长时间</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拦截器完整使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 创建一个单独的axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://xxx.xxx.xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">6000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">user</span>?.<span class="property">token</span>) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;store.user?.token&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="comment">// 数据脱壳、业务成功、业务失败、401 token失效的处理</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面判断用户请求的业务成功</span></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">data</span>?.<span class="property">code</span> === <span class="number">10000</span>) &#123;</span><br><span class="line">      <span class="comment">// 数据脱壳</span></span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 业务失败, 提示错误</span></span><br><span class="line">      <span class="title function_">showToast</span>(res.<span class="property">data</span>?.<span class="property">message</span> || <span class="string">&#x27;请求失败&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面这里的函数是请求失败，http状态码是 4xx 5xx</span></span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>?.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理401错误</span></span><br><span class="line">      <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">      store.<span class="title function_">delUser</span>()</span><br><span class="line">      router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><p>如果需要移除拦截器，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>面向面试开发的感觉，这些东西平日用的太顺手，整理出来甚至也不算细究，只是调用别人的工具方法。</p><p>但是在面试时候问出来，真是有一种。。。。无趣的感觉。</p><p>累了，这次单纯是为了面试整理了一下知识点，后续大概不会持续关注这种工具方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-17">一文熟悉Ajax</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解ajax</title>
      <link href="/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/"/>
      <url>/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/</url>
      
        <content type="html"><![CDATA[<p>面试官：ajax是什么？我：啥？这不是JQuery封装的工具方法吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，模拟面试那时候，什么刁钻的问题几乎都接触过，用这种远古问题拷打我，真是。。。绝了。</p><p>我还没答上来，真是，绝妙。</p><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX 代表异步的 JavaScript 和 XML（<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML）。</p><p>简单点说，就是使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象与服务器通信。它可以使用 JSON、XML (Extensible Markup Language)、HTML 和文本文件等格式发送和接收数据</p><p>AJAX 最吸引人的就是它的<code>异步</code>特性，也就是说它可以在<strong>不重新刷新页面</strong>的情况下与服务器通信、交换数据或更新页面</p><p>整个流程很简单，如下</p><ol><li>创建一个XMLHttpRequest对象，发送异步请求HttpRequest</li><li>服务器通过网络，接收HttpRequest请求，返回请求数据</li><li>浏览器通过网络，接收服务器返回的数据，用JS操作DOM更新页面</li></ol><p>为避免混淆，这里重新梳理一下 Ajax 概念：</p><ol><li>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</li><li>AJAX <strong>不是编程语言</strong>，而是一种基于现有标准的新方法</li><li>AJAX 最大的优点是在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并更新部分网页内容</li><li>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。</li><li><strong>XMLHttpRequest 只是实现 Ajax 的一种方式</strong></li></ol><p><strong>总的来说，AJAX是浏览器与服务器进行数据通信的技术</strong></p><h3 id="AJAX实现"><a href="#AJAX实现" class="headerlink" title="AJAX实现"></a>AJAX实现</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL (Uniform Resource Locator) 统一资源定位符（统一资源定位器、定位地址、URL地址）俗称地址，是因特网上标准的资源的地址，如同在网络上的门牌，用于访问网络上的资源</p><p>URL组成：URL 由<strong>协议</strong>、<strong>域名</strong>、<strong>资源路径</strong>组成</p><ul><li>协议：URL 使用 http 协议（超文本传输协议），规定浏览器与服务器之间传输数据的格式</li><li>域名：标记服务器在互联网中的方位</li><li>资源路径：标记资源在浏览器下的具体位置</li></ul><p>比如，我们这里架假设要去访问百度网站上的一份文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/test/helloworld.txt</span><br></pre></td></tr></table></figure><p>这里我们将上述url拆分一下，结果如下</p><table><thead><tr><th>访问协议</th><th>服务器名称：域名</th><th>目录名</th><th>文件名</th></tr></thead><tbody><tr><td>http:</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td><td>test</td><td>helloworld.txt</td></tr></tbody></table><p>域名这里如果细说，还要提到IP和端口，这里暂时先跳过，下期再说。</p><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><h5 id="XHR概念"><a href="#XHR概念" class="headerlink" title="XHR概念"></a>XHR概念</h5><p><code>XMLHttpRequest</code>（XHR）对象<strong>用于与服务器交互</strong>。</p><p>通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL 来获取数据。</p><p>这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p><p><code>XMLHttpRequest</code> 在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX">AJAX</a> 编程中被大量使用，所有现代浏览器均支持 XMLHttpRequest 对象</p><p><code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML，它甚至支持 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:&#x2F;&#x2F; 和 FTP），尽管可能受到更多出于安全等原因的限制</p><h5 id="XHR使用"><a href="#XHR使用" class="headerlink" title="XHR使用"></a>XHR使用</h5><p>实现 <code>Ajax</code>异步交互需要完成以下步骤：</p><ul><li>创建 <code>XMLHttpRequest</code> 对象</li><li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li><li>构建请求所需的数据内容，并通过<code> XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li><li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>readystatechange、loadend</code> 事件监听服务器端的通信状态</li><li>接受并处理服务端向客户端响应的数据结果</li><li>将处理结果更新到 <code>HTML</code>页面中</li></ul><h5 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h5><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法</p><p><strong>open()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务器建立连接</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>method</td><td>表示当前的请求方式，常见的有 <em>GET</em>、<em>POST</em></td></tr><tr><td>url</td><td>服务端地址</td></tr><tr><td>async</td><td>布尔值，表示是否异步执行操作，默认为 <em>true</em>(异步)</td></tr><tr><td>user</td><td>可选的用户名用于认证用途；默认为 <em>null</em></td></tr><tr><td>password</td><td>可选的密码用于认证用途，默认为 <em>null</em></td></tr></tbody></table></li></ul><p><strong>send()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body为 XHR 请求中要发送的数据体(string)，如果不传递数据则为 null</span></span><br><span class="line">xhr.<span class="title function_">send</span>([body])</span><br></pre></td></tr></table></figure></li></ul><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p><p>每当 readyState 改变时（存有 XMLHttpRequest 状态信息）就会触发 readystatechange 事件</p><p>以下是 XMLHttpRequest 对象的三个重要的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</td></tr><tr><td>readyState</td><td>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200：”OK”，404：未找到页面</td></tr></tbody></table><blockquote><p>readystatechange 事件被触发四次，分别是：0-1、1-2、2-3、3-4，对应着 readyState 的每个变化</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span> ) &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>获取 XMLHttpRequest 响应体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readBody</span>(<span class="params">xhr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!xhr.<span class="property">responseType</span> || xhr.<span class="property">responseType</span> === <span class="string">&quot;text&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseText</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">responseType</span> === <span class="string">&quot;document&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseXML</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">response</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XHR使用示例"><a href="#XHR使用示例" class="headerlink" title="XHR使用示例"></a>XHR使用示例</h5><ul><li>GET 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://xxxx.com/xxx/xxx?参数名1=值1&amp;参数名2=值2&#x27;</span>) </span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POST请求，要设置请求头，请求体携带JSON字符串</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://xxx/api/register&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><h3 id="相关概念拓展"><a href="#相关概念拓展" class="headerlink" title="相关概念拓展"></a>相关概念拓展</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>但在以下情况中，请使用 POST 请求：</p><ul><li>不愿使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><p>常见 GET 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/try/ajax/demo.php?fname=Henry&amp;lname=Ford&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><p>常见 POST 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo.php&quot;</span>,<span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>POST 方式发送数据，需要设置请求头，并且使用<code>send</code>方法传递参数</p></blockquote><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><code>Content-Type</code>是 HTTP 头部字段之一，用于指示请求或响应消息的媒体类型</p><p>以下是常见的<code>Content-Type</code>格式：</p><ul><li><code>application/json</code>：用于传输 JSON 格式的数据</li><li><code>application/xml</code>：用于传输 XML 格式的数据</li><li><code>text/plain</code>：纯文本格式，通常用于普通文本文件</li><li><code>text/html</code>：用于传输 HTML 格式的数据</li><li><code>image/jpeg, image/png, image/gif</code>：用于传输图像数据</li><li><code>multipart/form-data</code>：通常用于上传文件，表单数据会被编码成一系列的部分</li><li><code>application/x-www-form-urlencoded</code>：通常用于发送表单数据，数据会被编码为键值对的形式（表单默认的提交数据的格式）</li></ul><p>在 HTTP 协议中，如果未明确指定 <code>Content-Type</code> 头部字段，默认值取决于请求或响应的具体情况：</p><ul><li><strong>对于请求（Request）</strong><ul><li>对于常见的表单提交，即 <code>application/x-www-form-urlencoded</code></li><li>对于通过表单上传文件的情况，即 <code>multipart/form-data</code></li></ul></li><li><strong>对于响应（Response）</strong><ul><li>如果服务器响应包含实际的数据，而不仅仅是一条状态码和头部字段，则常见的默认值为 <code>application/octet-stream</code>，表示二进制流，没有指定具体的数据类型</li></ul></li></ul><p>HTTP 协议规范允许在请求和响应中都不设置 <code>Content-Type</code> 头部字段。</p><p>在这种情况下，接收方可能需要根据上下文来猜测数据的类型，这可能引入一些不确定性。</p><p>推荐在请求和响应中显式地设置 <code>Content-Type</code> 头部字段</p><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>Ajax 操作往往用来传递表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单，特别适用于发送包含文件上传等复杂数据的请求</p><p>使用 FormData 可以执行以下步骤：</p><ul><li>创建一个 FormData 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br></pre></td></tr></table></figure><ul><li>向 FormData 对象中添加字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>添加文件类型的字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件输入框中获取选中的文件, 可以根据实际情况选择获取文件的方式</span></span><br><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>将 FormData 对象作为请求的 body 或附加到 XMLHttpRequest 或 fetch 等发送请求的方法中：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/api/endpoint&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(formData)</span><br></pre></td></tr></table></figure><p>以上就将 FormData 数据作为请求的一部分发送给服务器端了</p><p>注意事项：</p><ul><li>当使用 FormData 时，浏览器会自动设置适当的 <code>Content-Type</code> 头部，无需手动设置</li><li>FormData 也支持删除字段和追加相同字段名的多个值等操作，请根据需求使用相应的方法</li></ul><blockquote><p>FormData 对象其他方法参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">MDN-FormData</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说实话，早年就以为这东西是jquery封装的，结果上次模拟面试被狠狠拷打了一波。</p><p>虽然这种远古问题不应该算是关注范围以内的东西了，但是有备无患，这里记录一下。</p><p>2024年了，我居然又翻到ajax了，真是。。绝了。</p><p>这两天把ajax，axios，fetch相关的请求方式全整理一遍，不然面试还真有点发憷。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817?searchId=2024050820515495FC5659A1B7863EB72F">一文熟悉Ajax</a></p><p><a href="https://developer.mozilla.org/zh-CN/">MDN-CN</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决github提交代码端口报错的问题</title>
      <link href="/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>癞蛤蟆趴脚上，不咬人膈应人，这事能出问题，国内这个网络环境全责，这狗屎一样的网络环境真是一言难尽。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天写完博客，提交代码的时候正好遇到这个问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><p>这里简单翻译一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh:连接到主机github.com端口22:连接超时</span><br></pre></td></tr></table></figure><p>常规的做法无非就是挂加速器或一些梯子，但是好巧不巧，今天梯子到期了。</p><p>于是只能连夜翻CSDN，结果屎里淘金找了半个小时也没有几个靠谱的解法，好在掘金论坛翻到了一个不错的解决方案。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>出现这个问题，很可能是你的网络供应商（比如广电网）在出口防火墙上屏蔽了22端口（本地使用vpn等代理服务），这意味着你将无法访问其他主机的22端口。</p><p>github提供了一种解决方案，允许你使用<strong>443端口进行ssh连接</strong>。</p><p>因为443端口是访问<strong>https网站</strong>所必须的，大部分防火墙都会允许通过，但如果使用<strong>代理服务器</strong>可能产生干扰。</p><h3 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h3><p>我这里使用gitbash命令行工具，不推荐使用powershell和cmd，因为win的权限和创建文件的命令太难背。</p><p>这里我的电脑是win11，默认大家存放的公钥的文件都在ssh文件夹下。</p><p>首先，我们切换到ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>然后，若是没有文件config，我们这里新建一个config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure><p>config文件需要手动添加如下内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port <span class="number">443</span></span><br><span class="line"><span class="keyword">User</span> git</span><br></pre></td></tr></table></figure><p>之后，继续在gitbash中，写入如下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>命令行在这里会提示你确定是不是要这么做，你选yes就行。</p><p>因为这是为了让每次ssh连接github都通过443端口，指明ssh连接<code>git@github.com</code>或<code>git@ssh.github.com</code>走443端口</p><p>最后，重新执行，检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果命令行中有success等字样，那就代表修改成功了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这虽然是个简单的修改方式，但是没想到国内传统的技术论坛就没几个靠谱的解法。</p><p>为了防止下一次再次翻车，这里必须得写一下了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7325627349080424457?searchId=20240507230033784D20BC75A8A6B6BB11">解决git push提交超时问题ssh: Connection timed out</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解6种接口请求的方式</title>
      <link href="/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模拟面试题，今天刷到了，我除了知道传参方式略有不同之外，什么也回答不上来。</p><p>干了这么多年的前端，不知道这个，说实话，有点汗颜。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作。</p><h3 id="六种方式"><a href="#六种方式" class="headerlink" title="六种方式"></a>六种方式</h3><ol><li>Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）</li><li>Post 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改</li><li>Put 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）</li><li>Delete 请求服务器删除request-URL所标示的资源（请求服务器删除页面）</li><li>Head 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的响应中没有具体内容，用于获取报头）</li><li>opions 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许客户端查看服务器性能）</li></ol><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET一般用于获取&#x2F;查询资源信息。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>post向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改。</p><p>post请求一般通过body传递参数。</p><p>包括一些文件上传什么的，常用这种请求类型。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>这个方法比较少见,HTML表单也不支持这个，常见的工作任务中，多数后端都更远已使用post来取代put。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><p>就是说，put是更在更新服务器上已经存在的数据。</p><p>举个例子：如一个用于提交博文的URL，&#x2F;addBlog。如果用PUT，则提交的URL会是像这样的”&#x2F;addBlog&#x2F;abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。</p><p>目前大部分博客都是这样的，显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除某一个资源。</p><p>因为目前大多数公司业务删除都是伪删除，所以这种类型的请求很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。</p><p>有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。</p><p>若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一度以为接口常见的请求方式就四种，如果不是今天刷面试题，还真不清楚这个冷知识，也是颇为长见识了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6899465311712935949?from=search-suggest">接口请求的六种常见方式详解（get、post、head等）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年生活规划</title>
      <link href="/2024/04/27/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/"/>
      <url>/2024/04/27/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>完成 2023 年没搞定的任务，并继续人生新目标。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>2023 年规定的事，只完成了一半，有点尴尬。</p><p>不过，好在也是折腾出来打了一些东西，所以不算太过尴尬，这里继续去年的计划，开始新一轮的新年计划。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>前几年工作的积蓄消耗了一些，赶上家里出事，又赶上市场暴死，幸亏还有点技术底子，不然现在真是不知道要怎么干。</p><p>如今找到了一份勉强糊口的清闲工作，于是打算趁这段时间好好规划，这是 30 之前的最后一年了，如果规划好，35 之前的卖身日子应该还是有救的。</p><ol><li><del><strong>简单掌握 nodejs，并简单写两个项目作为自己可以展示的私人项目来做护城河。</strong></del></li><li><del><strong>简单掌握 JAVA，完成一个像样的后台管理系统</strong>（放弃）</del></li><li><strong>维护自己的开源工具 cat-tools，完成去年未做完的事情</strong></li></ol><h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>去年减重太过反复，虽然中间削低谷时期削弱到了 90KG 级左右，但是之后因为冬季，运动量骤减，最终体重快速反弹。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><strong>本年目标恢复 75KG 级体重</strong></li><li>作息稳态化，不要像去年那样容易被打乱</li><li>身体内分泌常规化，尽量摆脱药物，将<del>高血压</del>高血脂控制再常规水平之下</li><li>调理腰椎和皮肤</li></ol><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ol><li>严格控制摄入量，每天不要摄入大量碳水，<del>每月最多一餐油炸类食物</del>。</li><li><strong><del>控制饮料，减少碳酸类等饮料的摄入</del></strong></li><li><strong><del>作息从轮班换成常规作息</del>，晚上 11 点之前能不依赖药物睡着</strong></li><li><strong><del>能够进行 5 公里快速长途骑行</del>，时速能拉到 18 左右最好</strong></li><li>能够进行<strong>简单的游泳</strong>（冬季）</li><li>经常进行腰椎和皮肤的调理，并长期使用工学椅</li></ol><h4 id="年末总结"><a href="#年末总结" class="headerlink" title="年末总结"></a>年末总结</h4><p>今年总体来说，并没有什么突破，不过身体这种事，随着年龄的增大，总是会越来越坏。</p><ol><li>油炸食品的摄入解决了一半，现在几乎不吃麻辣烫或者烧烤这种重油重盐的东西，但是因为工作不稳定，目前只能吃猪脚饭，依然还是偏油腻。</li><li>控制碳酸饮料的摄入，这个倒是解决了，因为没钱，所以很多时候嘴馋也不敢买。</li><li>应该是作息间歇性规律，熬夜的坏习惯每个月时不时会自动重发。</li><li>锻炼这个问题倒是因为居住地不近不远，勉强解决了，可喜可贺，但是目前没钱，一直用的是共享单车，真闹心啊。</li><li>待定，因为居住地年后可能会更换，至少要有个人厨房，方便做饭，不然没法节省开支</li><li>因为新的工作点似乎不太合适搞个性化的办公环境，所以没换椅子，腰椎和皮肤也一直没管。</li></ol><p>完成度只能算是25%左右吧，身体这块今年投入的时间资源还是不够，后续需要加大投入。</p><h3 id="学历"><a href="#学历" class="headerlink" title="学历"></a>学历</h3><p>由于去年各种糟心事太多，自考这点除了去年一开始还在正轨，后来完全脱轨，生活的种种琐事硬是冲断了自己的计划。</p><p>因为种种缘故，原定的八门课程，去年拢共就考了一门，真是太过操蛋。</p><p>而今年也因为找工作的缘故，4 月份的自考也没能花时间去准备，一切真是糟糕。</p><p>今年如果再次被打断，我就不考虑走大自考路线了，直接放弃证道，选择最 low 的成人高考模式，毕竟这些东西本质上就是弄个证书。</p><p>因今年考试计划变动，这里按照新版考试计划重新规划，过渡期无法按照原有的课表进行考试，只能按照新版来了。</p><table><thead><tr><th>开考时间</th><th>课程</th><th>备注原因</th></tr></thead><tbody><tr><td>10-26 上午 9：00 -11：30</td><td>02324 离散数学</td><td>必考</td></tr><tr><td>10-26 上午 14：30 -17：00</td><td>00023 高数</td><td>必考</td></tr><tr><td>10-27 上午 9：00 -11：30</td><td>04735 数据库系统原理</td><td>必考</td></tr><tr><td>10-27 上午 14：30 -17：00</td><td>00898 互联网软件与应用开发</td><td>新版新增</td></tr></tbody></table><h4 id="年末总结-1"><a href="#年末总结-1" class="headerlink" title="年末总结"></a>年末总结</h4><p>以上四门今年一个都没过，因为频繁找工作，导致时间的地点不稳定，进而无法固定时间去做事。</p><p>这次索性报了个简单的小自考，先简单弄个证书再说，后续再考虑别的事。</p><p>学历今年是一点都没推进，只能用小自考缓冲一下未来计划了。</p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>去年接触了 nas 之后，知识体系走的有点偏，今年为了工作，重新矫正一下知识体系。</p><ol><li><p><del><strong>补全前端的更底层知识体系，有时候还真是架不住面试官问的太深层。</strong></del></p></li><li><p><strong>较为纯熟的掌握 nestjs，自主开发一套小型的后端管理平台</strong></p></li><li><p>初步掌握<code> nuxt3js</code>，对外整理出一套开源博客类的前端项目</p></li></ol><h4 id="年末总结-2"><a href="#年末总结-2" class="headerlink" title="年末总结"></a>年末总结</h4><ol><li>前端知识体系算是补全了9成以上，八股文这块，下次如果再问，基本上能在一个月左右完成复健</li><li><code>nest.js</code>虽然没有较为纯属的学习，但是通过<a href="https://github.com/taozhi1010/nest-admin">nest-admin</a>，配合掘金小册，初步能够掌握基础的增删改查，并简单的整合了一些后端的基础知识。</li><li>因为有了<code>nuxt2</code>的底子，所以<code>nuxt3</code>用起来并不麻烦，在最初的适应期之后，事情变得简单了很多，不是我适应性不强，而是官网提供的<code>demo</code>实在太过烂，导致学习进度推得奇慢无比。</li></ol><p>总之，今年唯独在知识这块，执行力大大提升，大概是因为生活和面试的反复捶打，推进的异常迅速。</p><p>这块的执行力基本上拉满，把以前没注意到的边边角角都扫了一遍，有点超期完成了。</p><p>就是在开源项目上，太过消耗心力，经常改个简单的问题就得消耗大概几个小时（需要测试），如果能有个同好和自己一起组团做事，事情可能会方便很多。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong>写一本小说，先存稿 60 万字，将去年想到的一些思路进行整合</strong>，10 月份过后，试试水。</li><li>在身体恢复正常后，尝试相亲或者恋爱，太久没和女人接触了，感觉人有点不正常</li><li>每月拜一拜关二爷。</li></ol><p>书么，写了进30万字之后，只能写写设定，之后再也没时间写了。</p><p>女人么，是一点没接触的，这段时间工作虽然清闲，但自己的日程排的很满，再加上如今条件困苦，实在没那个心力去照顾别人的心思了。</p><p>关二爷也没法拜了，按照传统，总不能让关二爷的像供在卧室里，这太不敬了。</p><p>总之，自己希望的这点闲杂事项，是一点都没做，可能得等到什么时候闲着了，才能再做那些有的没的。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>读一些已经读过的书，以如今的心境，会有一些不一样的感觉。</p><ol><li>《南明史》</li><li>《三体》</li></ol><h4 id="年末总结-3"><a href="#年末总结-3" class="headerlink" title="年末总结"></a>年末总结</h4><p>书是一点儿都没看，因为时政比书精彩多了，关于今年的时政，后续年末大概会单独开篇写一下，记录这颇为戏剧的一年。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>去年规划的太过满了，再加上平日琐事太多，规划的任务大部分未能完成（尴尬，吹牛吹爆了）。</p><p>但是，至少留下了一些可供参考的路径，今年努把力，把去年没做完的地方补全，尤其是身体和学历这方面。</p><p>今年规划至少满足了部分，明年大概会以生活为主，技术偏辅，毕竟生活状态现在算是稳定下来了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 年计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年的第一份offer</title>
      <link href="/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/"/>
      <url>/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/</url>
      
        <content type="html"><![CDATA[<p>终于找到工作了，但只是暂时安全了，种种巧合让我有种无力的宿命感，我不信命，但是不得不承认世事的无常。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，相对于整个前端的技术栈来说，我这点水平，属实有点鸭子睁眼，大可不必了。</p><p>找了这么久，什么样的技术栈都见过了，但是头一回遇到把我手里的技术栈近乎清零的公司了。</p><p>我会的是vue全家桶，这家公司的招人要求，除了是vue全家桶之外，别的几乎和我没什么交集，简直他妈的离谱。</p><p>我从来不注重性能，全面专注业务领域的，所以深层代码实现了解的较浅，但他们问的还都挺深，看上去和我有点犯冲。</p><p>不过，这几天面试下来，我也习惯从拷打面试官变成被拷打的一方了。</p><p>前端现在太广了，谁都不敢说自己事事精通。</p><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>在正式接面试的时候，看公司规模，0-20人，以为又是一家垃圾小公司，结果到地方一看就被镇住了。</p><p>妈的，是正儿八经的玩无人机的，而且型号还挺多，看着不像是胡闹的。</p><p>不仅有各式各样的无人机，开发人员也很年轻，很有年轻人的朝气，和我这种时代中浪迹的老油条完全是两个画风，不的不感叹，年轻真好。</p><p>现在想来，开在闹市区的CBD里边，注册资金1000万的级别，稍微想了一下，这感觉怎么也不像是普通公司，能在徐州招人用vue3+ts的公司，想来也是一朵奇葩（褒义）。</p><p>毕竟，我都在徐州面试使用jquery的岗位了（丢人的是还没面过），那我还能说什么呢。</p><p>跑了数家公司，见识了各种光怪陆离的情况，现在这家公司的情况，反而算是正常甚至有些优秀的画风了。</p><p>不得不说，我的认知滤镜第一时间给出了错误的判断，在到了现场之后，就表面看上去，这家公司看着确实是挺有实力的。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>这次基本上是我被拷打了。</p><p>说实话，我vue的底层原理除了早些年为了跳槽准备的时候仔细准备过，现在几乎都很难捡起来了。</p><p>然后传统的网络原理及网络安全这块，我几乎就没戏唱了，因为我只能说浅层次的涉猎，但是深入的问我的话，我几乎都不能准确而全面的回答上来。以前都是做的TOB或者TOG的项目，谁有胆子去入侵别人内网搞事情？</p><p>网络安全这块的认知，我几乎就是憨憨，我连SQL注入的手法都玩不明白。</p><p>你不能指望一个平时连放置个人网站都用傻瓜教程的家伙去深层次探秘。</p><p>之后是视频直播这块，我这里就更尴尬了，我对视频直播的了解，仅限于nas相关的那些东西，上传带宽+硬解码暴打一切不服，别的几乎没有任何方案了，就这么个认知，我也没法回答上来啥。</p><p>然后是地图，早些年确实基于百度开发的vueAmap做过一些浅层的标识放置，现在告诉我，他们这里觉得地图麻烦，打算自己整地图引擎。</p><p>嘶。。。。</p><p>一种油然而生的不妙感。</p><p>业务，是我不熟悉的领域，以前的业务经验基本上就算是打了折扣了。</p><p>技术，视频直播，地图开发，网站安全，这三相之力几乎全部都是软肋，任何其中一项技能都是一个肉眼可见的天坑。</p><p>这次的面试，基本上是我单方面被暴打。</p><p>不过，好在也算是快人快语，事情当场就给了结果，我周日就可以先去试岗，先试一周看看。</p><p>虽然面试被拷打，然后感觉上自己可能撑不过试岗，但是无人机真的很酷炫，能靠过去凑凑热闹也不错。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>如果未来能顺利通过试用期，入职的话，倒是会深入考虑深入看看视频相关的技术手段，网络安全这块应该也会考虑一下，至于3D这块，不太敢考虑。</p><p>毕竟，那玩意是出了名的投入大，回报少，我如今青春的时间不是很多了，不是很乐意去研究相关的技术。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新公司虽然给的薪资不算太多，但是总算是有点意思了，确实比长久不变的业务线有趣的多，就是不知道自己能不能扛下来。</p><p>本来都打算脱下长衫去送外卖了，但是偏偏命运垂青，给了一点点足够转机，我愿意试试看。</p><p>如果不成，那我大概率是真不适合这行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解重绘和重排(回流)</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%EF%BC%88%E5%9B%9E%E6%B5%81%EF%BC%89/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%EF%BC%88%E5%9B%9E%E6%B5%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这是上海某次面试中的问题，说实话，我这个VueBoy还真不清楚这块的基础，这里整合一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文主要面向面试，所以先挑干的说，然后再细讲原理。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="重排或回流（Reflow）"><a href="#重排或回流（Reflow）" class="headerlink" title="重排或回流（Reflow）"></a>重排或回流（Reflow）</h4><p>当render树中的一部分或者全部因为大小边距等问题发生改变而<strong>需要DOM树重新计算</strong>的过程</p><h5 id="产生重排的场景"><a href="#产生重排的场景" class="headerlink" title="产生重排的场景"></a>产生重排的场景</h5><ul><li>页面渲染初始化，这是开销最大的一次重排</li><li>添加或者删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变，边距、填充、边框、宽度和高度</li><li>元素内容改变，如文本改变或者图片大小改变而引起的计算值宽度和高度改变</li><li>元素字体大小 改变</li><li>浏览器窗口尺寸改变，resize事件发生时</li><li>CSS伪类激活，如hover</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><h5 id="重排影响的范围"><a href="#重排影响的范围" class="headerlink" title="重排影响的范围"></a>重排影响的范围</h5><p>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h4 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a>重绘（Repaint）</h4><p>元素的一部分属性发生改变，如外观、背景、颜色等<code>不会引起布局变化</code>，只需要浏览器根据元素的新属性<strong>重新绘制</strong>，使元素呈现新的外观叫做重绘。</p><h5 id="产生重绘的场景"><a href="#产生重绘的场景" class="headerlink" title="产生重绘的场景"></a>产生重绘的场景</h5><ul><li><code>设置背景图片</code></li><li><code>修改字体颜色及样式</code></li><li><code>改变 visibility 属性值</code></li><li><code>设置box盒子阴影</code></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="页面生成"><a href="#页面生成" class="headerlink" title="页面生成"></a>页面生成</h4><ol><li>HTML 被 HTML 解析器解析成 DOM 树</li><li>CSS  被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制(paint)在屏幕上，显示出整个页面</li></ol><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h4 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h4><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h4 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h4><h5 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h5><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">left</span> = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">cssText</span> += <span class="string">&quot;; left: &quot;</span> + left + <span class="string">&quot;px; top: &quot;</span> + top + <span class="string">&quot;px;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.<span class="property">className</span> += <span class="string">&quot; className&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h5><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h5 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h5><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h5 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h5><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h5 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h5><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 根据上面的结论</span></span><br><span class="line"><span class="comment">  * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">  * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">  * 提高动画性能</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  div &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate3d</span>(10px, 10px, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在浏览器中查看页面渲染时间"><a href="#在浏览器中查看页面渲染时间" class="headerlink" title="在浏览器中查看页面渲染时间"></a>在浏览器中查看页面渲染时间</h3><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。</p><ul><li>loading: 网络通信和HTML解析</li><li>scripting: JavaScript执行</li><li>Rendering: 样式计算和布局，即重排</li><li>Painting: 重绘</li></ul><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。</p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>渲染的三个阶段 Layout，Paint，Composite Layers。 </p><p>Layout：重排，又叫回流。 </p><p>Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 </p><p>Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</p><p>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>太久远的知识了，回顾了一下大佬的总结，感觉真是一种难得的有趣体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904083212468238?searchId=20240422171513D3B4751FC9432336560C">重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6938376882005999646?searchId=20240422171235DF23177183B7AA3806A2#heading-1">CSS 重绘（Repaint）、重排（回流）(reflow) - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解http常用状态码</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>工作中不常用，而面试题常考。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1XX（临时响应）"><a href="#1XX（临时响应）" class="headerlink" title="1XX（临时响应）"></a>1XX（临时响应）</h3><ul><li>100 <code>Continue </code>继续。客户端应继续其请求</li><li>101  <code>Switching Protocols </code>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul><hr><h3 id="2XX（成功）"><a href="#2XX（成功）" class="headerlink" title="2XX（成功）"></a>2XX（成功）</h3><ul><li>200 <code>OK</code> 请求成功。一般用于<code> GET</code> 与 <code>POST</code> 请求</li><li>201 <code>Created</code> 已创建。成功请求并创建了新的资源</li><li>202 <code>Accepted</code> 已接受。已经接受请求，但未处理完成</li><li>203 <code>Non-Authoritative Information</code> 非授权信息。请求成功。但返回的 <code>meta </code>信息不在原始的服务器，而是一个副本</li><li>204 <code>No Content </code>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 <code>Reset Content </code>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 <code>Partial Content </code>部分内容。服务器成功处理了部分 <code>GET</code> 请求</li></ul><hr><h3 id="3XX（重定向）"><a href="#3XX（重定向）" class="headerlink" title="3XX（重定向）"></a>3XX（重定向）</h3><ul><li>300 <code>Multiple Choices </code>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 <code>Moved Permanently</code> 永久移动。请求的资源已被永久的移动到新 <code>URI</code>，返回信息会包括新的 <code>URI</code>，浏览器会自动定向到新 <code>URI</code>。今后任何新的请求都应使用新的<code>URI</code>代替</li><li>302 <code>Found </code>临时移动。与 <code>301 </code>类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 <code>See Other</code> 查看其它地址。与<code> 301</code> 类似。使用 <code>GET</code> 和<code>POST</code>请求查看</li><li>304 <code>Not Modified</code> 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>305 <code>Use Proxy</code> 使用代理。所请求的资源必须通过代理访问</li><li>306 <code>Unused </code>已经被废弃的<code> HTTP</code> 状态码</li><li>307 <code>Temporary Redirect</code> 临时重定向。与 <code>302</code> 类似。使用 <code>GET </code>请求重定向</li></ul><hr><h3 id="4XX（请求错误）"><a href="#4XX（请求错误）" class="headerlink" title="4XX（请求错误）"></a>4XX（请求错误）</h3><ul><li>400 <code>Bad Request</code> 客户端请求的语法错误，服务器无法理解</li><li>401 <code>Unauthorized</code> 请求要求用户的身份认证</li><li>402 <code>Payment Required </code>保留，将来使用</li><li>403 <code>Forbidden</code> 服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404 <code>Not Found </code>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>405 <code>Method Not Allowed</code> 客户端请求中的方法被禁止</li><li>406 <code>Not Acceptable</code> 服务器无法根据客户端请求的内容特性完成请求</li><li>407 <code>Proxy Authentication Required</code> 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权</li><li>408 <code>Request Time-out</code> 服务器等待客户端发送的请求时间过长，超时</li><li>409 <code>Conflict</code> 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</li><li>410 <code>Gone </code>客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</li><li>411 <code>Length Required</code> 服务器无法处理客户端发送的不带<code> Content-Length</code> 的请求信息</li><li>412 <code>Precondition Failed</code> 客户端请求信息的先决条件错误</li><li>413 <code>Request Entity Too Large</code> 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个<code> Retry-After</code> 的响应信息</li><li>414 <code>Request-URI Too Large </code>请求的 <code>URI</code> 过长（<code>URI</code> 通常为网址），服务器无法处理</li><li>415 <code>Unsupported Media Type</code> 服务器无法处理请求附带的媒体格式</li><li>416 <code>Requested range not satisfiable</code> 客户端请求的范围无效</li><li>417 <code>Expectation Failed</code> 服务器无法满足<code>Expect </code>的请求头信息</li><li>429  <code>Too Many Requests</code> 请勿频繁操作</li></ul><hr><h3 id="5XX（服务器错误）"><a href="#5XX（服务器错误）" class="headerlink" title="5XX（服务器错误）"></a>5XX（服务器错误）</h3><ul><li>500 <code>Internal Server Error</code> 服务器内部错误，无法完成请求</li><li>501 <code>Not Implemented </code>服务器不支持请求的功能，无法完成请求</li><li>502 <code>Bad Gateway</code> 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 <code>Service Unavailable</code> 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 <code>Retry-After </code>头信息中</li><li>504 <code>Gateway Time-out </code>充当网关或代理的服务器，未及时从远端服务器获取请求</li><li>505 <code>HTTP Version not supported</code> 服务器不支持请求的 <code>HTTP </code>协议的版本，无法完成处理</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基本上属于面试题不考的类型，但是经常会遇到，所以这里整理一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7030428038953173029?searchId=202404221657433AF2988FD33492318F90">一篇梳理http返回的状态码 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解http与https的区别</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>http与https的区别是什么，今天看到群里有回答是复数的，一时间有点没绷住。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>早些年做个人网站，简单了解了相关知识，但是不够深入，这里整理一下。</p><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><h4 id="HTTP-定义"><a href="#HTTP-定义" class="headerlink" title="HTTP 定义"></a>HTTP 定义</h4><p>超文本传输协议（HTTP）是万维网使用的底层协议，它规定了消息如何被格式化和传输，以及网络服务器和浏览器应当如何回应各种命令。</p><h4 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h4><p>通常，HTTP的工作流程如下：</p><ol><li><strong>发起请求</strong>：在浏览器中输入URL或点击链接后，浏览器向对应的服务器发起资源请求。</li><li><strong>服务器响应</strong>：服务器处理接受到的请求并返回资源和HTTP头。</li><li><strong>建立连接</strong>：在HTTP老版本中，每次请求需要建立一个新的连接，造成了延迟。为了解决这个问题，在新的版本中提出了持久连接。</li><li><strong>资源渲染</strong>：浏览器接收到资源后开始解析并展示。</li></ol><h4 id="HTTP-的局限性"><a href="#HTTP-的局限性" class="headerlink" title="HTTP 的局限性"></a>HTTP 的局限性</h4><p>HTTP在状态无关、安全性、性能、数据传输大小等方面存在局限性。</p><h3 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h3><h4 id="了解-HTTPS"><a href="#了解-HTTPS" class="headerlink" title="了解 HTTPS"></a>了解 HTTPS</h4><p>安全超文本传输协议（HTTPS），即HTTP的安全版本，使用类似TLS或SSL的加密协议，加固客户端和服务器之间的连接。</p><h4 id="HTTPS-与-HTTP-的对比"><a href="#HTTPS-与-HTTP-的对比" class="headerlink" title="HTTPS 与 HTTP 的对比"></a>HTTPS 与 HTTP 的对比</h4><p>与HTTP以明文传送数据不同，HTTPS通过加密保护传输的数据，确保通讯过程的安全与数据在传递过程中不被篡改。</p><h4 id="HTTP-与-HTTPS-的六大不同"><a href="#HTTP-与-HTTPS-的六大不同" class="headerlink" title="HTTP 与 HTTPS 的六大不同"></a>HTTP 与 HTTPS 的六大不同</h4><ol><li>加密：HTTPS对数据进行加密，确保沟通的保密性。</li><li>数据完整性：HTTPS检验数据传输中未被修改。</li><li>身份验证：通过SSL证书，HTTPS可以验证服务器身份，防中间人攻击。</li><li>安全水平：与HTTP相比，HTTPS提供了更高的安全性。</li><li>端口定义：HTTPS默认使用443端口，而HTTP使用80端口。</li><li>URL模式：HTTPS的URL以 <code>https://</code> 开头，而HTTP则是 <code>http://</code>。</li></ol><table><thead><tr><th>特性</th><th>http</th><th>https</th></tr></thead><tbody><tr><td>加密</td><td>无</td><td>使用TLS&#x2F;SSL协议加密数据包</td></tr><tr><td>安全性</td><td>不安全，数据以铭文形式传输，容易被第三方截取和查看</td><td>安全，使用TLS&#x2F;SSL协议加密的数据包，防止拦截和篡改</td></tr><tr><td>证书</td><td>无</td><td>需要SSL证书，由可信任的证书办法机构（CA）颁发，用于验证服务器的身份</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>url标识</td><td>http:&#x2F;&#x2F;开头</td><td>https:&#x2F;&#x2F;开头</td></tr><tr><td>性能</td><td>通常较高</td><td>可能略低，犹豫加密解密带来的一些 计算开销，但随着技术进步，差异会逐渐缩小</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>连续翻看了几个介绍，发觉都差不多，这里就选了一篇最清楚的文档做了个整合。</p><p>当初弄个人网站的时候，简单了解了这二者的区别，并不深入，如今梳理之后，倒也颇为明晰，也算是小有收获了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7329772404645806099?searchId=2024042215523434CA7F568FA739283956">理解 Web 安全：HTTP 和 HTTPS 的关键区别 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解URL到页面加载的过程</title>
      <link href="/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>好早之前的面试题，最近猛的一问，居然答不上来了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>在页面加载到最终渲染显示大致是这样的：</p><ol><li>用户在浏览器输入URL回车后，浏览器为了将URL解析成IP地址，会向DNS服务器发起DNS查询，获取IP地址。</li><li>在建立连接后，浏览器就可以发起HTTP请求，而服务器接受请求后进行响应，浏览器从响应结果中拿到数据，并进行解析和渲染，</li><li>最后在用户面前就出现了一个网页。</li></ol><p>简而言之就是三个阶段：</p><ul><li>客户端发起请求阶段</li><li>服务端数据处理请求阶段</li><li>客户端页面渲染阶段</li></ul><p>详细一些的说，大致流程如下</p><ol><li>缓存解析地址，判断是否</li><li>DNS解析，（输入的是域名）</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回需要的数据</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>输入了一个域名,域名要通过DNS解析找到这个域名对应的服务器地址(ip),通过TCP请求链接服务,通过WEB服务器(apache)返回数据,浏览器根据返回数据构建DOM树,通过css渲染引擎及js解析引擎将页面渲染出来,关闭tcp连接</p><h3 id="正常分析"><a href="#正常分析" class="headerlink" title="正常分析"></a>正常分析</h3><h4 id="首先在浏览器中输入URL-，缓存解析"><a href="#首先在浏览器中输入URL-，缓存解析" class="headerlink" title="首先在浏览器中输入URL ，缓存解析"></a>首先在浏览器中输入URL ，缓存解析</h4><p>浏览器先在缓存里找资源，浏览器缓存-系统缓存-路由缓存（如CDN缓存）中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><p>浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</p><h5 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h5><p>如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</p><h5 id="路由器缓存"><a href="#路由器缓存" class="headerlink" title="路由器缓存"></a>路由器缓存</h5><p>如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</p><h5 id="ISP（互联网提供服务商）缓存"><a href="#ISP（互联网提供服务商）缓存" class="headerlink" title="ISP（互联网提供服务商）缓存"></a>ISP（互联网提供服务商）缓存</h5><p>若上述均失败，继续向ISP搜索。</p><h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><p>浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。</p><p>DNS服务器是基于UDP的，因此会用到UDP协议。</p><ul><li>DNS(Domain Name System, 域名系统)，是域名和IP地址相互映射的一个分布式数据库</li><li>DNS 解析就是从域名映射到IP地址的过程</li><li>如果有些网站已经访问过了，下次访问时浏览器会依次从浏览器缓存、系统缓存、路由器缓存、ISP缓存、根域名服务器、顶级域名服务器、主域名服务器里面找IP地址，所以下次访问速度更快</li></ul><h4 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h4><p>解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。</p><h5 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a><strong>三次握手过程</strong></h5><p>建立tcp连接就是三次握手，三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号</p><p>第一次，客户端&#x3D;&gt;服务端 客户端向服务器端发送SYN&#x3D;1,代表请求建立连接；还发送seq&#x3D;n是客户端的序列号。</p><p>第二次，服务端&#x3D;&gt;客户端，服务端表名收到请求，发给客户端SYN&#x3D;1,代表同意建立连接，ack&#x3D;n+1，返回客户端序列号加1，代表确认收到信息，同时发送一个自己的序列号，seq&#x3D;x代表服务端序列号。</p><p> 第三次，客户端&#x3D;&gt;服务端 客户端发送SYN&#x3D;0表明开始发送信息，并返回ack &#x3D; x+1确认收到服务端序列号，并发送seq &#x3D; n+1</p><h4 id="发起HTTP请求"><a href="#发起HTTP请求" class="headerlink" title="发起HTTP请求"></a>发起HTTP请求</h4><p>浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器</p><h4 id="服务器响应请求并返回结果"><a href="#服务器响应请求并返回结果" class="headerlink" title="服务器响应请求并返回结果"></a>服务器响应请求并返回结果</h4><p>服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p><h5 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h5><p>通过四次挥手释放TCP连接； 前两次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道。</p><h5 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a><strong>四次挥手过程</strong></h5><p>​    客户端向服务器发送FIN控制报文段（首部中的 FIN 比特被置位）；</p><p>​    服务端收到FIN，回复ACK。服务器进入关闭等待状态，发送FIN;</p><p>​    客户端收到FIN，给服务器回复ACK，客户端进入等待状态（进入“等待”，以确保服务器收到ACK真正关闭连接）;</p><p>​    服务端收到ACK，链接关闭。</p><p><strong>四次挥手原因</strong></p><p> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p><p>TCP是全双工模式，这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；</p><p>但是，这个时候客户端还是可以接受来自服务端的数据；</p><p>当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；</p><p>当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><p>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</p><p> 构建CSS规则树：生成CSS规则树（CSS Rule Tree）</p><p> 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</p><p> 布局（Layout）：计算出每个节点在屏幕中的位置</p><p> 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</p><h5 id="浏览器渲染详细过程"><a href="#浏览器渲染详细过程" class="headerlink" title="浏览器渲染详细过程"></a>浏览器渲染详细过程</h5><p><strong>浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。</strong></p><p>最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，这个内部结构就是 DOM，DOM 提供了对 HTML 文档的结构化表述。渲染进程通过分词器将html字节流成功成一个个 token，包括 Tag token 和文本 token。HTML 解析器维护了一个 token 栈结构，token 会按照对应顺序入栈出栈，然后将 token 解析成 DOM 节点，并将 DOM 节点添加进 DOM 树中。</p><p><strong>异步下载资源文件</strong></p><p>解析过程中，如果遇到&lt; link href &#x3D;＂..＂＞和&lt; script src &#x3D;＂..＂＞这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p><p><strong>渲染样式</strong></p><p>渲染引擎在接受到 CSS 文本时，会将 CSS 生成 CSS对象模型CSSOM(即CSS Object Model) ，通过document.styleSheets可获取所有CSS样式表，然后将 styleSheet 中的属性值进行标准化操作。最后将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 进行渲染。</p><p>最后，渲染过程中，如果遇到＜ script ＞就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待＜ script ＞内容执行完之后，浏览器继续渲染。</p><p>—— <strong>为何要将 CSS 放在 HTML 头部？</strong> —— </p><p>这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM ，然后在解析 HTML 之后可一次性生成最终的RenderTree ，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p><p>—— <strong>为何要将 JS 放在 HTML 底部？</strong> —— </p><p>JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外， JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行， JS 放在底部执行时， HTML 肯定都解析成了 DOM 结构。 </p><p>JS 如果放在 HTML 顶部， JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p><h5 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h5><p>调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><h6 id="创建window对象"><a href="#创建window对象" class="headerlink" title="创建window对象"></a>创建window对象</h6><p>window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</p><h6 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h6><p>完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</p><h6 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h6><p>在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</p><h6 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h6><p>执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个基础知识我能回答，但是细节我答不上太多，稍微显得有点丢人。</p><p>当初面试时候都记得，如今居然都记不得了。</p><p>现在趁着梳理知识体系时候，好好学习一下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7154306280868282381?searchId=20240421211440950468993CA81FC881AA">从输入URL到页面加载的全过程 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年第一次被骗</title>
      <link href="/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/"/>
      <url>/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<p>这次好歹是没什么损失，问题不大，只是有种恶心的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>经过上次被骗的事，对于这类问题，我已经非常敏感了。</p><p>感觉自己化身烙印战士了，在最糟糕的时候，被骗子群体标记了，一旦我有所松懈，就会被这些小鬼缠上，真是麻烦。</p><p>妈的，等以后有钱了，一定要想办法干死这帮搞诈骗的。</p><p>终归是修行不够，贪了，想要个工作的贪欲占了上分，要是不贪，就不会有这么多屁事。</p><p>另外，2024了，连骗子都能对前端面试题说道说道，我真是麻了。</p><p>前端已死真不是随便说说啊。</p><h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><h4 id="陌生人"><a href="#陌生人" class="headerlink" title="陌生人"></a>陌生人</h4><p>昨夜凌晨3-4点，接到一个QQ添加的好友，说是同行，看到我简历不错，想和我私聊。</p><p>昨天夜里是周五，技术下班，第二天有休息，所以有技术人熬夜，这事儿常见。</p><p>稍稍思考一下，我没多想就同意了。</p><p>正好最近找工作找的火大尿黄，于是就先问了这个陌生人的几个前端面试题，没毛病，都能答上来，应该是同行，看样子问题不大。</p><p>毕竟最近面试机会不多，难得有个线上懂行的模拟面试，这怎么想就是一个好事儿。</p><p>现在想想，这个过程真是处处透着诡异，单纯就是自己纯纯上头了。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>首先是发了我一个面试题库软件呢。</p><p>这个我也知道，就是灵题库嘛，类似这种面试题集合的软件工具，我是不排斥的，我个人也喜欢用软件刷前端面试题。</p><p>但是，一直登录不上去，挺烦的，然后他给了我一串账号，说用自己的账号试试。</p><p>顺利登录了，之后点不开，不得已就转QQ视频，说是直接面试。</p><p>这里我还是排斥，如果不是工作找不到，我是真不考虑这些破事。</p><p>然后这时候又谈了一下最近的工作情况，他说自己是湖南人，然后在上海工作，然后和这个陌生人相谈甚欢，这里我放松戒备了。</p><p>然后，他说软件不好用，干脆他就模拟面试，不过需要开视频。</p><p>开视频这点是我很排斥的，毕竟半夜，开视频总有种不对劲的感觉，陌生人突然开视频怎么想都感觉不对劲啊。</p><p>可我真是太想进步了，难得的面试机会，就算是模拟面试我也想把握一下。</p><p>想了好一会儿，还是同意视频模拟面试。</p><h4 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h4><p>然后我就和他开了视频，对方是个男生，这更没什么不妥了，不是女人就意味着视频怎么也不会伪造，这让我还挺开心的。</p><p>简单的自我介绍和技术问答之后，三分钟左右，他说他要上厕所，先关闭视频。</p><p>然后差不多十多分钟后，劲爆的就来了。</p><p>这畜生拉老子进了一个小群，里面就我和他，然后发了我的裸照和裸聊视频，这还没完，通讯录和周围熟人的联系方式全给我盒出来了，包括我的个人身份信息。</p><p>这一手直接把我干懵了。</p><p>妈的，裸聊你好歹给我看个女人啊，我连女人都没看到，怎么就裸聊了，操你妈的！</p><p>但我毕竟是被骗过一次的人了，这套路我可太熟了。</p><p>提钱，免谈。</p><p>而且我属于社会独立的边缘人，你要发我裸照，我只会说，这图里边的不够大，麻烦P的大一点。</p><p>主要是，他妈个逼，我他妈的根本没裸聊过，居然就整了一套视频加图片，真行。</p><p>然后就是电话威胁+发彩信威胁，勒索说要八千。</p><p>他妈的，笑死人了，我怕你这个？</p><p>下次记得给我换个肥一点的，我现在的身体比之前更垃圾，照片上的人还是瘦了，不像我，还有，他下边太小了。</p><p>总之，接下来就是互喷，然后我当场报警，存了他的QQ。</p><p>本来还想存下来那个换脸视频研究下的，QQ把视频给拦截了，然后我自己都下不下来。</p><p>还有图，类似的情况。</p><p>再之后，我又骂了几句，本来还打算等一波电话轰炸来着，之后就没信了，骗子QQ注销了。</p><h3 id="技术思路"><a href="#技术思路" class="headerlink" title="技术思路"></a>技术思路</h3><p>虽然这事儿很恶心，但稍微盘点一下思路，倒也不是不可以理解。</p><p>这里不盘他的话术，单纯盘点一下他的技术手段。</p><ol><li>我的QQ应该是最近海投简历泄露出去的，因为简历中，我的邮箱就是常用的QQ邮箱，而且我已近海投了简历，对方猜出来我最近是在找工作的人，所以抓住了我的求职心理，妈的，信息裸奔是真烦。</li><li>面试软件是木马工具，猜测应该是先用超量授权的应用读取用户的通讯录，不然对方应该是盒不到我手里那么多信息的。</li><li>其次，视频换源应该是用克隆语音加AI换脸搞定的，我模拟面试时候穿着衣服，但是对面让我看一下全身装，之后发给我的视频里边，封面上我是没有穿衣服的，虽然没点开视频，但是估计是全裸了。猜测这里用了类似的AI脱衣手法，这个我自己也玩过。</li><li>最后，批量给亲友发彩信，目前没有朋友电话我，猜测应该是没发，这太怪了，群发彩信应该是成本不贵的，猜测应该是时间成本不值当，寻找下一个怨种了。</li></ol><h3 id="事情结果"><a href="#事情结果" class="headerlink" title="事情结果"></a>事情结果</h3><ol><li>报警，但是没正式立案，因为警察也比较同情我，说这要是立案，用人单位一查，有这事儿就难受了，干脆就别立案。</li><li>无事发生，没啥亲友找我，估计彩信没发出去，要么就是被当做骚扰电话拦截了，不过，那个辣眼睛的裸照，我自己都想戳瞎自己的双眼，妈的，造裸照就能造好看点吗。</li><li>骗子QQ主动注销，那家伙的QQ空间还蛮正常的，一个太阳号就这么被注销了，真可惜。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>估计自己已经在骗子那边挂号了，从第一次信息泄露之后，我就像是剑风传奇中，被蚀刻的鹰之团战士，就算逃了第一次估计后续也是一辈子被挂号了。</p><p>他妈的，联想早年的事儿，真是感觉缘分到了。</p><p>最近找工作太忙，没时间收拾这帮家伙。</p><p>妈的，后续我要有钱了，我先想办法干死这帮畜生。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年前端求职经历</title>
      <link href="/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
      <url>/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>大劫将至，前端已死。</p><p>我们都是技术上的妓女，当青春的肉体不再，年老之时，我们将不再有任何价值。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在正式开始说话前，先将我个人的暴论放在前边。</p><p>如果还是现在这个行情，两年内，前端和后端都会有一场近乎踩踏式的失业潮。</p><p>前端已死，2023的小型裁员潮只是第一年，2024的内卷求职潮才是真正的开始。</p><p>以往火烧到了应届生身上，现在火烧到了应届本科生和三到五年的大专生身上，未来不好说。</p><p>当然，重本那群怪物不在考虑范围之内，如果连他们工作都不好找，那只有一种可能，世界大战的火烧到本土了。</p><p>2024，不仅仅是前端，是所有的互联网职业 ，都要为自己的过去的高收入付账了。</p><h3 id="招聘软件"><a href="#招聘软件" class="headerlink" title="招聘软件"></a>招聘软件</h3><p><strong>推荐使用BOSS直聘</strong>，也只有boss直聘反馈快点，其他的几个软件都是一坨屎。</p><p>智联等于失联，拉钩连个像样的发贴请求都没有，猎聘和51根本不是程序员用的。</p><p>如果没有内推，推荐使用BOSS直聘求职。</p><h3 id="求职经历"><a href="#求职经历" class="headerlink" title="求职经历"></a>求职经历</h3><p>在2024的4月里，本着金三银四的求职时间，我这个臭带专毕业的，选择在四月份来赶一下这个晚集。</p><p>然后，我就发现今年的就业环境不是一般的冷，我的项目履历如果放在一年前，出去也算是暴打一批人，但是今年的就业环只让我感觉到一阵心凉。</p><p>我之前的工作地点大约都在苏州，所以，本来想在苏州继续找份工作，但今年到了苏州之后才发现，这里的就业环境几乎是大专绝地。</p><p>从4月8号开始正式，我大约面试了8家左右，这里林林总总包括一些线上面试。</p><p><strong>我的项目履历不差。</strong></p><p>三到五年的工作经验，项目履历涉及到低代码，bpmnJS流程图，涉及过OA系统，小程序，大型资产管理系统，数据大屏+地图可视化，做过npm的包，带过团队，在项目现场救过火。</p><p>这些我都写到简历里边，但这么多东西，没有换到任何一家苏州的面试邀约。</p><p><strong>大专，在这个时候是犯天条了。</strong></p><p>当初，没能花时间完成自考真是可惜，不过当初一直在加班，根本没时间，而现在的空窗期只有一年，一年时间，就算我再怎么努力，恐怕也没办法把剩余的十二门考试全弄考完，因为一年只能报八门。</p><p>学历就算上去了也没用，要求里边全是统招本科，后续提升上去的，大概率没戏。</p><p>此时，苏州大部分工作，待遇依然没有下降，但是招聘要求抬了好几个档次，简历过不了人事那关，就只能上其他城市了。</p><p>扫了一眼，上海还行。</p><p>虽然上海房租贵，物价高，外地人被歧视的严重，交通恶心，而且疫情期间那种封闭到现在让我感觉到畏惧，我有个同事真的在上海被关在房里饿了一天。</p><p>但，人要过日子的。</p><p>不得已，只能将目光转到上海，去魔窟卖身了，好在上海没给大专上天条，至少我还能看到有很多家招收大专的，3-5年，正经的态度。</p><p>然后，在一周的时间里，我看到BOSS直聘的招聘要求，逐渐从1-3年，转到3-5年，最后从大专升到本科，然后工资压到实习生的水准。</p><p>麻了，今年的就业环境真是彻底凉透了。</p><h3 id="招聘要求"><a href="#招聘要求" class="headerlink" title="招聘要求"></a>招聘要求</h3><p>投了大概500多家，环江苏找了一圈工作之后，最后只能停留在上海附近。</p><p>苏州这种新一线城市，要求提的虽然高，但是技术栈挺新潮，工作待遇大多较好，大环境虽然烂，但是待遇这块没的说。</p><p>上海那边超一线城市，要求相对不高，而且技术栈较新，待遇参差，上下差距极大，但至少有的选。</p><p>其他地方大多垃圾，要么技术栈直接拉胯到爆炸，要么薪资待遇就是在养黑奴，综合下来，找了半天，整个江苏居然只有苏州和上海勉强能看。</p><p>所有公司的招聘意向，我大致梳理了一下，有如下几个套路，我个人按照心里的综合评分，从高到底逐次介绍。</p><ol><li>优中选优的正常向纯前端，要求本科学历，3-5年工作经验，项目履历丰富，能加班，有大厂项目经历最好，在上海薪资11k-15k（考虑到3000左右的房租，这个薪资勉强算是能活，毕竟3-5年不年轻了，再有两年，可能就做不了事情了，这个工资水平是最后的晚餐）</li><li>全干工程师，要求大专及以上，3-5年工作经验，前端要掌握一门后端语言，后端要掌握一门前端框架，能加班，在上海薪资15K-20K（看着正常，但这种全干工程师，绝对是要一个人干两个人的事情，而且项目管理大多不正规，各种死线周期瞎改需求是常有的事，在这种地方做久了，会折寿）</li><li>设计型前端，，但是倾向于设计，自带审美（这话的意思是你要做设计的活），工资水平大约12k-15k左右。（这种工资水平虽然低了一些，但只要稍微懂点设计应该能糊弄，但一个没有设计的公司，大概率还在蛮荒时期，这个技术栈难以想象，平庸但是安稳。）</li><li>短期外包型，要求大专起步，1-3年或3-5年，纯前端或者纯后端都可以，但是要你签短期合同，而且承诺无偿加班，待遇有些偏黑奴，不过。（外包，在技术行业里基本上和黑奴没差别，在外边做技术支持的时候，甚至不能喝那些人饮水机里边的水，如果要形容的话，和黑奴比，唯一的优势大概就是至少有一定的人权，不是纯纯的农具）</li><li>纯农具型外包，学历大专起步，1-3年工作经验，纯前端，有的要求短期不结账，等项目完成后再结账，有的要求在上海月薪约莫2-4K（妈了个逼的，2-4k这种连吃饭的钱都够呛，上海一碗牛肉面就得18，他妈的莫不是让人不吃牛肉？能开出这种要求，我只能说没钱你装你妈比的boss，资本家是那么好当的？）</li></ol><p>以上五种，大致是我这边整理出来的所有需求，仅供参考。</p><h3 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h3><p>时隔这么多年，再次拿起这些八股文，我只感觉一股悲凉。</p><p>毕业的时候，背面试题，被卡本科学历，然后低价招到公司。</p><p>干了快五年了，我还在背面试题，被卡本科学历，然后又会被低价招到了公司。</p><p>工作经验，属于屁用没有了，反而因为年轻的肉体已经不在，因为年龄大而遭到了就业的歧视。</p><p>重新看了很多，VUE的常规问题，es6的基础，promise的部分内容，computed和watch监听的实现，https和http，TCP和UDP，url输入之后发生什么之类的基础八股文看了一堆。</p><p>有用，也有些感悟，但是感觉心凉。</p><p>他奶奶的，这种问题平日谁看啊？业务上一堆逼事不做，来看这个？</p><p>好在，面试官大多给了我这个求职者最后的尊严，简单问了一些小的技术点之后，他们露怯了，不敢细问，因为我的回答可能比他们手里的答案要深，如果要是胡搅蛮缠的让我去写算法，写二叉树，手写promise，那我只能说，太悲凉了。</p><p>之后，他们没有问那些假大空的八股文，反而问了我很多技术实现的细节，我讲了项目怎么优化翻新，怎么重构项目中不合理的地方，团队前端工具的统一管理，前公司的业务流程和技术实现。</p><p>我没有特地去记这些事情，只是随便讲了些许之前的内容，可只是一开口，我就停不下来了，每次讲到这些，我好像又回到了那些时候。</p><p>每当我讲到这些项目经历时，我居然有种怀念青春的可笑感。</p><p>他妈的，我真是贱人啊。</p><p>高三天天熬夜，因为小高考残废考不上本科，我认了。</p><p>工作后天天加班熬夜，把身体搞垮，调养一年重新就业之后，我再次竞争失利，因为我是大专，哈哈哈哈，他妈了个逼的。</p><p>我认了，大专，就是犯了天条的罪人。</p><p>现在想来，我非常讨厌高三，但是却非常怀念加班的日子。</p><p>这两个于我而言同样都是苦日子，但我却更怀念那段加班的日子，不是因为我贱，而是我上班之后，终于能挣钱了，钱给了我尊严。</p><p>我并不怀念青春，我只是渴求金钱，我不想再忍受贫穷的苦楚。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不买房，不结婚，不疯魔，老老实实等着，挣够了钱，我就给自己赎身回家。</p><p>这个时代，是最好的时代，也是最烂的时代。</p><p>在这个喧闹的时代里，技术人就像是十里洋场的舞女，将自己那不值一提的年轻肉体和精神化作洋场之上的霓虹灯，他们的血汗和尊严点缀了这个疯狂的时代，让这个时代有了病态的繁荣。</p><p>但是，宴会终有散会时，今年的失业潮终于要击碎这摇摇欲坠的黄粱一梦了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2生命周期</title>
      <link href="/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>工作时候用的特别熟悉的内容，如今竟然有一种生疏的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>重新整理一下，免得面试时候露怯。</p><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><p><strong>定义：组件从 创建 到 销毁 的整个过程就是生命周期</strong></p><p><strong>作用：特定的时间点，执行特定的操作</strong></p><p><strong>场景：组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据</strong></p><p><strong>分类: 4大阶段8个方法</strong></p><ul><li>初始化</li><li>挂载</li><li>更新</li><li>销毁</li></ul><table><thead><tr><th><strong>钩子函数</strong></th><th><strong>触发的行为</strong></th><th><strong>在此阶段可以做的事情</strong></th></tr></thead><tbody><tr><td>beforeCreadted</td><td>vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。</td><td>加loading事件</td></tr><tr><td>created</td><td>vue实例的数据对象data有了，$el还没有</td><td>结束loading、请求数据为mounted渲染做准备</td></tr><tr><td>beforeMount</td><td>vue实例的$el和data都初始化了，但还是虚拟的dom节点，具体的data.filter还未替换。</td><td></td></tr><tr><td>mounted</td><td>vue实例挂载完成，data.filter成功渲染</td><td>配合路由钩子使用</td></tr><tr><td>beforeUpdate</td><td>data更新时触发</td><td></td></tr><tr><td>updated</td><td>data更新时触发</td><td>数据更新时，做一些处理（此处也可以用watch进行观测）</td></tr><tr><td>beforeDestroy</td><td>组件销毁时触发</td><td></td></tr><tr><td>destroyed</td><td>组件销毁时触发，vue实例解除了事件监听以及和dom的绑定（无响应了），但DOM节点依旧存在</td><td>组件销毁时进行提示</td></tr></tbody></table><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="创建期间的生命周期函数"><a href="#创建期间的生命周期函数" class="headerlink" title="创建期间的生命周期函数"></a>创建期间的生命周期函数</h4><h5 id="beforeCreate（初始化界面前）"><a href="#beforeCreate（初始化界面前）" class="headerlink" title="beforeCreate（初始化界面前）"></a>beforeCreate（初始化界面前）</h5><p>实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</p><h5 id="created（初始化界面后）"><a href="#created（初始化界面后）" class="headerlink" title="created（初始化界面后）"></a>created（初始化界面后）</h5><p>实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</p><h4 id="挂载期间的生命周期函数"><a href="#挂载期间的生命周期函数" class="headerlink" title="挂载期间的生命周期函数"></a>挂载期间的生命周期函数</h4><h5 id="beforeMount（渲染DOM前）"><a href="#beforeMount（渲染DOM前）" class="headerlink" title="beforeMount（渲染DOM前）"></a>beforeMount（渲染DOM前）</h5><p>此时已经完成了模板的编译，但是还没有挂载到页面中</p><h5 id="mounted（渲染DOM后）"><a href="#mounted（渲染DOM后）" class="headerlink" title="mounted（渲染DOM后）"></a>mounted（渲染DOM后）</h5><p>此时，已经将编译好的模板，挂载到了页面指定的容器中显示</p><h4 id="运行期间的生命周期函数"><a href="#运行期间的生命周期函数" class="headerlink" title="运行期间的生命周期函数"></a>运行期间的生命周期函数</h4><h5 id="beforeUpdate（更新数据前）"><a href="#beforeUpdate（更新数据前）" class="headerlink" title="beforeUpdate（更新数据前）"></a>beforeUpdate（更新数据前）</h5><p>状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</p><h5 id="updated（更新数据后）"><a href="#updated（更新数据后）" class="headerlink" title="updated（更新数据后）"></a>updated（更新数据后）</h5><p>实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</p><h4 id="销毁期间的生命周期函数"><a href="#销毁期间的生命周期函数" class="headerlink" title="销毁期间的生命周期函数"></a>销毁期间的生命周期函数</h4><h5 id="beforeDestroy（卸载组件前）"><a href="#beforeDestroy（卸载组件前）" class="headerlink" title="beforeDestroy（卸载组件前）"></a>beforeDestroy（卸载组件前）</h5><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><h5 id="destroyed（卸载组建后）"><a href="#destroyed（卸载组建后）" class="headerlink" title="destroyed（卸载组建后）"></a>destroyed（卸载组建后）</h5><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>组件模板自己试着写就好，此处贴js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Vue的生命周期&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeCreate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeCreate创建前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span> , <span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//undefined </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------created创建完毕状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeMount挂载前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + (<span class="variable language_">this</span>.<span class="property">$el</span>)); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------mounted 挂载结束状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeUpdate</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);   </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updated</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeDestroy</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">destroyed</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="激活与未激活的生命周期"><a href="#激活与未激活的生命周期" class="headerlink" title="激活与未激活的生命周期"></a>激活与未激活的生命周期</h3><h4 id="activated（）"><a href="#activated（）" class="headerlink" title="activated（）"></a>activated（）</h4><p>被 keep-alive 缓存的组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="deactivated（）"><a href="#deactivated（）" class="headerlink" title="deactivated（）"></a>deactivated（）</h4><p>被 keep-alive 缓存的组件停用时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><blockquote><p>2.5.0+ 新增</p></blockquote><h4 id="errorCaptured（）"><a href="#errorCaptured（）" class="headerlink" title="errorCaptured（）"></a>errorCaptured（）</h4><p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p><h3 id="钩子函数的理解"><a href="#钩子函数的理解" class="headerlink" title="钩子函数的理解"></a>钩子函数的理解</h3><p>所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong>(例如created: () &#x3D;&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此this与你期待的 Vue 实例不同，this.fetchTodos的行为未定义。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也算是温故而知新了，太久没看的vue2相关的内容了，捕获错误这个之前一直没有，如今也算是新发现了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>原帖：<a href="https://juejin.cn/post/7024074527420203044">Vue生命周期（简单易懂,超详细）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解原型链</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>原型链，从来都没去理解过，为了面试特意查了一下，发现早就是在工作里边用的熟悉了，只是我没有去深入了解这块。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工作中，为了调试，我们常常输出对象查看内容。</p><p>例如，我在vue中输出内容，经常会发现会经常看到Prototype，__proto__，.constructor等意义不明的东西。</p><p>后来工作久了，细细查了一下，才知道这玩意是原型链。</p><p>毕竟我不是正规前端出身，做事儿总是奉行能用就行，所以后来一直没详细整理这块的内容。</p><p>如今闲下来了，针对这块内容，这里梳理一下，也防止面试被问到。</p><h3 id="必要概念"><a href="#必要概念" class="headerlink" title="必要概念"></a>必要概念</h3><p>在正式进入原型链之前，先简单了解一些简单的概念。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数和普通函数本质上没什么区别，只不过使用了<code>new</code>关键字创建对象的函数，被叫做了构造函数。</p><p>构造函数命名通常采用首字母大写的方式，以便与普通函数和变量进行区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;人类&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>在JavaScript中，<code>Object</code>构造函数创建一个对象包装器。</p><p>如果给定值是null或undefined，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。</p><p>当以<strong>非构造函数</strong>（即，没有使用new）的方式被调用时，Object函数将转换为对象。</p><p>它可以将任何值转换为对象，这种方式通常被用于将基本数据类型（如数字、字符串和布尔值）转换为相应的对象。</p><p>以下代码举例，可以看出Object的转换能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// 输出：Number &#123;123&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj); <span class="comment">// 输出：&quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>根据上面构造函数的定义，<code>Object</code>是满足当做一个构造函数的要求的。</p><p>既然是个函数了，那么就会有<code>prototype</code>属性。 </p><p>这里先埋一个伏笔，到现在只需要记住，Object是JS运行时就创建好了的，是JS内置的，并且Object身上有个<code>prototype</code>属性即可</p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>Function是一个特殊的构造函数，它是在JavaScript运行时就创建的一个<strong>对象</strong>。</p><p>Function是所有函数的构造函数，先通过代码的方式举例一下通过new Function()的方式创建一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greet = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;console.log(&quot;Hello, &quot; + name + &quot;!&quot;);&#x27;</span>);</span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;John&#x27;</span>); <span class="comment">// 输出 &quot;Hello, John!&quot;</span></span><br></pre></td></tr></table></figure><p>到这里我们知道了<code>new Function()</code> 构造函数可以动态地创建函数，从这里先解释一下上面有关Object的解释中的伏笔。</p><p>既然所有函数都是Function生产出来的，那么Object这个构造函数是不是也是Function生产出来的呢？ </p><p>答案是的。</p><p>那Function自身怎么来的呢？</p><p>答案是Function创造了Function，没错这是一个特殊的情况，因为万物都有个源头，Function和Object一样，都是JS在运行时就创建好了。</p><blockquote><p>例如下面代码，可以先略过。看完下面有关constructor 的解释再回来看这个就理解了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abc</span> () &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(abc.<span class="property">constructor</span> === <span class="title class_">Function</span>) <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">constructor</span>  === <span class="title class_">Function</span>) <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码就印证了，所有函数都是Function生产的（包括Function自身也是）</p></blockquote><h4 id="显式原型（prototype）"><a href="#显式原型（prototype）" class="headerlink" title="显式原型（prototype）"></a>显式原型（prototype）</h4><p>显示原型就是利用prototype属性查找原型，只是这个是函数类型数据的属性。</p><p>当然，这个东西在我们那个时候叫显示原型，现在叫做原型对象，本质上是一个东西。</p><p>个人感觉现在的说法更贴切，因为这东西本质上指向的内容是对象，所以叫做原型对象，更贴切。</p><ol><li>Prototype是<strong>函数</strong>的一个属性</li><li>是个对象</li><li>创建函数的时候时候，自带该属性</li></ol><h4 id="隐式原型（-proto-）"><a href="#隐式原型（-proto-）" class="headerlink" title="隐式原型（__proto__）"></a>隐式原型（__proto__）</h4><p>隐式原型是利用__proto__属性查找原型，这个属性指向当前对象的构造函数的原型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(per1.__proto__ === Person.prototype); // true</span><br><span class="line">console.log(per2.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure><ol><li><strong>对象</strong>的属性</li><li>指向构造函数Prototype</li></ol><h4 id="构造器（Constructor）"><a href="#构造器（Constructor）" class="headerlink" title="构造器（Constructor）"></a>构造器（Constructor）</h4><p>对于原型对象Prototype来说，它有个constructor属性，指向它的构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.\__proto__ === Function.prototype) // 结果为true</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="经典图解"><a href="#经典图解" class="headerlink" title="经典图解"></a>经典图解</h3><p>在了解了上述的名词之后，我们再看下边的这张图，应该就会清晰很多了。</p><p>以下这张图，代入核心知识点。</p><p>为了清晰的解释这个关系，我们先在脑海中抽象出两个线路，一个是<strong>函数线</strong>，一个<strong>对象线</strong>。</p><p>这两个线，只是暂时的把函数和对象两个概念做个区分，但实际上，函数属于对象，只是一个特殊的对象而已。</p><p><strong>在JS中一切皆对象，而所有的对象原型最终指向的是null</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">牢记下面我抽象出来的两个知识点</span><br></pre></td></tr></table></figure><p><strong>函数</strong>有 <code>prototype</code> 和 <code>__proto__</code> , <strong>对象</strong>有 <code>__proto__</code>。</p><blockquote><p>写一段伪代码，只是帮助你理解原型链，但是这个核是一定要记住的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function = &#123;</span><br><span class="line">    prototype,</span><br><span class="line">    __proto__</span><br><span class="line">&#125;</span><br><span class="line">Object= &#123;</span><br><span class="line">    __proto__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/27/qgtMbucF6ZPV9yK.png" alt="image-20240527221624949"></p><h3 id="个人拓展"><a href="#个人拓展" class="headerlink" title="个人拓展"></a>个人拓展</h3><p>之前看到有人在群里装逼，说隐式原型（__proto__）已经被废止，说已经使用新的[[Prototype]]做标识，听他说的信誓旦旦，我还真信了。</p><p>后来查了一下MDN的相关文档，大致闹明白了是怎么回事儿。</p><h4 id="Prototype-是什么"><a href="#Prototype-是什么" class="headerlink" title="[[Prototype]] 是什么"></a>[[Prototype]] 是什么</h4><p>ECMA-262使用一些内部特性来描述属性的特征，这里放一下官方文档的原文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遵循 ECMAScript 标准，符号 someObject.[[Prototype]] 用于标识 someObject 的原型。</span><br><span class="line">内部插槽 [[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 函数来访问。</span><br><span class="line">这个等同于 JavaScript 的非标准但被许多 JavaScript 引擎实现的属性 __proto__ 访问器。</span><br><span class="line">为在保持简洁的同时避免混淆，在我们的符号中会避免使用 obj.__proto__，而是使用 obj.[[Prototype]] 作为代替。其对应于 Object.getPrototypeOf(obj)。</span><br><span class="line">它不应与函数的 func.prototype 属性混淆，后者指定在给定函数被用作构造函数时分配给所有对象实例的 [[Prototype]]。我们将在后面的小节中讨论构造函数的原型属性。</span><br></pre></td></tr></table></figure><p>这段话说的挺绕，但实际就很简单的意思：这些特性是由为JavaScript实现引擎的规范定义的，因此，开发者不能在JavaScript中直接访问这些特性。</p><p> 为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Prototype]]、[[Enumerable]]等。</p><p><strong>[[Prototype]]就是这个一个内部属性, 它指的是对象的原型</strong>，脚本中没有访问这个[[Prototype]]特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。</p><p>因此，所谓的<code>__proto__</code>被废除，纯粹是瞎说，我亲自在控制台上敲过，用的很正常。</p><p>而[[Prototype]] ，也只是内部属性，并不能在控制台中被执行。</p><p>所以，原型链这种基础的东西，几乎不太可能动的，有些人纯粹的是胡编的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然很绕，但是其实一旦理解了就很容易明白，而明白之后，再看那张经典的原型链图就会非常明白。</p><p>B站的<a href="https://www.bilibili.com/video/BV1LY411d7Yt/?spm_id_from=333.788&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【前端八股文】原型和原型链</a>，还有掘金的<a href="https://juejin.cn/post/7254443448563040311#heading-1">你可能不太理解的JavaScript - 原型与原型链</a>这篇文档都解释的很不错，我算是照猫画虎的理解了一下。</p><p>当然，我也翻看了现代MDN的文档，发现似乎隐式原型（__proto__）被官方弃用了，现在似乎</p><p>只是，这块的知识，除非是涉及到基础框架开发，不然大多数时候是用不上的，属于一看就能明白是什么意思的基础问题，但开发根本用不到太多。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1LY411d7Yt/?spm_id_from=333.788&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【前端八股文】原型和原型链</a></p><p><a href="https://juejin.cn/post/7254443448563040311#heading-1">你可能不太理解的JavaScript - 原型与原型链</a></p><p><a href="https://juejin.cn/post/7255605810453217335?searchId=20240326154528B151AB415507AF9D5722">原型和原型链–图解</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链 - JavaScript | MDN (mozilla.org)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解页面布局</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>太久没看过了，这里回顾一下页面的基础还原方法，有点累。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>盒子模型这种传统的东西就不提了，这里直接提几种布局模式。</p><h3 id="block，inline与inline-block"><a href="#block，inline与inline-block" class="headerlink" title="block，inline与inline-block"></a>block，inline与inline-block</h3><ul><li>行内标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，行内标签无法设置宽高</span><br><span class="line"></span><br><span class="line">2，行内标签不会独占一行，会连续占满一行，直到换行</span><br><span class="line"></span><br><span class="line">3，行内元素不能包含块级元素，只能容纳文本或者其他行内元素</span><br></pre></td></tr></table></figure><ul><li>块状元素</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>，块状标签可以设置宽高度</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>，块元素独占一行</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>，块属性标签的宽度假如不做设置，会直接默认为父元素宽度的<span class="number">100</span><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>，块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素</span><br></pre></td></tr></table></figure><ul><li>行内块元素</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1，结合的行内和块级的优点:能够设置宽高，并且在一行内独立显示</span></span><br></pre></td></tr></table></figure><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 如果父元素不设置高度，会引起父元素塌陷 </span><br><span class="line">2. 元素浮动，引起同行兄弟元素占位，导致页面错乱</span><br></pre></td></tr></table></figure><p>常用的元素塌陷处理方式</p><ol><li>直接给父元素设置高度</li><li>使用clear:both清空浮动（如果不清楚这个属性是干什么的，可以去W3C官网看看，很容易理解的）</li><li>给父元素加overflow:hidden</li><li>给父元素添加浮动，父子元素一起浮动，就没问题了;</li></ol><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>默认定位（static），不会让div或者其他元素脱离文档流，而是遵循排版的原则，从上到下，块级元素换行，行内元素不换行等等通用原则。所以，如果不用定位属性，那么这个position就不用设置。</p><p>相对定位（relative），相对于元素原本的位置进行位移，原本的位置不为空，仍然已经位移的该元素继续占用</p><p>绝对定位（absolute），相对于元素的父元素最左上角进行坐标定位，会脱离文档流，产生类似浮动的效果</p><p>固定定位（fixed），相对于当前窗口最左上角进行坐标定位</p><p>粘性定位（sticky）， 基于用户的滚动位置来定位，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置，常常用来做页面的顶部标签。</p><p>这里要注意以下两点：</p><ol><li>定位是相对于父元素进行定位的，如果父元素没有设置定位属性，则相对于BODY标签进行定位。</li><li>如果父元素没有设置定位的话，那么，绝对定位是相对于body标签进行定位的。</li><li>如果父元素设置了相对定位，绝对定位，固定定位，任意一种，那么，绝对定位相对于父元素左上角进行定位。</li></ol><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>移动端常用的解决方式，懒得写。</p><p>参考：<a href="https://juejin.cn/post/7245898637779157052?searchId=20240326095317548BA608AFC1017DB216">一文吃透 CSS Flex 布局 - 掘金 (juejin.cn)</a></p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>参考：<a href="https://juejin.cn/post/6854573220306255880?searchId=2024032609542547B81E72E842C57E26AF">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说实话，不是很想写这篇，但是我自己回忆这些内容的时候，发现太过熟悉以至于卡壳了。</p><p>不得已，写了这篇内容回忆一下以前熟的发昏的内容。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903671717691405">切图仔基础篇————块级元素与行级元素</a></p><p><a href="https://juejin.cn/post/6844903684510318599">切图仔基础篇————如何熟练的使用定位</a></p><p><a href="https://juejin.cn/post/6844903678151770119">切图仔基础篇————浮动问题浅析</a></p><p><a href="https://www.runoob.com/css/css-positioning.html">菜鸟驿站，css定位</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解less与scss</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3less%E4%B8%8Escss/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3less%E4%B8%8Escss/</url>
      
        <content type="html"><![CDATA[<p>本来以为不会有人问这种级别的面试题了，没想到有人提到了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>二者作为预编译语言，寻常使用过程中没有什么太大的差别。</p><p>预编译语言的特点，两者都有。</p><ol><li>定义变量</li><li>嵌套编译</li><li>混合宏</li></ol><p>如果一定要分出个高低，个人推荐使用less，因为scss的库大多项目都用的是node-scss，这个库常常导致项目更新失败，新人使用可能会产生大问题，而less的库则没有相关问题。</p><h3 id="Less-和-SCSS-简介"><a href="#Less-和-SCSS-简介" class="headerlink" title="Less 和 SCSS 简介"></a>Less 和 SCSS 简介</h3><h4 id="Less：简洁而强大"><a href="#Less：简洁而强大" class="headerlink" title="Less：简洁而强大"></a>Less：简洁而强大</h4><p>Less（Leaner Style Sheets）是一种向后兼容的 CSS 扩展，它允许开发者使用类似于编程的方式来编写 CSS。Less 引入了变量、混合（类似于函数的结构）、嵌套规则等特性，极大地提高了代码的可重用性和可维护性。它可以在客户端或服务器端（如 Node.js）运行，这为开发者提供了灵活的使用方式。</p><h4 id="SCSS：丰富功能的优雅选择"><a href="#SCSS：丰富功能的优雅选择" class="headerlink" title="SCSS：丰富功能的优雅选择"></a>SCSS：丰富功能的优雅选择</h4><p>SCSS（Sassy CSS）是 Sass 的一个版本，它使用类似于 CSS 的语法，这意味着任何有效的 CSS 代码都是合法的 SCSS 代码。SCSS 不仅保留了 Less 的所有优点，还增加了诸如条件语句、循环、函数等更高级的功能。这使得 SCSS 在处理复杂项目时显得更加得心应手。</p><h3 id="Less-和-SCSS-的异同"><a href="#Less-和-SCSS-的异同" class="headerlink" title="Less 和 SCSS 的异同"></a>Less 和 SCSS 的异同</h3><p>虽然 Less 和 SCSS 都是 CSS 预处理器，但它们在语法和功能上有一些关键的差异。</p><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol><li><strong>预处理功能</strong>：两者都提供了变量、混合、函数、嵌套规则等功能。</li><li><strong>编译到 CSS</strong>：它们都需要被编译成普通的 CSS 才能在浏览器中使用。</li><li><strong>社区支持</strong>：Less 和 SCSS 都有着活跃的开发社区和丰富的文档资源。</li></ol><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ol><li><strong>语法差异</strong>：</li></ol><ul><li><strong>Less</strong> 使用 <code>@</code> 符号来定义变量（例如 <code>@primary-color</code>），其语法与传统 CSS 较为接近，但有自己的特点。</li><li><strong>SCSS</strong> 使用 <code>$</code> 符号定义变量（例如 <code>$primary-color</code>），其语法几乎与原生 CSS 一致，这对于熟悉 CSS 的开发者来说非常友好。</li></ul><ol><li><strong>功能差异</strong>：<ul><li><strong>Less</strong> 提供了基本的预处理功能，如变量、混合和嵌套规则，适合于轻量级应用。</li><li><strong>SCSS</strong> 拥有更高级的功能，如条件语句、循环、函数等，更适合复杂的项目和大型应用。</li></ul></li><li><strong>编译环境</strong>：<ul><li><strong>Less</strong> 可以在客户端（浏览器）或服务器端（如 Node.js）环境中编译。</li><li><strong>SCSS</strong> 通常需要通过服务器端环境来编译，如 Ruby 或 Node.js。</li></ul></li><li><strong>社区和生态系统</strong>：<ul><li><strong>SCSS</strong>，作为 Sass 的一个版本，继承了 Sass 的强大生态系统和广泛的社区支持。</li><li><strong>Less</strong> 也有一个活跃的社区，但相对于 SCSS&#x2F;Sass，它的生态系统可能稍显逊色。</li></ul></li></ol><h3 id="使用场景和案例分析"><a href="#使用场景和案例分析" class="headerlink" title="使用场景和案例分析"></a>使用场景和案例分析</h3><h4 id="Less-在实际中的应用"><a href="#Less-在实际中的应用" class="headerlink" title="Less 在实际中的应用"></a>Less 在实际中的应用</h4><ol><li><strong>小到中型项目</strong>：Less 的简洁性使其非常适合小到中型的网站或应用项目。</li><li><strong>快速原型开发</strong>：需要快速迭代和原型设计时，Less 的简单性可以加速开发过程。</li><li><strong>动态主题</strong>：Less 的变量和函数可以轻松创建可配置的主题样式，适用于动态主题切换。</li></ol><h4 id="SCSS-的使用场景"><a href="#SCSS-的使用场景" class="headerlink" title="SCSS 的使用场景"></a>SCSS 的使用场景</h4><ol><li><strong>大型项目或框架</strong>：SCSS 的高级功能使其成为处理大型项目或复杂应用程序的理想选择。</li><li><strong>与现代前端框架集成</strong>：SCSS 与 Angular、Vue 或 React 等前端框架结合使用，能够提供更复杂的样式管理。</li><li><strong>高级功能需求</strong>：当项目需要使用条件逻辑、循环或函数等高级功能时，SCSS 是更好的选择。</li></ol><h3 id="实际代码示例"><a href="#实际代码示例" class="headerlink" title="实际代码示例"></a>实际代码示例</h3><p>让我们通过一个简单的按钮样式示例来进一步理解 Less 和 SCSS 的具体应用。</p><h4 id="Less-代码示例"><a href="#Less-代码示例" class="headerlink" title="Less 代码示例"></a>Less 代码示例</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">less</span>复制代码<span class="comment">// 定义变量</span></span><br><span class="line">@<span class="selector-tag">primary-color</span>: <span class="selector-id">#4CAF50</span>;</span><br><span class="line">@<span class="selector-tag">warning-color</span>: <span class="selector-id">#f44336</span>;</span><br><span class="line">@<span class="selector-tag">font-stack</span>: <span class="selector-tag">Helvetica</span>, <span class="selector-tag">sans-serif</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本按钮样式</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">@font-stack</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大号按钮</span></span><br><span class="line"><span class="selector-class">.button-large</span> &#123;</span><br><span class="line">  <span class="selector-class">.button</span>(); <span class="comment">// 使用混合</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告按钮</span></span><br><span class="line"><span class="selector-class">.button-warning</span> &#123;</span><br><span class="line">  <span class="selector-class">.button</span>(); <span class="comment">// 使用混合</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@warning-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SCSS-代码示例"><a href="#SCSS-代码示例" class="headerlink" title="SCSS 代码示例"></a>SCSS 代码示例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">css复制代码// 定义变量</span><br><span class="line">$primary-<span class="attribute">color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">$warning-<span class="attribute">color</span>: <span class="number">#f44336</span>;</span><br><span class="line">$<span class="attribute">font</span>-stack: Helvetica, sans-serif;</span><br><span class="line"></span><br><span class="line">// 基本按钮样式</span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: $font-stack;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 大号按钮</span><br><span class="line"><span class="selector-class">.button-large</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button; // 使用继承</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 警告按钮</span><br><span class="line"><span class="selector-class">.button-warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button; // 使用继承</span><br><span class="line">  <span class="attribute">background-color</span>: $warning-color;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个示例展示了如何在 Less 和 SCSS 中使用变量、混合（或继承）、嵌套等特性来创建一个可复用和易于维护的按钮样式。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>选择 Less 还是 SCSS 取决于项目需求、团队熟悉度以及个人偏好。两者都能显著提高 CSS 的编写效率和可维护性。Less 以其简单直观著称，适合小到中型项目；而 SCSS 则以其强大的功能和灵活性适用于更大型和复杂的项目。</p><p>当然，如果我个人开发，我倾向于是用less的来维护项目。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>原贴链接：<a href="https://juejin.cn/post/7323271668990722058">Less 和 SCSS，哪一个更适合你？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS的栈与堆</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>说实在的，堆和栈这个东西，工作这么多年了，如果不是面试，我确实不清楚。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>面试回答</p><ol><li>栈是基础类型，先进后出，存储空间系统分配，系统自动释放，是值传递</li><li>堆是引用类型，动态分配存储空间，存储空间大，是地址传递</li></ol><h3 id="一、-栈-stack-和-堆-heap"><a href="#一、-栈-stack-和-堆-heap" class="headerlink" title="一、 栈(stack)和 堆(heap)"></a>一、 栈(stack)和 堆(heap)</h3><p><strong>栈(stack)：</strong>是栈内存的简称，栈是<strong>自动分配</strong>相对<strong>固定大小</strong>的内存空间，并由系<strong>统自动释放，</strong>栈<strong>数据结构</strong>遵循<strong>FILO</strong>（first in last out）<strong>先进后出</strong>的原则，较为经典的就是乒乓球盒结构，先放进去的乒乓球只能最后取出来；</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/29/1739946914d2b233~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>堆(heap)：</strong>是堆内存的简称，堆是<strong>动态分配</strong>内存，<strong>内存大小不固定</strong>，也<strong>不会自动释放，</strong>堆<strong>数据结构</strong>是一种无序的树状结构，同时它还满足key-value键值对的存储方式；我们只用知道key名，就能通过key查找到对应的value。比较经典的就是书架存书的例子，我们知道书名，就可以找到对应的书籍；</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/29/173995964a8ebad8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>栈的特点：开口向上、速度快,容量小；</strong></p><p><strong>堆的特点：速度稍慢、容量比较大；</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/22/17375f8624e6c831~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><h3 id="二、-基本类型和引用类型"><a href="#二、-基本类型和引用类型" class="headerlink" title="二、  基本类型和引用类型"></a>二、  基本类型和引用类型</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/23/17379552d18f1b91~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>基本数据类型</strong>：<strong>Undefined,String,Boolean,Null,Number，</strong>都是直接按值存放在栈内存中，占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p><p><strong>引用数据类型</strong>：指那些可能由多个值构成的对象，如<strong>对象(Object)、数组(Array)、函数(Function)</strong> ，它们是通过拷贝和new出来的，这样的数据存储于堆中。</p><h3 id="三、-传值和传址的区别"><a href="#三、-传值和传址的区别" class="headerlink" title="三、 传值和传址的区别"></a>三、 传值和传址的区别</h3><p><strong>基本类型</strong>：采用的是<strong>值传递</strong>。</p><p><strong>引用类型</strong>：则是<strong>地址传递</strong>。</p><p>引用类型的数据的地址指针是存储于栈中的，将存放在栈内存中的地址赋值给接收的变量。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据（保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针）。</p><h3 id="四、-内存分配垃圾回收"><a href="#四、-内存分配垃圾回收" class="headerlink" title="四、 内存分配垃圾回收"></a>四、 内存分配垃圾回收</h3><p><strong>1.内存分配：</strong></p><p><strong>（1）栈内存：</strong>线性有序存储，容量小，系统分配效率高。</p><p><strong>（2）堆内存：</strong>首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。 </p><p><strong>2.垃圾回收</strong>：</p><p><strong>（1）栈内存：</strong>变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。</p><p><strong>（2）堆内存</strong>：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>讲的很清晰明了，比早年的云里雾里的那些教程好了很多。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6854573215327617031">js中栈和堆的概念和区别 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解闭包</title>
      <link href="/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
      <url>/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>经典面试内容，ES5时代的必须面试题，虽然回答起来简单，但是想要说明白要破费一些口舌。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>面试回答</p><ol><li>js中声明的变量都是有作用域的，不同函数之间的变量无法互相引用，于是有了闭包，保证不同函数之间的内容可以互相引用</li><li>简单的来说，闭包就是将函数内的变量抛出，供外部访问或者使用。</li><li>闭包是指有权访问另一个函数作用域中变量的函数</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>了解闭包前先来了解一下上级作用域和堆栈内存释放问题。</p></blockquote><h3 id="上级作用域的概念"><a href="#上级作用域的概念" class="headerlink" title="上级作用域的概念"></a>上级作用域的概念</h3><ul><li>函数的上级作用域在哪里创建创建的，上级作用域就是谁</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><p><strong>函数 <code>foo()</code> 是在全局下创建的，所以 <code>a</code> 的上级作用域就是 <code>window</code>，输出就是 <code>10</code></strong></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> n =<span class="number">20</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">       n++;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="title function_">f</span>()</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*  21</span></span><br><span class="line"><span class="comment">    22</span></span><br><span class="line"><span class="comment">    23</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><p><strong>稍微提个醒，单独的 n++ 和 ++n 表达式的结果是一样的</strong></p><blockquote><p><strong>思路：<code>fn</code> 的返回值是什么变量 <code>x</code> 就是什么，这里 <code>fn</code> 的返回值是函数名 <code>f</code> 也就是 <code>f</code> 的堆内存地址，<code>x()</code> 也就是执行的是函数 <code>f()</code>，而不是 <code>fn()</code>，输出的结果显而易见</strong></p></blockquote><ul><li>关于如何查找上级作用域</li></ul><blockquote><p>参考：<a href="https://juejin.cn/post/6933377315573497864">彻底解决 JS 变量提升的面试题</a></p></blockquote><h3 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h3><ul><li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li><li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li><li>栈内存：提供代码执行的环境和存储基本类型值。</li><li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li></ul><blockquote><p><strong>但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放</strong></p></blockquote><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><blockquote><p>在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。</p></blockquote><blockquote><p>概述上面的话，<strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p></blockquote><h3 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h3><blockquote><p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b =<span class="number">14</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><blockquote><p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p></blockquote><h3 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h3><blockquote><p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p></blockquote><ul><li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li></ul><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li><li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li></ul><h3 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h3><ul><li><ol><li><code>return</code> 回一个函数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> n =<span class="number">20</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">       n++;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">x</span>() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p></blockquote><ul><li><ol><li>函数作为参数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;林一一&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    <span class="title function_">p</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="title function_">foo</span>())</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*   foo</span></span><br><span class="line"><span class="comment">/ </span></span><br></pre></td></tr></table></figure><blockquote><p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code>  的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p></blockquote><ul><li><ol><li>IIFE（自执行函数）</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="string">&#x27;林一一&#x27;</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">p</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*   林一一</span></span><br><span class="line"><span class="comment">/ </span></span><br></pre></td></tr></table></figure><blockquote><p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p></blockquote><ul><li><ol><li>循环赋值</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, <span class="number">1000</span>) </span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为存在闭包的原因上面能依次输出0~9，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p></blockquote><ul><li><ol><li>使用回调函数就是在使用闭包</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;林一一&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li><ol><li>节流防抖</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, timeout</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li>柯里化实现</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, len = fn.length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_curry</span>(fn, len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_curry</span>(<span class="params">fn, len, ...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...params</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> _arg = [...arg, ...params]</span><br><span class="line">        <span class="keyword">if</span> (_arg.<span class="property">length</span> &gt;= len) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, _arg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, len, ..._arg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">curry</span>(<span class="keyword">function</span> (<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c + d + e)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 15</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h3><blockquote><p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p></blockquote><h4 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h4><ul><li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li></ul><p>详细可以查看：<a href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ul><li>for 循环和闭包(号称必刷题)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p></blockquote><ul><li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>( data[j] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure><ul><li>写法2：使用 <code>let</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure><blockquote><p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p></blockquote><h3 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            total += i * a;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>]();  <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>]();  <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>]();  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><blockquote><p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>实现私有变量和数据封装：通过闭包可以创建私有变量，只能在内部函数中访问和修改，外部无法直接访问。这样可以实现封装，隐藏数据细节，提高代码安全性。</li><li>保持数据的持久性：闭包使得内部函数可以持续访问外部函数的变量，即使外部函数已经执行完毕。这对于需要保持数据状态或延长变量生命周期的场景非常有用。</li><li>创建函数工厂和动态函数：通过闭包可以动态生成函数，每个函数都有自己的独立作用域和状态。这样可以创建函数工厂，根据不同的参数生成不同的函数。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>内存占用：闭包会导致外部函数的作用域被内部函数引用而无法释放，可能导致内存占用过高。需要注意在不再需要使用闭包时，将其引用置为 <code>null</code>，释放内存。</li><li>性能影响：闭包涉及作用域链的查找，相比普通函数，闭包的执行速度可能较慢。因此，在性能敏感的场景中，过度使用闭包可能会影响代码执行效率。</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>封装模块和实现私有成员：通过闭包可以创建模块，将相关的函数和数据封装在一起，避免全局命名冲突，实现模块化开发。</li><li>记忆和缓存：通过闭包可以实现记忆化函数，将函数的计算结果缓存起来，避免重复计算，提高性能。</li><li>回调函数和异步操作：闭包可以在异步操作中保持数据的状态，使回调函数能够访问异步操作完成后的结果。</li><li>实现<a href="https://juejin.cn/post/7282950171008450560">函数柯里化</a>和函数参数的延迟绑定：通过闭包可以实现函数柯里化，将多个参数的函数转化为接受单个参数的函数，方便函数的复用和组合。</li><li>实现特殊的编程模式和技术，如单例模式、函数式编程等。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>闭包这个经典面试题，在最近面试的时候，经常遇到，我回答的也不够完美。</p><p>所以这里整理一下，防止后续遇到相关的问题。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6937469222251560990?searchId=2024032607455194BE7E124D95E971BAFA#heading-2">闭包经典使用场景和含闭包必刷题</a></p><p><a href="https://juejin.cn/post/7274839871276040246?searchId=2024042117394567E753B7DDC9A9AC503E">JavaScript 闭包 优缺点和作用的详细解释 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解深浅拷贝</title>
      <link href="/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>对于深拷贝和浅拷贝，之前一直不怎么用到，所以一直也没太深入了解，22年的时候，被一个赋值问题教育了，这是那时候记录下的问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>变量的每次声明都会开辟新的存储空间，js中为了找到对应的存储空间，需要指针来指向这个内容。</p><ol><li>深拷贝，重新开辟一个存储空间，来存储你拷贝过来的内容</li><li>浅拷贝，简单的改一下引用指向，使新申明的内容指向原有的内容</li><li>深浅拷贝只针对对象和数组，无所谓好坏，看情况使用，一般是针对多层级的对象嵌套使用深拷贝，便于内容的修改</li><li>虽然有很多方法，但是个人一般使用自己写的js工具方法来处理这些小问题。</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在了解深浅拷贝之前，要先了解定义变量发生了什么。</p><p>我们每次申明变量，会在存储空间内分出来一块单位用来存储变量，而每个存储的变量，又会有个叫做指针的地址。</p><p>所以，我们在给其他变量赋值的时候，就会有个区分：是连着存储单位一块赋值的深拷贝，还是只给一个地址的浅拷贝。</p><p>深拷贝：开辟一块新的存储空间，存放原有的变量，并新开一个指针地址</p><p>浅拷贝：只拷贝指针地址，不另开辟存储空间</p><p>如果使用浅拷贝赋值，原有值会被修改</p><p>如果使用深拷贝赋值，原有值不会被修改</p><p>当然，有人可能会说我胡说，为什么string，boolean,null,undefined这些类型的值怎么没有改变原有值？</p><p>因为深复制和浅复制只针对象  Object对象、Array数组、RegExp对象(正则表达式)、Date时间对象、Function函数 这类复杂对象的。</p><p>简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。</p><p>所以，一般深浅拷贝，都是针对数组或对象这类数据进行操作的。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>如果已经理解上边的朋友，可以跳过这段，这是给一些新手朋友理解的。</p><p>举个不恰当的例子，声明变量，就像我开一家公司，我必然会有个地址，也必然会在现实有个场地办公司。</p><p>我如果要开子公司，子公司就相当于我声明的新变量，而我要把母公司挂名给子公司，就像是赋值这个过程。</p><p>但是开的子公司，我可以只挂名，不开新办公室，直接把新公司的地址指向母公司————这就类似于浅拷贝；</p><p>那么，与之相对的，如果子公司不仅挂名，而且新开了一间办公室，那么我的新公司的地址就指向了新的办公室————这就深拷贝。</p><p>深拷贝会有个新空间来存储赋值后的变量，而浅拷贝没有。</p><p>所以，我们继续用这个例子来讲解：</p><p>如果是深拷贝，我要修改新公司的布局，因为新公司指向的是新办公室，所以只会修改新办公室的布局，而母公司的办公室不会被修改；</p><p>但若是浅拷贝，我要修改新公司的布局，因为新公司指向的是老办公室，所以，原有办公室的布局会被修改；</p><h3 id="深拷贝应用"><a href="#深拷贝应用" class="headerlink" title="深拷贝应用"></a>深拷贝应用</h3><p>浅拷贝没什么好说的，而深拷贝则需要一些特殊的方法赋值，以下记录一些常用的深拷贝使用手法。</p><h3 id="1-手动复制"><a href="#1-手动复制" class="headerlink" title="1. 手动复制"></a>1. 手动复制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1 = &#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">obj2 = &#123;a: obj1.a,b: obj.b&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对象只有一层的话。可以用object-assign-obj1"><a href="#2-对象只有一层的话。可以用object-assign-obj1" class="headerlink" title="2. 对象只有一层的话。可以用object.assign({},obj1)"></a>2. 对象只有一层的话。可以用object.assign({},obj1)</h3><p>Es6的object.assign()是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身</p><p>所以只能实现一层基本类型属性的拷贝 当obj1中属性是引用类型时，就会发现，修改其中一个属性值，另一个值也发生变化。 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;a: 1, b: &#123; c: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = Object.assign(&#123;&#125;,obj1)</span><br><span class="line"></span><br><span class="line"> // 或者 obj2 = &#123;...obj1&#125;</span><br><span class="line"></span><br><span class="line">obj2.b.c = 4</span><br><span class="line"></span><br><span class="line">console.log(obj1) //&#123; a: 1, b: &#123; c: 4 &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="3-转成json再转换回来"><a href="#3-转成json再转换回来" class="headerlink" title="3. 转成json再转换回来"></a>3. 转成json再转换回来</h3><p>用JSON.stringify转为字符串 再用JSON.parse把字符串再转为新的对象</p><p>obj2 &#x3D; JSON.parse（JSON.stringify（obj1））</p><p>坏处： 摒弃了对象的constructor,不管原来的constructor是什么，拷贝后都是object. 只能处理可以被json直接表示的数据结构，number,string,array,扁平对象；</p><p>boolean RegExp对象，无法通过此方式深拷贝</p><h3 id="4-递归拷贝"><a href="#4-递归拷贝" class="headerlink" title="4. 递归拷贝"></a>4. 递归拷贝</h3><p>递归深拷贝的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">deepCopy(obj) &#123;</span><br><span class="line">  if (!obj &amp;&amp; typeof obj !== &quot;object&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;error arguments&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // const targetObj = obj.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">  const targetObj = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    // 只对对象自有属性进行拷贝</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;</span><br><span class="line">        targetObj[key] = deepCopy(obj[key]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        targetObj[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 相互引用会出现死循环，深拷贝的做法是遇到对象就进行递归 复制，那么结果只能无限循环下去</p><h3 id="5-object-create-方法"><a href="#5-object-create-方法" class="headerlink" title="5. object.create()方法"></a>5. object.create()方法</h3><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p><p>也就是说，现有对象是新的对象的构造函数的prototype.其实现过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-直接使用一些库函数方法，-如lodash"><a href="#6-直接使用一些库函数方法，-如lodash" class="headerlink" title="6.直接使用一些库函数方法， 如lodash"></a>6.直接使用一些库函数方法， 如lodash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;)</span><br><span class="line">_.cloneDeep()</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>深浅拷贝也算是经典面试题了，无论什么时候都会有人考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844904178934874126">https://juejin.cn/post/6844904178934874126</a></p><p><a href="https://juejin.cn/post/6871053262767734791">https://juejin.cn/post/6871053262767734791</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解null和undefined的关系</title>
      <link href="/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3null%E5%92%8Cundefined%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/03/25/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3null%E5%92%8Cundefined%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>简单的面试题，21年做的笔记，现在用上了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>21年常见的面试题，如今问到还真是有点怀念，大多数厂商实际上不会问的太深。</p><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><ol><li>二者不全等</li><li>null的类型是对象，undefined的类型是undefined</li></ol><h3 id="它们是什么"><a href="#它们是什么" class="headerlink" title="它们是什么"></a>它们是什么</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>undefined代表了一个并不存在的值，很多情况都会产生undefined，比如：</p><ol><li>没有返回语句的函数运行结束，就会返回undefined</li><li>访问数组中不存在的下标和对象不存在的属性</li><li>void运算符会返回undefined</li></ol><p>undefined是一个全局定义的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined in window  // true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>空引用或者空对象，下面这些情况都会用到null：</p><ol><li>试图获取一个不存在的元素返回一个null值</li><li>通过分配null可以手动的释放对象，便于垃圾回收</li></ol><h3 id="它们哪儿相同"><a href="#它们哪儿相同" class="headerlink" title="它们哪儿相同"></a>它们哪儿相同</h3><h4 id="undefined和null都不能被设置属性或者取属性"><a href="#undefined和null都不能被设置属性或者取属性" class="headerlink" title="undefined和null都不能被设置属性或者取属性"></a>undefined和null都不能被设置属性或者取属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span>.<span class="property">name</span>  <span class="comment">// Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"><span class="literal">null</span>.<span class="property">name</span>   <span class="comment">// Uncaught TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="在条件上下文中，都会被计算成false"><a href="#在条件上下文中，都会被计算成false" class="headerlink" title="在条件上下文中，都会被计算成false"></a>在条件上下文中，都会被计算成false</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show undefined&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show null&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show undefined</span></span><br><span class="line"><span class="comment">// show null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="它们哪儿不同"><a href="#它们哪儿不同" class="headerlink" title="它们哪儿不同"></a>它们哪儿不同</h3><h4 id="它们是两个不同的类型"><a href="#它们是两个不同的类型" class="headerlink" title="它们是两个不同的类型"></a>它们是两个不同的类型</h4><p>我们都知道JavaScript里面基本类型有：string，number，boolean，null，undefined，所以null和undefined是两个完全不同的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)    <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)   <span class="comment">//  [object Undefined]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="typeof操作返回值不同"><a href="#typeof操作返回值不同" class="headerlink" title="typeof操作返回值不同"></a>typeof操作返回值不同</h4><p>先看现象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>    <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>     <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>) <span class="comment">// false </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>两者类型不同，但是在值这一点上，两者其实是相同的。</p><p>其实typeof null返回object是一个遗存的bug，因为第一个版本JavaScript值存在32位的bit中，1-3位是类型标识，而且前三位为000的是object，恰好null表示机器码空指针，在大多数平台上为0x00，所以typeof null就会被误以为是object，而且这个bug到现在也没fix，据说是因为历史代码太多所以被委员会拒绝。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这也算是远古面试题了，虽然远古但是基础，还挺怀念的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>原贴链接：<a href="https://juejin.im/post/5b330932e51d4558c65222e2">【前端工程师手册】null和undefined到底是什么关系？</a></p><p><a href="https://link.juejin.im/?target=http://2ality.com/2013/10/typeof-null.html">typeof-null</a></p><p><a href="https://link.juejin.im/?target=https://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/">探索JavaScript中Null和Undefined的深渊</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟搞清楚选择器和权重</title>
      <link href="/2024/03/25/10%E5%88%86%E9%92%9F%E6%90%9E%E6%B8%85%E6%A5%9A%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E6%9D%83%E9%87%8D/"/>
      <url>/2024/03/25/10%E5%88%86%E9%92%9F%E6%90%9E%E6%B8%85%E6%A5%9A%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E6%9D%83%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>最近考虑去面试新工作，所以这里准备下老早之前刷到的面试题库。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>选择器这个比较冷门，一般不会考的太深，但是出于对面试的谨慎考虑，还是要准备一下。</p><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ol><li>通配选择器（＊）</li><li>ID选择器（#ID）</li><li>类选择器（.className）</li><li>元素选择器(tagName)</li><li>后代选择器（a b）</li><li>子元素选择器(a&gt;b)</li><li>相邻后面兄弟元素选择器(a + b)</li><li>通用后面兄弟选择器（a 〜 b）</li><li>群组选择器（selector1,selector2,…）</li></ol><p>这里面平时不太常用的选择器有<strong>相邻后面兄弟选择器</strong>和<strong>通用后面兄弟选择器</strong> 首先，很多资料上把它们叫做<strong>相邻兄弟选择器</strong>和<strong>通用兄弟选择器</strong>，我觉得这样会有一定的误导意义， 例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l6&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l7&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l8&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;l9&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">li &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    height: 20px;</span><br><span class="line">    width: 20px;</span><br><span class="line">    background: red;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: white;</span><br><span class="line">    float: left;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用相邻兄弟选择器时：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.l3</span> + <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为</p><p><img src="https://s2.loli.net/2024/06/09/y3pOfabFeHEvD1L.png" alt="img"></p><p>可以看出相邻兄弟选择器只会选择它<strong>后面的一个</strong>兄弟元素。 当使用通用兄弟选择器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.l3 ~ li &#123;</span><br><span class="line">        background: green;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果为：</p><p><img src="https://s2.loli.net/2024/06/09/bOVnHrP8BaZdm5t.png" alt="img"></p><p>可以看出来通用兄弟选择器会选择它<strong>后面所有的</strong>兄弟元素</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>参考链接：<a href="http://www.w3school.com.cn/css/css_selector_attribute.asp">属性选择器-w3cSchool</a></p><ul><li>E[attr]：只使用属性名，但没有确定任何属性值</li><li>E[attr&#x3D;”value”]：指定属性名，并指定了该属性的属性值</li><li>E[attr~&#x3D;”value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写</li><li>E[attr^&#x3D;”value”]：指定了属性名，并且有属性值，属性值以value开头的；</li><li>E[attr$&#x3D;”value”]：指定了属性名，并且有属性值，属性值以value结束的；</li><li>E[attr*&#x3D;”value”]：指定了属性名，并且有属性值，属值中包含了value；</li><li>E[attr|&#x3D;”value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说big-name）;</li></ul><p>属性选择器中有波浪（〜）时属性值有value时就相匹配，没有波浪（〜）时属性值要完全是value时才匹配</p><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h3><p>在链接中常看到的锚点伪类：link、visited、hover、active</p><h3 id="UI元素状态伪类"><a href="#UI元素状态伪类" class="headerlink" title="UI元素状态伪类"></a>UI元素状态伪类</h3><p>例如 :enabled，:disabled，:checked等，这些主要是对一些表单元素操作。 比较常见的如”type&#x3D;”text”有enable和disabled两种状态，前者为可写状态后者为不可写状态。</p><h2 id="CSS3的-nth选择器"><a href="#CSS3的-nth选择器" class="headerlink" title="CSS3的:nth选择器"></a>CSS3的:nth选择器</h2><ul><li>first-child: 选择某个元素的第一次的出现</li><li>last-child: 选择某个元素的最后一次的出现</li><li>nth-child(): 选择某个元素的一个或多个特定的条件的出现，（）内常用算式来指定条件。</li></ul><h2 id="权重如何计算"><a href="#权重如何计算" class="headerlink" title="权重如何计算"></a>权重如何计算</h2><ol><li>根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） &gt; style标签 &gt; link标签</li><li>根据选择器的类型，id选择器 &gt; 类、属性选择器和伪类选择器 &gt; 元素和伪元素</li><li>一般来说我们的计算方式为，从0开始，一个行内样式+1000，一个id+100，一个属性选择器&#x2F;class或者伪类+10，一个元素名，或者伪元素+1</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>太过冷门了，一般不是基础框架级别的开发项目，理论上不会考这种层次的题目。</p><p>原贴链接：<a href="https://juejin.im/post/5b370c63e51d4558c232637e">【前端工程师手册】30分钟搞清楚选择器和权重</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搬家清单汇总</title>
      <link href="/2024/03/14/%E5%BF%AB%E9%80%9F%E6%90%AC%E5%AE%B6%E6%B8%85%E5%8D%95%E6%B1%87%E6%80%BB/"/>
      <url>/2024/03/14/%E5%BF%AB%E9%80%9F%E6%90%AC%E5%AE%B6%E6%B8%85%E5%8D%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>新的一年到了，2024年即将开始去找工作了，整理一下搬家清单，方便日后再次搬家。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先带些简单的物品过去，等工作安定的时候再进行二次搬运。</p><h3 id="核心工具"><a href="#核心工具" class="headerlink" title="核心工具"></a>核心工具</h3><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>以下物品使用电脑背包完成装运</p><ol><li><p>笔记本电脑，日常工作用</p></li><li><p>纸笔，纸笔本子，负责在外记录日常事件</p></li><li><p>钱包，携带各类证件，<strong>驾照，身份证</strong></p></li><li><p>药品，高血压+甲状腺相关的药物</p></li><li><p>充电宝，防止路上没有电量</p></li><li><p>钥匙</p></li></ol><h3 id="生活工具"><a href="#生活工具" class="headerlink" title="生活工具"></a>生活工具</h3><p>行李箱携带，买个加固的行李箱</p><h4 id="自带"><a href="#自带" class="headerlink" title="自带"></a>自带</h4><ol><li>眼镜及清洗更换套装</li><li>春秋用被褥，毯子</li><li>换洗衣着，两套春秋装，三套内衣内裤，四双袜子</li><li>洗漱用品，洗脸用毛巾，杯子+牙膏+牙刷，刮胡刀+剃须沫</li><li>颈部U形枕</li><li>卫生纸</li><li>部分书籍</li></ol><h4 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h4><ol><li>洗浴用品，洗头膏+沐浴露</li><li>垃圾桶+垃圾袋</li></ol><h3 id="后期搬家"><a href="#后期搬家" class="headerlink" title="后期搬家"></a>后期搬家</h3><p>新地方要有空调，冰箱。</p><h4 id="学习用"><a href="#学习用" class="headerlink" title="学习用"></a>学习用</h4><ol><li>台式机+手柄+双显示器+耳机，日常游戏和家庭办公使用</li><li>书籍，最近要看的书</li><li>标签，方便贴</li><li>绘画板</li><li>插排（长插排，短插排）</li><li>电影挂</li></ol><h4 id="生活用"><a href="#生活用" class="headerlink" title="生活用"></a>生活用</h4><ol><li>冬季被褥+枕头</li><li>各季节衣物</li><li>抱枕</li><li>超大水壶+喝水的杯子</li><li>货架（考虑购买，用来装日常的东西）</li><li>医疗箱（感冒发烧药，创可贴，温度计，血压计）</li></ol><h4 id="食物用"><a href="#食物用" class="headerlink" title="食物用"></a>食物用</h4><ol><li>保鲜膜</li><li>电水壶，日常烧水使用</li><li>空气炸锅+电磁炉+小型高压锅</li><li>食材（鸡蛋，挂面）</li><li>调料（油，盐，辣椒，孜然，黑胡椒，花椒，八角）</li><li>购买厨具，捞面勺，木铲，厨具挂架，玻璃碗，筷子，勺子</li></ol><h4 id="通勤用"><a href="#通勤用" class="headerlink" title="通勤用"></a>通勤用</h4><ol><li>自行车+骑行水壶+骑行用的套装</li><li>运动用装衣袋子</li><li>电动车【这次考虑买个电池容量大的】</li></ol><h4 id="摆件"><a href="#摆件" class="headerlink" title="摆件"></a>摆件</h4><ol><li>手办</li><li>桌面书架</li><li>桌面灯具</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>u盘，工作用的</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>仿佛重新回到的大学毕业前夕。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终减肥汇总</title>
      <link href="/2023/12/30/2023%E5%B9%B4%E7%BB%88%E5%87%8F%E8%82%A5%E6%B1%87%E6%80%BB/"/>
      <url>/2023/12/30/2023%E5%B9%B4%E7%BB%88%E5%87%8F%E8%82%A5%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>回想起今年这一年关于身体调养这一块儿的进度，简直是惨不忍睹。</p><p>但是，相比之前不要命的工作生活，我感觉要好很多，我更感觉到自己像个人，而不是爆金币机器一样的在活着。</p><p>这次到年底了，我汇总了一下这年的减肥经历，算是为来年工作后变更的生活方式做准备。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>随着减肥计划的正式执行起来，我个人才发觉，这不仅仅是控制饮食和每天多执行一两项运动。</p><p>为了控制饮食，那么就无法选择外卖或餐馆，这需要自己购买食材，修改食谱，订购厨具，日常下厨。</p><p>为了增加运动，自己必须着手学习运动的基础知识，并且自己制定和实施计划，购买器械，甚至是报班学习。</p><p>这完全是另一种生活，和只有游戏与工作的我完全不一样的一种生活方式。</p><p>果然，形体其实是一种生活方式的体现，这话在一定程度上挺有道理的。</p><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>因为生活方式发生了改变，所以生活习惯中的注意事项必须得改，让身体学会适应新习惯，这很重要。</p><p>以下按照个人感受的重要程度由高到低排序，仅供参考，未必正确。</p><ol><li><strong>遵循本能</strong>，身体累了就停下休息，上不了强度就不要上，不要为了莫名其妙的胜负欲拉强度，宁愿三天打鱼两天晒网，不要一猛子扎到底，你的身体反应比意志更明白自己的上限在哪。半月板损伤，韧带拉伤，横纹肌溶解，腰椎脆弱，随便一种问题，就能短时间进医院掏空钱包。人体，比想象的强悍也比想象的脆弱，一定要遵循本能。</li><li><strong>控制摄入</strong>，吃比练重要，控制摄入比控制输出更容易，且更容易出效果。我在6到7月，将饮食缩减到一天两顿，体重在三个月内掉了10公斤，且仅仅做了一些普通的大体力活动。当然，如果不辅助运动控制输出，胖回来很容易，在10月之后，饮食恢复了之后，体重又涨了5公斤，所以，吃和练，缺一不可。</li><li><strong>准备运动</strong>，准备运动是一种低成本的保险，做好准备运动，对低烈度大时长的有氧运动，这种工作有一定必要，对于大烈度短时间的爆发性无氧运动，准备运动不做，早晚进医院。</li><li><strong>注意保暖</strong>，因为是在冬季的高强度运动，毛孔扩张容易引起寒气入侵，所以要注意保暖，尤其是膝盖。无论哪种户外运动，膝关节一旦受冷，容易产生关节炎，这将是个长期病痛，所以一定要仔细进行保暖。</li><li><strong>注意睡觉</strong>，睡觉能够恢复每日因锻炼造成的身体磨损，长时间的睡眠对大强度的运动恢复很重要，有几次甚至我睡的时间超过12个小时，那天是第一次骑行40公里且游泳，睡觉，这很重要。</li><li><strong>规律作息</strong>，工作中常态的加班，导致自己在一段时间的紊乱作息之后，彻底无法恢复，而这一年的休假，在初期的混乱之后，作息逐渐正常，尤其是最近锻炼之后，睡眠质量更是好了很多，稳定的作息对身体激素的分泌是有好处的，这点很重要。</li></ol><h3 id="调整饮食"><a href="#调整饮食" class="headerlink" title="调整饮食"></a>调整饮食</h3><p>因为自己有中度脂肪肝，超重，高血压，高血脂，且有肾结石的隐患。</p><p>所以，食谱的制定方向是很容易确定的，而且，也都是医生老生常谈的话题了。</p><p>但这些说辞在实际饮食中，估计很多人都不知道怎么改，又或者没有上心进行特别研究，这里我将自己的策略作为例子放一下，仅供参考。</p><ol><li><strong>低油盐</strong>，针对高血脂和高血压，脂肪肝，盐目前都是捏一点放进去，油基本不沾，直接空气炸锅不加油，或者是炒菜的时候少放，减少日常生活中的火锅和烧烤，控制额外的油盐摄入。</li><li><strong>增加蛋白质</strong>，针对最近运动的补充，因为初期运动对肌肉的损失比较严重，所以需要补充蛋白质。这点选择水煮鸡胸肉比较好，因为鸡胸肉成分较为单一，蛋白质含量较高，且水煮过后，几乎没有油脂。而鸡蛋的蛋黄有一定的固醇，对血脂可能不太好，尽量少吃。当然，就个人而言，煮鸡蛋做起来方便，吃起来简单，早餐鸡蛋配煎饼，随便配点酱菜就能下肚。</li><li><strong>减糖分</strong>，也就是减少碳水，这点针对体重，尤其是米饭和挂面，高GI值，很容易造成碳水摄入超标，如果可以，尽可能的多砍一些，仅做到饱腹感即可，不要每顿吃到撑，目前吃挂面的一顿摄入量也从2两减少到1两重。</li><li><strong>多吃水果</strong>，补充维C，水果只能当辅餐，适用于运动后补充，避免饥饿感，也可以作为前期轻断食的早餐。</li><li><strong>增加饮水</strong>，针对肾结石的问题，只能多饮水了，但是不能在一段时间内狂饮，尊重身体的代谢规律，在日常生活中增加饮水量即可。</li><li><strong>轻断食</strong>，16+8 断食法，8小时内吃完两顿，完成一天的饮食摄入，剩下的16小时不吃，要么就稍微吃点水果填填肚子，解决掉就行。</li></ol><h3 id="运动选择"><a href="#运动选择" class="headerlink" title="运动选择"></a>运动选择</h3><p>体重105 KG，所以减重无法选择跑步等运动，最终能选择的方向也只有那几个，将来体重减少的话，可能会选择其他运动。</p><p>现在，经过参考和选择之后，锚定在骑行和游泳这两个运动上。</p><ul><li><strong>骑行</strong>，是因为成本相对便宜，而且是个便捷的交通方式，能够让人走到很多地方。</li><li><strong>游泳</strong>，是因为这个热量消耗较高，不伤膝盖，强化腰背，锻炼起来不痛苦，并且很解压，能作为将来工作时候平衡心情的运动，所以很值得选择。</li></ul><p>这里浅谈一下运动中的及两种运动中的注意事项，仅仅说的是对安全注意事项，不包括运动的具体准备。</p><ol><li><strong>注意时间</strong>，剧烈运动前后一个小时不要吃饭，会影响胃部供血，长期会导致肠胃问题。</li><li><strong>注意补水</strong>，就是普通的整点盐水就行，调味可以按照自己的需求加点别的，我自己扔了个泡腾片感觉味道还不错。保证自己身体不会进入脱水状态，就是所谓的电解质失衡，自己整个脉动也行。</li></ol><h4 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h4><ol><li><strong>防风</strong>，不然冬季骑行大概率不是锻炼，而是骨科病症的催化剂，尤其是膝盖和腰部需要注意保暖。</li><li><strong>蹬腿</strong>，调整座位和脚蹬的距离，保证自己的腿是能蹬的开，确保是直上直下，这对膝盖有好处的。</li><li><strong>配灯</strong>，因为有可能是夜骑，所以前后灯光最好都配一下，便于路上标识，省的路灯暗的时候被撞。</li></ol><h4 id="游泳"><a href="#游泳" class="headerlink" title="游泳"></a>游泳</h4><ol><li><strong>热身准备</strong>，不然容易腿抽筋，确实不伤膝盖，在下水锻炼之前，最好多做几组拉伸运动。</li><li><strong>配带泳镜</strong>，游泳学习必备，防止眼睛出结膜炎，泳池的水很脏，而眼睛很脆弱</li><li><strong>注意洗浴</strong>，否则皮肤和头皮在游泳后会很难受，防止头发和皮肤出问题。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>回顾这段时间的经历，真的是又是一种全新的生活体验，不讨厌，也谈不上喜欢。</p><p>这不仅仅是少吃一顿，或者是每天多运动几个小时这么简单的问题，因为时间分配的改变，自己平日的关注方向和日常喜好都开始往另一个方向偏移，感觉很微妙。</p><p>我会花费一年时间尽快完成这段经历，希望尽快恢复健康吧，我有点讨厌这种被一件事牵着鼻子走的感觉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酸辣鸡胸肉汤</title>
      <link href="/2023/12/04/%E9%85%B8%E8%BE%A3%E9%B8%A1%E8%83%B8%E8%82%89%E6%B1%A4/"/>
      <url>/2023/12/04/%E9%85%B8%E8%BE%A3%E9%B8%A1%E8%83%B8%E8%82%89%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<p>慢菜，不过容易做，价格便宜，且味道不错，可以作为休闲菜记录下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这个菜的起手方式比较通用，蒜，辣椒爆香，炒肉。</p><p>前半段算是常规的辣子鸡的做法，本来到此打算结束来着，但是是</p><p>至于加入蘑菇，加醋和水，这两个操作单纯是自己按照个人喜好调了一下，没想到味道意外的不错，有点大学时候吃酸汤肥牛的感觉。</p><p>所以，姑且就把这次的菜，命名为酸辣鸡胸肉汤吧。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>这里边的数据只能做个参考，实际情况按照每人调配的情况为准</p><table><thead><tr><th>指标</th><th>数据</th></tr></thead><tbody><tr><td>时间</td><td>30 min</td></tr><tr><td>价格</td><td>5元左右</td></tr><tr><td>重量</td><td>520 g</td></tr><tr><td>热量</td><td>300大卡左右</td></tr></tbody></table><h3 id="调料"><a href="#调料" class="headerlink" title="调料"></a>调料</h3><ul><li>植物油，铺锅底一点点就行</li><li>盐，捏点就行</li><li>蚝油，挑几筷子，稍微放点</li><li>醋，多加点</li><li>味精，捏点就行</li><li>烧烤料（辣椒粉，孜然粉，黑胡椒粉等）</li></ul><h3 id="备菜"><a href="#备菜" class="headerlink" title="备菜"></a>备菜</h3><p>之所以这里加蒜黄，是为了自己降血脂用，具体每种备菜的多少，按自己喜好稍微调整</p><ul><li>几颗辣椒，随便切切，如果是腌制辣椒更好</li><li>几颗蒜，拍平随便切切，</li><li>一瓣蘑菇，巴掌大，撕成条，最好是平菇</li><li>一块鸡胸肉，撕成条，空气炸锅热处理一下（160度 20 min）</li><li>蒜黄两颗，随便切切，半指长就行</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>这里我用的是电磁炉，全程2400度，最后煮的时候才是3500大火</p><ol><li>鸡胸肉焯水之后，用空气炸锅炸20 min做备用菜</li><li>热油，加入蚝油，听到油响声，加入辣椒和蒜，开炒</li><li>等到油开始炸了，放入炸好的鸡胸肉，蘑菇，醋，让肉和蘑菇入酸味</li><li>翻炒1 min左右，加水，煮5 min左右</li><li>最后撒上蒜黄，稍微煮一下</li><li>出锅，装盘</li></ol><p>建议配合面饼吃，这个鸡胸肉的嚼劲配合面饼还是带劲的，配饭吃的话，稍微浪费了这个口感。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是第一次在个人博客中记录自己做菜的经历，虽然有点怪，但排除刷锅和刷碗的麻烦，做菜真是一个让人心情放松的事情啊。</p><p>不过，这也许是因为这段时间闲着，才会有这种心态吧，不知道未来忙起来的我，会不会还认为做菜是个放松的事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 做菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次游泳</title>
      <link href="/2023/12/01/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%B3%B3/"/>
      <url>/2023/12/01/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%B3%B3/</url>
      
        <content type="html"><![CDATA[<p>关于游泳，在一开始设计骑行的时候，就规划了，但是真到了做起来的时候，还是有点期待和紧张。</p><p>特别记录一下自己这段时间的经历，说不定未来会用得上这次的经验，这里也分享出来，说不定有朋友用得上。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>市中心游泳馆距离自己所在位置是20公里，骑行过去一小时左右。</p><p>之后，再进行游泳这样的大体力消耗，以我现阶段200斤的肥肥体重，感觉力不从心，但还是血脂血压一直超标，需要尽早处理，我需要这个高效的运动方式。</p><p>所以，这个运动得尽快学会，这对将来会是个不错的选择。</p><h3 id="游泳优点"><a href="#游泳优点" class="headerlink" title="游泳优点"></a>游泳优点</h3><p>关于游泳的优点，很多人都已经吹过了。这里结合自己的体验，大致总结了一下自己感受到的优势</p><ol><li>散热快，水里很快就能把身体产生的热量散掉，流汗的感觉几乎没有</li><li>体感弱，因为游泳过程较为放松，虽然后边体力明显感到下降，但是你最后居然不会觉得很累</li><li>对腰好，平日其他运动锻炼不到背肌，但游泳确实对背部和腹部的锻炼效果很明显</li><li>换装快，不担心像常规运动一样换衣服，洗过澡后，穿衣服和平常一样，适合冬季这种衣服多的季节</li><li>效率高，热消耗速度很快，对时间要求不高，只要抽个整块的时间就好</li></ol><p>而且，在今后的工作里边，如果每周工作时间吃紧，游泳将会是很好的解压和消耗方式，对于热量消耗的效率来说，游泳也确实是最快的。</p><h3 id="场地选择"><a href="#场地选择" class="headerlink" title="场地选择"></a>场地选择</h3><p>市体育中心游泳馆，综合考量了本地的所有场地之后，最终选择了这里，优势如下</p><ul><li>有吹风机，保证游完之后可以吹干头发</li><li>冬季游泳人数少，空间大方便活动</li><li>室内保暖，水温恒温，水质看着还可以</li><li>有私教，而且支持一对一，一对多教学，方便时间安排</li><li>周边有体育用品的商店，缺设备了可以直接买</li><li>周边饭店较多，如果某天实在饿，可以考虑去补餐</li></ul><p>目前看来，唯一的缺陷就是没有微波炉，我本来想带点吃的过去直接打热补餐的，现在看来不需要了。</p><h3 id="游泳准备"><a href="#游泳准备" class="headerlink" title="游泳准备"></a>游泳准备</h3><ul><li><strong>泳裤，泳镜，泳帽，耳塞</strong>。泳裤不用说，耳塞是为了防止自己中耳炎的问题，泳帽尽可能减少头发沾水，因为还要回去的，至于泳镜，考虑到进水想看东西，防止眼睛受水刺激，我觉得还是得戴。</li><li><strong>大瓶装自制电解质水，煮鸡蛋，苹果</strong>。游泳之后会很饿，所以得加餐压肚子，补充蛋白质很重要，另外少部分的碳水也能缓解体内碳水丢失的问题</li><li><strong>入场前散步半小时。</strong>因为是长途骑车过去的，所以一开始身体热量很大，需要散热至常温再游泳，防止因为温差导致感冒。</li></ul><h3 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h3><p>为了保证自己的体力，至少保证自己没有过量运动，毕竟现在是大体重时间，运动要小心。</p><ul><li>单日休息，学习的时间就骑电动车过去。</li><li>双日骑行，保证每周骑行100公里以上。</li><li>保证每周游泳三公里以上</li></ul><h3 id="目标规划"><a href="#目标规划" class="headerlink" title="目标规划"></a>目标规划</h3><ul><li>学会蛙泳，能初步进行常规游泳的水平</li><li>尽可能一小时内游一公里的距离</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管知道短期高速减重对身体负荷很大，但是再不把体重压下去，过了30，估计身体真的要出问题。</p><p>已经到了今年的最后一年了，是该把年初的减重计划继续执行了。</p><p>之前耽误了不少时间，现在快到年底了，尽可能的完成一部分目标，亡羊补牢吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次长途骑行</title>
      <link href="/2023/11/28/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/"/>
      <url>/2023/11/28/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>没想到自从初中毕业之后，第一回骑行超过40公里。</p><p>这种距离的骑行，简直离谱，这里先记录一下本次骑行的感受。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次骑行目的单纯的是为了去驾校拿驾照，市车管所距离我所在的居住点22公里左右，来回也就是45KM左右。</p><p>这个距离通行很是问题，目前我的通行方式有如下几种方式。</p><ul><li>坐公交，来回大约需要付出5小时左右的时间，花钱不超过20</li><li>出租车，来回大约需要1.5小时左右的车程，花钱大约需要200</li><li>骑电动车，来回大约3小时，不要花钱，但基本上单趟可能就没电了，中间充电需要最起码两到三小时</li><li>骑自行车，预计需要4小时起步，不花钱，但是对意志和体力是个极大的考验</li></ul><p>考虑到我这次不需要考试，没有时间上的要求，而且我最近正在进行体能恢复期，最后我选择骑行。</p><h3 id="骑行准备"><a href="#骑行准备" class="headerlink" title="骑行准备"></a>骑行准备</h3><p>因为本次骑行是冬季，所以做的准备还蛮多的，这一套装备下来，还行，不算太贵，粗略算了一下，也就不到一千，属于丢了不心疼的类型。</p><ul><li><strong>500左右的自行车</strong>，摔着不心疼</li><li><strong>灯光配件</strong>，大灯和车尾灯，保证天黑的时候自己不会被撞</li><li><strong>骑行手机支架，</strong>保证路上有导航不会迷路</li><li><strong>软车垫</strong>，屁股不会硌得慌</li><li><strong>耳机，漫步者的X3air</strong>，便宜丢了不心疼，音质还不错，不过不能通话，而且入耳式有点难受</li><li><strong>充电宝</strong>，骑行距离较远的情况下使用，</li><li><strong>防风的厚衣服，骑行服也可以</strong>，保证自己不受冷</li><li><strong>防风护膝</strong>，保证膝盖不受冷</li><li><strong>骑行风帽，围脖，手套</strong>，保证路上不受冷</li><li><strong>骑行护腰</strong>，保证屁股和腰不受冷</li><li><strong>自制电解质水</strong>，用保温壶装的，保证自己骑行过程中可以及时补充电解质和水分</li></ul><h3 id="骑行数据"><a href="#骑行数据" class="headerlink" title="骑行数据"></a>骑行数据</h3><ul><li>单次极限最大骑行距离：30km</li><li>配速：12km&#x2F;h左右</li><li>消耗大卡：240大卡&#x2F;10km</li></ul><p>以上数据是根据高德地图的给出的数据总结的，不过最大骑行距离是我个人的体感，估计未来会随着身体适应会增长。</p><p><strong>超过30KM这个距离</strong>，四肢会发冷，身体会极度饥饿，思维会止不住的往食物上思考，意识难以正常思考，对食物的渴望一度让我回想起很早之前离家流浪的时间，而且身体热量无法维持衣物保温的感觉。</p><p>饥饿甚至让我不自觉的想哭，明明我不是一个这么脆弱的人，但是我在骑行的最后那段距离，真的有点绷不住，不是理性上的，是情绪上的不对劲。街边很长一段距离找不到一家开着的饭店，甚至是普通的便利店！才下午5点，天一黑久关门的吗？！</p><p>我尽力用意识驱动身体，但是奈何腿部就像是不听使唤的软了一样，一用力眼前就有点发晕发黑。</p><p>30KM，这个距离似乎就是意志的极限，无论怎样想强迫身体行动，我都用不上力。</p><p>果然，像小说中用意志突破身体极限这种事想想就行了，现实还是老老实实吃饭。</p><p>所以，接下来的骑行距离，必须控制在30km这个距离来处理。</p><p>幸亏这时候有个餐馆，一盘土豆丝加十张煎饼总算压住了饥饿感，顺便老板还借用了充电器，总算把手机的电量也补上了，这要是没补上手机的电量，之后的10KM，估计得抓瞎。</p><p><strong>总结，必须要做好骑行规划！</strong></p><h3 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h3><p>大方向依然是减重，但是思路得改改，光靠饿，确实不够。</p><p>之前，靠着减餐加些许的体力活，2个月极速减短了15公斤左右的体重，然后就很难再压下去了。</p><p>而且，可能是由于饿下来的体重，最近一个月，两餐恢复到三餐，体重又开始上升了。</p><p>看来，大体力的日常训练还是需要提上日程的，必须的早点在进入工作前，将自己的体重压到正常状态。</p><p>目前因体重较大，无法进行跳绳、跑步等运动，所以，接下来需要提升心肺能力，增加基础代谢，同时减少体重，保证之后这些运动不难么损伤膝盖。</p><p>综上，我大概确定自己的骑行的目标，除了体重，其他暂时模糊一些，保证自己能够便于调节。</p><ol><li>提升自己的心肺能力，为接下来的运动做准备</li><li>提升自己的基础代谢能力，增加脂肪的消耗</li><li>摸清楚自己骑行的行动范围，便于规划行程</li><li>明年一月前，体重减至95KG左右</li></ol><h3 id="地点规划"><a href="#地点规划" class="headerlink" title="地点规划"></a>地点规划</h3><p>关于老家周边的景点，暂时不做长期规划，就自己最近当短途骑行练手了。</p><p>这里先放一些未来打算长期光临的功能地点，作为骑行终点。</p><table><thead><tr><th>目的地</th><th>距离</th><th>作用</th></tr></thead><tbody><tr><td>翰景园</td><td>21.7km</td><td>朋友家，他是独居的，可以用来做整修的篝火点</td></tr><tr><td>市体育馆</td><td>20.3km</td><td>有恒温游泳馆，冬季可以游泳</td></tr><tr><td>市图书馆</td><td>21.6km</td><td>可以去借一些社科类书籍</td></tr></tbody></table><h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><ol><li>骑行尽可能选择有店面的路途，不至于路途上补水都困难。</li><li>出发时间尽可能选在早上10到12点，有太阳，不会冷</li><li>出发时候可以稍微吃点，但是骑行到30KM，停下随便吃点，喝点水也行，保证自己的胃不至于干扰到大脑的判断</li><li>减少对高油脂类的肉食摄入，不然累死累活减少的热量，一吃肉全补回来了</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>意志不是万能的，不要相信小说里边意志支配一切的说法，体能训练，必然是要循序渐进的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《程序员修炼之道》</title>
      <link href="/2023/10/27/%E8%AF%BB%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/"/>
      <url>/2023/10/27/%E8%AF%BB%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>很早之前，在初步工作的时候，我的上级推荐了这本书，但那时忙于工作，没有阅读。</p><p>最近闲下来了，无事读了一下，只觉得很鸡肋。倒不是书里边说的不对，而是很多话很务虚。</p><p>对于职场新人来说，这书是有用的，但对于老工具人来说，这些说的大概率是基本常识。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来想按照书中的目录来做摘要，但是想了想，我觉得还是按照自我理解进行总结比较好。</p><p>这本书的核心，是给新手上路的程序员梳理了一套工具人的做事准则和标准，讲的更多是偏向于思路和准则，而非具体的行事手段。</p><p>所以，这里也只是做个概括和总结，不会在细节上深入探讨。</p><h3 id="角色分类"><a href="#角色分类" class="headerlink" title="角色分类"></a>角色分类</h3><p>于个人而言，一个程序员能在开发团队中无非扮演三个角色：<strong>协调者</strong>，<strong>开发者</strong>，<strong>项目猎手</strong>。</p><p><strong>项目猎手</strong>：负责和甲方进行需求谈判，往往会承担一定的产品经理的功能。这个角色不要求有多少开发能力，更偏向于设计者和商务人员，需要非常强的沟通能力。如果有很深的商务或政治背景，那更是如虎添翼。因为我涉及的比较少，所以这里不会涉及更多的讲解。</p><p><strong>协调者</strong>：一般是项目组长，团队leader，负责协调工程开发的人员和工期安排，以及其他的资源调度。</p><p><strong>开发者</strong>：工具人，负责解决具体的目标的落实，高级开发会负责攻克技术难点，普通开发负责完成常规的堆量任务。</p><h3 id="通用准则"><a href="#通用准则" class="headerlink" title="通用准则"></a>通用准则</h3><p>这里首先列举一些通用准则，无论是协调者和开发者，都需要遵循的做事准则。</p><ol><li><strong>不断学习，提升个人开发能力</strong>，对个人开发能力的提升，都是毋庸置疑的，不过协调者只需要了解大概，后者则需要将开发技术用到纯熟。</li><li><strong>提供方案，而非借口</strong>，无论是推卸责任，还是挑起大梁，当项目发生问题的时候，需要的是一个至少是能说服大多数的解决方案，而不是随意的借口用来推脱，很多项目成员用借口来推脱工期，很容易造成项目整体的迟缓。</li><li><strong>防微杜渐，不要破窗</strong>，在项目工期允许的情况下，尽可能的不要留下烂代码，这些埋下的雷，早晚会让自己陷入项目崩溃。</li><li><strong>不要技术追星，稳定压到一切</strong>，项目中使用新技术，一定要保证自己能够把持住，否则新技术的使用，有可能让项目整体陷入停摆。</li><li><strong>模块不耦合，独立功能块</strong>，功能尽可能的独立分割，这会让工程问题的排查和联调方便很多，后续独立升级也会方便。</li><li><strong>学习项目领域的知识</strong>，无论是开发人还是协调人，对于项目涉及领域的知识都要有一定的学习，这样才不会被甲方牵着鼻子走。</li><li><strong>文本工具很重要</strong>，除非个人的记忆能力几乎达到过目不忘的地步，否则不推荐脑记，最好用本子或者是文本工具记录每日的需求及任务，管理好需求。</li></ol><h3 id="协调人角度"><a href="#协调人角度" class="headerlink" title="协调人角度"></a>协调人角度</h3><ol><li><strong>有敏锐的技术嗅觉，做项目的变革者</strong>，如果一项新技术能大幅缩短开发周期，减少工作量，那么在你能掌握的情况下，可以试着引入项目中，推动项目变革，这需要你来做这个决断，也需要靠谱的组员来执行，请确定自己的团队在整体有意愿升级的情况下，再做出这个决定。</li><li><strong>不做最终决定，尽可能做预案</strong>，如果你是甲方，可以无视。但是大多数情况下，我们只能不断和甲方做沟通，给出一个方案，然后在确定一个基础版本的情况下进行迭代，推进任务进度。</li><li><strong>牢记全景，关注进度</strong>，无论是每日的快速会议，或者是日报周报，都是为了增加对项目的掌控力，不至于让开发进度失控，目前常规的做法就是日报周报，但是如果你对团队足够信任，团队又足够的自律，其实只需要周报即可。</li><li><strong>做好版本管理</strong>，一个稳定的版本管理，会让所有的意外都有个回档点，这会让所有人的工作量有个读档位置，作为协调者，一定要管理好每人每日的工作量。不然团队工作量的丢失会让团队闹出很大的不愉快。</li><li><strong>做好评估，排好日程</strong>，安排任务的时候，如果时间允许，就要预留一些冗余的时间来防止意外，而任务一旦确定，就要在管理平台或者是文本上做好记录，这便于后续做工作量的评估和管理</li></ol><h3 id="开发人角度"><a href="#开发人角度" class="headerlink" title="开发人角度"></a>开发人角度</h3><p>相对于协调人的角色，我更多的扮演了开发人的角色，所以这里会更多的提到开发角色应做的事情。</p><h4 id="做事准则"><a href="#做事准则" class="headerlink" title="做事准则"></a>做事准则</h4><ol><li><strong>学会反馈，做好沟通</strong>，所谓的沟通不是那种世俗的拍马屁，那种狗屎一样的传统文化必须尽早放弃。这里的沟通，更像是游戏中的报点和卡位，你的反馈就是项目协调者的眼睛，哪怕你遇到了解决不了的问题，一定要反馈，这样协调人才知道给你批多少时间才能解决你遇到的问题，需要给你协调什么资源解决这个问题。</li><li><strong>不越雷池半步，不要画蛇添足</strong>，每次任务迭代，要做什么事情，在任务规划好之后，完成自己的任务即可，不是自己完成部分，不要动，哪怕你知道那里有问题，要和协调人反馈，告知他问题所在及解决时间和方案，由协调者确认后再开始评估。</li><li><strong>自行开荒，他人即地狱</strong>，不要随意让他人涉及你的代码！这是你的工作！哪怕是实在解决不了的地方，在和团队中的高手沟通后，你只有两个选择，要么这个模块不归你负责，要么此后独自开荒。哪怕是一片荆棘，这条路也必须是你来走。</li><li><strong>做好开发者的个人信用</strong>，如果你承担了任务，哪怕再难也只能完成。你的完成程度，将决定协调者对你的评级，决定同为开发人对你的评价，做好开发任务，会让你在团队中成为可靠的存在，这会让你在技术方案决策中拥有更好的话语权。</li><li><strong>不要动已经很稳定的东西</strong>，这点是违反书籍里的说法的，但是实际操作的过程中，无数次验证了这个信条，当一样代码运行的很稳定的时候，不要随意的改动。除非是协调人给了充足的时间去重构，否则这里的变动会让整个项目发生崩溃。</li></ol><h4 id="编码准则"><a href="#编码准则" class="headerlink" title="编码准则"></a>编码准则</h4><ol><li><strong>简单有意义的命名</strong>，开发过程中，不要随意命名，这会让团队和自己最后陷入迷魂阵，增加开发难度，拖延开发进度。</li><li><strong>用简单快速的算法实现任务</strong>，早年会对算法的速度有要求，但是现在机器性能上升，可以考虑用简单的算法，这样便于他人接手，也便于自己排查。当然，如果能明显的提升速度，那么就用更快速的算法实现任务。</li><li><strong>多做测试</strong>，虽然开发的最后会有测试来做评价，但是实际开发的过程中，如果自己测试好，保证自己的开发质量，那么在后续的联调中，将会非常容易的完成对接，减少工作量。</li><li><strong>保持简洁</strong>，代码的实现不要整的太过于复杂，在保质保量的情况下，越是简单的代码，越好排查。</li><li><strong>倾听直觉</strong>，当你觉得代码编写总是出问题，举步维艰的时候，可以停一停，和他人交流或者去搜索引擎查查方案，这是你的直觉在告诉你，有更简单的方案。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本书毫无疑问是新手程序员的上路指南，很全面，很基础，挺好的。</p><p>但阅读体验不佳，笔者似乎是奔着写论文的感觉来说的，行文很拧巴，也可能是翻译腔的问题。</p><p>只能说上级推荐的时候，对当时的我来说很有用，但是现在的我已经远不是当初的我了。</p><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《程序员修炼之道通向务实的最高境界(第2版)》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觅长生仙术渡劫</title>
      <link href="/2023/10/25/%E8%A7%85%E9%95%BF%E7%94%9F%E4%BB%99%E6%9C%AF%E6%B8%A1%E5%8A%AB/"/>
      <url>/2023/10/25/%E8%A7%85%E9%95%BF%E7%94%9F%E4%BB%99%E6%9C%AF%E6%B8%A1%E5%8A%AB/</url>
      
        <content type="html"><![CDATA[<p>本来是打算随便玩玩的游戏，却没想到仿佛真像是活过一世，大梦一场。</p><p>梦醒之时，依然是叹息，心态似乎也是超然了一些，人活一世，不过如此吧。</p><p>这里顺便也分享一下自己的渡劫心得，算是为这场大梦的画上终结的句号。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>火修渡劫是我考虑很久的想法了，终于玩到这最后的关卡了。</p><p>之前每次过境界关的时候，大多都是抄铁臂猿攻略的。</p><p>但渡劫这个关算是游戏的最后一关了，我拿着最好的资源，好不容易走到这里了，如果最后不是自己走完，实在是有些遗憾。</p><p>所以，我根据手里收集的功法，还有根据攻略的查找，我大致设计了一套。</p><p>经过半天的测试，这套思路基本上不怎么需要太凹，大多数仙术都非常容易获取。</p><p>不过，玩家要保证每回合仙术要准确使用灵气，只要使用得当，飞升不是问题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>目前有两个思路，打击流和挨打反击流</p><ol><li>纯干，直接在最后的灭世劫之前干爆天劫，每个回合都先放积仙术，再用火仙术干就完事了。</li><li>叠血反打，前期叠血量上限，在最后的雷劫里，用火仙术打击，保证剩下的血量即使挨打也没有问题。</li></ol><p>最后权衡了一下，我决定用第二个，主要原因是第二个效果虽然没那么霸气，但是要求不高，不需要凹灵气获取的聚仙术和运仙术。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>血量最好在3.8万以上，尽量和道侣多双修增加血量上限</li><li>预留1000年以上的寿命，不然烬仙术会把自己烧死</li><li>准备好以上提到的仙术</li><li>化神大圆满，可以减伤12%</li><li>化劫丹，减伤10%（可以不用，因为我就没用这个）</li></ol><h3 id="雷劫"><a href="#雷劫" class="headerlink" title="雷劫"></a>雷劫</h3><p>大多数雷劫都不需要注意，只有以下几个雷劫需要注意。</p><h4 id="需要注意的雷劫"><a href="#需要注意的雷劫" class="headerlink" title="需要注意的雷劫"></a>需要注意的雷劫</h4><p><strong>风火劫</strong>，灵气多一点，伤害提升5%，不过基础伤害不高，而且是前期的雷劫，灵气不会存太多，所以还好说</p><p><strong>五行劫</strong>，第五回合回重置灵根权重，且消散所有灵气，第五道</p><p><strong>罡雷劫</strong>，每损失1%生命，则受到的伤害额外提升1%</p><p><strong>生死劫</strong>，附加剩余血量的一半的伤害，第七道</p><p><strong>灭世劫</strong>，附加1w点真实伤害，如果有声望-1000，本次攻略是没法过的，火的伤害不够</p><h4 id="渡劫流程"><a href="#渡劫流程" class="headerlink" title="渡劫流程"></a>渡劫流程</h4><p>随便让雷劈，除了最后一个，无论什么劫，随便劈，劈完之后，把血加上就行。</p><h5 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h5><ol><li>前八劫保证使用滞，气，烬，运，保证每回合的灵气获取，如果灵气多了，就用聚仙术把多余的灵气存到下回合。</li><li>第九劫之前，不要叠盾，要淬体加血量上限，尽可能不要去攻击雷劫，毕竟那都是血量上限</li><li>第九劫之前，尽可能的多存灵气，每回合多存点灵气到下一回合，最后一回合，一定要多存灵气，然后调出火灵气，能用火灵气打散雷劫的伤害，保证自己最后一回合不会被雷劫劈死。</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><h6 id="第一劫"><a href="#第一劫" class="headerlink" title="第一劫"></a><strong>第一劫</strong></h6><ol><li>本回合必须使用淬仙术</li><li>无论是什么劫，一定要在雷前后，把火木权重都加50，保证接下来大部分是这两种灵气，能使用大部分法术。</li></ol><h6 id="第五劫"><a href="#第五劫" class="headerlink" title="第五劫"></a><strong>第五劫</strong></h6><ol><li>保证自己的血量不会被劈到1w以下，尽可能的补血，如果感觉补血抗不下来，就用火灵气打散一部分劫云的伤害。（不过理论上不需要）</li><li>五行劫会重置权重消散所有的灵气，在第五雷劫之后，补上火灵气权重，在第六劫的时候，补上木灵气的权重</li></ol><h6 id="第六劫"><a href="#第六劫" class="headerlink" title="第六劫"></a><strong>第六劫</strong></h6><ol><li>让雷劫尽可能的劈，劈完之后，不要加血，剩下差不多8k容错就够了，因为第七劫血量越多，额外伤害越高</li><li>预留更多的灵气，在第七回合保证自己能打散主要的雷劫伤害</li></ol><h6 id="第七劫"><a href="#第七劫" class="headerlink" title="第七劫"></a>第七劫</h6><ol><li>适量打散雷劫，保证主要伤害加上额外伤害劈不死就行</li><li>第七劫之后，用体，丹仙术，增加血量和灵气，存到下回合</li></ol><h6 id="第八劫"><a href="#第八劫" class="headerlink" title="第八劫"></a>第八劫</h6><ol><li>存够足够的灵气，能压到最后的回合用来决战</li><li>在保证有足够的灵气，尽可能的回血，增加容错（体仙术回血不错）</li><li>可以不用气仙术了，因为这时候再增加灵气上限也没什么意义了，下回合直接决战了</li></ol><h6 id="第九劫"><a href="#第九劫" class="headerlink" title="第九劫"></a>第九劫</h6><ol><li>保证血量在3.5w左右基本上够数。</li><li>全力输出劫云，干就完事了，估计能把伤害压到3万没有问题。</li></ol><h3 id="仙术"><a href="#仙术" class="headerlink" title="仙术"></a>仙术</h3><h4 id="加牌仙术"><a href="#加牌仙术" class="headerlink" title="加牌仙术"></a>加牌仙术</h4><p>存牌，加牌，增加手牌上限</p><ol><li><strong>滞</strong>，受1000伤害，换本回合8点灵气，下回合少5点灵气</li><li><strong>聚</strong>，抽牌回合加牌加4点灵气，有人能做到5点灵气获取，但是我懒得凹了，就随便换了一个，用来存牌</li><li><strong>气</strong>，灵气上限+1，下回合多抽一点灵气</li><li><strong>烬</strong>，消耗50年寿元，1换2</li></ol><h4 id="洗牌仙术"><a href="#洗牌仙术" class="headerlink" title="洗牌仙术"></a>洗牌仙术</h4><p>一定要在使用转仙术改了权重之后，再去调灵气，增加灵气容错率</p><ol><li><strong>运</strong>，洗杂灵气，3换3，有人能做到3换4，但是我懒得凹了</li><li><strong>转</strong>，修改灵根权重+50，用来渡五行劫之后的问题</li></ol><h4 id="回血仙术"><a href="#回血仙术" class="headerlink" title="回血仙术"></a>回血仙术</h4><p><strong>淬，体</strong>仙术必带，<strong>焰，丹，愈</strong>带着是为了用来回血，增加容错率</p><p>这里推荐带愈仙术，补一下血量恢复，增加容错量，五行劫的时候，可以把多余的灵气用来补血。</p><p>如果感觉愈仙术难搞，可以整盾仙术，就是用来增加五行劫的容错率的，不然灵气消散实在可惜。</p><ol><li><strong>淬</strong>，10点雷劫伤害换1点血量上限</li><li><strong>体</strong>，恢复等同于已损失血量50%的生命</li><li><strong>焰</strong>，火灵气越多，回血效果越好，1点火灵气回400点</li><li><strong>丹</strong>，只能用一次，恢复4点灵气，10000点生命</li><li><strong>愈</strong>，5点灵气换5000血量</li></ol><h4 id="攻击仙术"><a href="#攻击仙术" class="headerlink" title="攻击仙术"></a>攻击仙术</h4><p>只要带火仙术就够了，存够足够的灵气，在最后的雷劫打伤害</p><ol><li><strong>火</strong>，3000点伤害。每剩1点火灵气，伤害提升200点</li></ol><h3 id="渡劫结果"><a href="#渡劫结果" class="headerlink" title="渡劫结果"></a>渡劫结果</h3><p><a href="https://www.bilibili.com/video/BV1Vp4y1w7Xj/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】首档飞升成功留念</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1Bo4y1i7hB/?share_source=copy_web&vd_source=a848031cce5c755167a3d6aa6bd87859">【浴火重生，怒焰焚天！觅长生火修渡劫通关（复活魏无极）】</a></p><p><a href="https://www.bilibili.com/video/BV1NF411f7jp/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】火修渡劫，只攻不防</a></p><p><a href="https://www.bilibili.com/video/BV18A411R7uC/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】：解锁 逆天造化 七种常用仙术滚键盘渡劫成功（1）</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以前没有大段的时间来玩这种游戏，在考完试之后，尝试了一下，然后十分上头的玩完了。</p><p>可以说这个游戏是个真的好游戏，我仿佛真的是在修仙世界中活过一世，飞升之时也是久久难以释怀。</p><p>本来想写更多，还是当回文抄公，赋诗一首，以表心意吧。</p><p><strong>万般因缘皆是相，不教红尘惑心间。</strong></p><p><strong>千磨万击还坚劲，我命由我不由天!</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年第一次被骗</title>
      <link href="/2023/06/10/2023%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/"/>
      <url>/2023/06/10/2023%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<p>万般皆是命，半点不由人，一波被清空了6.5万，是我自己亲手转过去的。</p><p>以前也有被骗过，但是金额如此之大，对我的生活影响如此之重，这是第一回。</p><p>现在想来，只能说事情已经被发生了，总结经验吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次的诈骗过程，我就不多说了，并未因为我贪心，而是我太信任官方了。</p><p>对方准备个人信息非常精准，甚至我的这段时间办理信用卡的事情都能知道，这太离谱了。</p><p>只能说是马老师遇上二百多斤大力士————有备而来，我也没有什么办法，只能说总结一下经验，避免下次在遇到吧。</p><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><p>复盘了整个被骗的流程，只要涉及到金额转账，大概率按照以下的思维回路去想，应该是没错的。</p><ol><li><strong>大金额，到柜台操作</strong></li><li><strong>什么大事警局见，电话网络都不可信</strong></li><li>事情都是简单的，复杂的操作一切转柜台，不然转二</li><li>要做好对方知道你所有信息的准备，哪怕他报出了你的身份证号，银行卡号，还有所在学校，手机号，电子邮箱，都不要信，凡是转第二条</li><li>官方的态度一般很恶劣，平时银行都是爱吊不吊的，不会电话提供复杂操作的便利，出现什么复杂操作，一切转第二条。</li><li>尽可能的把钱多散在其他的几张卡中，哪怕真出现损失，也不会损失太多</li><li>最后，哪怕你不贪心，也不要嫌事情麻烦，如果遇到威胁，一切转二</li></ol><h3 id="拉斯格十诫"><a href="#拉斯格十诫" class="headerlink" title="拉斯格十诫"></a>拉斯格十诫</h3><p>这里放上经典杂种的话，虽然他做的事情都很狗，但是这确实是很有道理。</p><ol><li>永远耐心倾听对方诉说；</li><li>永远生机勃勃；</li><li>让对方先表明政治倾向，然后附和；</li><li>让对方先表明宗教立场，然后附和；</li><li>轻微地暗示性话题，但不要发挥，除非对方表现出强烈的兴趣；</li><li>不要谈论任何疾病，除非对方特别关注；</li><li>不要打听对方的私人情况（最终他自己会说）；</li><li>永远不要自吹自擂，自然明确地显示你的分量；</li><li>永远衣冠整洁；</li><li>永远不要喝醉。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事情已经发生了，只能打乱计划重新来了。</p><p>原本计划到明年4月的内容，这次只能提速了，一切拉到今年10月份看看。</p><p>只要能做完计划中的任务，那也算是这趟休息没白休。</p><p>心里有着无尽的痛苦和愤怒，却最终只能无奈，这个世界，只有自己可以相信。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNF私服搭建指南——服务端部署</title>
      <link href="/2023/05/13/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/05/13/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>朋友最近想玩70版本的私服，正好腾讯云最近搞活动，想了想就搭建了这个服务器。</p><p>这里记录一下这个流程，毕竟私服搭建算是一个。</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你需要有以下的工具，在准备好以下内容之后，就可以进行服务端部署了。</p><ol><li><strong>一台linux云服务器</strong>，系统推荐使用CentOS 7.6 64bit，至于云服务的提供商，只要你是新人，随便哪家都可以，目前各家云服务商为了争新客户，对新人很优惠，老用户不如狗。</li><li><strong>一个SSH服务器链接工具</strong>。这里看到很多教程用Putty，但是用了几次感觉很难用，我个人推荐使用<a href="https://mobaxterm.mobatek.net/download.html">MobaxTerm</a>，下载使用free版本就行，免费可以连接十个服务器。</li><li><strong>一个服务端安装包</strong>。这里是推荐七月DNF的一键安装包，比很多教程中的各种安装好用了不少，我这里放一下<a href="https://pan.baidu.com/s/1BlY9OTYsUC5xpHuRO5mjtw?pwd=1234">百度云盘的链接</a></li><li>足够的有耐心，细心。整个服务端部署如果顺利，10分钟左右就能完成，不顺利的话，可能会有各种各样的意外</li></ol><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>这里略过服务器购买的过程了，这些东西就不讲了。</p><p>这里也默认大家将我以上的所有内容下载完毕，默认大家有一定的服务器使用知识，具体的细节我就不细讲了。</p><h4 id="连服务器"><a href="#连服务器" class="headerlink" title="连服务器"></a>连服务器</h4><p>如果对MobaXterm这里不清楚，可以参考<a href="https://www.bilibili.com/video/BV1NN4y1K7Np/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">教程</a>。</p><p>这里当然也可以使用其他的SSH链接工具，连接服务器。</p><h4 id="找到路径，上传服务包"><a href="#找到路径，上传服务包" class="headerlink" title="找到路径，上传服务包"></a>找到路径，上传服务包</h4><p>在服务器路径这里输入&#x2F;root，进入到服务器这个路径下。</p><p>然后将vip的服务端包放到&#x2F;root目录下，并在命令行中，启动该安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O dnf.7yvip.cn/vip;chmod +x vip;./vip</span><br></pre></td></tr></table></figure><p>剩下的，按照命令行的提示，无脑往下走就行，然后等待安装成功即可。</p><h4 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h4><p>如果我们需要在服务器端敲如下命令，启动安装包即可。</p><p>在linux中，.&#x2F;vip就代表执行这个安装包脚本，如果安装包的名字不一样，记得命令里边也换成安装包的名字，别弄错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vip</span><br></pre></td></tr></table></figure><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><p>我们这里需要进行<strong>数据备份</strong>，我们按照命令行选择对应的操作，然后一路按照提示设置下去即可。</p><p>备份好之后，我们服务器内会生成一个&#x2F;root&#x2F;mysqlbak&#x2F;的文件夹，之后，服务端会在我们设计的时长内进行一个备份，我们定期保存好这部分数据即可。</p><h4 id="服务重启"><a href="#服务重启" class="headerlink" title="服务重启"></a>服务重启</h4><p>数据回档或者其他的一些操作，可能需要停止服务器，这里可以按照如下操作。</p><p>注意，谨慎进行这些操作，不要随便执行，该操作容易对服务器内的数据造成影响。</p><p>如果方便，尽量让当前服务器内的玩家在对应时间段下线。</p><p><strong>停止服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stop</span><br></pre></td></tr></table></figure><p><strong>重启服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>SF运行真是个力气活，打死也不想参与这事儿。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/weixin_46526674/article/details/124864662">DNF单机版搭建（局域网、外网）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNF私服搭建指南——服务器选择</title>
      <link href="/2023/05/07/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/"/>
      <url>/2023/05/07/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>本文是转载帖，是在论坛正好看到的教程帖，非常不错，这里特地选择性的转载一下。</p><p>文末附上了原贴地址，有兴趣的可以参观原帖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>朋友最近因为DNF官服和谐太多比较不爽，所以脱坑。</p><p>正好我手里有一台闲置的服务器，想了一下，决定搭建一个私服让朋友们私下玩玩。</p><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线人数计算方式=带宽大小÷单人传输数据大小（360流量防火墙能看到具体数据值一般为50KB左右）</span><br></pre></td></tr></table></figure><h3 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h3><ul><li>处理器（核&#x2F;H）：处理器大小反映了服务器处理运算能力</li><li>内存（G）：内存大小关系到同时处理程序的数量多少</li><li>带宽（M）：  带宽会影响访问传输数据速度</li></ul><table><thead><tr><th>CPU</th><th>内存</th><th align="left">带宽</th><th>同时在线人数</th></tr></thead><tbody><tr><td>1</td><td>1</td><td align="left">1</td><td>10</td></tr><tr><td>1</td><td>2</td><td align="left">1</td><td>20</td></tr><tr><td>2</td><td>2</td><td align="left">2</td><td>50</td></tr><tr><td>2</td><td>4</td><td align="left">2</td><td>100</td></tr><tr><td>4</td><td>4</td><td align="left">5</td><td>200</td></tr><tr><td>4</td><td>8</td><td align="left">5</td><td>500</td></tr><tr><td>8</td><td>8</td><td align="left">10</td><td>1000</td></tr></tbody></table><h4 id="带宽备注"><a href="#带宽备注" class="headerlink" title="带宽备注"></a>带宽备注</h4><p>关于带宽，要注意，单位是M，不是mbps。</p><p>不了解的朋友可能会把带宽中的mpbs等同于M进行理解，这个是不对的，二者的换算关系如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8Mbps/8=1MB/S=1024KB/S</span><br></pre></td></tr></table></figure><p>如果有使用自家的服务器搭建的，大概能理解，比如千兆光纤对应的网络下载速度是125M&#x2F;s，就是这个意思。</p><p>所以，在挑选服务器的时候，一定要注意带宽单位，别选错了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的操作纯属玩票，预估100人左右就差不多了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bbs.aladedalu.com/thread-1265-1-1.html">DNF开服服务器配置如何选择参考指南 - DNF单机版 - DNF阿拉德游戏论坛 (aladedalu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> dnf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑装机及系统安装</title>
      <link href="/2023/05/05/%E7%94%B5%E8%84%91%E8%A3%85%E6%9C%BA%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>/2023/05/05/%E7%94%B5%E8%84%91%E8%A3%85%E6%9C%BA%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本来打算装完机就开始记录的，但是之后配置电脑环境和安装软件耽误了很多时间，一直忙到现在。</p><p>现在电脑安装一切就绪了，我也要记录这次多灾多难的安装过程。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，直接推荐<a href="https://www.bilibili.com/video/BV1BG4y137mG">硬件茶谈的教程</a>，确实做到了全网最细，没有之一。</p><p>但如果整个过程一步不差的按照他的流程走，大概率装机会出现一点小问题。所以，本次日志会记录自己的装机过程中的一些小插曲。</p><p>顺便，作为一个装机老白，也会记录自己整个装机过程的心得，以供参考。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>无论是让店家帮忙组装，还是自己挑选配置个人组装，都需要对自己的需求进行一波分析，合理规划，才不至于价格溢出。</p><p>这里放一下个人的需求及想法：</p><ol><li>电脑配置能游玩市面上大多数游戏，运行大型游戏时候，不会有硬件限制</li><li>能够运行AI跑图功能，本地安装实验性质的环境</li><li>运行速度足够快，不再使用机械硬盘（相对较慢）</li><li>剪辑视频的要快速读取素材，尽可能的加大内存（增加视频缓存量及读写速度）</li><li>外观要足够的漂亮，今年很长一段时间都会在家中，所以首选纯白海景房配合二次元套皮</li><li>配置要足够的稳定，寿命够长，五年内不会出现电源，冷排等硬件上的问题</li><li>声音尽可能的小，不要出现开机就是飞机起飞的状态</li><li>成本可以不计，但是尽可能的不要超过1万</li></ol><h3 id="硬件购买"><a href="#硬件购买" class="headerlink" title="硬件购买"></a>硬件购买</h3><p>根据上述需求，我大概选定了一些想法，从目前的市场来看，2023年说不定是最适合配电脑的一年。</p><p>这里浅谈一下我个人的理解，算是抛砖引玉吧，如果有不合理的地方，就做笑谈。</p><p>这里首先放一下配置表及具体购买原因。</p><table><thead><tr><th align="center">硬件名称</th><th align="center">型号</th><th align="center">购买原因</th><th>平台</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">主板</td><td align="center">华硕 PRIME Z690-P D4</td><td align="center">老厂商，值得信赖</td><td>京东</td><td align="center">3319</td></tr><tr><td align="center">CPU</td><td align="center">英特尔 12th Gen  Core i5-12600KF 十核</td><td align="center">主板套装</td><td>京东</td><td align="center">——</td></tr><tr><td align="center">散热</td><td align="center">利民冰封幻境360 瓦尔基里星环一体式水冷</td><td align="center">硬件茶谈店铺的货，质量有保证的</td><td>淘宝</td><td align="center">699</td></tr><tr><td align="center">内存</td><td align="center">威刚 64GB(2666 MHz &#x2F;  2666 MHz &#x2F;  2666 MHz &#x2F;  2666 MHz)</td><td align="center">国产，便宜，稳定</td><td>京东</td><td align="center">1067</td></tr><tr><td align="center">主硬盘</td><td align="center">致钛 2048 GB (ZHITAI TiPro7000 2TB)</td><td align="center">国产，便宜，稳定，有三个插槽，买了三个</td><td>京东</td><td align="center">3818</td></tr><tr><td align="center">显卡</td><td align="center">英伟达 NVIDIA GeForce RTX 3060 Ti (8192 MB)</td><td align="center">据说是一手货，而且外表够二次元</td><td>京东</td><td align="center">3248</td></tr><tr><td align="center">电源</td><td align="center">Seasonic 海韵电源80PLUS金牌FOCUS GX金牌全模1000W</td><td align="center">稳定，老牌子，没出过什么幺蛾子的厂商</td><td>京东</td><td align="center">1290</td></tr><tr><td align="center">机箱</td><td align="center">航嘉（Huntkey） S980龙卷风 全景侧透钢化玻璃 360水冷海景房游戏机箱</td><td align="center">性价比较高，买不起包豪斯</td><td>京东</td><td align="center">480</td></tr><tr><td align="center">显示器</td><td align="center">冠捷 AOC2701 27G1G4 (27.2英寸 &#x2F; 32位真彩色 &#x2F; 60Hz)</td><td align="center">之前剩的显示器</td><td>——</td><td align="center">——</td></tr></tbody></table><p><strong>合计13957，近1万4的价格，属实放大血，疼坏了。</strong></p><h4 id="核心套装"><a href="#核心套装" class="headerlink" title="核心套装"></a>核心套装</h4><p>关于Cpu和主板这个核心套装，本来是打算买散件拼的。</p><p>但是想了想，别费那个事儿了，我只是装机老白，又不是那种极客，没必要玩的太花，里边具体的门道我是不懂搭配的。</p><p>所以，这里直接上了华硕的车，华硕的板子，还是挺稳定得。</p><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>矿潮差不多刚过去，现在的市面上，矿卡虽然也多，但是多少还是能用的。</p><p>那些屯卡的奸商，现在估计也看清形式了，卖便宜点儿至少有得赚，还按照矿潮时代卖是纯纯的傻子。</p><p>所以，如果要是想挑好用的矿卡，可以买<a href="https://kinology.world.tmall.com/shop/view_shop.htm?spm=a230r.1.14.14.718558d3jjB9Ek&user_number_id=1574891186">卡诺基</a>家的卡，人家是正儿八经的好用的翻新卡，出问题是可以换的。</p><p>本来我也打算弄一个，但是为了颜值（别问为什么，打了那么长时间的工，我就不能享受享受吗），我选择了铭瑄的小瑷珈。</p><p>据说这个3060TI不是矿卡，个人到手后测了一下，也没感觉有什么问题，所以应该信得过。</p><p>至于为什么是小瑷珈，不是大瑷珈，很简单，预算不足，而且需求也溢出了，我没必要上这么好的卡。</p><p>哦，对了<a href="https://item.taobao.com/item.htm?spm=a1z10.3-c-s.w4002-21402720416.28.72b5ccd8RB4e76&id=691104242791">硬件茶谈的店铺</a>里也有不错的显卡，当时我本来想弄一个来着，显存看着很大。</p><p>但是外观看了一下，感觉不够二次元，到最后还是退了换了小瑷珈。</p><p>有些时候，人确实容易着相啊。</p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>2023年的固态真的很便宜，m2类型的固态我年前买的时候，2t是近1000左右，现在我看了一下有些国产颗粒的固态已经掉到600不到了。</p><p>虽然不是最低价让我有些恼火，但是想到数年前，三星把固态当金条卖，天天动不动火龙烧仓，工人罢工，各家厂商就是死命抬价格的狗娘养的状态，我个人可以接受现在固态的价格。</p><p>就凭长鑫把固态和内存的价格打下来这点，我就得买它，而且，如果能让友商降价处理，那只能说明一点，这批货做的不错，被对家认可了。</p><p>如果长鑫颗粒一直和三星怼的话，大概率这种倾销价格还得持续不少时间。</p><p>我预感，这种低价至少今年应该一直会这样，价格很便宜，随便买。</p><p>而且，因为之前装机械盘用sata实在是太累，所以这次全部用M2，正好电脑上的固态位置比较多。</p><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>这个是我没怎么了解的地方，但是电源这个钱最好不要省，市面上有不少厂家虚标电源，实际用的时候，可能出现功耗不足的情况。</p><p>而且如果电源出问题，很容易导致所有硬件烧毁的可能，最好不要在电源这里用小聪明，建议买个好点儿的电源。</p><p>2023年，目前市面上口碑不错的电源是<a href="https://mall.jd.com/index-1000097385.html">海韵（SEASONIC）</a>家的，我到手后拆箱看了看，配件送的很齐全，客服也很有耐心，中间解答了不少电源相关的疑惑，而且官方的教程相对来说，很亲民，对于我这种老白来说，很友好。</p><h4 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h4><p>这点我不太好推荐，外设这些，看个人喜好吧，机箱和水冷，我是在京东和淘宝买的。</p><p>和我不同，我弟是在拼多多买的，他认为拼多多的效果还可以，我没有验证，但是我对拼多多的砍价很是膈应，被耍猴了几次一直不是很喜欢这个平台。</p><p>个人感觉京东的售后是值得的，我中间机箱选错了，隔了一个月，协商退货，人家很痛快的就答应了。</p><p>就这点来说，京东的售后还是不错的，这个价格我个人较为认可。</p><p>但是贵确实是贵，所以，我只推荐主机相关的外设在京东买，比如机箱，水冷这种。</p><p>键盘和鼠标，还有耳机什么的，这种就随缘吧，如果不是太贵，拼多多应该也不是不行。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>为了保证电脑的外观效果，安装顺利，还需要准备如下道具</p><ol><li>机箱风扇（白色）</li><li>显卡延长线（白色）</li><li>金士顿U盘，作PE系统安装盘</li><li>2T的希捷机械硬盘，给旧电脑做数据转移用</li></ol><h3 id="电脑安装"><a href="#电脑安装" class="headerlink" title="电脑安装"></a>电脑安装</h3><p>再次安利一下<a href="https://www.bilibili.com/video/BV1BG4y137mG">硬件茶谈的教程</a>，我这里作为补充要说一下我在安装过程遇到的问题。</p><p>如果是新手安装，最好看一下我遇到的这些坑。</p><p>茶谈的教程里边，虽然已经足够的细致，但是对于实际情况来说，意外还是有的，看看我遇到的这些问题，说不定对你装机会有帮助。</p><ol><li>安装的平台尽可能的大，放螺丝的盒子多备一些，自己要规划好，记清楚了，不然找螺丝就是一个很费时间的事。</li><li>主板，水冷这两个安装说明书一定要保存好。</li><li>在没有安装水冷，风冷背板支架之前，不要急着把主板安装在机箱上，如果不装支架，直接放在机箱上，待会还得拆，因为你需要在主板背部安装支架，这样你才能去安装主板正面的水冷。</li><li>风扇有正叶扇和反叶扇，购买的时候，看清楚，反叶扇是风扇面（没有支架的凹面）出风，马达面（有支架的凸面）吸风，正叶扇和反叶扇是完全相反的，不然安装错了需要重新拆装风扇，很麻烦。</li><li>水冷一般是自带风扇的，<strong>水冷盒子下边有个抽拉的小盒子</strong>，打开就是风扇！如果水冷没有风扇，厂家一般会注明！不要用自己的风扇去怼水冷！</li><li>水冷虽然自带了说明书，但是如果还是觉得不保险，可以看看别人是怎么装的，这里推荐<a href="https://www.bilibili.com/video/BV1hg411A7yG?p=1&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">装机不求人之基础水冷安装教程</a>，相对于茶谈的大纲，这个教程在装水冷这里，细节做的不错。</li><li>风道最好一开始就要自己设计好，不然在风扇规划安装的时候，会反复拆装，加大工作量</li><li>有些时候电源如果开机测试怎么测都没有效果，考虑一下是不是风扇声音太小的问题，我在测试电源的时候，一直按照教程走，客服也说没有问题，都打算退货了，结果我仔细看了一下，是风扇声音太小，加上我装机的地方光线昏暗，没有看到风扇在转，导致我以为风扇有问题。</li><li>电源有些时候不是规整的情况，可能是运输过程中，盒子错位了，可以自己用钳子什么的敲一下，把电源规整一下。</li><li>理线是个大活，但是非水冷风扇的线，可以买个集线器来整理。水冷的集线器是专门给水冷风扇插的，主板要检测CPU对应的风扇转速，所以，其他风扇可以另外买一个集线器来整理，不要和水冷的集线器混用。</li><li>如果有了集线器，就没要按照官方教程来做风扇的串接了，只要集线器的插口足够的富裕，可以直接全部都插一遍，我这里买的是<a href="https://item.jd.com/100031537714.html">利民的8组16口集线器</a>，因为我的风扇都是带灯光效果的，所以就买了这种双插口的集线器，具体需求情按照自己的配置来决定，不必按照我这个来。</li><li><strong>一定要保证风扇的公头针脚不外露</strong>，不然接触到主板和机箱，漏电可能会造成硬件损坏。</li><li>集线器对应主板的插口，各家的主板都有不一样的说法，如果你没有找到ARGB的接口，可能是名字不一样，比如华硕的主板中，argb的接口名称叫<strong>ADD_GEN2</strong>，在微星的板子上应该叫<strong>JRGB</strong>，这个需要自己看看主板的说明书来确认。</li><li>如果对自己的能力实在没有信心，尽可能的保证自己身边有个懂行的哥们儿，如果你装机装出问题了，哥们儿能帮你兜个底，但是装成了，记得请人家吃顿饭。</li></ol><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>个人之前是没接触过PE安装的，这次按照以下两个教程走了一遍之后，感觉这确实比官方自带的安装方式方便不少。</p><h4 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h4><p>如果不清楚原理，个人推荐看一下硬件茶谈的视频。</p><p>如果不清楚具体的操作方法，我推荐看机械师只只的安装教程，他的教程确实更加稳妥。</p><p><a href="https://www.bilibili.com/video/BV1DJ411D79y?p=2&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区</a></p><p><a href="https://www.bilibili.com/video/BV15e411x7nw">【U盘模式】Win10重装系统教程（10分钟装好）</a></p><h4 id="论坛推荐"><a href="#论坛推荐" class="headerlink" title="论坛推荐"></a>论坛推荐</h4><p>整理了一下装机论坛，朋友推荐的，很不错</p><ol><li><a href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn)</a></li><li><a href="https://www.itsk.com/">IT天空－新的十年，与您同行！ （已创建16年零10个月） (itsk.com)</a></li></ol><h4 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h4><p>这里整理了一下朋友推荐的pe工具，这是市面上推荐，比较好的PE工具包</p><ol><li>优启通</li><li>微PE</li></ol><p>最后，贴一下<a href="https://space.bilibili.com/409055282">机械师只只</a>大佬给的网盘工具链接</p><p><a href="https://www.123pan.com/s/wEeA-UiMmH">重装系统官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘 (123pan.com)</a></p><p>这里顺便贴一下我用的win10镜像文件，之前用他们给的镜像文件装上去一直有问题，要么就是装好了没有网络，用这个镜像文件倒是一步到位了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1CLi2gRlo7XqNZEFxQgKpoA?pwd=1234 </span><br><span class="line">提取码：1234 </span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>下次再也不装水冷了，风扇噪音也不小，而且还费事，据说还有水管破裂导致所有硬件瘫痪的风险。</p><p>这次装机装了两天多，中间安装软件刷系统，整个人都给这玩意整颓了，好几天都没缓过来。</p><p>但是，安装完成之后，点亮的那一刻，不得不说，真是有种前所未有的开心。</p><p>这次也是感谢客服和各路好兄弟帮忙了，更是谢谢各路UP的装机分享，不然这装机属实是个麻烦的事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————https认证</title>
      <link href="/2023/05/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94https%E8%AE%A4%E8%AF%81/"/>
      <url>/2023/05/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94https%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>之前同事搞了很久，本以为要弄很久的事，结果出乎意料的简单。</p><p>不过，这个过程知道了很多不了解的的东西，这里特别记录下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来一开始没想搞https，但是浏览器上一直红字提示不安全，一直放在那里挺膈应人。</p><p>想来想去，还是弄吧，不然每次浏览的时候，都感觉怪怪的，后续分享我也不想让别人每次都注意到这个。</p><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>首先，我们要到服务商，申请到证书。</p><p>这里有付费证书和免费证书的说法，我看了很多人的教程，讲的很详尽，但是详尽的有点太过复杂了。</p><p>我这里就以我为例，说个简略版的，默认大家使用的是阿里云平台，并且已经完成了实名认证，然后参考如下流程。</p><ol><li>找到并打开域名控制台</li><li>选择你个人博客的域名，点击管理，进入博客，找到SSL证书，然后打开对应的链接，跳转到证书控制台</li><li>到了证书控制台之后，直接选择免费证书购买（阿里云目前是提供每年20个证书的量，对于常规用户来说够用了）</li><li>点击创建证书，完成表单填写，创建</li><li>阿里云很给力，直接会完成前几个步骤，你这里只需要点击签发就可以了</li></ol><p>好了，这里我们的个人博客就有了https认证的证书，这很简单。</p><p>如果博客是部署到自己服务器的朋友，可能还需要把证书下载下来部署，过程感觉还有点多，我个人不多做赘述。</p><p>可以参考<a href="https://tech.mindseed.cn/Website/%E7%BD%91%E7%AB%99HTTPS%E4%B9%8B%E8%B7%AF-%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E5%8F%8A%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFHTTPS.html">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 心站日志 | 心种子技术站 (mindseed.cn)</a></p><h3 id="修改pages设置"><a href="#修改pages设置" class="headerlink" title="修改pages设置"></a>修改pages设置</h3><p>在完成证书申请之后，我们需要让github完成对域名的https的使用。</p><p>我这里默认大家用的是github的个人网站，以我自己为例。</p><p>我所部署的项目是<strong>CrazyStudent13.github.io</strong>，打开之后，找到setting设置选项，找到左侧的pages选项。</p><p>这里，我们找到<strong>Custom domain</strong>，然后下边有个<strong>Enforce HTTPS</strong>的复选框，这里我们把它勾上。</p><p>它下边有一段小字，是可以忽略的提示，这里顺便提供下翻译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTPS provides a layer of encryption that prevents others from snooping on or tampering with traffic to your site.</span><br><span class="line">When HTTPS is enforced, your site will only be served over HTTPS</span><br><span class="line"></span><br><span class="line">HTTPS提供了一层加密，防止其他人窥探或篡改到您站点的流量。</span><br><span class="line">当HTTPS被强制执行时，您的站点将只能通过HTTPS提供服务</span><br></pre></td></tr></table></figure><h3 id="最后确认"><a href="#最后确认" class="headerlink" title="最后确认"></a>最后确认</h3><p>完成以上之后，我们只需要把自己的网页复制到浏览器上打开。</p><p>如果https认证通过，之前浏览器上处于爆红的、打开状态的锁，就会闭合并且成为常规的灰色。</p><p>我们点击那个锁，也会看到提示，表明连接安全。</p><h3 id="通过QQ认证"><a href="#通过QQ认证" class="headerlink" title="通过QQ认证"></a>通过QQ认证</h3><p>这个是额外的情况，我之前给一些QQ上的朋友发送博客的链接。</p><p>他们说打开总是提示需要复制再打开，之前我以为这是Https的问题。</p><p>但是结果浏览器上申请通过之后，QQ上还是要求我复制打开，等了半小时左右，效果还是不行。</p><p>后来，和朋友部署在国内服务器的情况对比了一下，感觉问题不是https的问题，他的博客甚至都没有通过https认证。</p><p>想了一圈，我估计我部署位置的问题，所以我试着直接给<a href="https://urlsec.qq.com/complain.html">腾讯安全-网址安全中心 (qq.com)</a>提了一下拦截申诉，很快，大约十分钟左右就有回应了。</p><p>所以，我猜测应该是腾讯封锁这种github部署的境外网站，一开始拦截没有通过，我这里的博客才打不开，现在申诉过后，通过审核了，才可以访问。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前看了一下，似乎证书有效期只有30天，具体什么情况，还得等到期之后看看。</p><p>至于付费证书，没打算搞，太贵了，这个博客就是个记录站点，没必要整的这么金贵，越金贵的东西，越舍不得动。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/110478585">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 知乎 (zhihu.com)</a></p><p><a href="https://tech.mindseed.cn/Website/%E7%BD%91%E7%AB%99HTTPS%E4%B9%8B%E8%B7%AF-%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E5%8F%8A%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFHTTPS.html">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 心站日志 | 心种子技术站 (mindseed.cn)</a></p><p><a href="http://lhalcyon.com/hexo_ssl_netlify/">Hexo绑定自定义Https域名 | Halcyon Days (lhalcyon.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激光打印机安装及使用</title>
      <link href="/2023/04/20/%E6%BF%80%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/20/%E6%BF%80%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这玩意纯粹是小玩具，买了之后一直没组，最近有时间了才开始整的。</p><p>个人感觉，玩具确实是玩具，但是效果还是很不错的，后续可以用来刻印一些木板画做做手工</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文只介绍新人的注意事项，并不会详细写出安装过程。</p><p>本文会尽可能提出一些注意事项，规避安装中的坑点。</p><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><ul><li>刻印图画，在部分木材，铝材，不锈钢等的板材上烧刻图案，利用高温留下点线，组成图形。</li><li>切割板材，不过由于我这个激光器的功率不是很大，最多能切一些薄木板，其他的不太行，不过，按照平时的要求来说，够用了</li></ul><h3 id="配件安装"><a href="#配件安装" class="headerlink" title="配件安装"></a>配件安装</h3><p>因为没钱，所以尽可能的是用散件组装的，不过价格累计¥626，还是有点肉疼。</p><p>这里因为激光头是定焦的，所以老板松了一个调节平台，还有一些扎带，还好。</p><ol><li>10w蓝紫光激光器，¥288</li><li>12V2A的电源适配器，¥15</li><li>激光雕刻机机架，¥237</li><li>Arduino主板+4988驱动模块，¥86</li></ol><p>因为我不是电气相关专业，所以这里只能先当积木来拼了。</p><p>安装的时候，大部分时间接口其实和主板都是能对的上的，线材对接如下：</p><ol><li>红色对应VOC</li><li>黑色对应GND</li><li>绿色对应PWM</li></ol><p>主板上的X和Y，对应的是电机的X和Y轴</p><ol><li>X对应的是上方的轴，就是和激光器挂在一起的那个电机</li><li>Y对应的是下方的轴</li></ol><h3 id="主板驱动"><a href="#主板驱动" class="headerlink" title="主板驱动"></a>主板驱动</h3><p>主板还是要装驱动的，这里电脑注意最好是win10,8,7这样的，或者linux也可以。</p><p>个人首先推荐教程：<a href="https://wiki.dfrobot.com.cn/Arduino%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85">Arduino驱动的安装</a>，讲的很详细，很好用。</p><p>因为我买的是<strong>Arduino主板</strong>，这里推荐去<a href="https://arduino.me/download">软件下载 - Arduino中文社区</a>查查相关的帖子。</p><p>这个社区相对来说，还算是正经的社区，有不少靠谱的帖子。</p><p><strong>tips</strong>：不推荐使用驱动精灵之类的安装，一如既往的没用</p><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p><a href="https://lasergrbl.com/download/">laserGRBL</a>，这个是Up主<a href="https://space.bilibili.com/283644869">BD黑色蒲公英</a>推荐的激光器控制软件。</p><p>之前我买驱动的淘宝店家，也推荐了一个微雕精灵，个人找了一圈，不推荐。</p><p>在试用了好几个工具之后，我个人也用这个工具，理由如下：</p><ol><li>laserGRBL官网正规，微雕精灵没有官网，都是野路子下载，很多下载链接，都在一些乱七八糟的人论坛里。</li><li>laserGRBL引擎检索，微雕精灵名字检索混乱，是的，无论是用国内还是国外的搜索引擎，都能找到类似名字的软件，如微雕管家，微雕大师等等。这不像一个成熟的商业软件该有的样子，日后出问题，估计难以维护。</li><li>laserGRBL的视频教程很多，B站有很多教程，微雕精灵相关教程几乎没有，教程生态不行</li><li>就界面及功能来看，感觉微雕精灵像是盗版的laserGRBL，很难说这个软件的未来</li></ol><h3 id="机器使用"><a href="#机器使用" class="headerlink" title="机器使用"></a>机器使用</h3><p><a href="https://www.bilibili.com/video/BV1cP4y1478T/?vd_source=ee3784ffe5f760cb992921cb8c5c98e5">一分钟学会如何使用激光雕刻机进行灰度雕刻！</a></p><p><a href="https://b23.tv/lt4wFOd?share_medium=android&share_source=qq&bbid=XYA6C72AB48107F9A6238AE3F89C3CF8857C0&ts=1681962712197">GRBL入门到进阶教程 激光雕刻机扩展板入门指导 Arduino主控GRBL视频教程</a></p><p>详细教程可以参考上述教程，我个人这里稍微写个大致流程仅供参考。</p><ol><li>使用软件，完成驱动安装</li><li>选中对应的端口，连接主板</li><li>放置好板材，因为我是定焦，所以要调整好板材和激光头的焦距</li><li>点击电机方向，启动激光器测试是否靠谱</li><li>导入图片，配置好参数，放入打印机</li><li>扫一下打印的大致范围，确认打印机和电机不会超过板材的之外的范围</li><li>开窗通风，等待打印完成即可</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>保证桌面的水平，确定不会滑动</li><li>线材不要放在雕刻机的扫描范围内，容易有线材被切割的风险</li><li>机器周围不要放什么易燃物，水杯，或者是振动物品，有一定的风险</li><li>激光头在使用会出现较大噪音，这是正常现象，因为要散热</li><li>每次雕刻图案之前，记得先用软件扫一下图案的范围大小，不然很容易超出范围，烧到范围之外的地方，又或者卡在边缘位置，重复烧刻一条线，形成切割的效果，很糟糕</li><li>不要长时间直视激光器打印的光斑，如果有需要，可以考虑配一副眼镜</li><li>不要在木制桌板上刻印！切记！我桌子上被烧了两个黑斑，实在是难看</li><li>保持房间通风，不然烧刻木板的糊味儿实在不好闻</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里非常感谢<a href="https://space.bilibili.com/283644869">BD黑色蒲公英</a>的技术支持，中间安装和后续打印过程中，给了我这个新手不少指导。</p><p>如有错误，还请指正，在这里谢谢了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.dfrobot.com.cn/Arduino%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85">Arduino驱动的安装</a></p><p><a href="https://www.bilibili.com/video/BV1cP4y1478T/?vd_source=ee3784ffe5f760cb992921cb8c5c98e5">一分钟学会如何使用激光雕刻机进行灰度雕刻！</a></p><p><a href="https://b23.tv/lt4wFOd?share_medium=android&share_source=qq&bbid=XYA6C72AB48107F9A6238AE3F89C3CF8857C0&ts=1681962712197">GRBL入门到进阶教程 激光雕刻机扩展板入门指导 Arduino主控GRBL视频教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑软件下载清单整理</title>
      <link href="/2023/04/18/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86/"/>
      <url>/2023/04/18/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本来没打算整理的，结果打算给新电脑腾地方的时候，才发现要下载的软件也太多了。</p><p>考虑到后续可能会有可能继续升级新电脑，所以整理了该下载清单，这样以后搬运电脑会很方便。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><p>新电脑几乎什么都没有，个人推荐先装这些必须得工具，便于后续使用</p><ul><li>edge浏览器，微软浏览器</li><li>chrome，谷歌浏览器</li><li>Opera浏览器，谷歌内核浏览器，主要是游戏方向的内容做的不错</li><li>bandzip，好用的文件压缩软件</li></ul><h3 id="游戏工具"><a href="#游戏工具" class="headerlink" title="游戏工具"></a>游戏工具</h3><p>这里大多数都是我自己常用的软件，酌情选择</p><ul><li>哔哩哔哩直播姬，bilibili直播软件</li><li>OBS Studio，电脑直播软件，相对稳定</li><li>网易UU，游戏加速器</li><li><a href="https://cheatengine.org/">Cheat Engine</a>，游戏作弊器</li><li>steam，游戏平台</li><li>Epic Games，游戏平台</li><li>wegame，游戏平台</li><li>origin，游戏平台</li><li>ubisoft，游戏平台</li><li>Mumu模拟器，手游模拟器</li><li><a href="https://www.bilibili.com/video/BV1jG4y1z7Gn/?spm_id_from=333.788.recommend_more_video.9&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">Start11</a>，更换win11开始界面，可以用来切换win10的风格（主要是磁贴功能）</li></ul><h3 id="聊天相关"><a href="#聊天相关" class="headerlink" title="聊天相关"></a>聊天相关</h3><ul><li>QQ</li><li>微信</li><li>阿里旺旺</li><li>KOOK，开黑游戏用</li><li>钉钉，非工作用不推荐</li></ul><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>开发人员需要配置的环境，这个按照自己的需求酌情安装</p><ul><li>node，前端开发环境，用官方推荐的版本</li><li>java8，java开发环境，用8版本比较稳定，这里附上一份环境<a href="https://blog.csdn.net/Marvin_996_ICU/article/details/106240065">配置教程</a></li><li>python3，python开发环境</li><li>gitbash，git命令终端及环境</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>程序员大多数都会接触到的工具，有些工具的推荐并非我喜欢，而是不得已。</p><p>有时候为了实现需求，往往必须要用一些特殊的工具，没办法。</p><ul><li>VsCode，开发工具</li><li>IntelliJ IDEA，后端开发工具</li><li>eclipse，后端开发工具</li><li>hbuilderX，国产多平台代码开发工具，个人不太喜欢用</li><li>Dev-C++，C++开发工具，考试用</li><li>微信开发者工具，如果有小程序开发需要的朋友推荐使用</li><li>ApiPost&#x2F;postman，接口测试</li><li>GitHub Desktop，github代码管理工具，官方下载非常慢，推荐自己找好安装包</li><li>MobaXterm，服务器连接管理</li><li>WinSCP 5.21.2，服务器可视化操作工具</li></ul><h3 id="文档工具"><a href="#文档工具" class="headerlink" title="文档工具"></a>文档工具</h3><p>关于wps，个人觉得，如果有正版平替的话，还是用微软的吧。</p><p>现在微软的文档工具接入了AI，比起WPS的全家桶，好用了很多。</p><ul><li>typora，好用的markdown编辑器（收费）</li><li>有道云笔记，工作常用的备忘录</li><li>wpsoffice，一些文档打开工具</li><li>语雀，办公可能会用到</li></ul><h3 id="影音工具"><a href="#影音工具" class="headerlink" title="影音工具"></a>影音工具</h3><p>因为我用的是win系列的，所以这里主要会推荐adobe的工具</p><p>adobe全家桶工具，推荐一个<a href="https://baiyunju.cc/8602">破解版教程</a>，简单好用，下载解压，按教程安装即可</p><ul><li>网易云音乐</li><li>腾讯视频</li><li>爱奇艺</li><li>PotPlayer，视频播放器</li><li>万兴优转，视频格式转码，不推荐</li><li>小丸工具箱，视频格式转码</li><li>Adobe photoshop，图片编辑工具</li><li>Adobe premiere，视频编辑工具</li><li>Adobe Effects，视频特效工具</li></ul><h3 id="建模绘图"><a href="#建模绘图" class="headerlink" title="建模绘图"></a>建模绘图</h3><ul><li>草图大师（SketchUp），快速建模软件</li><li>SAI，绘画工具</li></ul><h3 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h3><ul><li>百度网盘</li><li>阿里云盘</li><li>SynologyAssistant，群晖电脑助手，记得配置好本地硬盘映射</li></ul><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>腾讯电脑管家和百度网盘这两个东西，说实话，不是很想用。</p><p>但是比起无序扩张的360，有些时候，确实这两个工具还是有必要使用的。</p><p>还有一些软件是个人设备需求，如果没有同样的需求，就不需要装。</p><ul><li>腾讯电脑管家，电脑新手推荐用</li><li>wallpaper相关</li><li><a href="https://www.den4b.com/downloads/renamer">ReNamer</a>，文件批量命名工具</li><li>MAA（明日方舟自动化代理工具）</li><li>AVerMedia RECentral 4，圆钢的视频采集工具</li><li>Arduino主板驱动，激光打印机的主板驱动，个人设备要求</li><li>laserrgbl，激光打印机的工具</li></ul><h3 id="必要设置"><a href="#必要设置" class="headerlink" title="必要设置"></a>必要设置</h3><ol><li>window的机子，记得打开文件扩展名，文件隐藏项目</li><li>如果有nas，在局域网范围内，记得映射对应的网络</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本清单会不定期更新，按照需求调整。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一份计划总纲</title>
      <link href="/2023/04/16/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%AE%A1%E5%88%92%E6%80%BB%E7%BA%B2/"/>
      <url>/2023/04/16/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%AE%A1%E5%88%92%E6%80%BB%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<p>本来没打算放出来这份生活总纲的，毕竟有点私密的感觉。</p><p>但是想了想，这部分计划其实也算不上隐私，而且生活类的计划，放在博客里也不算什么。</p><p>所以大家有兴趣看个乐子就行，毕竟，往往计划赶不上变化，新年计划往往都是旧计划洗洗就能用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果按照正常的计划，3月份这个计划总纲应该是要出来的。</p><p>但是，因为甲状腺切除的手术，牙龈刮治等一系列问题，在工作地耽误太久了。</p><p>回到老家已经是4月中了，考完自考之后，终于松了口气，现在算是可以做事了。</p><h3 id="房子基建"><a href="#房子基建" class="headerlink" title="房子基建"></a>房子基建</h3><h4 id="基建更新"><a href="#基建更新" class="headerlink" title="基建更新"></a>基建更新</h4><p>主要保证家里的房子，便于清理，同时兼具保温，美观，便于检修，成本低。</p><ol><li><del>添加空调</del></li><li><del>添加房间管线（恒温管替换空调），保证三间房子的电路和网络能走通，不是现在这种随便搭线的情况</del></li><li><del>更换房间吊顶，在管线铺设完成之后，确认没有问题，开始吊顶。</del></li><li><del>贴地砖，卧室+客厅+厨房+淋浴间（低成本贴一下就行，便于房间清理）</del></li><li>更换窗户，考虑换成更方便的推拉铝合金窗户</li><li><del>更换卧室的门，独立空间私密化，不要随便被人入侵，讨厌没有距离的感觉。</del></li><li><del>厕所+淋浴间一体化</del></li><li>厨房现代化（电器化，装修正规化，不需要多豪华，先达到正常农村装修水平就行，不能过的像工地）</li><li><del>洗衣房+洗漱间一体化（房间内要有足够的地方摆放衣物，摆放）</del></li><li><del>东屋暂时不拆除，暂时清空，改为工房仓库</del></li><li>添加15米靶场，射箭用</li><li>家庭供电自动化，加入光伏板，接入国家电网，不再使用外部供电（两年后的计划，这个太烧钱了）</li></ol><h4 id="家居更新"><a href="#家居更新" class="headerlink" title="家居更新"></a>家居更新</h4><p>保证家里的基础功能不会出问题，并且物品归类整理好后，便于寻找</p><ol><li><del>换掉洗衣机</del></li><li><del>电气化部分设备，淋浴热水器，电磁炉，空气炸锅（其他可以靠后，但是淋浴热水器和电磁炉必须今年考虑加入，不然冬天没法子过）</del></li><li><del>添加书柜，重要文件集中管理，在我的房间加入书架，集中管理所有人的重要文件（家用户口本等）</del></li><li><del>使用外卖货架整理东屋，堆放杂货</del></li><li><del>使用洞洞板，及其他桌搭工具，整理目前已有的工具</del></li></ol><h4 id="智能化"><a href="#智能化" class="headerlink" title="智能化"></a>智能化</h4><p>主要保证家里的娱乐设备没有问题，便于生产力设备的升级</p><ol><li>硬件的更替，<del>出售旧的电脑，nas，拼装新电脑</del></li><li>升级新nas（下半年，和朋友确认硬盘坏道情况，如果没问题准备入手黑群晖）</li><li><del>升级网络，替换路由器，扩大覆盖范围</del></li><li><del>卧室灯光设计合理改造，插线板要符合房间的布局，不能按照现有情况胡乱布线</del></li></ol><h2 id="身体调理"><a href="#身体调理" class="headerlink" title="身体调理"></a>身体调理</h2><h3 id="减重"><a href="#减重" class="headerlink" title="减重"></a>减重</h3><p>降重到合理的程度，恢复正常BMI（重中之重！血压的事不能再拖了！）</p><ol><li>制定正常的食谱</li><li>制定正常的运动计划</li></ol><h3 id="情绪控制"><a href="#情绪控制" class="headerlink" title="情绪控制"></a>情绪控制</h3><p>调理至甲状腺切除之前的正常状态，最好是大学时候的状态。</p><p>不是用暴力的药物调理方式，而是用缓和的情绪方式，最好是运动类的。</p><ol><li>体重回复之后，定期射箭，来调控自己对身体的控制力</li><li><del>减少对负面新闻的观看，虽然这个狗屎一样的社会总是会增加负面新闻</del></li><li><del>多和外界沟通交流，保证自己能快速融入到外界中</del></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>去找医生正骨，在重量下降之后再做，不然没法调整（下半年的事情）</li></ol><h2 id="技术升级"><a href="#技术升级" class="headerlink" title="技术升级"></a>技术升级</h2><h3 id="自考"><a href="#自考" class="headerlink" title="自考"></a>自考</h3><p><a href="https://www.jseea.cn/webfile/selflearning_xsxw/2007-11-06/5017.html">南京航空航天大学主考工业工程等专业自考本科毕业生申请学位的规定 - 学士学位 (jseea.cn)</a></p><ol><li>7月中旬，必须得进行高数的学习，平时有事儿没事就看一下数学相关的内容，别真到了那时候不会了（失败）</li><li>挑一部分难搞的课程，十月份处理掉（失败）</li></ol><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ol><li>全面接入智能化，使用Copilot，辅助代码书写</li><li><del>搭建自用的图片生成工具</del></li><li>完善开源工具cat-tools，做到自动化测试用例，自动化部署，文档自动化，并搭建开源工具包的帮助文档，建立issue</li><li>搭建番剧，电影wiki检索系统，二者对外是两个业务，但是后台可以考虑使用一套业务来整合到一起，这个要好好做，因为主要是未来刮削影视信息不方便，必须得有个集中化的地方</li><li>学习使用python,着手抓取第三方数据（尽快，6月之前要有能学明白，做到图片爬虫工具，网站信息抓取工具）</li><li>学习使用vue3+vite，搭建论坛，类贴吧，主要交流硬件相关知识</li><li>学习Electron，尝试写一个硬件配置工具系统（如果有更好的平替工具，就不用做了）</li></ol><h3 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h3><ol><li><del>弄清楚考试流程，最好准备一口气过完，我怕拖了之后容易出问题</del></li></ol><h3 id="写小说"><a href="#写小说" class="headerlink" title="写小说"></a>写小说</h3><ol><li>每月编个千字小故事，随便什么小故事，但是要精妙完整</li><li>将一些比较精品的点子，组合起来，定期写一下，投稿一些科幻论坛</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><ol><li>《重构》</li><li>《人月神话》</li><li><del>《程序员的自我修养》</del></li><li>《孙子兵法》</li><li>《腰背维修师》</li></ol><h3 id="B站出视频"><a href="#B站出视频" class="headerlink" title="B站出视频"></a>B站出视频</h3><ol><li><p>记录一些房间生活改造内容</p></li><li><p>写一些番剧，电影小作文锐评一波，蹭蹭热度，也不图啥，就是想图个热闹，不然这些东西没有人一块看，总是很孤单，随缘写，看喜欢了就写</p></li></ol><h3 id="完善保险"><a href="#完善保险" class="headerlink" title="完善保险"></a>完善保险</h3><ol><li><del>完善医保</del></li><li>完善父母养老保险</li><li>带爸妈去做体检，做好预防措施</li><li><del>失业人员是否可以领补助金（小城镇很难领到，不要相信国家）</del></li><li><del>查一下社保问题，所谓的灵活就业人员是否可以和失业人员补助金冲突（交社保很麻烦，而且在老家小病用不上，大病没地用）</del></li></ol><h3 id="学习硬件修理"><a href="#学习硬件修理" class="headerlink" title="学习硬件修理"></a>学习硬件修理</h3><ol><li>学习显卡的维修（这个留到明年吧）</li><li>学习硬件维修相关技能（这个下半年再考虑）</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>该文档年内不定期更新，会有实际调整。</p><p>虽然是计划总纲，但实际情况可能会有很多出入，所以目前仅参考用。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 年计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册及使用chatGPT</title>
      <link href="/2023/04/02/%E6%B3%A8%E5%86%8C%E5%8F%8A%E4%BD%BF%E7%94%A8chatGPT/"/>
      <url>/2023/04/02/%E6%B3%A8%E5%86%8C%E5%8F%8A%E4%BD%BF%E7%94%A8chatGPT/</url>
      
        <content type="html"><![CDATA[<p>风云激荡，时代变幻，人工智能，你终于来了。</p><p>本来以为这玩意，会和核聚变一样永远差50年，但是没想到，他现在就来了，而且以如此呼啸的方式。</p><p>不过，既来之，则安之，我们这里记录一下注册方式，当然，随着形式变化，该文档会不定期修改。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来以为会很麻烦，但是没想到很简单，整个流程不过就十分钟左右就完了。</p><p>如果是经常使用这些墙外软件的朋友，估计会更快。</p><h3 id="邮箱注册"><a href="#邮箱注册" class="headerlink" title="邮箱注册"></a>邮箱注册</h3><p>在注册之前，先注意满足以下的前提</p><ul><li>更换梯子节点，尽量不要选择东亚和俄罗斯，选择东南亚和欧洲节点</li><li>最好清理一下页面缓存</li></ul><p>如果不确定自己IP已经切换到境外，可以使用<a href="https://ipinfo.io/">ipinfo.io</a>看一下，只要信息框中的timezone显示不是china就行。</p><p>满足以上条件之后，在<a href="https://openai.com/blog/chatgpt">chatGPT</a>官网，点击<a href="https://chat.openai.com/auth/login">Try chatGPT</a>，之后sign up进入注册流程就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signup is currently unavailable, please try again later！</span><br></pre></td></tr></table></figure><p>如果你正常填写邮箱和密码之后，出现上述提示，那你排查注册的邮箱有无如下情况</p><ul><li>QQ邮箱，foxmail邮箱</li><li>163邮箱，网易邮箱yeah.net，126邮箱</li><li>新浪邮箱</li><li>Outlook、hotmail邮箱（<del>只能通过快捷登录，也就是Continue with Microsoft Account</del>）2023年4月2日更新：目前微软邮箱已经不能注册ChatGPT，使用Continue with Microsoft Account这种方式也不行。</li><li>eud.cn邮箱</li><li>Gmail(只能通过快捷登录，也就是Continue with Google）</li></ul><p>主要是现在chatGPT封禁了东亚区的注册，所以，以上邮箱会无效。</p><p>如果你暂时没有好的解决办法，我推荐你使用自定义域名的邮箱，或者公司提供的企业邮箱即可。</p><h3 id="获取手机验证码"><a href="#获取手机验证码" class="headerlink" title="获取手机验证码"></a>获取手机验证码</h3><p>完成了上述的邮箱注册之后，可能会需要当前用户提供手机号，这里主要用境外手机号，填写验证码就行。</p><ol><li>选择好自己手机号对应的国家</li><li>尽可能的不选择东亚这块的国家注册手机号</li></ol><p>针对墙内用户，如果有自己的海外手机号，那没什么好说的，用自己的海外手机号验证码注册一下就行。</p><p>但是如果你没有海外手机号，可以注册<a href="https://sms-activate.org/">sms-activate</a>，充值就可以，允许使用支付宝的。</p><p>推荐这里参考这个文档：<a href="https://zhuanlan.zhihu.com/p/615585092">如何使用sms-activate服务 - 知乎 (zhihu.com)</a></p><p>进入页面之后，左侧选择OpenAI，然后选一个国家，按照教程的流程注册一下就行。</p><p>这里推荐选择东欧的一些国家，比如罗马尼亚（Romania）之类的，因为最近似乎有针对亚洲国家封禁的情况，这个还是挺尬的。</p><p>填入验证码之后，chatGPT就注册好了，之后就可以用了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对于如此强劲的新技术，在初步体验之后，我实在是无法拒绝。</p><p>也许，新的技术奇点已经到了，未来真是值得期待啊。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.vpsdawanjia.com/6251.html">ChatGPT无法注册的原因错误提示：Signup is currently unavailable, please try again later</a></p><p><a href="https://zhuanlan.zhihu.com/p/615585092">如何使用sms-activate服务 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次手术（后）</title>
      <link href="/2023/03/31/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%90%8E%EF%BC%89/"/>
      <url>/2023/03/31/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%90%8E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>因乳头状细胞癌，所以需要切除右侧甲状腺，折腾了快两周，伤口终于快好了。</p><p>这里记录一下术后的日子，也算是缅怀一下这段不同寻常的时光吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>梳理了一下住院前后流程，真是感觉这段时间蛮让人感慨的。</p><p>果然，就算说是小手术，对于身体来说，还是相当的遭罪啊。</p><h3 id="术前问题"><a href="#术前问题" class="headerlink" title="术前问题"></a>术前问题</h3><p>因为这个病查出来的挺突然，手术前，心里还是做了一段时间的博弈，整理了如下问题。</p><p>我感觉后续如果再遇到大病了，都可以按照这个思考逻辑来，这里也给大家做个参考。</p><ol><li>治疗方式具体都有什么？</li><li>拖着不做可以吗？</li><li>这个手术的后遗症是什么？</li><li>手术费用是否会很多？医保能报多少？（有钱人不必考虑）</li><li>手术后调理恢复要多久？是否会耽误日常生活？</li></ol><p>我的手术是甲状腺切除，咨询了医生的意见之后，我自己评估了一下，可以接受，确实不是啥大问题。</p><ol><li>只要手术切除甲状腺即可，不需要化疗，这病是危险性最小的癌症。</li><li>我这个甲状腺细胞乳头状癌拖着没啥，但癌细胞有扩散风险，尽管不高，但是要做。</li><li>后遗症就是以后都要吃优碘乐，而且手术如果出了意料外的情况，说不定会干扰声带的音色，但是医生自信9成可能不会出这种问题。</li><li>手术费用反而最不用担心，医保报了6成费用之后，自己缴费即可，术后结账我算了一下，拢共也就近4千。</li><li>手术调理按照医嘱即可，两周就差不多正常行动。</li></ol><h3 id="住院准备"><a href="#住院准备" class="headerlink" title="住院准备"></a>住院准备</h3><p>在确认必须要做手术后，事情就好办了。</p><p>和有住院经历的朋友确认了相关事宜后，我大概做了如下的准备。</p><ul><li>带本子和笔，护士的嘱托会很多，如果不记录，后续忙起来容易忘</li><li>准备住院金，提前和医生确定好预期金额，到时候交就可以</li><li>确认医院附近的食堂和外卖取餐点，不然术后，自己和家人吃饭，找起来会是个问题</li><li>确认好手术时间之后，让家人在手术当天陪同就可以，如无必要，不必第一天让家人在医院就开始等着</li><li>如有必要，让家人带一床被褥，夜里如果保持通风，房间会偏冷</li><li>带一身换洗衣服，不过我住院时间很短，所以这个不需要</li><li>医院里有褪黑素，不过没用到，那天我靠着自己强大的意志力，在同房的呼噜声中睡着了</li></ul><h3 id="提前出院"><a href="#提前出院" class="headerlink" title="提前出院"></a>提前出院</h3><p>本来想写写手术的感觉，但是吧，手术全麻太给力。</p><p>医生说让我吸两口氧，结果吸完我就没意识了。</p><p>等到再醒我就被推出来了，好家伙，手术已经结束了？这过程，就是把我腰子拿了，我估计我都没有反应。</p><p>所以，手术没啥好说的。</p><p>反而是术后，我住院时候没细说多久，结果上午刚手术完，下午就和我说，第二天上午可以出院了。</p><p>这个速度快的我有点无语，当时为了吸出伤口内的血液，我脖子还插着一个导流管呢，根本不方便行动。</p><p>然而就是这么个状态，就让我出院了，属实离谱，后来我考虑了一下，觉得可能是医院床位不足的问题。</p><p>剩下的就没啥好说的了，第二天麻药劲儿过了，伤口也愈合的可以简单行动，就按照医生说的，交钱，收拾房间，走人。</p><h3 id="术后恢复"><a href="#术后恢复" class="headerlink" title="术后恢复"></a>术后恢复</h3><p>本来以为三两天就能恢复，但是没想到花了快两周时间，现在才差不多恢复结束。</p><ul><li>两天后拆导流管</li><li>每三天换药，需要去医院</li><li>一周后拆线</li></ul><p>如上，过了一周，然后又在家里躺了一周，嗓子吃饭和说话都不太好使，还是怪难受的。</p><p>不过，现在伤口恢复的差不多了，甚至吃了个火锅，挺好，一周没有吃点辣味，简直要死了。</p><p>但是目前没有完全恢复，稍微走动就会累，而且容易困，并且如果药稍微吃晚点，就容易腿疼。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的手术蛮让我感慨的，不论这次的病症是不是一开始的不规律作息及饮食，我都要考虑身体的稳定了。</p><p>我只是普通人，所以这也算是足够幸运了，虽然这个病出乎意料，却没有造成太大的困扰。</p><p>随着年龄越来越大，身体愈发破败，苍老是肉眼可见的，如果再这么玩下去，我确实必死无疑。</p><p>这像是命运的警告，亦是命运的垂怜。</p><p>希望接下来身体会好起来，希望我不会是个短命鬼。</p><p>人世间很精彩，现在正是时代交界的时刻，我很想见证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nas使用心得笔记————入门篇</title>
      <link href="/2023/03/11/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%EF%BC%8Cnas%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/11/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%EF%BC%8Cnas%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本系列文档给还没入坑的小伙伴一个介绍引导，如有说错，还请在评论区多多指教。</p><p>如果你是个整准备入坑的小白，可以试着和群里的大家交流搞机心得（哎嘿）。</p><p>当然，欢迎老手指正，也欢迎新手提问。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇内容作为入门内容，只告诉大家怎么选购，选购后可能会遇到哪些坑。</p><p>所以，这里并不会详细的深入探讨内网穿透，家庭音影搭建，脚本部署等问题。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>nas 的详细定义去看<a href="https://baike.baidu.com/item/NAS/3465615?fr=aladdin">百度百科</a>，就我个人来看，这个东西就是私有的个人云盘。</p><p>正常的电脑轻度用户，一般是不会有这种需求的。所以，我们首先分析需求，这里我列一下可能的方向。</p><ol><li><strong>家庭影院</strong>，有很多电影资源，不仅在局域网看，也想在公网远程观看</li><li><strong>大文件备份</strong>，手里有很多照片，文档，压缩包之类的文件需要备份</li><li><strong>后台下载</strong>，有很多本机存不下，又想要下载的时候，可以使用。</li><li><strong>担心网盘检测</strong>，被净网行动教育过，不安心厂商网盘的检验</li></ol><p>如果有以上的一种或者多种需求，那么，我个人建议，可以考虑综合实力使用 nas。</p><p>作为私人云盘来说，nas 的存在，确实让很多事情方便了很多。</p><p>当然，如果你只是想存备份，不考虑远程备份。我推荐考虑<strong>硬盘柜</strong>，只要共振问题不大，就可入手。</p><h3 id="入门条件"><a href="#入门条件" class="headerlink" title="入门条件"></a>入门条件</h3><p>在需求分析之后，我们确认如果有以下硬性条件，的就可以考虑入门了。</p><ol><li>时间较充裕，如果您每日加班到深夜，就略过吧，这玩意如果想折腾的合心意，较为花时间</li><li>金钱较为充裕，至少保证有 4k 以上的预算，不会说因为买个机器，接下来几个月都要吃咸菜馒头算日子</li><li>有一个较为稳定的住所，保证网络和供电，可长期规划，毕竟 nas 更偏向于远程访问</li><li>有一定的搞机常识，对于软硬件知识有基础的了解</li><li>动手能力强，善用搜索引擎，能保证在 B 站或者其他论坛解决一些问题</li></ol><h3 id="主机挑选"><a href="#主机挑选" class="headerlink" title="主机挑选"></a>主机挑选</h3><p>在正式罗列之前，我先列出 nas 机器的评判标准（个人主观意见）。</p><p>后续如果我们选购 nas，拿不定评价方向，可以参考如下思路进行评测，权重按照自己的要求衡量。</p><ol><li>系统生态，这个对于比较喜欢折腾的人来说，比较重要，社区的活力一般决定厂商是否走的长远</li><li>是否耗电，不要产品便宜，设备烧电，不然长久下来，电费也是一笔大开支</li><li>硬件损耗，是否会对机械硬盘造成强烈损耗，不然数据损毁恢复起来，也是一笔不小的开支</li><li>噪音问题，家用 nas 虽然设备垃圾，但是相对的，散热要求不高，所以噪音一般不大</li><li>产品价格，性价比也是个比较重要的参考项，不过一定要在满足硬件标准的情况下考虑</li></ol><h4 id="群晖系列"><a href="#群晖系列" class="headerlink" title="群晖系列"></a><a href="https://mall.jd.com/index-1000002032.html?from=pc">群晖系列</a></h4><p>不差钱的富哥首选，高薪打工人的备选，穷鬼别沾，真的太贵了！</p><p>光价格，如果要是六盘位，八盘位，就足足赶得上一台高配电脑了，这还不算硬盘的裸机价格。</p><p>我个人觉得这实在是高的离谱，即便我买的也是这个系列，但我依然感觉这个价格很咋舌，实在是有种智商税的感觉了。</p><p>不过，我当时主要是没太多时间折腾，而且，它贵确实有贵的理由，我这里罗列一下原因</p><ol><li>正版系统，不担心各种软件使用不稳定的问题，不折腾</li><li>功耗足够低，不会担心成为国家电网的合作伙伴</li><li>噪音相对不大，卧室可以放，不至于和服务器一样，一开就是飞机起飞</li><li>盗版系统社区发展好，社区足够的强大，大多数偏门的社区套件，都是从盗版社区发源来的</li><li>有客服，真出了搞不定的问题，我能找客服帮忙做事</li></ol><p>当然，不是没有缺陷，群晖的机器用的设备较拉胯，一般来说，个人组的黑群晖能吊着打正版群晖，这个看个人取舍。</p><h4 id="其他厂商"><a href="#其他厂商" class="headerlink" title="其他厂商"></a>其他厂商</h4><p>除了群晖，市面上确实之后其他厂商了，毕竟盗版系统刷群晖的居多，有什么问题都好解决。</p><p>尽管市面上<a href="https://item.jd.com/100016638665.html">威联通</a>，<a href="https://item.jd.com/100039880211.html">绿联</a>，还有各种厂商都做了很多自家的 nas，尤其是威联通的性价比还不错。</p><p>但是，如果系统出了啥问题，大多数都只能去各种社区论坛找方案，找客服进度缓慢，所以这里不是很推荐。</p><h4 id="黑群晖"><a href="#黑群晖" class="headerlink" title="黑群晖"></a>黑群晖</h4><p>现在市面上是有一些自售的成品，我看了一下价格，性价比非常高。</p><p>而且，烧盘问题已经解决了，早期黑群晖系统因为系统休眠问题，对硬盘损耗极大，几个月就能烧掉一个新硬盘。</p><p>在解决掉烧盘问题之后，现在的黑群晖，几乎算是没有短板，我个人十分推荐组一个，推荐理由我这里也列一下。</p><ol><li>性能好，硬件自选，不用被官方束缚，所以很多人组的快赶上服务器了</li><li>价格超低，基本上 800-1000，就能组一台暴打正版的高性能设备，盘位还多</li><li>社区解决方案多，因为早期折腾的人多，所以问题也多，所以解决方案就多</li><li>基本上和正版没什么差别的系统，现在基本上和官方一样了，只要刷白，问题不大</li><li>噪音也不大，卧室可用</li></ol><p>这里，也列一下大佬给出的组合作为参考（2023）</p><ol><li>主板，b365</li><li>cpu，g4560</li><li>机箱，蜜獾超存机箱（闲鱼上找，其他平台要么没有要么很贵）</li><li>内存条，威刚万紫千红 8&#x2F;16G</li></ol><h3 id="硬盘相关"><a href="#硬盘相关" class="headerlink" title="硬盘相关"></a>硬盘相关</h3><p>硬盘是 nas 的核心，毕竟作为特化存储的设备，必然是要用机械硬盘的，固态盘的虽然快，但因为它的结构，所以它不能作为长久存储方案。</p><p>我个人推荐先看完<a href="https://www.bilibili.com/video/BV1rE411Q71m/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">硬件茶谈的科普</a>，这个科普详尽而且务实，弄明白了，相信你自己心中也有一套选购标准。</p><p>我这里主要说一些我已经整理到的入门信息，仅供参考使用</p><ol><li>不选瓦楞盘(SMR)，<strong>选垂直盘（CMR）！</strong>具体参考<a href="https://www.bilibili.com/video/BV1rE411Q71m/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">硬件茶谈的科普</a></li><li>硬盘缓存尽可能的选大的，硬盘在写入数据的时候，大缓存硬盘相对来说频率会低一些，响声不会太大，当然出问题的概率也更高</li><li>机械盘如果没有特别价位参考的话，推荐按照 180&#x2F;T 的单价来算，一般来说，16-18T 左右的硬盘性价比最高</li><li>具体容量大小自行决定，如果只想组家庭影院，推荐上企业盘</li><li>是否组 raid，要看自己整理的数据是否重要，性价比是否值得，如果是企业数据，推荐组 Raid1</li><li>不要无脑 Raid0，组 Raid0 虽然读写速度快，但是一旦出问题，所有数据会全部崩盘，所以不要乱来</li><li>机械硬盘的寿命很长，据说有十年都没问题的，你也可以选择冷备份，每隔两三年拿出来读写一次就可以</li></ol><h3 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h3><ol><li>尽量放在网络稳定的环境里，使用舒心，硬盘如果长期上传下载也不会出现问题</li><li>使用环境避免潮湿，灰尘，保持通风，硬盘还是蛮娇贵的，机器无所谓</li><li>电力尽可能的稳定，能够保证不会因硬关机导致机械硬盘损坏</li><li>尽量不要放在频繁振动的地方，不然会影响硬盘的指针精度，导致硬盘损毁</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来只是打算简单写篇入门文档，没想到一写就写了一天。</p><p>信息收集不易，后续如果有机会，我会继续更新 nas 相关文档。</p><p>如果有兴趣，可以加群 813222463，大家一起讨论。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nas </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次手术（前）</title>
      <link href="/2023/03/09/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%89%8D%EF%BC%89/"/>
      <url>/2023/03/09/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%89%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>虽然做好了这次体检很糟糕的情况，但是没想到会这么糟糕。</p><p>甲状腺结节，穿刺验证之后，病理科给出判断——<strong>乳头状癌</strong>，考虑手术。</p><p>嗯，真是开年有惊喜的捏。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一开始查出来这结果，人懵了，毕竟只要沾上癌症之类的字样，基本等同于宣判死刑。</p><p>不过后来去找医生咨询了结果之后，大致可以接受。</p><p>这里把近况稍微做个梳理，也把我术前的心态记录一下。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><ul><li>问题不是很严重，是一种较为常见病症，不是需要特殊命名的情况</li><li>手术可以解决，复发率不高，且对寿命等无影响，不会遗传</li><li>如果长期不解决的话，大致情况就是可能随淋巴扩散，产生其他问题</li><li>医保范围覆盖了该手术，报销之后，估计也就2-3k左右，不用考虑金钱的问题</li></ul><h3 id="难处"><a href="#难处" class="headerlink" title="难处"></a>难处</h3><ul><li>我周边没有空闲的朋友能帮忙，所以最终只能让家人来帮忙</li><li>离职后正处于搬完东西的时候，现在手里基本上没有什么日用品，不方便疗养</li><li>离职后，和预期不一样，所以房租没交，现在房东没说话，所以不稳定，不好规划</li><li>因为一开始挂号不在三甲医院，这个时候，想换医院做手术，要等不少时间，较为繁琐</li><li>下个月就要开始考试了，接下来复习和调理都很费事</li><li>苏州物价偏高，花销上可能会稍微出点问题</li></ul><h3 id="备选"><a href="#备选" class="headerlink" title="备选"></a>备选</h3><p>因为我没在三甲挂号，导致现在很多事情难以处理，如果接下来能够换到三甲医院，一切自然万事大吉。</p><p>但是如果没法换过去，只能按照如下三种备选方案做事了。</p><ol><li>在相城人民医院直接准备手术，让家人过来帮忙照顾</li><li>回老家，动用老家的人脉在三甲医院手术</li><li>拖，等到手边的事情忙完了，再考虑手术</li></ol><p>以上三种方案，都有不小的弊端，但是也只能是目前的无奈之选了。</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ol><li>如果体检出麻烦的问题，<strong>一定要去三甲挂号！</strong>听人劝，吃饱饭，别为了省事绕远路，到头来只会更麻烦</li><li>第一次挂完号之后，后续可以直接拿着检测报告找医生，医生也不喜欢别人一直挂号</li><li>检测结果整理成档案，这便于下一位医生接手</li><li>医院在手术前，需要安排床位，据之前的同事的住院经验，这个时间等待的不是很长（希望如此）</li><li>确实需要一位能够相互扶持的亲近之人，不然真出了问题，朋友们是有自己的事的，他们可以帮你，但是无法陪伴你</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>身体永远是做事的本钱，无论你心中有着何等疯狂的想法，一定要有一副野蛮的体魄才能实现。</p><p>现在这个时间点，也完全不建议用身体去交换金钱————回报太低了。</p><p>最近把所有苏州同事推荐的有意思的点逛了一下，不过，最终还是觉得观前街的美食街有意思，<strong>要得火锅</strong>的番茄汤好喝。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm工具包————发布</title>
      <link href="/2023/03/05/npm%E5%B7%A5%E5%85%B7%E5%8C%85%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83/"/>
      <url>/2023/03/05/npm%E5%B7%A5%E5%85%B7%E5%8C%85%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>本次开源的方法是<a href="https://demo.assetech.com.cn/">cat-tools</a>，目前该工具包已经在npm上可下载，公司多个项目使用，没出什么问题。</p><p>尽管市面上开源了<a href="https://www.lodashjs.com/">loadsh</a>，<a href="http://momentjs.cn/">moment.js</a>，<a href="https://dayjs.fenxianglu.cn/">day.js</a>这类的工具包，但是总有不能满足需求的时候。</p><p>所以，我觉得，还是得造一个趁手的工具包。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一开始，是不同的项目中，有一些独立的工具类方法的整合。</p><p>后来，独立项目越来越多，不同项目之间，同步工具类方法是个大问题。</p><p>如果某项目加入了新的方法，我就要同步复制到很多项目！</p><p>折腾很多次之后，实在感觉耽误时间，且犯错太多，所有就有了本次流程记录。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在项目开发完成之后，我们首先要打包项目，生成一个能够发布的dist包。</p><p>当然，ui包可能有自己的结构，这个只要开发那边确认之后就行。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>然后，我们需要到<a href="https://www.npmjs.com/">npm官网</a>注册一个账号。</p><p>如果之前<strong>有npm账号的人</strong>，可以略过这步。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>在登录之前需要保证你现在使用的 <code>npm源</code> 是指向 <code>npm</code> 的。</p><p>先安装 <code>nrm</code> 工具查看和切换 <code>npm</code> 源</p><p><code>nrm</code> 安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure><p>查看当前使用的 <code>npm</code> 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm ls #查看包源列表</span><br><span class="line">nrm use npm  #切换包源列表</span><br></pre></td></tr></table></figure><p>在执行nrm use npm之后，如果命令行中有如下提示，代表切换成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry has been set to: https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在终端使用一下命令登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>然后根据提示输入账号、密码、邮箱，同时还有注册邮箱的一次验证码。</p><p>以我为例，我按照下边的完成填写之后，就算是登录了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Username: *********</span><br><span class="line">Password: ********</span><br><span class="line">Email: (this IS public) *********@qq.com</span><br><span class="line">npm notice Please check your email for a one-time password (OTP)</span><br><span class="line">Enter one-time password from your authenticator app: 04471694</span><br><span class="line">Logged in as crazystudent13 on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm publish # 发布公有包</span><br><span class="line">或</span><br><span class="line">npm publish --access public # 发布带命名空间的包，npm publish默认私有需要付费</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="迭代需要修改版本号"><a href="#迭代需要修改版本号" class="headerlink" title="迭代需要修改版本号"></a>迭代需要修改版本号</h4><p>如果项目更新需要重新发布，必须修改 <code>package.json</code> 里的版本号。</p><p>版本号只能不断往上增加，哪怕你后边版本号拖的很长也可以。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="包权限管理"><a href="#包权限管理" class="headerlink" title="包权限管理"></a>包权限管理</h4><p>很多时候，一个项目包往往不只是你一个人在管理的，这时需要给其他一起维护的同学开通发布的权限，相关使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看模块 owner, 其中 demo 为模块名称</span></span><br><span class="line">$ npm owner <span class="built_in">ls</span> demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个发布者, 其中 xxx 为要添加同学的 npm 账号</span></span><br><span class="line">$ npm owner add xxx demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个发布者</span></span><br><span class="line">$ npm owner <span class="built_in">rm</span> xxx demo</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>选择npm，也是因为用的人多，出了问题，论坛的解决方案应该多。</p><p>其实一开始想过其他的同步方案，比如用一个Git来做同步管理。</p><p>但是后来考虑到用的人少，隐患大，而且，这玩意也许不止我们一个人可以用，干脆开源吧。</p><p>开源的项目，如果别人用出了问题，他们也会提示，方便了别人，也促进了自己，挺好的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6991300926099357709">原生 node 搭建最基础的 npm 工具包</a></p><p><a href="https://juejin.cn/post/6844903918414102535">使用npm发布一个vue组件</a></p><p><a href="https://juejin.cn/post/6920231981834108942">一文搞定 npm 包发布与管理</a></p><p><a href="https://juejin.cn/post/7074116683673108493">规范化开发并发布npm包</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————自动部署</title>
      <link href="/2023/03/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>之前写博客的时候还没注意，后来在修改博客的时候，发现不停的敲命令发布确实烦。</p><p>为了解决博客发布占用时间的问题，查了一圈论坛，和相关人员的解决方案。</p><p>最终，我选中了<a href="https://docs.github.com/zh/actions/quickstart">github Action</a>，对于托管在github上的hexo来说，这玩意真是好用。</p><p>另外，我目前只部署到github上，暂时不考虑部署到gitee和coding上。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>在正式确立工作流之前，这里是有两个方案的。</p><ol><li>在GIthub.io那个仓库中新建源码分支，等到分支提交时候，触发命令，然后github流程化部署，博客上线</li><li>新建一个仓库，用来管理博客，博客每次提交，就会触发命令，然后github流程化的自动部署，博客上线</li></ol><p>这两种方案，一开始我更倾向于第一种，因为没什么必要，不多开项目，总是好的。</p><p>但是后来考虑到源码内容中，总会有这种隐私性质的秘钥之类的，放在开源项目确实不好。</p><p>而且，目前很多论坛都倾向于第二种方案，想了想，那这里选择<strong>新建仓库</strong>吧。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>参考市面上大多数人的选择，我在<a href="https://github.com/">github</a>建了一个<strong>blog</strong>仓库，注意新仓库是<strong>私有的</strong>。</p><p>因为，这个仓库是用来存博客源码的，为了规避秘钥被别人看到，所以<strong>不能设置为public！</strong></p><p>在新仓库准备完成之后，我们清空本地仓库的远程链接，然后，让本地的hexo博客源码和远程新仓库完成对接。</p><p>这里我魔改了一下<a href="https://anzhiy.cn/posts/asdx.html#%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%92%8C%E5%88%86%E6%94%AF">安知鱼大佬的流程</a>，咳咳，如果要新建仓库的话，就参考他的教程，我这是对已有的源码修改。</p><ol><li><p>删除博客主题的git文件，比如我这里是<a href="https://github.com/Lhcfl/hexo-theme-anatolo">anatolo</a>。我删除了<code>/themes/anatolo/.git</code>文件，避免主题文件夹下的<code>.git</code>文件夹其被识别成子项目，无法被上传到源码仓库。</p></li><li><p>在博客根目录下，运行指令，我这里是在E:\gitPro\blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化</span><br><span class="line">git remote add origin git@github.com:crazystudent13/blog.git</span><br><span class="line">git checkout -b main # 切换到main分支，</span><br></pre></td></tr></table></figure></li><li><p>添加屏蔽项</p><p>因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到 github 上。这样可以显著减少需要提交的文件量和加快提交速度。</p><p>我再<code>E:\gitPro\blog\.gitignore</code>,屏蔽了以下文件，如果你应用了主题里边的配置项，记得，主题里边的gitignore文件也要完成修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TXT.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></li><li><p>之后再运行 git 提交指令，将博客源码提交到 github 上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;github action update&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li><li><p>此时你的主题文件夹若已经被正常上传，并且你也添加了主题文件夹下的.git 文件夹的屏蔽项。那你可以考虑把第二步移走或删除的<code>.git</code>放回来，用作以后升级。（个人觉得这种升级方式不是很好）</p></li></ol><h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a>获取权限</h3><p>为了确保交由<code>Github Action</code>来持续部署时，<code>Github Action</code> 具备足够的权限来进行 <code>hexo deploy</code> 操作,需要先获取 <code>Token</code></p><p>访问 Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token。</p><p>注意事项：</p><ol><li>名称自己琢磨功能随便填下就行，我这里填的是自动部署。</li><li>必须勾选 repo 项 和 workflows 项。</li><li>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</li></ol><h3 id="建立流程"><a href="#建立流程" class="headerlink" title="建立流程"></a>建立流程</h3><p>打开github在项目的actions下，点击new workflow，新建一个autodeploy.yml的文件就行，然后把我下边的脚本放上去，就能完成博客的自动化部署了。</p><p>我之前用别人的脚本并未一次通关，所以自己查资料调整了一下，这里放调整结果。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"><span class="comment"># 当有改动推送到main分支时，启动Action</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;mian&quot;</span> ]</span><br><span class="line">      <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">mian</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">cache-npm</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">cache-name:</span> <span class="string">cache-node-modules</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-build-$&#123;&#123;</span> <span class="string">env.cache-name</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.cache-npm.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install gulp-cli -g #全局安装gulp</span></span><br><span class="line"><span class="string">          npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署到Github</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">ghp_*****************************</span></span><br><span class="line">          <span class="attr">repository-name:</span> <span class="string">CrazyStudent13/CrazyStudent13.github.io</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">folder:</span> <span class="string">public</span></span><br><span class="line">          <span class="attr">commit-message:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; github.event.head_commit.message &#125;&#125;</span> Updated By Github Actions&quot;</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>这里有很多人直接按照教程走会出现有些坑，我这里稍微提一下我遇到的情况：</p><ol><li>不要乱改命令，上述代码中checkout@v2，这个对应的是功能，不是版本。</li><li><strong>注意本地和远端的冲突</strong>，在提交完成代码之后，可以在github远端创建自动部署脚本，不用本地新建文件夹，去产生冲突。</li><li><strong>注意博客源码分支名称</strong>，2021年修改之后，新建的项目主分支应该是main，如果你用到的脚本中有些地方写的是master，记得改成main。</li><li><strong>注意博客分支名称</strong>，也不要完全都改成main分支，我的博客是2019年部署的，废弃很久不用，现在又捡起来，所以分支依然还是master，最后提交的脚本，如果是提交到main，就会报错。</li><li><strong>自己主题内的配置要提交</strong>，不然构建博客的时候，页面构造命令可能会出现跑不通的情况。</li><li><strong>移除不需要的依赖</strong>，不然可能会造成不必要的错误，另外这样也减少下载时间。</li><li><strong>尝试AI帮忙写脚本</strong>，目前2023年，chatgpt发展的还不够狂野，但是我试过，是可以书写这类脚本的。</li></ol><h3 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h3><p>在完成上述内容之后，基本上应该是一步到位的完成。</p><p>如果要是不成，可以打开actions，一步步点进去，看到一个类似shell命令行的界面，里边会将哪个脚本报错，具体步骤的问题提示出来，按照报错排查就行。</p><p>具体操作参考<a href="https://www.bilibili.com/video/BV19P41157no?t=487.7">安知鱼的视频讲解</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在2019年知道有这个，但是没怎么用过。</p><p>没想到几年不见，自动化部署流程这么好用了，看来我这几年的工作，导致我的眼界太不宽阔了。</p><p>这里也非常感谢大佬安知鱼这篇文档的指路，真的对我的自动化部署要求产生了很大的助力。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://anzhiy.cn/posts/asdx.html">使用 Github Action 自动部署 | 安知鱼 (anzhiy.cn)</a></p><p><a href="https://www.bilibili.com/video/BV19P41157no?t=487.7">hexo完成github action自动部署</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次体检</title>
      <link href="/2023/03/03/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%93%E6%A3%80/"/>
      <url>/2023/03/03/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%93%E6%A3%80/</url>
      
        <content type="html"><![CDATA[<p>23年终于进入到了休息阶段，身体不行，打算休息一下了。</p><p>本来按照人生规划，这段时间是要进入职场中高层，开始弄大钱，过城市生活的，但是身体实在顶不住了。</p><p>而且看病这个事儿吧，我从来没想到会这么麻烦，特别记录一下，如果后续在遇到这种事，有个心理准备。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>看病这个流程是个相当消耗时间的活儿，放在工作的时候，我还真没那么多时间。</p><p>现在算是离职状态，所以时间较为充足，而且终于能挂的上专家号了。之前周六周日都挂不上，现在终于能放心的等一回了。</p><h3 id="挂号"><a href="#挂号" class="headerlink" title="挂号"></a><strong>挂号</strong></h3><ul><li>尽可能的网上挂号，地方的公众号，小程序都有相关的功能</li><li>如果不是血检相关的事情，不要挂早上的，下午的相对来说人比较少</li><li>一般只有周一到周五能挂专家号，尽可能的提前查好</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>常规的流程如下</p><ol><li>挂号，等叫号</li><li>医生诊断后，开药方</li><li>拿着单子去缴费</li><li>缴费完成后，去开药的药房拿药</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>挂号可以用电子医保卡缴费，不必用真社保卡</li><li>挂号，如果当日值班的医生专家还在，依然可以提挂号排队</li><li>叫号如果错过，只要不是当天错过医生的在职时间，都可以商量，在叫号期间稍微商量下，可以补叫号。</li><li>中间流程如果要查B超，血检之类的，那时间可就长了。最好预估自己的病症，若涉及到这类检测，自己要预估时间，最好起步做好一天甚至两天的时间准备。</li><li>如果有些小手术之类的说法，最好问清是否会干扰行动能力，只要不干扰行动能力，一切都可启动孤胆英雄模式，硬抗就可以。</li><li>身体能力不能太过虚弱，过于肥胖，老迈，都需要其他人陪同，不能自己单独行动</li></ol><h3 id="病情"><a href="#病情" class="headerlink" title="病情"></a>病情</h3><p>今年这年初的检测，我都不知道自己这个身体是什么年纪的，高血压高血脂，中度脂肪肝，甲状腺结节，肾结石。</p><p>这一堆问题几乎让我以为自己是老年人，亏得自己年轻，看来不能太卷了。</p><h4 id="甲状腺结节"><a href="#甲状腺结节" class="headerlink" title="甲状腺结节"></a>甲状腺结节</h4><p>目前还没有出现病理检测，所以不知道是什么情况，希望问题不大。</p><p>主要是做甲状腺穿刺之后，嗓子上就像是有根针顶着，稍微剧烈的吞咽，说话等动作，或者情绪激动，嗓子就疼的不行。</p><p>2023-03-10，检测结果出现，疑似乳头状癌，需要手术（艹）</p><h4 id="左肾结石"><a href="#左肾结石" class="headerlink" title="左肾结石"></a>左肾结石</h4><p>这个目前看来问题不大，医生的意思是多喝点水，定期检查就行。这个还是得注意的，毕竟是肾。</p><h4 id="中度至重度脂肪肝"><a href="#中度至重度脂肪肝" class="headerlink" title="中度至重度脂肪肝"></a>中度至重度脂肪肝</h4><p>荤食得忌口了，这一年，疗养时间怕是吃不到几次荤食了。</p><h4 id="高血压，高血脂"><a href="#高血压，高血脂" class="headerlink" title="高血压，高血脂"></a>高血压，高血脂</h4><p>盐，油估计都得节制了，医生的桌上写着，不要超过7g盐，感觉有点离谱。</p><p>因尿酸偏高，多吃低嘌呤食物，粗粮，减少饮酒。</p><h4 id="颈部曲度消失"><a href="#颈部曲度消失" class="headerlink" title="颈部曲度消失"></a>颈部曲度消失</h4><p>这个只能去找正骨科的医生问问了，现在脖子确实很难受</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因为医保在苏州，在没有弄清楚医保机制的前提下，只能先在这边用医保了。</p><p>对病症的确诊，远比想象的麻烦，作为没有什么关系的凡人，没想到看病这么麻烦啊，看来以后真的得好好学习身体的保养了。</p><p>如果对养生这块比较了解的朋友，可以在评论区留言，如果能推荐几本书就更好了，在这里提前谢谢了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 养生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————命令整理</title>
      <link href="/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>虽然Hexo确实很好用，但是由于我对命令和配置的不熟悉，导致很多东西都不是很好用。</p><p>建议参考<a href="https://hexo.io/themes/">官网</a>的文档，我梳理了一份属于自己的命令文档。</p> <span id="more"></span> <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装</span><br><span class="line">npm update hexo -g #升级 </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览，会监视文件变动并自动更新，您无须重启服务器</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br></pre></td></tr></table></figure><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">标题</td></tr><tr><td align="center">layout</td><td align="center">布局</td></tr><tr><td align="center">date</td><td align="center">文件建立日期</td></tr><tr><td align="center">title</td><td align="center">标题</td></tr><tr><td align="center">categories</td><td align="center">分类</td></tr><tr><td align="center">tags</td><td align="center">标签</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">categories: Blog</span><br><span class="line">tags: [Hexo]</span><br></pre></td></tr></table></figure><h3 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上是文章摘要 </span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">以下是余下全文</span><br></pre></td></tr></table></figure><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &lt;title&gt;</span><br><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:title</td><td align="center">标题</td></tr><tr><td align="center">:year</td><td align="center">建立的年份（4 位数）</td></tr><tr><td align="center">:month</td><td align="center">建立的月份（2 位数）</td></tr><tr><td align="center">:i_month</td><td align="center">建立的月份（去掉开头的零）</td></tr><tr><td align="center">:day</td><td align="center">建立的日期（2 位数）</td></tr><tr><td align="center">:i_day</td><td align="center">建立的日期（去掉开头的零）</td></tr></tbody></table><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="语雀同步插件"><a href="#语雀同步插件" class="headerlink" title="语雀同步插件"></a>语雀同步插件</h3><p>之前个人使用了<a href="https://blog.lxstart.net/">小冷</a>的<a href="https://github.com/x-cold/yuque-hexo#Example">语雀对接插件</a>，感觉很不错，这里也整理一下。</p><p>不过，现在语雀用我已经停用了，它总给我一种难受的感觉，我说不上来。</p><p>虽然语雀他们各方面整的都挺好，但是不知道为啥，用起来就是膈应。</p><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yuque-hexo</span><br><span class="line"># or</span><br><span class="line">npm i --save-dev yuque-hexo</span><br></pre></td></tr></table></figure><p><strong>Sync</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuque-hexo sync</span><br></pre></td></tr></table></figure><p><strong>Clean</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuque-hexo clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————域名绑定</title>
      <link href="/2019/02/09/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
      <url>/2019/02/09/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>电脑系统为window 10专业版，64位</p><p>这里默认大家已经完成了git博客的部署，接下来的操作，就是将git的地址，绑定到我们的个人域名</p><span id="more"></span><p>接下里的教程，我大致将过程分为三个阶段</p><ul><li>准备阶段：准备自己购买<strong>自己的域名</strong>，配置<strong>域名解析</strong></li><li>绑定阶段：<strong>在github上绑定自己的域名</strong>，并在本地<strong>设置CNAME文件</strong>，提交，完成域名的固定绑定</li><li>验证阶段：收尾，测试绑定是否成功</li></ul><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>需要实名认证，然后购买，不过域名不贵，推荐随便买个cn的域名就行。</p><p>购买渠道很多，腾讯，阿里，华为等，我个人在阿里云买的域名。</p><blockquote><p>crazystudent13.cn</p></blockquote><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>以我使用的阿里云为例，我会打开管理控制台，点击<strong>解析</strong>。</p><p>按照下边的记录，配置解析，按照下方的表格去操作。</p><p>记录类型为A的，是github的网址，CNAME是个人博客的仓库。</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="center">解析请求来源</th><th align="center">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.108.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.109.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.110.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.111.153</td></tr><tr><td align="center">www</td><td align="center">CNAME</td><td align="center">默认</td><td align="center">crazystudent13.github.io</td></tr></tbody></table><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>进入自己的Git博客项目中，打开setting，下拉，找到Github Pages。</p><p>在输入框中输入我们买的域名（不要输入www.），完成内容。</p><p>如果没有立刻生效，等10分钟左右（dns的解析时间差不多是这个时间，具体可以看域名控制台的说明）。</p><h4 id="固定域名"><a href="#固定域名" class="headerlink" title="固定域名"></a>固定域名</h4><p>这一步本来是不必要的，但是每次发布，域名就会失效。为了一劳永逸，这个得做。</p><p>在博客的source文件夹中，新建文件CNAME(没有后缀，什么后缀都没有，字母必须大写)。</p><p>将个人域名存入文件中，然后发布，等待。</p><blockquote><p>crazystudent13.cn</p></blockquote><h4 id="验证绑定"><a href="#验证绑定" class="headerlink" title="验证绑定"></a>验证绑定</h4><p>浏览器输入自己的域名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.crazystudent13.cn</span><br></pre></td></tr></table></figure><p>如果您像以上我的博客那样，您也跳转到了自己的git博客，那就代表成功了。</p><p>而且就算提交文件，也不会覆盖掉域名设置。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，所有的工作全部做完了，一路看下来，其实利用Github创建博客是个很简单的事。</p><p>其实一开始，我是想利用VUE和语雀的接口做一个博客来锻炼自己技术的。</p><p>但是后来我觉得太过麻烦，而且过年又犯懒，加之网上不止一个人以个人博客为项目写了DEMO，这里自己再做，恐怕也有点过于重复，没多少意义了。</p><p>时隔数年，没想到还是用这玩意了，真的是有些令人唏嘘。</p>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————基础流程</title>
      <link href="/2019/02/09/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/02/09/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建的流程几乎烂大街了，19年的时候搭建时候写的，没想到现在又用上了。</p><p>这是老早之前的文档，这次翻出来重新梳理搭建流程，完善几个细节，为了后续给其他人提供便利。</p><span id="more"></span><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>安装并配置好Node.js环境，只要常规的输入以下命令，如果输出版本号了，证明已经安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装Git和配置好Git环境，同上，用git版本号来确定以下有没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h4 id="注册项目"><a href="#注册项目" class="headerlink" title="注册项目"></a>注册项目</h4><p>Github账户注册，新建项目：账户名.github.io，并且需要勾选Initialize this repository with a README</p><p>比如我这里，是在GitHub上，建的<a href="https://github.com/CrazyStudent14/CrazyStudent14.github.io">CrazyStudent14.github.io</a>项目。</p><p><strong>注意</strong>：国内的码云实际上也是支持这个操作的，不过码云有个缺陷，就是如果你后续想绑定域名来访问这个博客的话，码云因为国内的政策问题，无法绑定，而github无所谓，所以，部署的时候，考虑清楚自己的需求。</p><h4 id="本地准备"><a href="#本地准备" class="headerlink" title="本地准备"></a>本地准备</h4><p>这个流程有点长，主要是在本地完成博客的准备和构建</p><p>以下流程尽可能的全程命令行操作</p><p>本地自己先部署Hexo项目，在自己认为合适的地方创个文件夹。</p><p>我是在E盘建了一个blog文件夹，然后npm全局安装一个Hexo依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;cd gitpro/blog</span><br><span class="line">E:\gitPro\blog&gt;npm install hexo -g</span><br></pre></td></tr></table></figure><p>安装完成hexo之后，hexo -v，查hexo的版本号，检查hexo是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo -v</span><br></pre></td></tr></table></figure><p>至此，本地部署的前期工作完成，输入hexo init，初始化该文件夹（有点漫长的等待。。。）</p><p>完成安装后，出现Start blogging with Hexo！这就代表Hexo已经在这个文件夹下初始化成功可，在本地完成项目新建了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo init</span><br></pre></td></tr></table></figure><p>这时候的项目，是个架子，没有安装依赖，相当于炒菜有锅没买菜一样，所以，需要npm来安装依赖。</p><p>输入npm install，安装所需要的组件，等安装成功之后就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>输入hexo g，先完成项目构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo g</span><br></pre></td></tr></table></figure><p>输入hexo s，开启服务器，访问本地化网址，如果没有端口占用的话，一般是<a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo s</span><br></pre></td></tr></table></figure><p>假如页面一直无法跳转，那么可能端口被占用了，输入“hexo server -p 端口号”来改变端口号。</p><p>这样的话，我们会直接启动<a href="http://localhost:5000/">http://localhost:5000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo s -p 5000</span><br></pre></td></tr></table></figure><h4 id="准备秘钥"><a href="#准备秘钥" class="headerlink" title="准备秘钥"></a>准备秘钥</h4><p>这一步操作有点繁琐，我的教程只是个大纲，如果要是不清楚细节，可以在<a href="https://juejin.cn/">掘金</a>详细搜一下这里的小标题，里边应该有很多详细操作。</p><p><strong>注意</strong>：如果是首次设置git本地的秘钥，请按照如下流程操作，如果已经有秘钥了，其实生成部分可以跳过。</p><h5 id="设置Git的user-name和email"><a href="#设置Git的user-name和email" class="headerlink" title="设置Git的user name和email"></a>设置Git的user name和email</h5><p>我这里随便取个crazystudent14的假名字做演示，如果自己部署，不要抄名字，名字和邮箱换成自己的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;git config --global user.name &quot;crazystudent14&quot;</span><br><span class="line">E:\gitPro\blog&gt;git config --global user.name &quot;crazystudent14@test.com&quot;</span><br></pre></td></tr></table></figure><h5 id="Git生成SSH密钥"><a href="#Git生成SSH密钥" class="headerlink" title="Git生成SSH密钥"></a>Git生成SSH密钥</h5><p>为了将Hexo与Github page联系起来，切换到C盘，准备生成秘钥文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\crazystudent14&gt;cd C:\Users\crazystudent14\.ssh</span><br><span class="line">C:\Users\crazystudent14&gt;ssh-keygen -t rsa -C &quot;crazystudent14@163.com&quot;</span><br></pre></td></tr></table></figure><p>判断<strong>id_rsa</strong>，<strong>id_rsa.pub</strong>，<strong>known_hosts</strong>这三个文件是否存在。</p><p>我这里是win系统，如果是linux和mac系统，自己查一下相关的命令，或者到对应的文件夹去看一下。反正就是看看这个文件夹下边有没有这是三个文件，有的话，可以继续做。</p><h5 id="在github上添加key"><a href="#在github上添加key" class="headerlink" title="在github上添加key"></a>在github上添加key</h5><p>登录Github，点击头像下的settings，找到左侧的SSH and GPG keys。</p><p>点击new ssh key按钮，将id_rsa.pub文件里的内容复制上去，title就填写blog（这个title就是告诉你，这个Key是做什么用的，相当于备注）</p><h5 id="检测Key是否添加成功"><a href="#检测Key是否添加成功" class="headerlink" title="检测Key是否添加成功"></a>检测Key是否添加成功</h5><p>输入ssh -T <a href="">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@coding.net</span><br></pre></td></tr></table></figure><h4 id="准备发布"><a href="#准备发布" class="headerlink" title="准备发布"></a>准备发布</h4><p>好了，一切终于快结束了，我们再确认下流程。</p><ol><li>配置完成本地环境</li><li>在github注册好项目</li><li>本地完成Hexo博客的准备</li><li>在github添加自己的本地生成的key</li></ol><p>确认以上流程完成后，我们可以进行最后一步了。</p><h5 id="设置deploy"><a href="#设置deploy" class="headerlink" title="设置deploy"></a>设置deploy</h5><p>在博客项目的根件夹中，我这里是E:\gitPro\blog，找到_config.yml文件。</p><p>配置Deployment，修改repo值（在末尾），repo值是你在github项目里的ssh（右下角）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: &#x27;git@github.com:CrazyStudent14/CrazyStudent14.github.io.git&#x27;</span><br><span class="line">  branch: &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h5 id="部署deploy"><a href="#部署deploy" class="headerlink" title="部署deploy"></a>部署deploy</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>项目根目录中，执行命令hexo d -g，生成以及部署了（记住这个命令，这是用来把文章提交到Github上的命令，以后会经常用的）</p><p>部署成功后访问你的地址：<a href="http://用户名.github.io/">http:&#x2F;&#x2F;用户名.github.io</a>。那么将看到生成的文章</p><h5 id="写新博客"><a href="#写新博客" class="headerlink" title="写新博客"></a>写新博客</h5><p>通过以下命令创建新文件，我们会在source&#x2F;_posts目录下将会看到已经创建的文件，然后在新文件中写文章就行了。</p><p>写完之后，继续部署ok。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;博客名&quot;</span><br></pre></td></tr></table></figure><p>好了，到此为止，最基本的hexo+github搭建流程结束了。</p><p>我们看看效果吧。</p><h4 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h4><p>在建好的项目，点击右侧settings的tab栏目，向下拉到GitHub Pages，你会看到那边有个网址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://CrazyStudent14.github.io</span><br></pre></td></tr></table></figure><p>这时候，你已经有了一个部署在github上的hexo博客了。</p>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
