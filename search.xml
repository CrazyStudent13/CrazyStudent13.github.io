<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>10分钟了解浏览器的进程</title>
      <link href="/2024/05/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/05/16/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面试官：难道您没有了解过浏览器到底有哪些线程吗？</p><p>我：工作中用到的不多，没了解。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于进程与线程的事情说完了，但是浏览器到底有什么进程，这里我也比较好奇，所以也了解了一下。</p><p>虽然平时不怎么会用到，但也算是开拓眼界了。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是一个多进程架构设计，<strong>每打开一个标签页就会创建一个进程</strong>。当然浏览器内部也有着自己的优化，比如：当浏览器同时打开多个空白标签页的时候，会合并成一个进程。</p><p>浏览器到关闭到启动，至少开启四个进程：</p><ol><li><code>1个 browser进程</code></li><li><code>1个GPU进程</code></li><li><code>1个网络进程</code></li><li><code>1个渲染进程</code></li></ol><p>当新增其他标签页时，前面三个进程是可以共用的，不用重启。</p><p>默认情况下，每打开一个标签页，就会开启一个渲染进程。但是也会存在特殊的情况，就是如果打开的标签页在同一个站点下，会共享同一个渲染进程。</p><p>最新的浏览器进程主要包含：</p><ul><li>1个浏览器主进程</li><li>1个GPU进程（也可能存在多个，每个标签页都需要一个进程，用于绘制图形）</li><li>1个网络进程</li><li>多个插件进程（每个插件都会开启一个进程，因为防止一个插件崩溃，造成整个浏览器崩溃）</li><li>多个渲染进程（标签页需要独立的进程）</li></ul><h3 id="browser-进程（主进程）"><a href="#browser-进程（主进程）" class="headerlink" title="browser 进程（主进程）"></a>browser 进程（主进程）</h3><p>负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</p><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a>GPU 进程</h3><p>负责处理与图形渲染相关的任务。（着重在于<strong>图像</strong>）</p><ul><li>图形渲染</li><li>动画和过渡</li><li>3D 和 WebGL 渲染</li><li>视频播放和解码等</li></ul><h3 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h3><p>负责处理与网络相关的任务。它主要负责管理和维护网络连接，以及处理所有的网络请求和响应。</p><ul><li>管理网络连接</li><li>处理网络请求和响应</li><li>处理DNS解析</li><li>处理缓存</li><li>处理安全问题</li></ul><blockquote><p><strong>浏览器的网络进程和渲染进程的异步HTTP线程之间存在通信吗？</strong></p><p>在浏览器中，<strong>当用户在页面上发起一个网络请求时，该请求首先由渲染进程中的异步 HTTP 线程发起，异步 HTTP 线程会将该请求通过 IPC 传递给网络进程</strong>。网络进程收到请求后，负责管理和维护网络连接，发送请求并接收响应，最后<strong>将响应数据再通过 IPC 传递给渲染进程中的异步 HTTP 线程处理</strong>。</p><p>在这个过程中，网络进程和渲染进程之间需要频繁地进行通信，以协同完成网络请求和响应的处理。</p><p>例如，当请求被发送出去后，网络进程需要不断地监控连接状态和接收数据，并及时将收到的数据通过 IPC 传递给渲染进程中的异步 HTTP 线程，同时异步 HTTP 线程也需要不断地向网络进程查询请求状态和响应数据。 </p><p>浏览器通过 IPC（进程间通信）机制来实现这种进程间通信，IPC 是浏览器中进程间交换数据的标准方法，其通信方式包括消息传递、共享内存、管道等。</p><p>通过 IPC 机制，网络进程和渲染进程之间可以高效地传递数据和信息，保证了浏览器的正常工作和性能表现。</p></blockquote><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><p>用于处理浏览器插件的进程（每个插件，就会创建一个进程）</p><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>负责将 HTML、CSS 和 JavaScript 转换为可视化的页面。默认情况下，浏览器的tab就会创建一个渲染进程。</p><blockquote><p>针对前端，需要着重了解该进程。</p></blockquote><p>该进程包含：<code>GUI 渲染线程</code>、<code>JS 引擎线程</code>、<code>定时触发线程</code>、<code>异步 HTTP 线程</code>、<code>事件触发线程</code></p><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><p>负责页面的渲染和绘制；解析 HTML和CSS，构建 DOM树、CSSOM树 、 渲染树（Render 树） ，布局和绘制等。重绘和重排也是发生在该线程中。</p><p>GUI 更新会被保存在一个队列之中，等到 JS 引擎线程空闲时，GUI 线程就会立即执行。</p><p><strong>「GUI 线程和JS引擎线程是互斥的」</strong></p><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><p>也称为 JS 内核，负责处理 JavaScript 脚本程序。</p><p>再次注意，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong> ，所以，如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h4 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h4><p>指的是计时函数：setInterval 和 setTimeout 两个函数。</p><p>由于 JS 引擎是单线程的，如果该线程处于堵塞状态，那么就会造成计时不准确，那么就需要单独一个线程来进行计时。</p><p>当计时完成之后，就会把事件回调（任务）添加事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="异步-HTTP-线程"><a href="#异步-HTTP-线程" class="headerlink" title="异步 HTTP 线程"></a>异步 HTTP 线程</h4><p>XMLHttpRequest 在连接后是通过浏览器新开的一个线程请求。</p><p>检测到状态发生变化之后，就会事件回调（任务）添加到事件队列中，等待 JS 引擎空闲后去执行。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>用来控制事件循环的（Event Loop）。</p><p>就比如上面的，</p><ul><li>定时器的任务通过事件触发线程添加到事件队列中，</li><li>异步请求的任务是通过事件触发线程添加到事件队列中</li><li>。。。（收集任务）</li></ul><p>事件触发线程还会周期性地检查事件队列中是否存在任务。当JS引擎线程空闲了，就会将其中的任务顺序交给 JS 引擎线程执行。</p><blockquote><p>这里的解释可能存在错误。</p><p>事件触发线程是连接事件的发生和任务执行的桥梁。它负责接收事件，并将对应的任务添加到事件队列中，然后主动触发 JavaScript 引擎线程来执行任务。</p></blockquote><h4 id="存储线程"><a href="#存储线程" class="headerlink" title="存储线程"></a>存储线程</h4><p>负责处理浏览器的各种存储机制，包括 cookie、localStorage、indexedDB 等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>虽然面试时候感觉完全不太可能会提到，但是作为拓充知识涉猎一下也是不错的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7287914116286201891">浏览器原理：进程与线程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS的线程与进程</title>
      <link href="/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/05/15/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面试官：你能说一下线程和进程吗？我：工作中用不到，我没了解过。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>大多数前端都知道前端的JS是单线程语言，但是JS为什么是单线程语言大多数人可能还是不清楚的。</p><p>线程与进程这个东西，虽然不影响日常开发，但这是程序员必会的基础知识，我没能完整的说出来，确实不太好。</p><p>因此，我这里整理一下相关的知识点。</p><h3 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h3><ol><li>查看人管理器，每个应用程序至少会启动一个进程，有的会启动多个进程</li><li>一个进程会占有一片独立的内存空间。</li><li>各个进程的内存空间相互独立，不能互相访问。</li></ol><h3 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h3><ol><li>是进程内一个独立执行的单元。</li><li>是进程内的一个独立的执行单元</li><li>是CPU的最小调度单元</li></ol><p>单线程与多线程的概念，是针对一个进程内的概念。</p><ul><li>一个进程内有多个线程，那这个进程对应的程序就是多线程的程序。</li><li>一个进程内只有一个线程，那么这个程序就是单线程的程序，并且，一个程序，如果只有一个主线程，那就是单线程。</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li>某个独立的模块(浏览器的JS引擎)必须运行在某个进程的某个线程上，不能直接运行在进程上。</li><li>一个进程中必须至少有一个线程，就是所谓的主线程。主线程是进程启动后自动创建的，要运行代码必须要创建线程。</li><li>一个进程可以同时运行多个线程，叫做多线程。</li><li>一个进程内的数据可心供其中多个线程直接共享使用</li><li>多进程之间的数据不能直接共享使用</li></ol><h4 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h4><p>单线程和多线程之间并无优劣之分，只是根据使用场景而确定的方案，譬如JS一开始之所以确定为单线程，就是为了提高执行效率。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:能有效提升CPU的利用率</span><br><span class="line">缺点:创建多线程开销，线程间切换开销，锁进制与状态同步问题</span><br></pre></td></tr></table></figure><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点:代码顺序执行，编码更加简单</span><br><span class="line">缺点:效率低</span><br></pre></td></tr></table></figure><h4 id="关于cpu利用率"><a href="#关于cpu利用率" class="headerlink" title="关于cpu利用率"></a>关于cpu利用率</h4><p>单核cpu，某一个时刻肯定只能有一个线程在执行。但是却也能创建多线程，多线程是交替执行的，只是比较快，看着好像是同时执行的。<br>双核cpu，某一个时刻可以有两个线程在执行。单线程的就浪费了双核的能力了，另外一个核闲置了。</p><h4 id="异步与多线程的区别"><a href="#异步与多线程的区别" class="headerlink" title="异步与多线程的区别"></a>异步与多线程的区别</h4><p>异步和多线程都是处理并发任务的方式，但它们本质上是不同的。</p><p>多线程和异步编程之间的一个关键区别是，多线程涉及在一个进程内创建多个线程，而异步编程涉及以非阻塞方式执行任务。</p><p>另一个区别是，多线程需要显式地管理线程同步和通信，而异步编程可以使用编程构造（例如回调或承诺）来处理异步操作。</p><p>多线程和异步编程都可以用于实现计算机系统的并发和并行，但使用哪种取决于程序的具体要求以及底层硬件和软件基础设施。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 执行方式：多线程是并行执行任务，即多个线程同时执行任务，而异步是串行执行任务，即一个任务执行完成后再执行下一个任务。</span><br><span class="line">2. 内存使用：每个线程都有自己的栈和内存，因此多线程会占用更多的内存。而异步则可以在一个线程中共享内存。</span><br><span class="line">3. 调度机制：多线程需要操作系统提供的线程调度器来进行线程之间的切换，而异步则是通过事件循环和任务队列的机制完成任务的调度。</span><br><span class="line">4. 错误处理：多线程中一个线程抛出异常时，其他线程不受影响，但异步中一个任务出错可能会影响后续的任务执行。</span><br></pre></td></tr></table></figure><p>总的来说，多线程适用于CPU密集型的任务（如计算），而异步则适用于IO密集型的任务（如网络请求），它们都有自己的优缺点，在选择使用时需要根据具体的场景进行判断。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>谈到异步多线程了，多少就顺手讲一下并行与并发的概念，这都算是计算机相关的基础名词，多少要做一个了解。</p><p><strong>并发</strong>是一个人同时吃三个馒头（时间点是相互独立的，在一个时间点只能吃其中馒头的一口）</p><p><strong>并行</strong>是三个人同时吃三个馒头（时间是重合的，三个人可以在同一时间吃馒头）</p><h4 id="并行-parallel"><a href="#并行-parallel" class="headerlink" title="并行(parallel)"></a>并行(parallel)</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><h4 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发(concurrency)"></a>并发(concurrency)</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p>这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。</p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><h4 id="关于CPU与二者的关系"><a href="#关于CPU与二者的关系" class="headerlink" title="关于CPU与二者的关系"></a>关于CPU与二者的关系</h4><p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p><p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端的基础知识，仅做内功修炼的一条，可以涉猎了解，但是没必要深入了解。</p><p>除非，是真正纯正的技术MAN。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1iw4m1R7Xr/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">JS进程与线程全解析-前端开发-JavaScript_哔哩哔哩_bilibili</a></p><p><a href="https://juejin.cn/post/7231391129945047096">异步和多线程的区别</a></p><p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/scarificed/article/details/114645082">并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂_咋么又饿了的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS异步与同步</title>
      <link href="/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
      <url>/2024/05/13/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>模拟面试，感觉自己JS异步同步自己回答的不够精彩，重新整理下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文仅算入门浅析，如有说错的部分，还请轻喷。</p><p>在正式了解Promise之前，我们需要先了解一些基础知识。</p><p>我们知道JavaScript的单线程的，这与它的用途有关。</p><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</p><p>这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所谓”单线程”，就是指一次只能完成一件任务。</p><p>如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p><p>这种模式好处坏处都很明显。</p><p>好处是实现起来比较简单，执行环境相对单纯；</p><p>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。</p><p>常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><p>ajax的同步请求就会导致浏览器产生假死，因为它会锁定浏览器的UI（按钮，菜单，滚动条等），并阻塞所有用户的交互，jquery中的ajax有这样一个同步请求的功能，一定要慎用，尤其是在请求的数据量很大的时候，要避免使用同步请求。</p><p>举几个栗子感受一下异步</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>javascript异步<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> myData = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//ajax请求</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>(<span class="string">&#x27;https://easy-mock.com/mock/5b0525349ae34e7a89352191/example/mock&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回成功&quot;</span>);<span class="comment">// handle success</span></span></span><br><span class="line"><span class="language-javascript">            myData = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">          .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// console.log(error); // handle error</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ajax返回失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h3><p>JavaScript 单线程指的是浏览器中负责解释和执行 JavaScript 代码的只有一个线程，即为<strong>JS引擎线程</strong>，但是浏览器的渲染进程是提供多个线程的</p><ul><li>JS引擎线程</li><li>事件触发线程</li><li>定时触发器线程</li><li>异步http请求线程</li><li>GUI渲染线程</li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,应该没什么悬念</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// 定时器d</span></span><br></pre></td></tr></table></figure><p>我们看一下执行顺序</p><ol><li>console.log(myData)</li><li>定时器，将定时器挂起（就是暂停了这个定时器）</li><li>继续执行第二个 console.log(myData);</li><li>没有可以执行的js代码，回头把挂起的任务继续执行下去</li></ol><h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;(这是接口返回的数据，我们不必关心返回的具体内容，只要知道返回了就好，陌上寒注)</span></span><br></pre></td></tr></table></figure><h4 id="定时器与AJAX"><a href="#定时器与AJAX" class="headerlink" title="定时器与AJAX"></a>定时器与AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//ajax返回成功</span></span><br><span class="line"><span class="comment">//&#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">//定时器</span></span><br></pre></td></tr></table></figure><p>两个异步函数相遇了，先执行谁？谁跑的快就先执行谁？</p><p>当遇到计时器、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给 webapi，也就是浏览器提供的相应线程去处。</p><p>如定时器线程为setTimeout计时、异步http请求线程处理网络请求，而JS引擎线程继续后面的其他任务，这样便实现了 <strong>异步非阻塞</strong>。</p><p>定时器触发线程也只是为 <code>setTimeout(..., 1000)</code> 定时而已，时间一到，还会把它对应的回调函数(callback)交给 <strong>任务队列</strong> 去维护，JS引擎线程会在适当的时候去<strong>任务队列</strong>取出任务并执行。</p><p>JS引擎线程什么时候去处理呢？消息队列又是什么？</p><p>为了解决这个异步执行顺序的问题，JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制来解决这个问题。</p><h3 id="事件循环和任务队列"><a href="#事件循环和任务队列" class="headerlink" title="事件循环和任务队列"></a>事件循环和任务队列</h3><p>两个console.log(myData)是同步执行的，他们都在js的主线程上执行</p><p>在主线程之外还存在一个任务队列，任务队列中存放着需要异步执行的内容</p><p>当主线程运行完毕之后，就会去执行任务队列中的任务（不断的重复扫描）直到任务队列清空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出,这没什么可解释的</span></span><br><span class="line"><span class="comment">// 1，3，2</span></span><br></pre></td></tr></table></figure><p>再看一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出,但是后者次序依旧在上</span></span><br><span class="line"><span class="comment">// 2，1，</span></span><br></pre></td></tr></table></figure><p>console.log(2)在主线程中，先执行，</p><p>setTimeout(function(){console.log(1);}, 0)放在了任务队列中，只有在主线程执行完了才会去执行任务列队中的内容</p><p>只有主线程的任务执行完成才会执行</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>为什么主线程的任务执行完了后需要不断的扫描任务列队中的内容呢？</p><p>看这段代码，有助于你的理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myData);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点击了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// (10次输出)点击了</span></span><br><span class="line"><span class="comment">// ajax返回成功</span></span><br><span class="line"><span class="comment">// &#123;success: true, data: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="comment">// 点击了</span></span><br></pre></td></tr></table></figure><p>我们为button按钮添加了点击事件，在浏览器刷新的同时不停地对按钮进行点击操作（当然是手动点击）</p><p>这样是不是可以理解为什么主线程要去循环扫描任务列队了？</p><p>事件循环的每一轮称为一个tick（有没有联想到vue中的nextTick？）</p><p>当产生用户交互（鼠标点击事件，页面滚动事件，窗口大小变化事件等等），ajax，定时器，计时器等，会向事件循环中的任务队列添加事件，然后等待执行</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>在查找相关文档的时候，我发现有的笔者混淆了任务队列与消息队列，这两个名词虽然相近，但本质上并非是可以混为一谈的事儿，这次我们本次不做深入讨论。</p><blockquote><p>任务队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">2. 主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">3. 一但&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">4. 主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复，这种机制就被称为事件循环（event loop）机制。</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-595fdd0e4697bed589dc4b30f2c60aeb_r.jpg" alt="img"></p><p>JavaScript 通过 <strong>事件循环</strong> <strong>event loop</strong> 的机制解决了异步时间执行顺序排序的问题。</p><p><strong>事件循环</strong> 机制和 <strong>任务队列</strong> 的维护是由事件触发线程控制的。</p><p><strong>事件触发线程</strong> 同样是浏览器渲染引擎提供的，它会维护一个 <strong>任务队列</strong>。</p><p>JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等…），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 <strong>事件触发线程</strong> 将异步对应挂起的 <strong>回调函数</strong> 重新加入到任务队列中，消息队列中的回调函数等待被执行。</p><p>同时，JS引擎线程会维护一个 <strong>执行栈</strong>，同步代码会依次加入执行栈然后执行，结束会退出执行栈。</p><p>如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从任务队列取出一个任务（即异步的回调函数）放入执行栈中执行。</p><p>这里关于线程的进程的说法比较模糊，后续我会单开一文着重复述一下<code>线程</code>与<code>进程</code>。</p><h3 id="前端异步场景分析"><a href="#前端异步场景分析" class="headerlink" title="前端异步场景分析"></a>前端异步场景分析</h3><ol><li>定时任务：setTimeout,setInverval</li><li>网络请求：ajax请求，img图片的动态加载</li><li>ES6中的Promise</li><li>事件绑定或者叫DOM事件。比如一个点击事件，我不知道它什么时候点，但是在它点击之前，我该干什么还是干什么。用addEventListener注册一个类型的事件的时候，浏览器会有一个单独的模块去接收这个东西，当事件被触发的时候，浏览器的某个模块，会把相应的函数扔到任务队列中，如果现在任务列队中是空的，就会直接执行这个函数。</li></ol><h3 id="需要异步的场景分析"><a href="#需要异步的场景分析" class="headerlink" title="需要异步的场景分析"></a>需要异步的场景分析</h3><p>到底什么时候需要异步呢？这里我们稍微分析一下平时的业务场景。</p><ol><li>在可能发生等待的情况</li><li>等待过程中不能像alert一样阻塞程序的时候</li><li>因此，所有的“等待的情况”都需要异步</li></ol><p>一句话总结就是需要等待但是又不能阻塞程序的时候需要使用异步</p><h3 id="异步和并行"><a href="#异步和并行" class="headerlink" title="异步和并行"></a>异步和并行</h3><p>千万不要把异步和并行搞混了</p><p>异步：单线程的,主线程的任务以同步的方式执行完毕，才会去依次执行任务列队中的异步任务</p><p>并行：两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>主题是JS异步，话题有点歪到JS的执行顺序机制里边了，而且自己似乎还没顺明白，这里有点差了。</p><p>温故而知新，今天扫了很多文档才知道，消息队列和任务队列原来是同一回事儿，早些年就没怎么关注这些东西。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/139967525">一篇搞定（Js异步、事件循环与消息队列、微任务与宏任务）</a></p><p><a href="https://www.cnblogs.com/c3gen/p/6170504.html">关于js中的同步和异步</a></p><p><a href="http://blog.sina.com.cn/s/blog_c112a2980102xlrh.html">异步和单线程——什么时候需要异步，前端使用异步的场景</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解常用的git命令</title>
      <link href="/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/05/12/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>git命令还是在刚毕业时为了面试学的，工作时常用图形化的工具处理。</p><p>如今新入职的公司又要手敲命令，简直有种重返猿人时代的美。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git clone <url></td><td>clone远程版本库到本地</td></tr><tr><td>git init</td><td>初始化本地版本库</td></tr></tbody></table><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git diff</td><td>查看变更内容</td></tr><tr><td>git add .</td><td>添加所有改动文件到暂存区</td></tr><tr><td>git add <file></td><td>添加指定文件或目录到暂存区</td></tr><tr><td>git mv <old> <new></td><td>文件改名</td></tr><tr><td>git rm <file></td><td>删除指定文件或文件夹</td></tr><tr><td>git rm –cached <file></td><td>删除暂存区的文件追踪，不删除源文件</td></tr><tr><td>git commit -m “提交描述”</td><td>提交更新文件，并附带提交信息</td></tr><tr><td>git commit –amend -m “本次提交的描述”</td><td>将本次提交，加入到上次的提交中，并重写提交信息</td></tr></tbody></table><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/git/git-status.html">git status</a></td><td>查看状态（分支名称，与远程分支的关系，未暂存，未跟踪的文件）</td></tr><tr><td>git log</td><td>查看提交历史</td></tr><tr><td>git log -p <file></td><td>查看指定文件的提交历史</td></tr><tr><td>git blame  <file></td><td>以列表方式查看指定文件的提交历史</td></tr></tbody></table><h3 id="代码检出"><a href="#代码检出" class="headerlink" title="代码检出"></a>代码检出</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git checkout</td><td>核查工作区相对于版本库修改过的文件</td></tr><tr><td>git checkout  分支名</td><td>切换到对应的分支</td></tr><tr><td>git checkout -b 分支名</td><td>以当前分支的当前状态创建新分支并切换到新分支  -b 表示创建新分支</td></tr><tr><td>git pull <remote> <branch></td><td>将远程分支的代码拉取到本地分支</td></tr></tbody></table><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git branch</td><td>显示本地所有分支</td></tr><tr><td>git branch -r</td><td>查看本地仓库的远程分支</td></tr><tr><td>git checkout &lt;branch&#x2F;tag&gt;</td><td>切换到指定分支或标签</td></tr><tr><td>git branch <new-branch></td><td>创建新分支</td></tr><tr><td>git branch -d <branch></td><td>删除本地分支</td></tr><tr><td>git tag</td><td>显示本地所有标签</td></tr><tr><td>git tag <tagname></td><td>基于最新提交创建标签</td></tr><tr><td>git tag -d <tagname></td><td>删除标签</td></tr></tbody></table><h3 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git merge <branch></td><td>合并指定分支到当前分支</td></tr><tr><td>git rebase <branch></td><td>衍合指定分支到当前分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>git fetch <remote></td><td>从远程库获取代码</td></tr><tr><td>git pull <remote> <branch></td><td>指定的远程仓库（<code>&lt;remote&gt;</code>）拉取指定分支（<code>&lt;branch&gt;</code>）的最新更改，并尝试合并到当前分支</td></tr><tr><td>git push <remote> <branch></td><td>把当前分支的更改推送到指定的远程仓库（<code>&lt;remote&gt;</code>）的指定分支（<code>&lt;branch&gt;</code>），并快速合并</td></tr><tr><td>git push <remote>  :&lt;branch&#x2F;tag-name&gt;</td><td>删除远程分支或标签</td></tr><tr><td>git push –tags</td><td>上传所有标签</td></tr><tr><td>git remote -v</td><td>列出当前仓库中已配置的远程仓库，并显示它们的 URL</td></tr><tr><td>git remote add <remote_name> <remote_url></td><td>添加一个新的远程仓库。指定一个远程仓库的名称和 URL，将其添加到当前仓库中。</td></tr><tr><td>git remote rename <old_name> <new_name></td><td>将已配置的远程仓库重命名。</td></tr><tr><td>git remote remove <remote_name></td><td>从当前仓库中删除指定的远程仓库。</td></tr><tr><td>git remote set-url <remote_name> <new_url></td><td>修改指定远程仓库的 URL。</td></tr><tr><td>git remote show <remote_name></td><td>显示指定远程仓库的详细信息，包括 URL 和跟踪分支。</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时就先整理这么多，至于代码的冲突解决，暂时先不做了解。</p><p>毕竟，在大多数业务开发过程中，很难遇到代码冲突的情况。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7359833391192031273?searchId=20240512115740A18BB0AFCF72FB30AEA6">常用的Git命令指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解fetch</title>
      <link href="/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/"/>
      <url>/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3fetch/</url>
      
        <content type="html"><![CDATA[<p>朋友：也许面试官是问你什么是fetch呢？我：什么是fetch？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果不是刷面试题，我真的不知道有fetch这个东西。</p><h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><h4 id="基本历史"><a href="#基本历史" class="headerlink" title="基本历史"></a>基本历史</h4><p>远古时期，XMLHttpRequest对象的出现，JavaScript调用它就可以让浏览器异步地发http请求，然后这项异步技术就被称为Ajax。</p><p>之后jQuery封装了它，让异步结果更清晰的表现在一个对象的回调函数属性上，编写方式更简单，但出现了新的问题，回调地狱。</p><p>Promise为了解决异步编程的回调地狱问题诞生了。</p><p>随后有人把XHR对象用Promise封装了起来，它就是axios库(浏览器端)，axios在node.js环境是http模块的封装。</p><p>后来又出现了一个可以异步地发http请求的api，就是fetch()。</p><p>Fetch它并非是封装xhr对象的库，而是全新的JavaScript的接口。</p><p>而且Fetch的api天生就是自带Promise的，现在的Ajax就有了两种方式: XHR对象和Fetch()。</p><h4 id="Ajax，Axios，Fetch三者关系"><a href="#Ajax，Axios，Fetch三者关系" class="headerlink" title="Ajax，Axios，Fetch三者关系"></a>Ajax，Axios，Fetch三者关系</h4><ol><li>Ajax 是一种代表异步 JavaScript + XML 的模型（技术合集），所以 Fetch 也是 Ajax 的一个子集</li><li>在之前，我们常说的 Ajax 默认是指以 XHR 为核心的技术合集，而在有了 Fetch 之后，Ajax 不再单单指 XHR 了，我们将以 XHR 为核心的 Ajax 技术称作<strong>传统 Ajax</strong>。</li><li>Axios 属于传统 Ajax（XHR）的子集，因为它是基于 XHR 进行的封装。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代AJAX包含XHR和Fetch两种类型的常见接口请求方式，AJAX和AXIOS都是基于XHR做的封装。</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象</p><p>基本用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询参数直接通过 ?、&amp; 拼接</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err))</span><br></pre></td></tr></table></figure><p><code>fetch()</code>接收到的<code>response</code>是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Stream 对象</a>，<code>response.json()</code>是一个<strong>异步操作</strong>，取出所有内容，并将其转为 JSON 对象</p><p>使用 await 语法改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;http://example.com/movies.json&#x27;</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求</p><ul><li><code>fetch(url, options)</code></li><li>post、put、patch 用法类似</li><li>HTTP 请求的方法、标头、数据体都在<code>options</code>这个对象里面设置</li></ul><p>下面是一些示例：</p><p><strong>（1）POST 请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br></pre></td></tr></table></figure><blockquote><p>此处的<code>body</code>指的是POST 请求的数据体</p></blockquote><p><strong>（2）提交 JSON 数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user =  &#123; <span class="attr">name</span>:  <span class="string">&#x27;John&#x27;</span>, <span class="attr">surname</span>:  <span class="string">&#x27;Smith&#x27;</span>  &#125;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type`的默认值是`&#x27;text/plain;charset=UTF-8&#x27;</span><br></pre></td></tr></table></figure></blockquote><p><strong>（3）提交表单</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>（5）直接上传二进制数据</strong></p><p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> canvasElem.<span class="title function_">toBlob</span>(resolve,  <span class="string">&#x27;image/png&#x27;</span>))</span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/image&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:  <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: blob</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="完整配置项"><a href="#完整配置项" class="headerlink" title="完整配置项"></a>完整配置项</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="comment">// 指定请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定请求体数据</span></span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="comment">// 指定 fetch() 请求的 referer 标头</span></span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 Referer 标头的规则</span></span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定请求的模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>, </span><br><span class="line">  <span class="comment">// 指定是否发送 Cookie</span></span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定如何处理缓存</span></span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定 HTTP 跳转的处理方法</span></span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="comment">// 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值</span></span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据</span></span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 指定一个 AbortSignal 实例，用于取消fetch()请求</span></span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于官网对于部分配置项没有中文翻译，以下列出全部配置项具体值及其说明</p><p><code>cache</code>：指定如何处理缓存，可能的取值如下：</p><blockquote><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误</li></ul></blockquote><p><code>mode</code>：指定请求的模式，可能的取值如下：</p><blockquote><ul><li><code>cors</code>：默认值，允许跨域请求</li><li><code>same-origin</code>：只允许同源请求</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求</li></ul></blockquote><p><code>credentials</code>：指定是否发送 Cookie，可能的取值如下：</p><blockquote><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送</li><li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie</li><li><code>omit</code>：一律不发送</li></ul></blockquote><p><code>redirect</code>：指定 HTTP 跳转的处理方法，可能的取值如下：</p><blockquote><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转</li></ul></blockquote><p><code>referrerPolicy</code>：用于设定<code>Referer</code>标头的规则，可能的取值如下：</p><blockquote><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名</li><li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头</li></ul></blockquote><h3 id="取消Fetch请求"><a href="#取消Fetch请求" class="headerlink" title="取消Fetch请求"></a>取消Fetch请求</h3><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象，流程如下：</p><ul><li>创建<code>AbortController</code>实例</li><li>配置对象的<code>signal</code>属性指定接收<code>AbortController</code>实例发送的信号<code>controller.signal</code></li><li>使用<code>controller.abort()</code>方法发出取消信号</li><li>发出取消信号后，会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>()</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: signal</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>))</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>()<span class="comment">// 取消fetch请求</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p><code>fetch()</code>请求成功以后，得到的是一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Response">Response 对象</a>。它对应服务器的 HTTP 响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br></pre></td></tr></table></figure><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>Response 实例属性如下表：</p><table><thead><tr><th>属性</th><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><strong>ok</strong></td><td>布尔值</td><td>表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码</td></tr><tr><td><strong>status</strong></td><td>数字</td><td>表示 HTTP 回应的状态码（如：200，表示成功请求）</td></tr><tr><td><strong>statusText</strong></td><td>字符串</td><td>表示 HTTP 回应的状态信息（如：请求成功以后，服务器返回”OK”）</td></tr><tr><td><strong>url</strong></td><td>请求的 URL</td><td>如果 URL 存在跳转，该属性返回的是最终 URL</td></tr><tr><td><strong>type</strong></td><td>请求的类型</td><td><code>basic</code>：普通请求，即同源请求  <code>cors</code>：跨域请求  <code>error</code>：网络错误，主要用于 Service Worker  <code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值。表示发出的是简单的跨域请求 <code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值</td></tr><tr><td><strong>redirected</strong></td><td>布尔值</td><td>表示请求是否发生过跳转</td></tr><tr><td><strong>body</strong></td><td>ReadableStream 对象</td><td>暴露响应体内容</td></tr><tr><td><strong>headers</strong></td><td>与响应关联的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">Headers</a>对象</td><td>通过访问与响应关联的 Headers 对象，来操作 HTTP 响应头</td></tr></tbody></table><p><code>fetch()</code>发出请求以后，<strong>只有网络错误，或者无法连接时</strong>，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。这意味着服务器返回的状态码是<code>4xx</code>或<code>5xx</code>时，不会报错（Promise 不会变为 <code>rejected</code>状态）</p><p>以下两种方法可以判断是否发生错误：</p><ul><li>通过<code>status</code>属性，得到 HTTP 回应的真实状态码，判断请求是否成功</li><li>判断<code>ok</code>属性是否为<code>true</code></li></ul><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>()</span><br><span class="line">  <span class="keyword">if</span> (done) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块，其中：</p><ul><li><code>done</code>属性是一个布尔值，用来判断有没有读完</li><li><code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容</li><li><code>value.length</code>属性是当前块的大小</li></ul><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers 对象</a>，对应 HTTP 回应的所有标头</p><p>Headers 对象提供了以下方法，用来操作标头：</p><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加</li><li><code>Headers.append()</code>：添加标头</li><li><code>Headers.delete()</code>：删除标头</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数</li></ul><blockquote><p>方法具体用法请参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Headers">developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;…</a></p></blockquote><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法</p><ul><li><code>response.text()</code>：得到文本字符串</li><li><code>response.json()</code>：得到 JSON 对象</li><li><code>response.blob()</code>：得到二进制 Blob 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取图片文件flower.jpg，显示在网页上</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">myImage.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob)</span><br></pre></td></tr></table></figure><ul><li><code>response.formData()</code>：得到 FormData 表单对象</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>Stream 对象只能读取一次，这意味着，前五个读取方法，只能使用一个，否则会报错。Response 对象提供了克隆方法</p><ul><li><code>response.clone()</code>：创建<code>Response</code>对象的副本，实现多次读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flowers.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> response2 = response1.<span class="title function_">clone</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBlob1 = <span class="keyword">await</span> response1.<span class="title function_">blob</span>()</span><br><span class="line"><span class="keyword">const</span> myBlob2 = <span class="keyword">await</span> response2.<span class="title function_">blob</span>()</span><br><span class="line"><span class="comment">// 将同一张图片读取了两次</span></span><br><span class="line">image1.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob1)</span><br><span class="line">image2.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob2)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>fetch这种方法虽然才了解，但是感觉好像还行，看了很多文章介绍，感觉在文件读取这里似乎有不错的应用。</p><p>但是说到底，这终归不是工作中常用的，连面试题问到的似乎都很少，如果不是这里刷到，似乎都没什么人讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-30">一文熟悉Ajax</a></p><p><a href="https://juejin.cn/post/6997784981816737800">有同学问我：Fetch 和 Ajax 有什么区别？ - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解axios</title>
      <link href="/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/"/>
      <url>/2024/05/09/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3axios/</url>
      
        <content type="html"><![CDATA[<p>承接昨天的日志，问到ajax，怎么可能不问axios呢。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这虽然是一次模拟面试，但当模拟真的开始的时候，我开始汗流浃背了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面试官：能详细说说axios吗？</span><br><span class="line"></span><br><span class="line">我：项目中常用的一个工具库，封装接口请求的工具方法。</span><br><span class="line"></span><br><span class="line">面试官：很高兴面试您，如果后续有结果了，我们会通知您的。</span><br></pre></td></tr></table></figure><p>虽然知道今年很卷，但是比想象中要卷的多。</p><blockquote><p>本节为 Axios 常规使用，更多方法请看<a href="https://link.juejin.cn/?target=https://www.kancloud.cn/yunye/axios/234845/">Axios中文文档</a>、<a href="https://link.juejin.cn/?target=https://www.axios-http.cn/docs/intro">Axios中文文档(官方)</a>、开源API库：<a href="https://link.juejin.cn/?target=https://www.bootcdn.cn/index.html">BootCDN</a></p></blockquote><h3 id="Axios概念"><a href="#Axios概念" class="headerlink" title="Axios概念"></a>Axios概念</h3><p>Axios 是一个基于 promise 的网络请求库，作用于 node.js 和浏览器中，它是 isomorphic 的 (即同一套代码可以运行在浏览器和 node.js 中)。</p><p>在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequest</p><ul><li><strong>Axios 本质上是对原生 XMLHttpRequest 的封装</strong>，只不过它是 Promise 的实现版本，符合最新的 ES6 规范</li></ul><blockquote><p>Promise教程请参考：<a href="https://juejin.cn/post/7321996765977198611">juejin.cn&#x2F;post&#x2F;732199…</a></p></blockquote><p>主要特点：</p><ul><li>从浏览器创建 XMLHttpRequests、从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>超时处理</li><li>自动将请求体序列化</li><li>自动转换 JSON 数据</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>使用 npm</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ul><li>使用 CDN</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>可以向 <code>axios</code> 传递相关配置来创建请求</p><ul><li><code>axios(config)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起一个get请求, 参数名和值会自动拼接到url</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起一个post请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>常用请求方法：</p><table><thead><tr><th>请求方法</th><th>操作</th></tr></thead><tbody><tr><td>GET</td><td>获取数据</td></tr><tr><td>POST</td><td>提交数据</td></tr><tr><td>PUT</td><td>修改数据（全部）</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>PATCH</td><td>修改数据（部分）</td></tr></tbody></table><p>为方便起见，为所有支持的请求方法提供了别名：</p><p>无 data 属性：</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[, config])</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.options(url[, config])</code></li></ul><p>有 data 属性：</p><ul><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config]])</code></li><li><code>axios.postForm(url[, data[, config]])</code></li><li><code>axios.putForm(url[, data[, config]])</code></li><li><code>axios.patchForm(url[, data[, config]])</code></li></ul><blockquote><p>别名中的data属性无需显式给出，只需传入一个对象即可</p></blockquote><p>下面是使用方法别名的示例：</p><ul><li>GET 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// data属性直接为一个对象, 无需显式给出</span></span><br><span class="line"><span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>,</span><br><span class="line">    <span class="attr">orders</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="attr">photo</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#fileInput&#x27;</span>).<span class="property">files</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>Axios 支持以 fetch API 方式—— <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a> 取消请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/foo/bar&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">controller.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure><h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><p>以下是创建请求时可以用的配置选项只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>GET</code> 方法</p><blockquote><p>配置源于官网，已将常用配置移到最前</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// baseURL 自动加在url前，除非url是一个绝对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// params 是与请求一起发送的 URL 参数, 与 get 方法搭配使用</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data 是作为请求体被发送的数据 (PUT、POST、DELETE、PATCH)</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属: Stream, Buffer</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定请求超时的毫秒数, 超时则请求会被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 默认值是 0 (永不超时)</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// responseType 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// auth 示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 Authorization ，覆写掉现有的任意使用 headers 置的自定义 Authorization </span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span></span><br><span class="line">  <span class="comment">// 你可以修改请求头。</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件 (浏览器专属)</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span></span><br><span class="line">  <span class="attr">maxBodyLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// 默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span></span><br><span class="line">  <span class="comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span></span><br><span class="line">  <span class="comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span></span><br><span class="line">  <span class="comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span></span><br><span class="line">  <span class="comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">protocol</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// see https://axios-http.com/zh/docs/cancellation</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed </span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  <span class="attr">decompress</span>: <span class="literal">true</span> <span class="comment">// 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>一个请求的响应包含以下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 服务器响应头, 所有的 header 名称都是小写, 而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: response.headers[&#x27;content-type&#x27;]</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// axios 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Axios默认配置"><a href="#Axios默认配置" class="headerlink" title="Axios默认配置"></a>Axios默认配置</h3><p>常规开源项目中的常见封装方式。</p><h4 id="全局默认配置"><a href="#全局默认配置" class="headerlink" title="全局默认配置"></a>全局默认配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="自定义实例"><a href="#自定义实例" class="headerlink" title="自定义实例"></a>自定义实例</h4><p>可以使用自定义配置新建一个实例：<code>axios.create([config])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例时配置默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例后修改默认值</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span></span><br></pre></td></tr></table></figure><h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p>配置将会按优先级进行合并</p><ul><li>优先级：<a href="https://link.juejin.cn/?target=https://github.com/axios/axios/blob/master/lib/defaults.js%23L28">lib&#x2F;defaults.js</a>默认值 &lt; 实例 <code>defaults</code> 属性 &lt; 请求 <code>config</code> 参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 使用库提供的默认配置创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 0</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写库的超时默认值 </span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写此请求的超时时间，因为该请求需要很长时间</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拦截器完整使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 创建一个单独的axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://xxx.xxx.xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">6000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">user</span>?.<span class="property">token</span>) &#123;</span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">authorization</span> = <span class="string">`Bearer <span class="subst">$&#123;store.user?.token&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="comment">// 数据脱壳、业务成功、业务失败、401 token失效的处理</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面判断用户请求的业务成功</span></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">data</span>?.<span class="property">code</span> === <span class="number">10000</span>) &#123;</span><br><span class="line">      <span class="comment">// 数据脱壳</span></span><br><span class="line">      <span class="keyword">return</span> res.<span class="property">data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 业务失败, 提示错误</span></span><br><span class="line">      <span class="title function_">showToast</span>(res.<span class="property">data</span>?.<span class="property">message</span> || <span class="string">&#x27;请求失败&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下面这里的函数是请求失败，http状态码是 4xx 5xx</span></span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">response</span>?.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理401错误</span></span><br><span class="line">      <span class="keyword">const</span> store = <span class="title function_">userStore</span>()</span><br><span class="line">      store.<span class="title function_">delUser</span>()</span><br><span class="line">      router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><p>如果需要移除拦截器，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor)</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>面向面试开发的感觉，这些东西平日用的太顺手，整理出来甚至也不算细究，只是调用别人的工具方法。</p><p>但是在面试时候问出来，真是有一种。。。。无趣的感觉。</p><p>累了，这次单纯是为了面试整理了一下知识点，后续大概不会持续关注这种工具方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817#heading-17">一文熟悉Ajax</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解ajax</title>
      <link href="/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/"/>
      <url>/2024/05/08/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3ajax/</url>
      
        <content type="html"><![CDATA[<p>面试官：ajax是什么？我：啥？这不是JQuery封装的工具方法吗？</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，模拟面试那时候，什么刁钻的问题几乎都接触过，用这种远古问题拷打我，真是。。。绝了。</p><p>我还没答上来，真是，绝妙。</p><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX 代表异步的 JavaScript 和 XML（<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML）。</p><p>简单点说，就是使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象与服务器通信。它可以使用 JSON、XML (Extensible Markup Language)、HTML 和文本文件等格式发送和接收数据</p><p>AJAX 最吸引人的就是它的<code>异步</code>特性，也就是说它可以在<strong>不重新刷新页面</strong>的情况下与服务器通信、交换数据或更新页面</p><p>整个流程很简单，如下</p><ol><li>创建一个XMLHttpRequest对象，发送异步请求HttpRequest</li><li>服务器通过网络，接收HttpRequest请求，返回请求数据</li><li>浏览器通过网络，接收服务器返回的数据，用JS操作DOM更新页面</li></ol><p>为避免混淆，这里重新梳理一下 Ajax 概念：</p><ol><li>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</li><li>AJAX <strong>不是编程语言</strong>，而是一种基于现有标准的新方法</li><li>AJAX 最大的优点是在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并更新部分网页内容</li><li>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。</li><li><strong>XMLHttpRequest 只是实现 Ajax 的一种方式</strong></li></ol><p><strong>总的来说，AJAX是浏览器与服务器进行数据通信的技术</strong></p><h3 id="AJAX实现"><a href="#AJAX实现" class="headerlink" title="AJAX实现"></a>AJAX实现</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL (Uniform Resource Locator) 统一资源定位符（统一资源定位器、定位地址、URL地址）俗称地址，是因特网上标准的资源的地址，如同在网络上的门牌，用于访问网络上的资源</p><p>URL组成：URL 由<strong>协议</strong>、<strong>域名</strong>、<strong>资源路径</strong>组成</p><ul><li>协议：URL 使用 http 协议（超文本传输协议），规定浏览器与服务器之间传输数据的格式</li><li>域名：标记服务器在互联网中的方位</li><li>资源路径：标记资源在浏览器下的具体位置</li></ul><p>比如，我们这里架假设要去访问百度网站上的一份文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com/test/helloworld.txt</span><br></pre></td></tr></table></figure><p>这里我们将上述url拆分一下，结果如下</p><table><thead><tr><th>访问协议</th><th>服务器名称：域名</th><th>目录名</th><th>文件名</th></tr></thead><tbody><tr><td>http:</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td><td>test</td><td>helloworld.txt</td></tr></tbody></table><p>域名这里如果细说，还要提到IP和端口，这里暂时先跳过，下期再说。</p><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><h5 id="XHR概念"><a href="#XHR概念" class="headerlink" title="XHR概念"></a>XHR概念</h5><p><code>XMLHttpRequest</code>（XHR）对象<strong>用于与服务器交互</strong>。</p><p>通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL 来获取数据。</p><p>这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p><p><code>XMLHttpRequest</code> 在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX">AJAX</a> 编程中被大量使用，所有现代浏览器均支持 XMLHttpRequest 对象</p><p><code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML，它甚至支持 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:&#x2F;&#x2F; 和 FTP），尽管可能受到更多出于安全等原因的限制</p><h5 id="XHR使用"><a href="#XHR使用" class="headerlink" title="XHR使用"></a>XHR使用</h5><p>实现 <code>Ajax</code>异步交互需要完成以下步骤：</p><ul><li>创建 <code>XMLHttpRequest</code> 对象</li><li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li><li>构建请求所需的数据内容，并通过<code> XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li><li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>readystatechange、loadend</code> 事件监听服务器端的通信状态</li><li>接受并处理服务端向客户端响应的数据结果</li><li>将处理结果更新到 <code>HTML</code>页面中</li></ul><h5 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h5><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法</p><p><strong>open()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务器建立连接</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>method</td><td>表示当前的请求方式，常见的有 <em>GET</em>、<em>POST</em></td></tr><tr><td>url</td><td>服务端地址</td></tr><tr><td>async</td><td>布尔值，表示是否异步执行操作，默认为 <em>true</em>(异步)</td></tr><tr><td>user</td><td>可选的用户名用于认证用途；默认为 <em>null</em></td></tr><tr><td>password</td><td>可选的密码用于认证用途，默认为 <em>null</em></td></tr></tbody></table></li></ul><p><strong>send()</strong></p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p></li><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body为 XHR 请求中要发送的数据体(string)，如果不传递数据则为 null</span></span><br><span class="line">xhr.<span class="title function_">send</span>([body])</span><br></pre></td></tr></table></figure></li></ul><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p><p>每当 readyState 改变时（存有 XMLHttpRequest 状态信息）就会触发 readystatechange 事件</p><p>以下是 XMLHttpRequest 对象的三个重要的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</td></tr><tr><td>readyState</td><td>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200：”OK”，404：未找到页面</td></tr></tbody></table><blockquote><p>readystatechange 事件被触发四次，分别是：0-1、1-2、2-3、3-4，对应着 readyState 的每个变化</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　<span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span> ) &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">　　  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>获取 XMLHttpRequest 响应体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readBody</span>(<span class="params">xhr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!xhr.<span class="property">responseType</span> || xhr.<span class="property">responseType</span> === <span class="string">&quot;text&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseText</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">responseType</span> === <span class="string">&quot;document&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">responseXML</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xhr.<span class="property">response</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XHR使用示例"><a href="#XHR使用示例" class="headerlink" title="XHR使用示例"></a>XHR使用示例</h5><ul><li>GET 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://xxxx.com/xxx/xxx?参数名1=值1&amp;参数名2=值2&#x27;</span>) </span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><ul><li>POST 请求</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POST请求，要设置请求头，请求体携带JSON字符串</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://xxx/api/register&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;readystatechange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理服务器的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><h3 id="相关概念拓展"><a href="#相关概念拓展" class="headerlink" title="相关概念拓展"></a>相关概念拓展</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>但在以下情况中，请使用 POST 请求：</p><ul><li>不愿使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><p>常见 GET 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/try/ajax/demo.php?fname=Henry&amp;lname=Ford&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><p>常见 POST 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo.php&quot;</span>,<span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>POST 方式发送数据，需要设置请求头，并且使用<code>send</code>方法传递参数</p></blockquote><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><code>Content-Type</code>是 HTTP 头部字段之一，用于指示请求或响应消息的媒体类型</p><p>以下是常见的<code>Content-Type</code>格式：</p><ul><li><code>application/json</code>：用于传输 JSON 格式的数据</li><li><code>application/xml</code>：用于传输 XML 格式的数据</li><li><code>text/plain</code>：纯文本格式，通常用于普通文本文件</li><li><code>text/html</code>：用于传输 HTML 格式的数据</li><li><code>image/jpeg, image/png, image/gif</code>：用于传输图像数据</li><li><code>multipart/form-data</code>：通常用于上传文件，表单数据会被编码成一系列的部分</li><li><code>application/x-www-form-urlencoded</code>：通常用于发送表单数据，数据会被编码为键值对的形式（表单默认的提交数据的格式）</li></ul><p>在 HTTP 协议中，如果未明确指定 <code>Content-Type</code> 头部字段，默认值取决于请求或响应的具体情况：</p><ul><li><strong>对于请求（Request）</strong><ul><li>对于常见的表单提交，即 <code>application/x-www-form-urlencoded</code></li><li>对于通过表单上传文件的情况，即 <code>multipart/form-data</code></li></ul></li><li><strong>对于响应（Response）</strong><ul><li>如果服务器响应包含实际的数据，而不仅仅是一条状态码和头部字段，则常见的默认值为 <code>application/octet-stream</code>，表示二进制流，没有指定具体的数据类型</li></ul></li></ul><p>HTTP 协议规范允许在请求和响应中都不设置 <code>Content-Type</code> 头部字段。</p><p>在这种情况下，接收方可能需要根据上下文来猜测数据的类型，这可能引入一些不确定性。</p><p>推荐在请求和响应中显式地设置 <code>Content-Type</code> 头部字段</p><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>Ajax 操作往往用来传递表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单，特别适用于发送包含文件上传等复杂数据的请求</p><p>使用 FormData 可以执行以下步骤：</p><ul><li>创建一个 FormData 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br></pre></td></tr></table></figure><ul><li>向 FormData 对象中添加字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>添加文件类型的字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件输入框中获取选中的文件, 可以根据实际情况选择获取文件的方式</span></span><br><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>)</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>将 FormData 对象作为请求的 body 或附加到 XMLHttpRequest 或 fetch 等发送请求的方法中：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/api/endpoint&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(formData)</span><br></pre></td></tr></table></figure><p>以上就将 FormData 数据作为请求的一部分发送给服务器端了</p><p>注意事项：</p><ul><li>当使用 FormData 时，浏览器会自动设置适当的 <code>Content-Type</code> 头部，无需手动设置</li><li>FormData 也支持删除字段和追加相同字段名的多个值等操作，请根据需求使用相应的方法</li></ul><blockquote><p>FormData 对象其他方法参考官网：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">MDN-FormData</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说实话，早年就以为这东西是jquery封装的，结果上次模拟面试被狠狠拷打了一波。</p><p>虽然这种远古问题不应该算是关注范围以内的东西了，但是有备无患，这里记录一下。</p><p>2024年了，我居然又翻到ajax了，真是。。绝了。</p><p>这两天把ajax，axios，fetch相关的请求方式全整理一遍，不然面试还真有点发憷。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7340295754245111817?searchId=2024050820515495FC5659A1B7863EB72F">一文熟悉Ajax</a></p><p><a href="https://developer.mozilla.org/zh-CN/">MDN-CN</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决github提交代码端口报错的问题</title>
      <link href="/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/07/%E8%A7%A3%E5%86%B3github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AB%AF%E5%8F%A3%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>癞蛤蟆趴脚上，不咬人膈应人，这事能出问题，国内这个网络环境全责，这狗屎一样的网络环境真是一言难尽。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天写完博客，提交代码的时候正好遇到这个问题了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><p>这里简单翻译一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh:连接到主机github.com端口22:连接超时</span><br></pre></td></tr></table></figure><p>常规的做法无非就是挂加速器或一些梯子，但是好巧不巧，今天梯子到期了。</p><p>于是只能连夜翻CSDN，结果屎里淘金找了半个小时也没有几个靠谱的解法，好在掘金论坛翻到了一个不错的解决方案。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>出现这个问题，很可能是你的网络供应商（比如广电网）在出口防火墙上屏蔽了22端口（本地使用vpn等代理服务），这意味着你将无法访问其他主机的22端口。</p><p>github提供了一种解决方案，允许你使用<strong>443端口进行ssh连接</strong>。</p><p>因为443端口是访问<strong>https网站</strong>所必须的，大部分防火墙都会允许通过，但如果使用<strong>代理服务器</strong>可能产生干扰。</p><h3 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h3><p>我这里使用gitbash命令行工具，不推荐使用powershell和cmd，因为win的权限和创建文件的命令太难背。</p><p>这里我的电脑是win11，默认大家存放的公钥的文件都在ssh文件夹下。</p><p>首先，我们切换到ssh文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>然后，若是没有文件config，我们这里新建一个config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure><p>config文件需要手动添加如下内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port <span class="number">443</span></span><br><span class="line"><span class="keyword">User</span> git</span><br></pre></td></tr></table></figure><p>之后，继续在gitbash中，写入如下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>命令行在这里会提示你确定是不是要这么做，你选yes就行。</p><p>因为这是为了让每次ssh连接github都通过443端口，指明ssh连接<code>git@github.com</code>或<code>git@ssh.github.com</code>走443端口</p><p>最后，重新执行，检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果命令行中有success等字样，那就代表修改成功了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这虽然是个简单的修改方式，但是没想到国内传统的技术论坛就没几个靠谱的解法。</p><p>为了防止下一次再次翻车，这里必须得写一下了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7325627349080424457?searchId=20240507230033784D20BC75A8A6B6BB11">解决git push提交超时问题ssh: Connection timed out</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解6种接口请求的方式</title>
      <link href="/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/05/07/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A36%E7%A7%8D%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>模拟面试题，今天刷到了，我除了知道传参方式略有不同之外，什么也回答不上来。</p><p>干了这么多年的前端，不知道这个，说实话，有点汗颜。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作。</p><h3 id="六种方式"><a href="#六种方式" class="headerlink" title="六种方式"></a>六种方式</h3><ol><li>Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）</li><li>Post 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改</li><li>Put 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）</li><li>Delete 请求服务器删除request-URL所标示的资源（请求服务器删除页面）</li><li>Head 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的响应中没有具体内容，用于获取报头）</li><li>opions 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许客户端查看服务器性能）</li></ol><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET一般用于获取&#x2F;查询资源信息。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>post向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改。</p><p>post请求一般通过body传递参数。</p><p>包括一些文件上传什么的，常用这种请求类型。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>这个方法比较少见,HTML表单也不支持这个，常见的工作任务中，多数后端都更远已使用post来取代put。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><p>就是说，put是更在更新服务器上已经存在的数据。</p><p>举个例子：如一个用于提交博文的URL，&#x2F;addBlog。如果用PUT，则提交的URL会是像这样的”&#x2F;addBlog&#x2F;abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。</p><p>目前大部分博客都是这样的，显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除某一个资源。</p><p>因为目前大多数公司业务删除都是伪删除，所以这种类型的请求很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。</p><p>有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。</p><p>若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一度以为接口常见的请求方式就四种，如果不是今天刷面试题，还真不清楚这个冷知识，也是颇为长见识了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6899465311712935949?from=search-suggest">接口请求的六种常见方式详解（get、post、head等）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年生活规划</title>
      <link href="/2024/04/28/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/"/>
      <url>/2024/04/28/2024%E5%B9%B4%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>完成2023年没搞定的任务，并继续人生新目标。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>2023年规定的事，只完成了一半，有点尴尬。</p><p>不过，好在也是折腾出来打了一些东西，所以不算太过尴尬，这里继续去年的计划，开始新一轮的新年计划。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>前几年工作的积蓄算是被清的差不多了，又赶上市场暴死，幸亏还有点技术底子，不然现在真是不知道做什么好。</p><p>如今找到了一份勉强糊口的清闲工作，于是打算趁这段时间好好规划，这是30之前的最后一年了，如果规划好，35之前的卖身日子应该还是有救的。</p><ol><li><strong>简单掌握nodejs，并简单写两个项目作为自己可以展示的私人项目来做护城河。</strong></li><li><strong>简单掌握JAVA，完成一个像样的后台管理系统</strong></li><li><strong>维护自己的开源工具cat-tools，完成去年未做完的事情</strong></li></ol><h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>去年减重太过反复，虽然中间削低谷时期削弱到了90KG级左右，但是之后因为冬季，运动量骤减，最终体重快速反弹。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><strong>本年目标恢复75KG级体重</strong></li><li>作息稳态化，不要像去年那样容易被打乱</li><li>身体内分泌常规化，尽量摆脱药物，将高血压高血脂控制再常规水平之下</li><li>调理腰椎和皮肤</li></ol><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ol><li><strong>严格控制摄入量，每天不要摄入大量碳水，每月最多一餐油炸类食物。</strong></li><li><strong>控制饮料，减少碳酸类等饮料的摄入</strong></li><li><strong>作息从轮班换成常规作息，晚上11点之前能不依赖药物睡着</strong></li><li><strong>能够进行5公里快速长途骑行，时速能拉到18左右最好</strong></li><li>能够进行<strong>简单的游泳</strong>（冬季）</li><li>经常进行腰椎和皮肤的调理，并长期使用工学椅</li></ol><h3 id="学历"><a href="#学历" class="headerlink" title="学历"></a>学历</h3><p>由于去年各种糟心事太多，自考这点除了去年一开始还在正轨，后来完全脱轨，生活的种种琐事硬是冲断了自己的计划。</p><p>因为种种缘故，原定的八门课程，去年拢共就考了一门，真是太过操蛋。</p><p>而今年也因为找工作的缘故，4月份的自考也没能花时间去准备，一切真是糟糕。</p><p>今年如果再次被打断，我就不考虑走大自考路线了，直接放弃证道，选择最low的成人高考模式，毕竟这些东西本质上就是弄个证书。</p><ol><li><strong>高数，原定的计划</strong></li><li><strong>离散数学，相对较为简单一门</strong></li><li><strong>数据结构，工作中要接触的科目</strong></li><li><strong>计算机网络原理，工作中必然要接触的科目</strong></li></ol><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>去年接触了nas之后，知识体系走的有点偏，今年为了工作，重新矫正一下知识体系。</p><ol><li><strong>补全前端的更底层知识体系，有时候还真是架不住面试官问的太深层。</strong></li><li><strong>较为纯熟的掌握nodejs，自主开发一套小型的类博客平台</strong></li><li>今年主要掌握视频直播的相关技术</li><li>次要掌握地图相关的技术</li><li>考虑掌握网络安全相关的技术</li><li>考虑掌握无人机飞行证书（视工作情况而定）</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong>写一本小说，先存稿60万字，将去年想到的一些思路进行整合</strong>，10月份过后，试试水。</li><li>在身体恢复正常后，尝试相亲或者恋爱，太久没和女人接触了，感觉人有点不正常</li><li>每月拜一拜关二爷。</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>读一些已经读过的书，以如今的心境，会有一些不一样的感觉。</p><ol><li>《南明史》</li><li>《三体》</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>去年规划的太过满了，再加上平日琐事太多，规划的任务大部分未能完成（尴尬，吹牛吹爆了）。</p><p>但是，至少留下了一些可供参考的路径，今年努把力，把去年没做完的地方补全，尤其是身体和学历这方面。</p><p>希望今年一切顺利。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 年计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年的第一份offer</title>
      <link href="/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/"/>
      <url>/2024/04/26/2024%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BDoffer/</url>
      
        <content type="html"><![CDATA[<p>终于找到工作了，但只是暂时安全了，种种巧合让我有种无力的宿命感，我不信命，但是不得不承认世事的无常。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>不得不说，相对于整个前端的技术栈来说，我这点水平，属实有点鸭子睁眼，大可不必了。</p><p>找了这么久，什么样的技术栈都见过了，但是头一回遇到把我手里的技术栈近乎清零的公司了。</p><p>我会的是vue全家桶，这家公司的招人要求，除了是vue全家桶之外，别的几乎和我没什么交集，简直他妈的离谱。</p><p>我从来不注重性能，全面专注业务领域的，所以深层代码实现了解的较浅，但他们问的还都挺深，看上去和我有点犯冲。</p><p>不过，这几天面试下来，我也习惯从拷打面试官变成被拷打的一方了。</p><p>前端现在太广了，谁都不敢说自己事事精通。</p><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><p>在正式接面试的时候，看公司规模，0-20人，以为又是一家垃圾小公司，结果到地方一看就被镇住了。</p><p>妈的，是正儿八经的玩无人机的，而且型号还挺多，看着不像是胡闹的。</p><p>不仅有各式各样的无人机，开发人员也很年轻，很有年轻人的朝气，和我这种时代中浪迹的老油条完全是两个画风，不的不感叹，年轻真好。</p><p>现在想来，开在闹市区的CBD里边，注册资金1000万的级别，稍微想了一下，这感觉怎么也不像是普通公司，能在徐州招人用vue3+ts的公司，想来也是一朵奇葩（褒义）。</p><p>毕竟，我都在徐州面试使用jquery的岗位了（丢人的是还没面过），那我还能说什么呢。</p><p>跑了数家公司，见识了各种光怪陆离的情况，现在这家公司的情况，反而算是正常甚至有些优秀的画风了。</p><p>不得不说，我的认知滤镜第一时间给出了错误的判断，在到了现场之后，就表面看上去，这家公司看着确实是挺有实力的。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>这次基本上是我被拷打了。</p><p>说实话，我vue的底层原理除了早些年为了跳槽准备的时候仔细准备过，现在几乎都很难捡起来了。</p><p>然后传统的网络原理及网络安全这块，我几乎就没戏唱了，因为我只能说浅层次的涉猎，但是深入的问我的话，我几乎都不能准确而全面的回答上来。以前都是做的TOB或者TOG的项目，谁有胆子去入侵别人内网搞事情？</p><p>网络安全这块的认知，我几乎就是憨憨，我连SQL注入的手法都玩不明白。</p><p>你不能指望一个平时连放置个人网站都用傻瓜教程的家伙去深层次探秘。</p><p>之后是视频直播这块，我这里就更尴尬了，我对视频直播的了解，仅限于nas相关的那些东西，上传带宽+硬解码暴打一切不服，别的几乎没有任何方案了，就这么个认知，我也没法回答上来啥。</p><p>然后是地图，早些年确实基于百度开发的vueAmap做过一些浅层的标识放置，现在告诉我，他们这里觉得地图麻烦，打算自己整地图引擎。</p><p>嘶。。。。</p><p>一种油然而生的不妙感。</p><p>业务，是我不熟悉的领域，以前的业务经验基本上就算是打了折扣了。</p><p>技术，视频直播，地图开发，网站安全，这三相之力几乎全部都是软肋，任何其中一项技能都是一个肉眼可见的天坑。</p><p>这次的面试，基本上是我单方面被暴打。</p><p>不过，好在也算是快人快语，事情当场就给了结果，我周日就可以先去试岗，先试一周看看。</p><p>虽然面试被拷打，然后感觉上自己可能撑不过试岗，但是无人机真的很酷炫，能靠过去凑凑热闹也不错。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>如果未来能顺利通过试用期，入职的话，倒是会深入考虑深入看看视频相关的技术手段，网络安全这块应该也会考虑一下，至于3D这块，不太敢考虑。</p><p>毕竟，那玩意是出了名的投入大，回报少，我如今青春的时间不是很多了，不是很乐意去研究相关的技术。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新公司虽然给的薪资不算太多，但是总算是有点意思了，确实比长久不变的业务线有趣的多，就是不知道自己能不能扛下来。</p><p>本来都打算脱下长衫去送外卖了，但是偏偏命运垂青，给了一点点足够转机，我愿意试试看。</p><p>如果不成，那我大概率是真不适合这行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解重绘和重排(回流)</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92-%E5%9B%9E%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>这是上海某次面试中的问题，说实话，我这个VueBoy还真不清楚这块的基础，这里整合一下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文主要面向面试，所以先挑干的说，然后再细讲原理。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="重排或回流（Reflow）"><a href="#重排或回流（Reflow）" class="headerlink" title="重排或回流（Reflow）"></a>重排或回流（Reflow）</h4><p>当render树中的一部分或者全部因为大小边距等问题发生改变而<strong>需要DOM树重新计算</strong>的过程</p><h5 id="产生重排的场景"><a href="#产生重排的场景" class="headerlink" title="产生重排的场景"></a>产生重排的场景</h5><ul><li>页面渲染初始化，这是开销最大的一次重排</li><li>添加或者删除可见的DOM元素</li><li>元素位置改变</li><li>元素尺寸改变，边距、填充、边框、宽度和高度</li><li>元素内容改变，如文本改变或者图片大小改变而引起的计算值宽度和高度改变</li><li>元素字体大小 改变</li><li>浏览器窗口尺寸改变，resize事件发生时</li><li>CSS伪类激活，如hover</li><li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li><li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者IE里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li></ul><h5 id="重排影响的范围"><a href="#重排影响的范围" class="headerlink" title="重排影响的范围"></a>重排影响的范围</h5><p>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点html开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。</p><p><strong>局部范围重排：</strong></p><p>用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。</p><h4 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a>重绘（Repaint）</h4><p>元素的一部分属性发生改变，如外观、背景、颜色等<code>不会引起布局变化</code>，只需要浏览器根据元素的新属性<strong>重新绘制</strong>，使元素呈现新的外观叫做重绘。</p><h5 id="产生重绘的场景"><a href="#产生重绘的场景" class="headerlink" title="产生重绘的场景"></a>产生重绘的场景</h5><ul><li><code>设置背景图片</code></li><li><code>修改字体颜色及样式</code></li><li><code>改变 visibility 属性值</code></li><li><code>设置box盒子阴影</code></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="页面生成"><a href="#页面生成" class="headerlink" title="页面生成"></a>页面生成</h4><ol><li>HTML 被 HTML 解析器解析成 DOM 树</li><li>CSS  被 CSS 解析器解析成 CSSOM 树</li><li>结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment</li><li>生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点</li><li>将布局绘制(paint)在屏幕上，显示出整个页面</li></ol><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p><h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><p>重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p><h4 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h4><p>我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。</p><ul><li>尽可能在低层级的DOM节点上，而不是像上述全局范围的示例代码一样，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</li></ul><h4 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h4><h5 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h5><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如IE6的效率依然低下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">left</span> = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当top和left的值是动态计算而成时...</span></span><br><span class="line"><span class="comment">// better </span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">cssText</span> += <span class="string">&quot;; left: &quot;</span> + left + <span class="string">&quot;px; top: &quot;</span> + top + <span class="string">&quot;px;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">el.<span class="property">className</span> += <span class="string">&quot; className&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h5><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = div.<span class="property">offsetTop</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = div.<span class="property">offsetRight</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = div.<span class="property">offsetBottom</span> + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.<span class="property">offsetLeft</span>;</span><br><span class="line"><span class="keyword">var</span> curTop = div.<span class="property">offsetTop</span>;</span><br><span class="line"><span class="keyword">var</span> curRight = div.<span class="property">offsetRight</span>;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.<span class="property">offsetBottom</span>;</span><br><span class="line"></span><br><span class="line">div.<span class="property">style</span>.<span class="property">left</span> = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">top</span> = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">right</span> = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">bottom</span> = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p><blockquote><p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p></blockquote><h5 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h5><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p><ul><li><p>使用 display:none</p><p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p></li><li><p>通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</p></li><li><p>复制节点，在副本上工作，然后替换它！</p></li></ul><h5 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h5><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p><h5 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h5><ul><li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。</p><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是Layout就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多</p></li><li><p>启用GPU加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</p><p><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 根据上面的结论</span></span><br><span class="line"><span class="comment">  * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment">  * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment">  * 提高动画性能</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  div &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate3d</span>(10px, 10px, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在浏览器中查看页面渲染时间"><a href="#在浏览器中查看页面渲染时间" class="headerlink" title="在浏览器中查看页面渲染时间"></a>在浏览器中查看页面渲染时间</h3><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。</p><ul><li>loading: 网络通信和HTML解析</li><li>scripting: JavaScript执行</li><li>Rendering: 样式计算和布局，即重排</li><li>Painting: 重绘</li></ul><p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。</p><p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p><p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</p><p>CSS3 就是在 GPU 发生的：Transform  Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>太久远的知识了，回顾了一下大佬的总结，感觉真是一种难得的有趣体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904083212468238?searchId=20240422171513D3B4751FC9432336560C">重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6938376882005999646?searchId=20240422171235DF23177183B7AA3806A2#heading-1">CSS 重绘（Repaint）、重排（回流）(reflow) - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解http常用状态码</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>工作中不常用，而面试题常考。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1XX（临时响应）"><a href="#1XX（临时响应）" class="headerlink" title="1XX（临时响应）"></a>1XX（临时响应）</h3><ul><li>100 <code>Continue </code>继续。客户端应继续其请求</li><li>101  <code>Switching Protocols </code>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul><hr><h3 id="2XX（成功）"><a href="#2XX（成功）" class="headerlink" title="2XX（成功）"></a>2XX（成功）</h3><ul><li>200 <code>OK</code> 请求成功。一般用于<code> GET</code> 与 <code>POST</code> 请求</li><li>201 <code>Created</code> 已创建。成功请求并创建了新的资源</li><li>202 <code>Accepted</code> 已接受。已经接受请求，但未处理完成</li><li>203 <code>Non-Authoritative Information</code> 非授权信息。请求成功。但返回的 <code>meta </code>信息不在原始的服务器，而是一个副本</li><li>204 <code>No Content </code>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 <code>Reset Content </code>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 <code>Partial Content </code>部分内容。服务器成功处理了部分 <code>GET</code> 请求</li></ul><hr><h3 id="3XX（重定向）"><a href="#3XX（重定向）" class="headerlink" title="3XX（重定向）"></a>3XX（重定向）</h3><ul><li>300 <code>Multiple Choices </code>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 <code>Moved Permanently</code> 永久移动。请求的资源已被永久的移动到新 <code>URI</code>，返回信息会包括新的 <code>URI</code>，浏览器会自动定向到新 <code>URI</code>。今后任何新的请求都应使用新的<code>URI</code>代替</li><li>302 <code>Found </code>临时移动。与 <code>301 </code>类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 <code>See Other</code> 查看其它地址。与<code> 301</code> 类似。使用 <code>GET</code> 和<code>POST</code>请求查看</li><li>304 <code>Not Modified</code> 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>305 <code>Use Proxy</code> 使用代理。所请求的资源必须通过代理访问</li><li>306 <code>Unused </code>已经被废弃的<code> HTTP</code> 状态码</li><li>307 <code>Temporary Redirect</code> 临时重定向。与 <code>302</code> 类似。使用 <code>GET </code>请求重定向</li></ul><hr><h3 id="4XX（请求错误）"><a href="#4XX（请求错误）" class="headerlink" title="4XX（请求错误）"></a>4XX（请求错误）</h3><ul><li>400 <code>Bad Request</code> 客户端请求的语法错误，服务器无法理解</li><li>401 <code>Unauthorized</code> 请求要求用户的身份认证</li><li>402 <code>Payment Required </code>保留，将来使用</li><li>403 <code>Forbidden</code> 服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404 <code>Not Found </code>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>405 <code>Method Not Allowed</code> 客户端请求中的方法被禁止</li><li>406 <code>Not Acceptable</code> 服务器无法根据客户端请求的内容特性完成请求</li><li>407 <code>Proxy Authentication Required</code> 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权</li><li>408 <code>Request Time-out</code> 服务器等待客户端发送的请求时间过长，超时</li><li>409 <code>Conflict</code> 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</li><li>410 <code>Gone </code>客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</li><li>411 <code>Length Required</code> 服务器无法处理客户端发送的不带<code> Content-Length</code> 的请求信息</li><li>412 <code>Precondition Failed</code> 客户端请求信息的先决条件错误</li><li>413 <code>Request Entity Too Large</code> 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个<code> Retry-After</code> 的响应信息</li><li>414 <code>Request-URI Too Large </code>请求的 <code>URI</code> 过长（<code>URI</code> 通常为网址），服务器无法处理</li><li>415 <code>Unsupported Media Type</code> 服务器无法处理请求附带的媒体格式</li><li>416 <code>Requested range not satisfiable</code> 客户端请求的范围无效</li><li>417 <code>Expectation Failed</code> 服务器无法满足<code>Expect </code>的请求头信息</li><li>429  <code>Too Many Requests</code> 请勿频繁操作</li></ul><hr><h3 id="5XX（服务器错误）"><a href="#5XX（服务器错误）" class="headerlink" title="5XX（服务器错误）"></a>5XX（服务器错误）</h3><ul><li>500 <code>Internal Server Error</code> 服务器内部错误，无法完成请求</li><li>501 <code>Not Implemented </code>服务器不支持请求的功能，无法完成请求</li><li>502 <code>Bad Gateway</code> 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 <code>Service Unavailable</code> 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 <code>Retry-After </code>头信息中</li><li>504 <code>Gateway Time-out </code>充当网关或代理的服务器，未及时从远端服务器获取请求</li><li>505 <code>HTTP Version not supported</code> 服务器不支持请求的 <code>HTTP </code>协议的版本，无法完成处理</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>基本上属于面试题不考的类型，但是经常会遇到，所以这里整理一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7030428038953173029?searchId=202404221657433AF2988FD33492318F90">一篇梳理http返回的状态码 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解http与https的区别</title>
      <link href="/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/04/22/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>http与https的区别是什么，今天看到群里有回答是复数的，一时间有点没绷住。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>早些年做个人网站，简单了解了相关知识，但是不够深入，这里整理一下。</p><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><h4 id="HTTP-定义"><a href="#HTTP-定义" class="headerlink" title="HTTP 定义"></a>HTTP 定义</h4><p>超文本传输协议（HTTP）是万维网使用的底层协议，它规定了消息如何被格式化和传输，以及网络服务器和浏览器应当如何回应各种命令。</p><h4 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h4><p>通常，HTTP的工作流程如下：</p><ol><li><strong>发起请求</strong>：在浏览器中输入URL或点击链接后，浏览器向对应的服务器发起资源请求。</li><li><strong>服务器响应</strong>：服务器处理接受到的请求并返回资源和HTTP头。</li><li><strong>建立连接</strong>：在HTTP老版本中，每次请求需要建立一个新的连接，造成了延迟。为了解决这个问题，在新的版本中提出了持久连接。</li><li><strong>资源渲染</strong>：浏览器接收到资源后开始解析并展示。</li></ol><h4 id="HTTP-的局限性"><a href="#HTTP-的局限性" class="headerlink" title="HTTP 的局限性"></a>HTTP 的局限性</h4><p>HTTP在状态无关、安全性、性能、数据传输大小等方面存在局限性。</p><h3 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h3><h4 id="了解-HTTPS"><a href="#了解-HTTPS" class="headerlink" title="了解 HTTPS"></a>了解 HTTPS</h4><p>安全超文本传输协议（HTTPS），即HTTP的安全版本，使用类似TLS或SSL的加密协议，加固客户端和服务器之间的连接。</p><h4 id="HTTPS-与-HTTP-的对比"><a href="#HTTPS-与-HTTP-的对比" class="headerlink" title="HTTPS 与 HTTP 的对比"></a>HTTPS 与 HTTP 的对比</h4><p>与HTTP以明文传送数据不同，HTTPS通过加密保护传输的数据，确保通讯过程的安全与数据在传递过程中不被篡改。</p><h4 id="HTTP-与-HTTPS-的六大不同"><a href="#HTTP-与-HTTPS-的六大不同" class="headerlink" title="HTTP 与 HTTPS 的六大不同"></a>HTTP 与 HTTPS 的六大不同</h4><ol><li>加密：HTTPS对数据进行加密，确保沟通的保密性。</li><li>数据完整性：HTTPS检验数据传输中未被修改。</li><li>身份验证：通过SSL证书，HTTPS可以验证服务器身份，防中间人攻击。</li><li>安全水平：与HTTP相比，HTTPS提供了更高的安全性。</li><li>端口定义：HTTPS默认使用443端口，而HTTP使用80端口。</li><li>URL模式：HTTPS的URL以 <code>https://</code> 开头，而HTTP则是 <code>http://</code>。</li></ol><table><thead><tr><th>特性</th><th>http</th><th>https</th></tr></thead><tbody><tr><td>加密</td><td>无</td><td>使用TLS&#x2F;SSL协议加密数据包</td></tr><tr><td>安全性</td><td>不安全，数据以铭文形式传输，容易被第三方截取和查看</td><td>安全，使用TLS&#x2F;SSL协议加密的数据包，防止拦截和篡改</td></tr><tr><td>证书</td><td>无</td><td>需要SSL证书，由可信任的证书办法机构（CA）颁发，用于验证服务器的身份</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>url标识</td><td>http:&#x2F;&#x2F;开头</td><td>https:&#x2F;&#x2F;开头</td></tr><tr><td>性能</td><td>通常较高</td><td>可能略低，犹豫加密解密带来的一些 计算开销，但随着技术进步，差异会逐渐缩小</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>连续翻看了几个介绍，发觉都差不多，这里就选了一篇最清楚的文档做了个整合。</p><p>当初弄个人网站的时候，简单了解了这二者的区别，并不深入，如今梳理之后，倒也颇为明晰，也算是小有收获了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7329772404645806099?searchId=2024042215523434CA7F568FA739283956">理解 Web 安全：HTTP 和 HTTPS 的关键区别 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解URL到页面加载的过程</title>
      <link href="/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/04/21/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>好早之前的面试题，最近猛的一问，居然答不上来了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>在页面加载到最终渲染显示大致是这样的：</p><ol><li>用户在浏览器输入URL回车后，浏览器为了将URL解析成IP地址，会向DNS服务器发起DNS查询，获取IP地址。</li><li>在建立连接后，浏览器就可以发起HTTP请求，而服务器接受请求后进行响应，浏览器从响应结果中拿到数据，并进行解析和渲染，</li><li>最后在用户面前就出现了一个网页。</li></ol><p>简而言之就是三个阶段：</p><ul><li>客户端发起请求阶段</li><li>服务端数据处理请求阶段</li><li>客户端页面渲染阶段</li></ul><p>如果想起</p><ol><li>缓存解析地址，判断是否</li><li>DNS解析，（输入的是域名）</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回需要的数据</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>输入了一个域名,域名要通过DNS解析找到这个域名对应的服务器地址(ip),通过TCP请求链接服务,通过WEB服务器(apache)返回数据,浏览器根据返回数据构建DOM树,通过css渲染引擎及js解析引擎将页面渲染出来,关闭<a href="https://www.zhihu.com/search?q=tcp%E8%BF%9E%E6%8E%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2603050043%7D">tcp连接</a></p><h3 id="正常分析"><a href="#正常分析" class="headerlink" title="正常分析"></a>正常分析</h3><h4 id="首先在浏览器中输入URL-，缓存解析"><a href="#首先在浏览器中输入URL-，缓存解析" class="headerlink" title="首先在浏览器中输入URL ，缓存解析"></a>首先在浏览器中输入URL ，缓存解析</h4><p>浏览器先在缓存里找资源，浏览器缓存-系统缓存-路由缓存（如CDN缓存）中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><p>浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</p><h5 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h5><p>如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</p><h5 id="路由器缓存"><a href="#路由器缓存" class="headerlink" title="路由器缓存"></a>路由器缓存</h5><p>如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</p><h5 id="ISP（互联网提供服务商）缓存"><a href="#ISP（互联网提供服务商）缓存" class="headerlink" title="ISP（互联网提供服务商）缓存"></a>ISP（互联网提供服务商）缓存</h5><p>若上述均失败，继续向ISP搜索。</p><h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><p>浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。</p><p>DNS服务器是基于UDP的，因此会用到UDP协议。</p><ul><li>DNS(Domain Name System, 域名系统)，是域名和IP地址相互映射的一个分布式数据库</li><li>DNS 解析就是从域名映射到IP地址的过程</li><li>如果有些网站已经访问过了，下次访问时浏览器会依次从浏览器缓存、系统缓存、路由器缓存、ISP缓存、根域名服务器、顶级域名服务器、主域名服务器里面找IP地址，所以下次访问速度更快</li></ul><h4 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h4><p>解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。</p><h5 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a><strong>三次握手过程</strong></h5><p>建立tcp连接就是三次握手，三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号</p><p>第一次，客户端&#x3D;&gt;服务端 客户端向服务器端发送SYN&#x3D;1,代表请求建立连接；还发送seq&#x3D;n是客户端的序列号。</p><p>第二次，服务端&#x3D;&gt;客户端，服务端表名收到请求，发给客户端SYN&#x3D;1,代表同意建立连接，ack&#x3D;n+1，返回客户端序列号加1，代表确认收到信息，同时发送一个自己的序列号，seq&#x3D;x代表服务端序列号。</p><p> 第三次，客户端&#x3D;&gt;服务端 客户端发送SYN&#x3D;0表明开始发送信息，并返回ack &#x3D; x+1确认收到服务端序列号，并发送seq &#x3D; n+1</p><h4 id="发起HTTP请求"><a href="#发起HTTP请求" class="headerlink" title="发起HTTP请求"></a>发起HTTP请求</h4><p>浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器</p><h4 id="服务器响应请求并返回结果"><a href="#服务器响应请求并返回结果" class="headerlink" title="服务器响应请求并返回结果"></a>服务器响应请求并返回结果</h4><p>服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p><h5 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h5><p>通过四次挥手释放TCP连接； 前两次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道。</p><h5 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a><strong>四次挥手过程</strong></h5><p>​    客户端向服务器发送FIN控制报文段（首部中的 FIN 比特被置位）；</p><p>​    服务端收到FIN，回复ACK。服务器进入关闭等待状态，发送FIN;</p><p>​    客户端收到FIN，给服务器回复ACK，客户端进入等待状态（进入“等待”，以确保服务器收到ACK真正关闭连接）;</p><p>​    服务端收到ACK，链接关闭。</p><p><strong>四次挥手原因</strong></p><p> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p><p>TCP是全双工模式，这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；</p><p>但是，这个时候客户端还是可以接受来自服务端的数据；</p><p>当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；</p><p>当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><p>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</p><p> 构建CSS规则树：生成CSS规则树（CSS Rule Tree）</p><p> 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</p><p> 布局（Layout）：计算出每个节点在屏幕中的位置</p><p> 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</p><h5 id="浏览器渲染详细过程"><a href="#浏览器渲染详细过程" class="headerlink" title="浏览器渲染详细过程"></a>浏览器渲染详细过程</h5><p><strong>浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。</strong></p><p>最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，这个内部结构就是 DOM，DOM 提供了对 HTML 文档的结构化表述。渲染进程通过分词器将html字节流成功成一个个 token，包括 Tag token 和文本 token。HTML 解析器维护了一个 token 栈结构，token 会按照对应顺序入栈出栈，然后将 token 解析成 DOM 节点，并将 DOM 节点添加进 DOM 树中。</p><p><strong>异步下载资源文件</strong></p><p>解析过程中，如果遇到&lt; link href &#x3D;＂..＂＞和&lt; script src &#x3D;＂..＂＞这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p><p><strong>渲染样式</strong></p><p>渲染引擎在接受到 CSS 文本时，会将 CSS 生成 CSS对象模型CSSOM(即CSS Object Model) ，通过document.styleSheets可获取所有CSS样式表，然后将 styleSheet 中的属性值进行标准化操作。最后将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 进行渲染。</p><p>最后，渲染过程中，如果遇到＜ script ＞就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待＜ script ＞内容执行完之后，浏览器继续渲染。</p><p>—— <strong>为何要将 CSS 放在 HTML 头部？</strong> —— </p><p>这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM ，然后在解析 HTML 之后可一次性生成最终的RenderTree ，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。</p><p>—— <strong>为何要将 JS 放在 HTML 底部？</strong> —— </p><p>JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外， JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行， JS 放在底部执行时， HTML 肯定都解析成了 DOM 结构。 </p><p>JS 如果放在 HTML 顶部， JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p><h5 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h5><p>调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><h6 id="创建window对象"><a href="#创建window对象" class="headerlink" title="创建window对象"></a>创建window对象</h6><p>window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</p><h6 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h6><p>完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</p><h6 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h6><p>在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</p><h6 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h6><p>执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个基础知识我能回答，但是细节我答不上太多，稍微显得有点丢人。</p><p>当初面试时候都记得，如今居然都记不得了。</p><p>现在趁着梳理知识体系时候，好好学习一下。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7154306280868282381?searchId=20240421211440950468993CA81FC881AA">从输入URL到页面加载的全过程 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年第一次被骗</title>
      <link href="/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/"/>
      <url>/2024/04/20/2024%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<p>这次好歹是没什么损失，问题不大，只是有种恶心的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>经过上次被骗的事，对于这类问题，我已经非常敏感了。</p><p>感觉自己化身烙印战士了，在最糟糕的时候，被骗子群体标记了，一旦我有所松懈，就会被这些小鬼缠上，真是麻烦。</p><p>妈的，等以后有钱了，一定要想办法干死这帮搞诈骗的。</p><p>终归是修行不够，贪了，想要个工作的贪欲占了上分，要是不贪，就不会有这么多屁事。</p><p>另外，2024了，连骗子都能对前端面试题说道说道，我真是麻了。</p><p>前端已死真不是随便说说啊。</p><h3 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h3><h4 id="陌生人"><a href="#陌生人" class="headerlink" title="陌生人"></a>陌生人</h4><p>昨夜凌晨3-4点，接到一个QQ添加的好友，说是同行，看到我简历不错，想和我私聊。</p><p>昨天夜里是周五，技术下班，第二天有休息，所以有技术人熬夜，这事儿常见。</p><p>稍稍思考一下，我没多想就同意了。</p><p>正好最近找工作找的火大尿黄，于是就先问了这个陌生人的几个前端面试题，没毛病，都能答上来，应该是同行，看样子问题不大。</p><p>毕竟最近面试机会不多，难得有个线上懂行的模拟面试，这怎么想就是一个好事儿。</p><p>现在想想，这个过程真是处处透着诡异，单纯就是自己纯纯上头了。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>首先是发了我一个面试题库软件呢。</p><p>这个我也知道，就是灵题库嘛，类似这种面试题集合的软件工具，我是不排斥的，我个人也喜欢用软件刷前端面试题。</p><p>但是，一直登录不上去，挺烦的，然后他给了我一串账号，说用自己的账号试试。</p><p>顺利登录了，之后点不开，不得已就转QQ视频，说是直接面试。</p><p>这里我还是排斥，如果不是工作找不到，我是真不考虑这些破事。</p><p>然后这时候又谈了一下最近的工作情况，他说自己是湖南人，然后在上海工作，然后和这个陌生人相谈甚欢，这里我放松戒备了。</p><p>然后，他说软件不好用，干脆他就模拟面试，不过需要开视频。</p><p>开视频这点是我很排斥的，毕竟半夜，开视频总有种不对劲的感觉，陌生人突然开视频怎么想都感觉不对劲啊。</p><p>可我真是太想进步了，难得的面试机会，就算是模拟面试我也想把握一下。</p><p>想了好一会儿，还是同意视频模拟面试。</p><h4 id="模拟面试"><a href="#模拟面试" class="headerlink" title="模拟面试"></a>模拟面试</h4><p>然后我就和他开了视频，对方是个男生，这更没什么不妥了，不是女人就意味着视频怎么也不会伪造，这让我还挺开心的。</p><p>简单的自我介绍和技术问答之后，三分钟左右，他说他要上厕所，先关闭视频。</p><p>然后差不多十多分钟后，劲爆的就来了。</p><p>这畜生拉老子进了一个小群，里面就我和他，然后发了我的裸照和裸聊视频，这还没完，通讯录和周围熟人的联系方式全给我盒出来了，包括我的个人身份信息。</p><p>这一手直接把我干懵了。</p><p>妈的，裸聊你好歹给我看个女人啊，我连女人都没看到，怎么就裸聊了，操你妈的！</p><p>但我毕竟是被骗过一次的人了，这套路我可太熟了。</p><p>提钱，免谈。</p><p>而且我属于社会独立的边缘人，你要发我裸照，我只会说，这图里边的不够大，麻烦P的大一点。</p><p>主要是，他妈个逼，我他妈的根本没裸聊过，居然就整了一套视频加图片，真行。</p><p>然后就是电话威胁+发彩信威胁，勒索说要八千。</p><p>他妈的，笑死人了，我怕你这个？</p><p>下次记得给我换个肥一点的，我现在的身体比之前更垃圾，照片上的人还是瘦了，不像我，还有，他下边太小了。</p><p>总之，接下来就是互喷，然后我当场报警，存了他的QQ。</p><p>本来还想存下来那个换脸视频研究下的，QQ把视频给拦截了，然后我自己都下不下来。</p><p>还有图，类似的情况。</p><p>再之后，我又骂了几句，本来还打算等一波电话轰炸来着，之后就没信了，骗子QQ注销了。</p><h3 id="技术思路"><a href="#技术思路" class="headerlink" title="技术思路"></a>技术思路</h3><p>虽然这事儿很恶心，但稍微盘点一下思路，倒也不是不可以理解。</p><p>这里不盘他的话术，单纯盘点一下他的技术手段。</p><ol><li>我的QQ应该是最近海投简历泄露出去的，因为简历中，我的邮箱就是常用的QQ邮箱，而且我已近海投了简历，对方猜出来我最近是在找工作的人，所以抓住了我的求职心理，妈的，信息裸奔是真烦。</li><li>面试软件是木马工具，猜测应该是先用超量授权的应用读取用户的通讯录，不然对方应该是盒不到我手里那么多信息的。</li><li>其次，视频换源应该是用克隆语音加AI换脸搞定的，我模拟面试时候穿着衣服，但是对面让我看一下全身装，之后发给我的视频里边，封面上我是没有穿衣服的，虽然没点开视频，但是估计是全裸了。猜测这里用了类似的AI脱衣手法，这个我自己也玩过。</li><li>最后，批量给亲友发彩信，目前没有朋友电话我，猜测应该是没发，这太怪了，群发彩信应该是成本不贵的，猜测应该是时间成本不值当，寻找下一个怨种了。</li></ol><h3 id="事情结果"><a href="#事情结果" class="headerlink" title="事情结果"></a>事情结果</h3><ol><li>报警，但是没正式立案，因为警察也比较同情我，说这要是立案，用人单位一查，有这事儿就难受了，干脆就别立案。</li><li>无事发生，没啥亲友找我，估计彩信没发出去，要么就是被当做骚扰电话拦截了，不过，那个辣眼睛的裸照，我自己都想戳瞎自己的双眼，妈的，造裸照就能造好看点吗。</li><li>骗子QQ主动注销，那家伙的QQ空间还蛮正常的，一个太阳号就这么被注销了，真可惜。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>估计自己已经在骗子那边挂号了，从第一次信息泄露之后，我就像是剑风传奇中，被蚀刻的鹰之团战士，就算逃了第一次估计后续也是一辈子被挂号了。</p><p>他妈的，联想早年的事儿，真是感觉缘分到了。</p><p>最近找工作太忙，没时间收拾这帮家伙。</p><p>妈的，后续我要有钱了，我先想办法干死这帮畜生。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年前端求职经历</title>
      <link href="/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/"/>
      <url>/2024/04/14/2024%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%B1%82%E8%81%8C%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>大劫将至，前端已死。</p><p>我们都是技术上的妓女，当青春的肉体不再，年老之时，我们将不再有任何价值。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在正式开始说话前，先将我个人的暴论放在前边。</p><p>如果还是现在这个行情，两年内，前端和后端都会有一场近乎踩踏式的失业潮。</p><p>前端已死，2023的小型裁员潮只是第一年，2024的内卷求职潮才是真正的开始。</p><p>以往火烧到了应届生身上，现在火烧到了应届本科生和三到五年的大专生身上，未来不好说。</p><p>当然，重本那群怪物不在考虑范围之内，如果连他们工作都不好找，那只有一种可能，世界大战的火烧到本土了。</p><p>2024，不仅仅是前端，是所有的互联网职业 ，都要为自己的过去的高收入付账了。</p><h3 id="招聘软件"><a href="#招聘软件" class="headerlink" title="招聘软件"></a>招聘软件</h3><p><strong>推荐使用BOSS直聘</strong>，也只有boss直聘反馈快点，其他的几个软件都是一坨屎。</p><p>智联等于失联，拉钩连个像样的发贴请求都没有，猎聘和51根本不是程序员用的。</p><p>如果没有内推，推荐使用BOSS直聘求职。</p><h3 id="求职经历"><a href="#求职经历" class="headerlink" title="求职经历"></a>求职经历</h3><p>在2024的4月里，本着金三银四的求职时间，我这个臭带专毕业的，选择在四月份来赶一下这个晚集。</p><p>然后，我就发现今年的就业环境不是一般的冷，我的项目履历如果放在一年前，出去也算是暴打一批人，但是今年的就业环只让我感觉到一阵心凉。</p><p>我之前的工作地点大约都在苏州，所以，本来想在苏州继续找份工作，但今年到了苏州之后才发现，这里的就业环境几乎是大专绝地。</p><p>从4月8号开始正式，我大约面试了8家左右，这里林林总总包括一些线上面试。</p><p><strong>我的项目履历不差。</strong></p><p>三到五年的工作经验，项目履历涉及到低代码，bpmnJS流程图，涉及过OA系统，小程序，大型资产管理系统，数据大屏+地图可视化，做过npm的包，带过团队，在项目现场救过火。</p><p>这些我都写到简历里边，但这么多东西，没有换到任何一家苏州的面试邀约。</p><p><strong>大专，在这个时候是犯天条了。</strong></p><p>当初，没能花时间完成自考真是可惜，不过当初一直在加班，根本没时间，而现在的空窗期只有一年，一年时间，就算我再怎么努力，恐怕也没办法把剩余的十二门考试全弄考完，因为一年只能报八门。</p><p>学历就算上去了也没用，要求里边全是统招本科，后续提升上去的，大概率没戏。</p><p>此时，苏州大部分工作，待遇依然没有下降，但是招聘要求抬了好几个档次，简历过不了人事那关，就只能上其他城市了。</p><p>扫了一眼，上海还行。</p><p>虽然上海房租贵，物价高，外地人被歧视的严重，交通恶心，而且疫情期间那种封闭到现在让我感觉到畏惧，我有个同事真的在上海被关在房里饿了一天。</p><p>但，人要过日子的。</p><p>不得已，只能将目光转到上海，去魔窟卖身了，好在上海没给大专上天条，至少我还能看到有很多家招收大专的，3-5年，正经的态度。</p><p>然后，在一周的时间里，我看到BOSS直聘的招聘要求，逐渐从1-3年，转到3-5年，最后从大专升到本科，然后工资压到实习生的水准。</p><p>麻了，今年的就业环境真是彻底凉透了。</p><h3 id="招聘要求"><a href="#招聘要求" class="headerlink" title="招聘要求"></a>招聘要求</h3><p>投了大概500多家，环江苏找了一圈工作之后，最后只能停留在上海附近。</p><p>苏州这种新一线城市，要求提的虽然高，但是技术栈挺新潮，工作待遇大多较好，大环境虽然烂，但是待遇这块没的说。</p><p>上海那边超一线城市，要求相对不高，而且技术栈较新，待遇参差，上下差距极大，但至少有的选。</p><p>其他地方大多垃圾，要么技术栈直接拉胯到爆炸，要么薪资待遇就是在养黑奴，综合下来，找了半天，整个江苏居然只有苏州和上海勉强能看。</p><p>所有公司的招聘意向，我大致梳理了一下，有如下几个套路，我个人按照心里的综合评分，从高到底逐次介绍。</p><ol><li>优中选优的正常向纯前端，要求本科学历，3-5年工作经验，项目履历丰富，能加班，有大厂项目经历最好，在上海薪资11k-15k（考虑到3000左右的房租，这个薪资勉强算是能活，毕竟3-5年不年轻了，再有两年，可能就做不了事情了，这个工资水平是最后的晚餐）</li><li>全干工程师，要求大专及以上，3-5年工作经验，前端要掌握一门后端语言，后端要掌握一门前端框架，能加班，在上海薪资15K-20K（看着正常，但这种全干工程师，绝对是要一个人干两个人的事情，而且项目管理大多不正规，各种死线周期瞎改需求是常有的事，在这种地方做久了，会折寿）</li><li>设计型前端，，但是倾向于设计，自带审美（这话的意思是你要做设计的活），工资水平大约12k-15k左右。（这种工资水平虽然低了一些，但只要稍微懂点设计应该能糊弄，但一个没有设计的公司，大概率还在蛮荒时期，这个技术栈难以想象，平庸但是安稳。）</li><li>短期外包型，要求大专起步，1-3年或3-5年，纯前端或者纯后端都可以，但是要你签短期合同，而且承诺无偿加班，待遇有些偏黑奴，不过。（外包，在技术行业里基本上和黑奴没差别，在外边做技术支持的时候，甚至不能喝那些人饮水机里边的水，如果要形容的话，和黑奴比，唯一的优势大概就是至少有一定的人权，不是纯纯的农具）</li><li>纯农具型外包，学历大专起步，1-3年工作经验，纯前端，有的要求短期不结账，等项目完成后再结账，有的要求在上海月薪约莫2-4K（妈了个逼的，2-4k这种连吃饭的钱都够呛，上海一碗牛肉面就得18，他妈的莫不是让人不吃牛肉？能开出这种要求，我只能说没钱你装你妈比的boss，资本家是那么好当的？）</li></ol><p>以上五种，大致是我这边整理出来的所有需求，仅供参考。</p><h3 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h3><p>时隔这么多年，再次拿起这些八股文，我只感觉一股悲凉。</p><p>毕业的时候，背面试题，被卡本科学历，然后低价招到公司。</p><p>干了快五年了，我还在背面试题，被卡本科学历，然后又会被低价招到了公司。</p><p>工作经验，属于屁用没有了，反而因为年轻的肉体已经不在，因为年龄大而遭到了就业的歧视。</p><p>重新看了很多，VUE的常规问题，es6的基础，promise的部分内容，computed和watch监听的实现，https和http，TCP和UDP，url输入之后发生什么之类的基础八股文看了一堆。</p><p>有用，也有些感悟，但是感觉心凉。</p><p>他奶奶的，这种问题平日谁看啊？业务上一堆逼事不做，来看这个？</p><p>好在，面试官大多给了我这个求职者最后的尊严，简单问了一些小的技术点之后，他们露怯了，不敢细问，因为我的回答可能比他们手里的答案要深，如果要是胡搅蛮缠的让我去写算法，写二叉树，手写promise，那我只能说，太悲凉了。</p><p>之后，他们没有问那些假大空的八股文，反而问了我很多技术实现的细节，我讲了项目怎么优化翻新，怎么重构项目中不合理的地方，团队前端工具的统一管理，前公司的业务流程和技术实现。</p><p>我没有特地去记这些事情，只是随便讲了些许之前的内容，可只是一开口，我就停不下来了，每次讲到这些，我好像又回到了那些时候。</p><p>每当我讲到这些项目经历时，我居然有种怀念青春的可笑感。</p><p>他妈的，我真是贱人啊。</p><p>高三天天熬夜，因为小高考残废考不上本科，我认了。</p><p>工作后天天加班熬夜，把身体搞垮，调养一年重新就业之后，我再次竞争失利，因为我是大专，哈哈哈哈，他妈了个逼的。</p><p>我认了，大专，就是犯了天条的罪人。</p><p>现在想来，我非常讨厌高三，但是却非常怀念加班的日子。</p><p>这两个于我而言同样都是苦日子，但我却更怀念那段加班的日子，不是因为我贱，而是我上班之后，终于能挣钱了，钱给了我尊严。</p><p>我并不怀念青春，我只是渴求金钱，我不想再忍受贫穷的苦楚。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不买房，不结婚，不疯魔，老老实实等着，挣够了钱，我就给自己赎身回家。</p><p>这个时代，是最好的时代，也是最烂的时代。</p><p>在这个喧闹的时代里，技术人就像是十里洋场的舞女，将自己那不值一提的年轻肉体和精神化作洋场之上的霓虹灯，他们的血汗和尊严点缀了这个疯狂的时代，让这个时代有了病态的繁荣。</p><p>但是，宴会终有散会时，今年的失业潮终于要击碎这摇摇欲坠的黄粱一梦了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2生命周期</title>
      <link href="/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2024/03/28/vue2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>工作时候用的特别熟悉的内容，如今竟然有一种生疏的感觉。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>重新整理一下，免得面试时候露怯。</p><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><p><strong>定义：组件从 创建 到 销毁 的整个过程就是生命周期</strong></p><p><strong>作用：特定的时间点，执行特定的操作</strong></p><p><strong>场景：组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据</strong></p><p><strong>分类: 4大阶段8个方法</strong></p><ul><li>初始化</li><li>挂载</li><li>更新</li><li>销毁</li></ul><table><thead><tr><th><strong>钩子函数</strong></th><th><strong>触发的行为</strong></th><th><strong>在此阶段可以做的事情</strong></th></tr></thead><tbody><tr><td>beforeCreadted</td><td>vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。</td><td>加loading事件</td></tr><tr><td>created</td><td>vue实例的数据对象data有了，$el还没有</td><td>结束loading、请求数据为mounted渲染做准备</td></tr><tr><td>beforeMount</td><td>vue实例的$el和data都初始化了，但还是虚拟的dom节点，具体的data.filter还未替换。</td><td></td></tr><tr><td>mounted</td><td>vue实例挂载完成，data.filter成功渲染</td><td>配合路由钩子使用</td></tr><tr><td>beforeUpdate</td><td>data更新时触发</td><td></td></tr><tr><td>updated</td><td>data更新时触发</td><td>数据更新时，做一些处理（此处也可以用watch进行观测）</td></tr><tr><td>beforeDestroy</td><td>组件销毁时触发</td><td></td></tr><tr><td>destroyed</td><td>组件销毁时触发，vue实例解除了事件监听以及和dom的绑定（无响应了），但DOM节点依旧存在</td><td>组件销毁时进行提示</td></tr></tbody></table><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="创建期间的生命周期函数"><a href="#创建期间的生命周期函数" class="headerlink" title="创建期间的生命周期函数"></a>创建期间的生命周期函数</h4><h5 id="beforeCreate（初始化界面前）"><a href="#beforeCreate（初始化界面前）" class="headerlink" title="beforeCreate（初始化界面前）"></a>beforeCreate（初始化界面前）</h5><p>实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</p><h5 id="created（初始化界面后）"><a href="#created（初始化界面后）" class="headerlink" title="created（初始化界面后）"></a>created（初始化界面后）</h5><p>实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</p><h4 id="挂载期间的生命周期函数"><a href="#挂载期间的生命周期函数" class="headerlink" title="挂载期间的生命周期函数"></a>挂载期间的生命周期函数</h4><h5 id="beforeMount（渲染DOM前）"><a href="#beforeMount（渲染DOM前）" class="headerlink" title="beforeMount（渲染DOM前）"></a>beforeMount（渲染DOM前）</h5><p>此时已经完成了模板的编译，但是还没有挂载到页面中</p><h5 id="mounted（渲染DOM后）"><a href="#mounted（渲染DOM后）" class="headerlink" title="mounted（渲染DOM后）"></a>mounted（渲染DOM后）</h5><p>此时，已经将编译好的模板，挂载到了页面指定的容器中显示</p><h4 id="运行期间的生命周期函数"><a href="#运行期间的生命周期函数" class="headerlink" title="运行期间的生命周期函数"></a>运行期间的生命周期函数</h4><h5 id="beforeUpdate（更新数据前）"><a href="#beforeUpdate（更新数据前）" class="headerlink" title="beforeUpdate（更新数据前）"></a>beforeUpdate（更新数据前）</h5><p>状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</p><h5 id="updated（更新数据后）"><a href="#updated（更新数据后）" class="headerlink" title="updated（更新数据后）"></a>updated（更新数据后）</h5><p>实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</p><h4 id="销毁期间的生命周期函数"><a href="#销毁期间的生命周期函数" class="headerlink" title="销毁期间的生命周期函数"></a>销毁期间的生命周期函数</h4><h5 id="beforeDestroy（卸载组件前）"><a href="#beforeDestroy（卸载组件前）" class="headerlink" title="beforeDestroy（卸载组件前）"></a>beforeDestroy（卸载组件前）</h5><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p><h5 id="destroyed（卸载组建后）"><a href="#destroyed（卸载组建后）" class="headerlink" title="destroyed（卸载组建后）"></a>destroyed（卸载组建后）</h5><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>组件模板自己试着写就好，此处贴js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Vue的生命周期&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeCreate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeCreate创建前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span> , <span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//undefined </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------created创建完毕状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------beforeMount挂载前状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + (<span class="variable language_">this</span>.<span class="property">$el</span>)); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;------mounted 挂载结束状态------&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">//已被初始化 </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeUpdate</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);   </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updated</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">beforeDestroy</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);    </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>); </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">destroyed</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="variable language_">this</span>.<span class="property">$data</span>); </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="激活与未激活的生命周期"><a href="#激活与未激活的生命周期" class="headerlink" title="激活与未激活的生命周期"></a>激活与未激活的生命周期</h3><h4 id="activated（）"><a href="#activated（）" class="headerlink" title="activated（）"></a>activated（）</h4><p>被 keep-alive 缓存的组件激活时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h4 id="deactivated（）"><a href="#deactivated（）" class="headerlink" title="deactivated（）"></a>deactivated（）</h4><p>被 keep-alive 缓存的组件停用时调用。</p><p><strong>该钩子在服务器端渲染期间不被调用。</strong></p><h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><blockquote><p>2.5.0+ 新增</p></blockquote><h4 id="errorCaptured（）"><a href="#errorCaptured（）" class="headerlink" title="errorCaptured（）"></a>errorCaptured（）</h4><p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p><h3 id="钩子函数的理解"><a href="#钩子函数的理解" class="headerlink" title="钩子函数的理解"></a>钩子函数的理解</h3><p>所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong>(例如created: () &#x3D;&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此this与你期待的 Vue 实例不同，this.fetchTodos的行为未定义。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也算是温故而知新了，太久没看的vue2相关的内容了，捕获错误这个之前一直没有，如今也算是新发现了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>原帖：<a href="https://juejin.cn/post/7024074527420203044">Vue生命周期（简单易懂,超详细）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解原型链</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>原型链，从来都没去理解过，为了面试特意查了一下，发现早就是在工作里边用的熟悉了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>工作中常常遇到输出对象的内容，</p><p><strong>暂时未完成施工，等手里的私活忙完我再继续写</strong></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>用来声明对象的函数</p><p>构造函数和普通函数本质上没什么区别，只不过使用了<code>new</code>关键字创建对象的函数，被叫做了构造函数。构造函数命名通常采用首字母大写的方式，以便与普通函数和变量进行区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">   this.name = name;</span><br><span class="line">   this.age = age;</span><br><span class="line">    this.species = &#x27;人类&#x27;;</span><br><span class="line">    this.say = function () &#123;</span><br><span class="line">        console.log(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let per1 = new Person(&#x27;xiaoming&#x27;, 20);</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>将函数作为参数传递的函数</p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>原型链的顶层是null</p><h4 id="显示原型"><a href="#显示原型" class="headerlink" title="显示原型"></a>显示原型</h4><ol><li>Prototype是<strong>函数</strong>的一个属性</li><li>是个对象</li><li>创建函数的时候时候，自带该属性</li></ol><h4 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h4><p>_<em>proto</em>_</p><ol><li><strong>对象</strong>的属性</li><li>指向构造函数Prototype</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b435c6ed064418969d80abcddb44e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>感觉这玩意除非涉及到基础框架开发，否则感觉真是用不上啊。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7255605810453217335?searchId=20240326154528B151AB415507AF9D5722">原型和原型链–图解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解页面布局</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>太久没看过了，这里回顾一下页面的基础还原方法，有点累。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>盒子模型这种传统的东西就不提了，这里直接提几种布局模式。</p><h3 id="block，inline与inline-block"><a href="#block，inline与inline-block" class="headerlink" title="block，inline与inline-block"></a>block，inline与inline-block</h3><ul><li>行内标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，行内标签无法设置宽高</span><br><span class="line"></span><br><span class="line">2，行内标签不会独占一行，会连续占满一行，直到换行</span><br><span class="line"></span><br><span class="line">3，行内元素不能包含块级元素，只能容纳文本或者其他行内元素</span><br></pre></td></tr></table></figure><ul><li>块状元素</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>，块状标签可以设置宽高度</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>，块元素独占一行</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>，块属性标签的宽度假如不做设置，会直接默认为父元素宽度的<span class="number">100</span><span class="comment">%</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>，块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素</span><br></pre></td></tr></table></figure><ul><li>行内块元素</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1，结合的行内和块级的优点:能够设置宽高，并且在一行内独立显示</span></span><br></pre></td></tr></table></figure><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 如果父元素不设置高度，会引起父元素塌陷 </span><br><span class="line">2. 元素浮动，引起同行兄弟元素占位，导致页面错乱</span><br></pre></td></tr></table></figure><p>常用的元素塌陷处理方式</p><ol><li>直接给父元素设置高度</li><li>使用clear:both清空浮动（如果不清楚这个属性是干什么的，可以去W3C官网看看，很容易理解的）</li><li>给父元素加overflow:hidden</li><li>给父元素添加浮动，父子元素一起浮动，就没问题了;</li></ol><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>默认定位（static），不会让div或者其他元素脱离文档流，而是遵循排版的原则，从上到下，块级元素换行，行内元素不换行等等通用原则。所以，如果不用定位属性，那么这个position就不用设置。</p><p>相对定位（relative），相对于元素原本的位置进行位移，原本的位置不为空，仍然已经位移的该元素继续占用</p><p>绝对定位（absolute），相对于元素的父元素最左上角进行坐标定位，会脱离文档流，产生类似浮动的效果</p><p>固定定位（fixed），相对于当前窗口最左上角进行坐标定位</p><p>粘性定位（sticky）， 基于用户的滚动位置来定位，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置，常常用来做页面的顶部标签。</p><p>这里要注意以下两点：</p><ol><li>定位是相对于父元素进行定位的，如果父元素没有设置定位属性，则相对于BODY标签进行定位。</li><li>如果父元素没有设置定位的话，那么，绝对定位是相对于body标签进行定位的。</li><li>如果父元素设置了相对定位，绝对定位，固定定位，任意一种，那么，绝对定位相对于父元素左上角进行定位。</li></ol><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>移动端常用的解决方式，懒得写。</p><p>参考：<a href="https://juejin.cn/post/7245898637779157052?searchId=20240326095317548BA608AFC1017DB216">一文吃透 CSS Flex 布局 - 掘金 (juejin.cn)</a></p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>参考：<a href="https://juejin.cn/post/6854573220306255880?searchId=2024032609542547B81E72E842C57E26AF">最强大的 CSS 布局 —— Grid 布局 - 掘金 (juejin.cn)</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>说实话，不是很想写这篇，但是我自己回忆这些内容的时候，发现太过熟悉以至于卡壳了。</p><p>不得已，写了这篇内容回忆一下以前熟的发昏的内容。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903671717691405">切图仔基础篇————块级元素与行级元素</a></p><p><a href="https://juejin.cn/post/6844903684510318599">切图仔基础篇————如何熟练的使用定位</a></p><p><a href="https://juejin.cn/post/6844903678151770119">切图仔基础篇————浮动问题浅析</a></p><p><a href="https://www.runoob.com/css/css-positioning.html">菜鸟驿站，css定位</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解less与scss</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3less%E4%B8%8Escss/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3less%E4%B8%8Escss/</url>
      
        <content type="html"><![CDATA[<p>本来以为不会有人问这种级别的面试题了，没想到有人提到了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>二者作为预编译语言，寻常使用过程中没有什么太大的差别。</p><p>预编译语言的特点，两者都有。</p><ol><li>定义变量</li><li>嵌套编译</li><li>混合宏</li></ol><p>如果一定要分出个高低，个人推荐使用less，因为scss的库大多项目都用的是node-scss，这个库常常导致项目更新失败，新人使用可能会产生大问题，而less的库则没有相关问题。</p><h3 id="Less-和-SCSS-简介"><a href="#Less-和-SCSS-简介" class="headerlink" title="Less 和 SCSS 简介"></a>Less 和 SCSS 简介</h3><h4 id="Less：简洁而强大"><a href="#Less：简洁而强大" class="headerlink" title="Less：简洁而强大"></a>Less：简洁而强大</h4><p>Less（Leaner Style Sheets）是一种向后兼容的 CSS 扩展，它允许开发者使用类似于编程的方式来编写 CSS。Less 引入了变量、混合（类似于函数的结构）、嵌套规则等特性，极大地提高了代码的可重用性和可维护性。它可以在客户端或服务器端（如 Node.js）运行，这为开发者提供了灵活的使用方式。</p><h4 id="SCSS：丰富功能的优雅选择"><a href="#SCSS：丰富功能的优雅选择" class="headerlink" title="SCSS：丰富功能的优雅选择"></a>SCSS：丰富功能的优雅选择</h4><p>SCSS（Sassy CSS）是 Sass 的一个版本，它使用类似于 CSS 的语法，这意味着任何有效的 CSS 代码都是合法的 SCSS 代码。SCSS 不仅保留了 Less 的所有优点，还增加了诸如条件语句、循环、函数等更高级的功能。这使得 SCSS 在处理复杂项目时显得更加得心应手。</p><h3 id="Less-和-SCSS-的异同"><a href="#Less-和-SCSS-的异同" class="headerlink" title="Less 和 SCSS 的异同"></a>Less 和 SCSS 的异同</h3><p>虽然 Less 和 SCSS 都是 CSS 预处理器，但它们在语法和功能上有一些关键的差异。</p><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol><li><strong>预处理功能</strong>：两者都提供了变量、混合、函数、嵌套规则等功能。</li><li><strong>编译到 CSS</strong>：它们都需要被编译成普通的 CSS 才能在浏览器中使用。</li><li><strong>社区支持</strong>：Less 和 SCSS 都有着活跃的开发社区和丰富的文档资源。</li></ol><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ol><li><strong>语法差异</strong>：</li></ol><ul><li><strong>Less</strong> 使用 <code>@</code> 符号来定义变量（例如 <code>@primary-color</code>），其语法与传统 CSS 较为接近，但有自己的特点。</li><li><strong>SCSS</strong> 使用 <code>$</code> 符号定义变量（例如 <code>$primary-color</code>），其语法几乎与原生 CSS 一致，这对于熟悉 CSS 的开发者来说非常友好。</li></ul><ol><li><strong>功能差异</strong>：<ul><li><strong>Less</strong> 提供了基本的预处理功能，如变量、混合和嵌套规则，适合于轻量级应用。</li><li><strong>SCSS</strong> 拥有更高级的功能，如条件语句、循环、函数等，更适合复杂的项目和大型应用。</li></ul></li><li><strong>编译环境</strong>：<ul><li><strong>Less</strong> 可以在客户端（浏览器）或服务器端（如 Node.js）环境中编译。</li><li><strong>SCSS</strong> 通常需要通过服务器端环境来编译，如 Ruby 或 Node.js。</li></ul></li><li><strong>社区和生态系统</strong>：<ul><li><strong>SCSS</strong>，作为 Sass 的一个版本，继承了 Sass 的强大生态系统和广泛的社区支持。</li><li><strong>Less</strong> 也有一个活跃的社区，但相对于 SCSS&#x2F;Sass，它的生态系统可能稍显逊色。</li></ul></li></ol><h3 id="使用场景和案例分析"><a href="#使用场景和案例分析" class="headerlink" title="使用场景和案例分析"></a>使用场景和案例分析</h3><h4 id="Less-在实际中的应用"><a href="#Less-在实际中的应用" class="headerlink" title="Less 在实际中的应用"></a>Less 在实际中的应用</h4><ol><li><strong>小到中型项目</strong>：Less 的简洁性使其非常适合小到中型的网站或应用项目。</li><li><strong>快速原型开发</strong>：需要快速迭代和原型设计时，Less 的简单性可以加速开发过程。</li><li><strong>动态主题</strong>：Less 的变量和函数可以轻松创建可配置的主题样式，适用于动态主题切换。</li></ol><h4 id="SCSS-的使用场景"><a href="#SCSS-的使用场景" class="headerlink" title="SCSS 的使用场景"></a>SCSS 的使用场景</h4><ol><li><strong>大型项目或框架</strong>：SCSS 的高级功能使其成为处理大型项目或复杂应用程序的理想选择。</li><li><strong>与现代前端框架集成</strong>：SCSS 与 Angular、Vue 或 React 等前端框架结合使用，能够提供更复杂的样式管理。</li><li><strong>高级功能需求</strong>：当项目需要使用条件逻辑、循环或函数等高级功能时，SCSS 是更好的选择。</li></ol><h3 id="实际代码示例"><a href="#实际代码示例" class="headerlink" title="实际代码示例"></a>实际代码示例</h3><p>让我们通过一个简单的按钮样式示例来进一步理解 Less 和 SCSS 的具体应用。</p><h4 id="Less-代码示例"><a href="#Less-代码示例" class="headerlink" title="Less 代码示例"></a>Less 代码示例</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">less</span>复制代码<span class="comment">// 定义变量</span></span><br><span class="line">@<span class="selector-tag">primary-color</span>: <span class="selector-id">#4CAF50</span>;</span><br><span class="line">@<span class="selector-tag">warning-color</span>: <span class="selector-id">#f44336</span>;</span><br><span class="line">@<span class="selector-tag">font-stack</span>: <span class="selector-tag">Helvetica</span>, <span class="selector-tag">sans-serif</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本按钮样式</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">@font-stack</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大号按钮</span></span><br><span class="line"><span class="selector-class">.button-large</span> &#123;</span><br><span class="line">  <span class="selector-class">.button</span>(); <span class="comment">// 使用混合</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警告按钮</span></span><br><span class="line"><span class="selector-class">.button-warning</span> &#123;</span><br><span class="line">  <span class="selector-class">.button</span>(); <span class="comment">// 使用混合</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@warning-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SCSS-代码示例"><a href="#SCSS-代码示例" class="headerlink" title="SCSS 代码示例"></a>SCSS 代码示例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">css复制代码// 定义变量</span><br><span class="line">$primary-<span class="attribute">color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">$warning-<span class="attribute">color</span>: <span class="number">#f44336</span>;</span><br><span class="line">$<span class="attribute">font</span>-stack: Helvetica, sans-serif;</span><br><span class="line"></span><br><span class="line">// 基本按钮样式</span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: $font-stack;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 大号按钮</span><br><span class="line"><span class="selector-class">.button-large</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button; // 使用继承</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 警告按钮</span><br><span class="line"><span class="selector-class">.button-warning</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button; // 使用继承</span><br><span class="line">  <span class="attribute">background-color</span>: $warning-color;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个示例展示了如何在 Less 和 SCSS 中使用变量、混合（或继承）、嵌套等特性来创建一个可复用和易于维护的按钮样式。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>选择 Less 还是 SCSS 取决于项目需求、团队熟悉度以及个人偏好。两者都能显著提高 CSS 的编写效率和可维护性。Less 以其简单直观著称，适合小到中型项目；而 SCSS 则以其强大的功能和灵活性适用于更大型和复杂的项目。</p><p>当然，如果我个人开发，我倾向于是用less的来维护项目。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>原贴链接：<a href="https://juejin.cn/post/7323271668990722058">Less 和 SCSS，哪一个更适合你？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解JS的栈与堆</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3JS%E7%9A%84%E6%A0%88%E4%B8%8E%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>说实在的，堆和栈这个东西，工作这么多年了，如果不是面试，我确实不清楚。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>面试回答</p><ol><li>栈是基础类型，先进后出，存储空间系统分配，系统自动释放，是值传递</li><li>堆是引用类型，动态分配存储空间，存储空间大，是地址传递</li></ol><h3 id="一、-栈-stack-和-堆-heap"><a href="#一、-栈-stack-和-堆-heap" class="headerlink" title="一、 栈(stack)和 堆(heap)"></a>一、 栈(stack)和 堆(heap)</h3><p><strong>栈(stack)：</strong>是栈内存的简称，栈是<strong>自动分配</strong>相对<strong>固定大小</strong>的内存空间，并由系<strong>统自动释放，</strong>栈<strong>数据结构</strong>遵循<strong>FILO</strong>（first in last out）<strong>先进后出</strong>的原则，较为经典的就是乒乓球盒结构，先放进去的乒乓球只能最后取出来；</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/29/1739946914d2b233~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>堆(heap)：</strong>是堆内存的简称，堆是<strong>动态分配</strong>内存，<strong>内存大小不固定</strong>，也<strong>不会自动释放，</strong>堆<strong>数据结构</strong>是一种无序的树状结构，同时它还满足key-value键值对的存储方式；我们只用知道key名，就能通过key查找到对应的value。比较经典的就是书架存书的例子，我们知道书名，就可以找到对应的书籍；</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/29/173995964a8ebad8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>栈的特点：开口向上、速度快,容量小；</strong></p><p><strong>堆的特点：速度稍慢、容量比较大；</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/22/17375f8624e6c831~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><h3 id="二、-基本类型和引用类型"><a href="#二、-基本类型和引用类型" class="headerlink" title="二、  基本类型和引用类型"></a>二、  基本类型和引用类型</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/23/17379552d18f1b91~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img"></p><p><strong>基本数据类型</strong>：<strong>Undefined,String,Boolean,Null,Number，</strong>都是直接按值存放在栈内存中，占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p><p><strong>引用数据类型</strong>：指那些可能由多个值构成的对象，如<strong>对象(Object)、数组(Array)、函数(Function)</strong> ，它们是通过拷贝和new出来的，这样的数据存储于堆中。</p><h3 id="三、-传值和传址的区别"><a href="#三、-传值和传址的区别" class="headerlink" title="三、 传值和传址的区别"></a>三、 传值和传址的区别</h3><p><strong>基本类型</strong>：采用的是<strong>值传递</strong>。</p><p><strong>引用类型</strong>：则是<strong>地址传递</strong>。</p><p>引用类型的数据的地址指针是存储于栈中的，将存放在栈内存中的地址赋值给接收的变量。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据（保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针）。</p><h3 id="四、-内存分配垃圾回收"><a href="#四、-内存分配垃圾回收" class="headerlink" title="四、 内存分配垃圾回收"></a>四、 内存分配垃圾回收</h3><p><strong>1.内存分配：</strong></p><p><strong>（1）栈内存：</strong>线性有序存储，容量小，系统分配效率高。</p><p><strong>（2）堆内存：</strong>首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。 </p><p><strong>2.垃圾回收</strong>：</p><p><strong>（1）栈内存：</strong>变量基本上用完就回收了，相比于堆来说存取速度会快，并且栈内存中的数据是可以共享的。</p><p><strong>（2）堆内存</strong>：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用(参数传递)。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>讲的很清晰明了，比早年的云里雾里的那些教程好了很多。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6854573215327617031">js中栈和堆的概念和区别 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解闭包</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>经典面试内容，ES5时代的必须面试题，虽然回答起来简单，但是想要说明白要破费一些口舌。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>面试回答</p><ol><li>js中声明的变量都是有作用域的，不同函数之间的变量无法互相引用，于是有了闭包，保证不同函数之间的内容可以互相引用</li><li>简单的来说，闭包就是将函数内的变量抛出，供外部访问或者使用。</li><li>闭包是指有权访问另一个函数作用域中变量的函数</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>了解闭包前先来了解一下上级作用域和堆栈内存释放问题。</p></blockquote><h3 id="上级作用域的概念"><a href="#上级作用域的概念" class="headerlink" title="上级作用域的概念"></a>上级作用域的概念</h3><ul><li>函数的上级作用域在哪里创建创建的，上级作用域就是谁</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><p><strong>函数 <code>foo()</code> 是在全局下创建的，所以 <code>a</code> 的上级作用域就是 <code>window</code>，输出就是 <code>10</code></strong></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> n =<span class="number">20</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">       n++;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="title function_">f</span>()</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br><span class="line"><span class="title function_">x</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*  21</span></span><br><span class="line"><span class="comment">    22</span></span><br><span class="line"><span class="comment">    23</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><p><strong>稍微提个醒，单独的 n++ 和 ++n 表达式的结果是一样的</strong></p><blockquote><p><strong>思路：<code>fn</code> 的返回值是什么变量 <code>x</code> 就是什么，这里 <code>fn</code> 的返回值是函数名 <code>f</code> 也就是 <code>f</code> 的堆内存地址，<code>x()</code> 也就是执行的是函数 <code>f()</code>，而不是 <code>fn()</code>，输出的结果显而易见</strong></p></blockquote><ul><li>关于如何查找上级作用域</li></ul><blockquote><p>参考：<a href="https://juejin.cn/post/6933377315573497864">彻底解决 JS 变量提升的面试题</a></p></blockquote><h3 id="JS-堆栈内存释放"><a href="#JS-堆栈内存释放" class="headerlink" title="JS 堆栈内存释放"></a>JS 堆栈内存释放</h3><ul><li>堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。</li><li>堆内存释放：将引用类型的空间地址变量赋值成 <code>null</code>，或没有变量占用堆内存了浏览器就会释放掉这个地址</li><li>栈内存：提供代码执行的环境和存储基本类型值。</li><li>栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。</li></ul><blockquote><p><strong>但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放</strong></p></blockquote><h3 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h3><blockquote><p>在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。</p></blockquote><blockquote><p>概述上面的话，<strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p></blockquote><h3 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h3><blockquote><p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。从上面介绍的上级作用域的概念中其实就有闭包的例子 <code>return f</code>就是一个表现形式。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b =<span class="number">14</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><blockquote><p>这里的子函数 <code>fo</code> 内存就存在外部作用域的引用 <code>a, b</code>，所以这就会产生闭包</p></blockquote><h3 id="闭包变量存储的位置"><a href="#闭包变量存储的位置" class="headerlink" title="闭包变量存储的位置"></a>闭包变量存储的位置</h3><blockquote><p>直接说明：<strong>闭包中的变量存储的位置是堆内存。</strong></p></blockquote><ul><li>假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。</li></ul><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。</li><li>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</li></ul><h3 id="闭包经典使用场景"><a href="#闭包经典使用场景" class="headerlink" title="闭包经典使用场景"></a>闭包经典使用场景</h3><ul><li><ol><li><code>return</code> 回一个函数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> n = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> n =<span class="number">20</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">       n++;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">x</span>() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 return <code>f</code>, <code>f()</code>就是一个闭包，存在上级作用域的引用。</p></blockquote><ul><li><ol><li>函数作为参数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;林一一&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    <span class="title function_">p</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="title function_">foo</span>())</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*   foo</span></span><br><span class="line"><span class="comment">/ </span></span><br></pre></td></tr></table></figure><blockquote><p>使用 return <code>fo</code> 返回回来，<code>fo()</code> 就是闭包，<code>f(foo())</code> 执行的参数就是函数 <code>fo</code>，因为 <code>fo() 中的 a</code>  的上级作用域就是函数<code>foo()</code>，所以输出就是<code>foo</code></p></blockquote><ul><li><ol><li>IIFE（自执行函数）</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="string">&#x27;林一一&#x27;</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">p</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">*   林一一</span></span><br><span class="line"><span class="comment">/ </span></span><br></pre></td></tr></table></figure><blockquote><p>同样也是产生了闭包<code>p()</code>，存在 <code>window</code>下的引用 <code>n</code>。</p></blockquote><ul><li><ol><li>循环赋值</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, <span class="number">1000</span>) </span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为存在闭包的原因上面能依次输出0~9，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 <code>i++</code> 到 10时，异步代码才开始执行此时的 <code>i=10</code> 输出的都是 10。</p></blockquote><ul><li><ol><li>使用回调函数就是在使用闭包</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;林一一&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li><ol><li>节流防抖</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, timeout</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li>柯里化实现</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, len = fn.length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_curry</span>(fn, len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_curry</span>(<span class="params">fn, len, ...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...params</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> _arg = [...arg, ...params]</span><br><span class="line">        <span class="keyword">if</span> (_arg.<span class="property">length</span> &gt;= len) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, _arg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, len, ..._arg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="title function_">curry</span>(<span class="keyword">function</span> (<span class="params">a, b, c, d, e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c + d + e)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">// 15</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h3><blockquote><p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p></blockquote><h4 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h4><ul><li>performance 面板 和 memory 面板可以找到泄露的现象和位置</li></ul><p>详细可以查看：<a href="https://juejin.cn/post/6844904048961781774#comment">js 内存泄漏场景、如何监控以及分析</a></p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ul><li>for 循环和闭包(号称必刷题)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>i</code> 是全局下的 <code>i</code>，共用一个作用域，当函数被执行的时候这时的 <code>i=3</code>，导致输出的结构都是3。</p></blockquote><ul><li>使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>( data[j] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure><ul><li>写法2：使用 <code>let</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]()</span><br></pre></td></tr></table></figure><blockquote><p><code>let</code> 具有块级作用域，形成的3个私有作用域都是互不干扰的。</p></blockquote><h3 id="思考题和上面有何不同-字节"><a href="#思考题和上面有何不同-字节" class="headerlink" title="思考题和上面有何不同 (字节)"></a>思考题和上面有何不同 (字节)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            total += i * a;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>);</span><br><span class="line">result[<span class="number">0</span>]();  <span class="comment">// 3</span></span><br><span class="line">result[<span class="number">1</span>]();  <span class="comment">// 6</span></span><br><span class="line">result[<span class="number">2</span>]();  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><blockquote><p>tip：这里也形成了闭包。total 被外层引用没有被销毁。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>实现私有变量和数据封装：通过闭包可以创建私有变量，只能在内部函数中访问和修改，外部无法直接访问。这样可以实现封装，隐藏数据细节，提高代码安全性。</li><li>保持数据的持久性：闭包使得内部函数可以持续访问外部函数的变量，即使外部函数已经执行完毕。这对于需要保持数据状态或延长变量生命周期的场景非常有用。</li><li>创建函数工厂和动态函数：通过闭包可以动态生成函数，每个函数都有自己的独立作用域和状态。这样可以创建函数工厂，根据不同的参数生成不同的函数。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>内存占用：闭包会导致外部函数的作用域被内部函数引用而无法释放，可能导致内存占用过高。需要注意在不再需要使用闭包时，将其引用置为 <code>null</code>，释放内存。</li><li>性能影响：闭包涉及作用域链的查找，相比普通函数，闭包的执行速度可能较慢。因此，在性能敏感的场景中，过度使用闭包可能会影响代码执行效率。</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>封装模块和实现私有成员：通过闭包可以创建模块，将相关的函数和数据封装在一起，避免全局命名冲突，实现模块化开发。</li><li>记忆和缓存：通过闭包可以实现记忆化函数，将函数的计算结果缓存起来，避免重复计算，提高性能。</li><li>回调函数和异步操作：闭包可以在异步操作中保持数据的状态，使回调函数能够访问异步操作完成后的结果。</li><li>实现<a href="https://juejin.cn/post/7282950171008450560">函数柯里化</a>和函数参数的延迟绑定：通过闭包可以实现函数柯里化，将多个参数的函数转化为接受单个参数的函数，方便函数的复用和组合。</li><li>实现特殊的编程模式和技术，如单例模式、函数式编程等。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>闭包这个经典面试题，在最近面试的时候，经常遇到，我回答的也不够完美。</p><p>所以这里整理一下，防止后续遇到相关的问题。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6937469222251560990?searchId=2024032607455194BE7E124D95E971BAFA#heading-2">闭包经典使用场景和含闭包必刷题</a></p><p><a href="https://juejin.cn/post/7274839871276040246?searchId=2024042117394567E753B7DDC9A9AC503E">JavaScript 闭包 优缺点和作用的详细解释 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解深浅拷贝</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>对于深拷贝和浅拷贝，之前一直不怎么用到，所以一直也没太深入了解，22年的时候，被一个赋值问题教育了，这是那时候记录下的问题。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><p>变量的每次声明都会开辟新的存储空间，js中为了找到对应的存储空间，需要指针来指向这个内容。</p><ol><li>深拷贝，重新开辟一个存储空间，来存储你拷贝过来的内容</li><li>浅拷贝，简单的改一下引用指向，使新申明的内容指向原有的内容</li><li>深浅拷贝只针对对象和数组，无所谓好坏，看情况使用，一般是针对多层级的对象嵌套使用深拷贝，便于内容的修改</li><li>虽然有很多方法，但是个人一般使用自己写的js工具方法来处理这些小问题。</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在了解深浅拷贝之前，要先了解定义变量发生了什么。</p><p>我们每次申明变量，会在存储空间内分出来一块单位用来存储变量，而每个存储的变量，又会有个叫做指针的地址。</p><p>所以，我们在给其他变量赋值的时候，就会有个区分：是连着存储单位一块赋值的深拷贝，还是只给一个地址的浅拷贝。</p><p>深拷贝：开辟一块新的存储空间，存放原有的变量，并新开一个指针地址</p><p>浅拷贝：只拷贝指针地址，不另开辟存储空间</p><p>如果使用浅拷贝赋值，原有值会被修改</p><p>如果使用深拷贝赋值，原有值不会被修改</p><p>当然，有人可能会说我胡说，为什么string，boolean,null,undefined这些类型的值怎么没有改变原有值？</p><p>因为深复制和浅复制只针对象  Object对象、Array数组、RegExp对象(正则表达式)、Date时间对象、Function函数 这类复杂对象的。</p><p>简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。</p><p>所以，一般深浅拷贝，都是针对数组或对象这类数据进行操作的。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>如果已经理解上边的朋友，可以跳过这段，这是给一些新手朋友理解的。</p><p>举个不恰当的例子，声明变量，就像我开一家公司，我必然会有个地址，也必然会在现实有个场地办公司。</p><p>我如果要开子公司，子公司就相当于我声明的新变量，而我要把母公司挂名给子公司，就像是赋值这个过程。</p><p>但是开的子公司，我可以只挂名，不开新办公室，直接把新公司的地址指向母公司————这就类似于浅拷贝；</p><p>那么，与之相对的，如果子公司不仅挂名，而且新开了一间办公室，那么我的新公司的地址就指向了新的办公室————这就深拷贝。</p><p>深拷贝会有个新空间来存储赋值后的变量，而浅拷贝没有。</p><p>所以，我们继续用这个例子来讲解：</p><p>如果是深拷贝，我要修改新公司的布局，因为新公司指向的是新办公室，所以只会修改新办公室的布局，而母公司的办公室不会被修改；</p><p>但若是浅拷贝，我要修改新公司的布局，因为新公司指向的是老办公室，所以，原有办公室的布局会被修改；</p><h3 id="深拷贝应用"><a href="#深拷贝应用" class="headerlink" title="深拷贝应用"></a>深拷贝应用</h3><p>浅拷贝没什么好说的，而深拷贝则需要一些特殊的方法赋值，以下记录一些常用的深拷贝使用手法。</p><h3 id="1-手动复制"><a href="#1-手动复制" class="headerlink" title="1. 手动复制"></a>1. 手动复制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1 = &#123;a:1,b:2&#125;</span><br><span class="line"></span><br><span class="line">obj2 = &#123;a: obj1.a,b: obj.b&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对象只有一层的话。可以用object-assign-obj1"><a href="#2-对象只有一层的话。可以用object-assign-obj1" class="headerlink" title="2. 对象只有一层的话。可以用object.assign({},obj1)"></a>2. 对象只有一层的话。可以用object.assign({},obj1)</h3><p>Es6的object.assign()是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身</p><p>所以只能实现一层基本类型属性的拷贝 当obj1中属性是引用类型时，就会发现，修改其中一个属性值，另一个值也发生变化。 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;a: 1, b: &#123; c: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line">let obj2 = Object.assign(&#123;&#125;,obj1)</span><br><span class="line"></span><br><span class="line"> // 或者 obj2 = &#123;...obj1&#125;</span><br><span class="line"></span><br><span class="line">obj2.b.c = 4</span><br><span class="line"></span><br><span class="line">console.log(obj1) //&#123; a: 1, b: &#123; c: 4 &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="3-转成json再转换回来"><a href="#3-转成json再转换回来" class="headerlink" title="3. 转成json再转换回来"></a>3. 转成json再转换回来</h3><p>用JSON.stringify转为字符串 再用JSON.parse把字符串再转为新的对象</p><p>obj2 &#x3D; JSON.parse（JSON.stringify（obj1））</p><p>坏处： 摒弃了对象的constructor,不管原来的constructor是什么，拷贝后都是object. 只能处理可以被json直接表示的数据结构，number,string,array,扁平对象；</p><p>boolean RegExp对象，无法通过此方式深拷贝</p><h3 id="4-递归拷贝"><a href="#4-递归拷贝" class="headerlink" title="4. 递归拷贝"></a>4. 递归拷贝</h3><p>递归深拷贝的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">deepCopy(obj) &#123;</span><br><span class="line">  if (!obj &amp;&amp; typeof obj !== &quot;object&quot;) &#123;</span><br><span class="line">    throw new Error(&quot;error arguments&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // const targetObj = obj.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">  const targetObj = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    // 只对对象自有属性进行拷贝</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;</span><br><span class="line">        targetObj[key] = deepCopy(obj[key]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        targetObj[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 相互引用会出现死循环，深拷贝的做法是遇到对象就进行递归 复制，那么结果只能无限循环下去</p><h3 id="5-object-create-方法"><a href="#5-object-create-方法" class="headerlink" title="5. object.create()方法"></a>5. object.create()方法</h3><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p><p>也就是说，现有对象是新的对象的构造函数的prototype.其实现过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-直接使用一些库函数方法，-如lodash"><a href="#6-直接使用一些库函数方法，-如lodash" class="headerlink" title="6.直接使用一些库函数方法， 如lodash"></a>6.直接使用一些库函数方法， 如lodash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;)</span><br><span class="line">_.cloneDeep()</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>深浅拷贝也算是经典面试题了，无论什么时候都会有人考。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844904178934874126">https://juejin.cn/post/6844904178934874126</a></p><p><a href="https://juejin.cn/post/6871053262767734791">https://juejin.cn/post/6871053262767734791</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟了解null和undefined的关系</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3null%E5%92%8Cundefined%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3null%E5%92%8Cundefined%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>简单的面试题，21年做的笔记，现在用上了。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>21年常见的面试题，如今问到还真是有点怀念，大多数厂商实际上不会问的太深。</p><h3 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h3><ol><li>二者不全等</li><li>null的类型是对象，undefined的类型是undefined</li></ol><h3 id="它们是什么"><a href="#它们是什么" class="headerlink" title="它们是什么"></a>它们是什么</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>undefined代表了一个并不存在的值，很多情况都会产生undefined，比如：</p><ol><li>没有返回语句的函数运行结束，就会返回undefined</li><li>访问数组中不存在的下标和对象不存在的属性</li><li>void运算符会返回undefined</li></ol><p>undefined是一个全局定义的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined in window  // true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>空引用或者空对象，下面这些情况都会用到null：</p><ol><li>试图获取一个不存在的元素返回一个null值</li><li>通过分配null可以手动的释放对象，便于垃圾回收</li></ol><h3 id="它们哪儿相同"><a href="#它们哪儿相同" class="headerlink" title="它们哪儿相同"></a>它们哪儿相同</h3><h4 id="undefined和null都不能被设置属性或者取属性"><a href="#undefined和null都不能被设置属性或者取属性" class="headerlink" title="undefined和null都不能被设置属性或者取属性"></a>undefined和null都不能被设置属性或者取属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span>.<span class="property">name</span>  <span class="comment">// Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"><span class="literal">null</span>.<span class="property">name</span>   <span class="comment">// Uncaught TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="在条件上下文中，都会被计算成false"><a href="#在条件上下文中，都会被计算成false" class="headerlink" title="在条件上下文中，都会被计算成false"></a>在条件上下文中，都会被计算成false</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show undefined&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;show null&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show undefined</span></span><br><span class="line"><span class="comment">// show null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="它们哪儿不同"><a href="#它们哪儿不同" class="headerlink" title="它们哪儿不同"></a>它们哪儿不同</h3><h4 id="它们是两个不同的类型"><a href="#它们是两个不同的类型" class="headerlink" title="它们是两个不同的类型"></a>它们是两个不同的类型</h4><p>我们都知道JavaScript里面基本类型有：string，number，boolean，null，undefined，所以null和undefined是两个完全不同的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)    <span class="comment">// [object Null]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)   <span class="comment">//  [object Undefined]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="typeof操作返回值不同"><a href="#typeof操作返回值不同" class="headerlink" title="typeof操作返回值不同"></a>typeof操作返回值不同</h4><p>先看现象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>    <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>     <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>) <span class="comment">// false </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>两者类型不同，但是在值这一点上，两者其实是相同的。</p><p>其实typeof null返回object是一个遗存的bug，因为第一个版本JavaScript值存在32位的bit中，1-3位是类型标识，而且前三位为000的是object，恰好null表示机器码空指针，在大多数平台上为0x00，所以typeof null就会被误以为是object，而且这个bug到现在也没fix，据说是因为历史代码太多所以被委员会拒绝。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这也算是远古面试题了，虽然远古但是基础，还挺怀念的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>原贴链接：<a href="https://juejin.im/post/5b330932e51d4558c65222e2">【前端工程师手册】null和undefined到底是什么关系？</a></p><p><a href="https://link.juejin.im/?target=http://2ality.com/2013/10/typeof-null.html">typeof-null</a></p><p><a href="https://link.juejin.im/?target=https://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/">探索JavaScript中Null和Undefined的深渊</a></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟搞清楚选择器和权重</title>
      <link href="/2024/03/26/10%E5%88%86%E9%92%9F%E6%90%9E%E6%B8%85%E6%A5%9A%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E6%9D%83%E9%87%8D/"/>
      <url>/2024/03/26/10%E5%88%86%E9%92%9F%E6%90%9E%E6%B8%85%E6%A5%9A%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E6%9D%83%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>最近考虑去面试新工作，所以这里准备一下老早之前刷到的面试题库。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>选择器这个比较冷门，一般不会考的太深，但是出于对面试的谨慎考虑，还是要准备一下。</p><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ol><li>通配选择器（＊）</li><li>ID选择器（#ID）</li><li>类选择器（.className）</li><li>元素选择器(tagName)</li><li>后代选择器（a b）</li><li>子元素选择器(a&gt;b)</li><li>相邻后面兄弟元素选择器(a + b)</li><li>通用后面兄弟选择器（a 〜 b）</li><li>群组选择器（selector1,selector2,…）</li></ol><p>这里面平时不太常用的选择器有<strong>相邻后面兄弟选择器</strong>和<strong>通用后面兄弟选择器</strong> 首先，很多资料上把它们叫做<strong>相邻兄弟选择器</strong>和<strong>通用兄弟选择器</strong>，我觉得这样会有一定的误导意义， 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">        &lt;li class=&quot;l1&quot;&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l2&quot;&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l3&quot;&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l4&quot;&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l5&quot;&gt;5&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l6&quot;&gt;6&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l7&quot;&gt;7&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l8&quot;&gt;8&lt;/li&gt;</span><br><span class="line">        &lt;li class=&quot;l9&quot;&gt;9&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    li &#123;</span><br><span class="line">        list-style: none;</span><br><span class="line">        height: 20px;</span><br><span class="line">        width: 20px;</span><br><span class="line">        background: red;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        color: white;</span><br><span class="line">        float: left;</span><br><span class="line">        line-height: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当使用相邻兄弟选择器时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.l3 + li &#123;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果为</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/236405/1548688981749-95b1721b-40b0-4150-8ad3-7325511e6cd4.png" alt="img"></p><p>可以看出相邻兄弟选择器只会选择它<strong>后面的一个</strong>兄弟元素。 当使用通用兄弟选择器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.l3 ~ li &#123;</span><br><span class="line">        background: green;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果为：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/236405/1548688993149-5f80c2bd-5acd-42a6-8b63-d6f6b028fecc.png" alt="img"></p><p>可以看出来通用兄弟选择器会选择它<strong>后面所有的</strong>兄弟元素</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>参考链接：<a href="http://www.w3school.com.cn/css/css_selector_attribute.asp">属性选择器-w3cSchool</a></p><ul><li>E[attr]：只使用属性名，但没有确定任何属性值</li><li>E[attr&#x3D;”value”]：指定属性名，并指定了该属性的属性值</li><li>E[attr~&#x3D;”value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写</li><li>E[attr^&#x3D;”value”]：指定了属性名，并且有属性值，属性值以value开头的；</li><li>E[attr$&#x3D;”value”]：指定了属性名，并且有属性值，属性值以value结束的；</li><li>E[attr*&#x3D;”value”]：指定了属性名，并且有属性值，属值中包含了value；</li><li>E[attr|&#x3D;”value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说big-name）;</li></ul><p>属性选择器中有波浪（〜）时属性值有value时就相匹配，没有波浪（〜）时属性值要完全是value时才匹配</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h3><p>在链接中常看到的锚点伪类：link、visited、hover、active</p><h3 id="UI元素状态伪类"><a href="#UI元素状态伪类" class="headerlink" title="UI元素状态伪类"></a>UI元素状态伪类</h3><p>例如 :enabled，:disabled，:checked等，这些主要是对一些表单元素操作。 比较常见的如”type&#x3D;”text”有enable和disabled两种状态，前者为可写状态后者为不可写状态。</p><h2 id="CSS3的-nth选择器"><a href="#CSS3的-nth选择器" class="headerlink" title="CSS3的:nth选择器"></a>CSS3的:nth选择器</h2><ul><li>first-child: 选择某个元素的第一次的出现</li><li>last-child: 选择某个元素的最后一次的出现</li><li>nth-child(): 选择某个元素的一个或多个特定的条件的出现，（）内常用算式来指定条件。</li></ul><h2 id="权重如何计算"><a href="#权重如何计算" class="headerlink" title="权重如何计算"></a>权重如何计算</h2><ol><li>根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） &gt; style标签 &gt; link标签</li><li>根据选择器的类型，id选择器 &gt; 类、属性选择器和伪类选择器 &gt; 元素和伪元素</li><li>一般来说我们的计算方式为，从0开始，一个行内样式+1000，一个id+100，一个属性选择器&#x2F;class或者伪类+10，一个元素名，或者伪元素+1</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>太过冷门了，一般不是基础框架级别的开发项目，理论上不会考这种层次的题目。</p><p>原贴链接：<a href="https://juejin.im/post/5b370c63e51d4558c232637e">【前端工程师手册】30分钟搞清楚选择器和权重</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搬家清单汇总</title>
      <link href="/2024/03/14/%E5%BF%AB%E9%80%9F%E6%90%AC%E5%AE%B6%E6%B8%85%E5%8D%95%E6%B1%87%E6%80%BB/"/>
      <url>/2024/03/14/%E5%BF%AB%E9%80%9F%E6%90%AC%E5%AE%B6%E6%B8%85%E5%8D%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>新的一年到了，2024年即将开始去找工作了，整理一下搬家清单，方便日后再次搬家。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先带些简单的物品过去，等工作安定的时候再进行二次搬运。</p><h3 id="核心工具"><a href="#核心工具" class="headerlink" title="核心工具"></a>核心工具</h3><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>以下物品使用电脑背包完成装运</p><ol><li><p>笔记本电脑，日常工作用</p></li><li><p>纸笔，纸笔本子，负责在外记录日常事件</p></li><li><p>钱包，携带各类证件，<strong>驾照，身份证</strong></p></li><li><p>药品，高血压+甲状腺相关的药物</p></li><li><p>充电宝，防止路上没有电量</p></li><li><p>钥匙</p></li></ol><h3 id="生活工具"><a href="#生活工具" class="headerlink" title="生活工具"></a>生活工具</h3><p>行李箱携带，买个加固的行李箱</p><h4 id="自带"><a href="#自带" class="headerlink" title="自带"></a>自带</h4><ol><li>眼镜及清洗更换套装</li><li>春秋用被褥，毯子</li><li>换洗衣着，两套春秋装，三套内衣内裤，四双袜子</li><li>洗漱用品，洗脸用毛巾，杯子+牙膏+牙刷，刮胡刀+剃须沫</li><li>颈部U形枕</li><li>卫生纸</li><li>部分书籍</li></ol><h4 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h4><ol><li>洗浴用品，洗头膏+沐浴露</li><li>垃圾桶+垃圾袋</li></ol><h3 id="后期搬家"><a href="#后期搬家" class="headerlink" title="后期搬家"></a>后期搬家</h3><p>新地方要有空调，冰箱。</p><h4 id="学习用"><a href="#学习用" class="headerlink" title="学习用"></a>学习用</h4><ol><li>台式机+手柄+双显示器+耳机，日常游戏和家庭办公使用</li><li>书籍，最近要看的书</li><li>标签，方便贴</li><li>绘画板</li><li>插排（长插排，短插排）</li><li>电影挂</li></ol><h4 id="生活用"><a href="#生活用" class="headerlink" title="生活用"></a>生活用</h4><ol><li>冬季被褥+枕头</li><li>各季节衣物</li><li>抱枕</li><li>超大水壶+喝水的杯子</li><li>货架（考虑购买，用来装日常的东西）</li><li>医疗箱（感冒发烧药，创可贴，温度计，血压计）</li></ol><h4 id="食物用"><a href="#食物用" class="headerlink" title="食物用"></a>食物用</h4><ol><li>保鲜膜</li><li>电水壶，日常烧水使用</li><li>空气炸锅+电磁炉+小型高压锅</li><li>食材（鸡蛋，挂面）</li><li>调料（油，盐，辣椒，孜然，黑胡椒，花椒，八角）</li><li>购买厨具，捞面勺，木铲，厨具挂架，玻璃碗，筷子，勺子</li></ol><h4 id="通勤用"><a href="#通勤用" class="headerlink" title="通勤用"></a>通勤用</h4><ol><li>自行车+骑行水壶+骑行用的套装</li><li>运动用装衣袋子</li><li>电动车【这次考虑买个电池容量大的】</li></ol><h4 id="摆件"><a href="#摆件" class="headerlink" title="摆件"></a>摆件</h4><ol><li>手办</li><li>桌面书架</li><li>桌面灯具</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>u盘，工作用的</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>仿佛重新回到的大学毕业前夕。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终减肥汇总</title>
      <link href="/2023/12/30/2023%E5%B9%B4%E7%BB%88%E5%87%8F%E8%82%A5%E6%B1%87%E6%80%BB/"/>
      <url>/2023/12/30/2023%E5%B9%B4%E7%BB%88%E5%87%8F%E8%82%A5%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>回想起今年这一年关于身体调养这一块儿的进度，简直是惨不忍睹。</p><p>但是，相比之前不要命的工作生活，我感觉要好很多，我更感觉到自己像个人，而不是爆金币机器一样的在活着。</p><p>这次到年底了，我汇总了一下这年的减肥经历，算是为来年工作后变更的生活方式做准备。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>随着减肥计划的正式执行起来，我个人才发觉，这不仅仅是控制饮食和每天多执行一两项运动。</p><p>为了控制饮食，那么就无法选择外卖或餐馆，这需要自己购买食材，修改食谱，订购厨具，日常下厨。</p><p>为了增加运动，自己必须着手学习运动的基础知识，并且自己制定和实施计划，购买器械，甚至是报班学习。</p><p>这完全是另一种生活，和只有游戏与工作的我完全不一样的一种生活方式。</p><p>果然，形体其实是一种生活方式的体现，这话在一定程度上挺有道理的。</p><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>因为生活方式发生了改变，所以生活习惯中的注意事项必须得改，让身体学会适应新习惯，这很重要。</p><p>以下按照个人感受的重要程度由高到低排序，仅供参考，未必正确。</p><ol><li><strong>遵循本能</strong>，身体累了就停下休息，上不了强度就不要上，不要为了莫名其妙的胜负欲拉强度，宁愿三天打鱼两天晒网，不要一猛子扎到底，你的身体反应比意志更明白自己的上限在哪。半月板损伤，韧带拉伤，横纹肌溶解，腰椎脆弱，随便一种问题，就能短时间进医院掏空钱包。人体，比想象的强悍也比想象的脆弱，一定要遵循本能。</li><li><strong>控制摄入</strong>，吃比练重要，控制摄入比控制输出更容易，且更容易出效果。我在6到7月，将饮食缩减到一天两顿，体重在三个月内掉了10公斤，且仅仅做了一些普通的大体力活动。当然，如果不辅助运动控制输出，胖回来很容易，在10月之后，饮食恢复了之后，体重又涨了5公斤，所以，吃和练，缺一不可。</li><li><strong>准备运动</strong>，准备运动是一种低成本的保险，做好准备运动，对低烈度大时长的有氧运动，这种工作有一定必要，对于大烈度短时间的爆发性无氧运动，准备运动不做，早晚进医院。</li><li><strong>注意保暖</strong>，因为是在冬季的高强度运动，毛孔扩张容易引起寒气入侵，所以要注意保暖，尤其是膝盖。无论哪种户外运动，膝关节一旦受冷，容易产生关节炎，这将是个长期病痛，所以一定要仔细进行保暖。</li><li><strong>注意睡觉</strong>，睡觉能够恢复每日因锻炼造成的身体磨损，长时间的睡眠对大强度的运动恢复很重要，有几次甚至我睡的时间超过12个小时，那天是第一次骑行40公里且游泳，睡觉，这很重要。</li><li><strong>规律作息</strong>，工作中常态的加班，导致自己在一段时间的紊乱作息之后，彻底无法恢复，而这一年的休假，在初期的混乱之后，作息逐渐正常，尤其是最近锻炼之后，睡眠质量更是好了很多，稳定的作息对身体激素的分泌是有好处的，这点很重要。</li></ol><h3 id="调整饮食"><a href="#调整饮食" class="headerlink" title="调整饮食"></a>调整饮食</h3><p>因为自己有中度脂肪肝，超重，高血压，高血脂，且有肾结石的隐患。</p><p>所以，食谱的制定方向是很容易确定的，而且，也都是医生老生常谈的话题了。</p><p>但这些说辞在实际饮食中，估计很多人都不知道怎么改，又或者没有上心进行特别研究，这里我将自己的策略作为例子放一下，仅供参考。</p><ol><li><strong>低油盐</strong>，针对高血脂和高血压，脂肪肝，盐目前都是捏一点放进去，油基本不沾，直接空气炸锅不加油，或者是炒菜的时候少放，减少日常生活中的火锅和烧烤，控制额外的油盐摄入。</li><li><strong>增加蛋白质</strong>，针对最近运动的补充，因为初期运动对肌肉的损失比较严重，所以需要补充蛋白质。这点选择水煮鸡胸肉比较好，因为鸡胸肉成分较为单一，蛋白质含量较高，且水煮过后，几乎没有油脂。而鸡蛋的蛋黄有一定的固醇，对血脂可能不太好，尽量少吃。当然，就个人而言，煮鸡蛋做起来方便，吃起来简单，早餐鸡蛋配煎饼，随便配点酱菜就能下肚。</li><li><strong>减糖分</strong>，也就是减少碳水，这点针对体重，尤其是米饭和挂面，高GI值，很容易造成碳水摄入超标，如果可以，尽可能的多砍一些，仅做到饱腹感即可，不要每顿吃到撑，目前吃挂面的一顿摄入量也从2两减少到1两重。</li><li><strong>多吃水果</strong>，补充维C，水果只能当辅餐，适用于运动后补充，避免饥饿感，也可以作为前期轻断食的早餐。</li><li><strong>增加饮水</strong>，针对肾结石的问题，只能多饮水了，但是不能在一段时间内狂饮，尊重身体的代谢规律，在日常生活中增加饮水量即可。</li><li><strong>轻断食</strong>，16+8 断食法，8小时内吃完两顿，完成一天的饮食摄入，剩下的16小时不吃，要么就稍微吃点水果填填肚子，解决掉就行。</li></ol><h3 id="运动选择"><a href="#运动选择" class="headerlink" title="运动选择"></a>运动选择</h3><p>体重105 KG，所以减重无法选择跑步等运动，最终能选择的方向也只有那几个，将来体重减少的话，可能会选择其他运动。</p><p>现在，经过参考和选择之后，锚定在骑行和游泳这两个运动上。</p><ul><li><strong>骑行</strong>，是因为成本相对便宜，而且是个便捷的交通方式，能够让人走到很多地方。</li><li><strong>游泳</strong>，是因为这个热量消耗较高，不伤膝盖，强化腰背，锻炼起来不痛苦，并且很解压，能作为将来工作时候平衡心情的运动，所以很值得选择。</li></ul><p>这里浅谈一下运动中的及两种运动中的注意事项，仅仅说的是对安全注意事项，不包括运动的具体准备。</p><ol><li><strong>注意时间</strong>，剧烈运动前后一个小时不要吃饭，会影响胃部供血，长期会导致肠胃问题。</li><li><strong>注意补水</strong>，就是普通的整点盐水就行，调味可以按照自己的需求加点别的，我自己扔了个泡腾片感觉味道还不错。保证自己身体不会进入脱水状态，就是所谓的电解质失衡，自己整个脉动也行。</li></ol><h4 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h4><ol><li><strong>防风</strong>，不然冬季骑行大概率不是锻炼，而是骨科病症的催化剂，尤其是膝盖和腰部需要注意保暖。</li><li><strong>蹬腿</strong>，调整座位和脚蹬的距离，保证自己的腿是能蹬的开，确保是直上直下，这对膝盖有好处的。</li><li><strong>配灯</strong>，因为有可能是夜骑，所以前后灯光最好都配一下，便于路上标识，省的路灯暗的时候被撞。</li></ol><h4 id="游泳"><a href="#游泳" class="headerlink" title="游泳"></a>游泳</h4><ol><li><strong>热身准备</strong>，不然容易腿抽筋，确实不伤膝盖，在下水锻炼之前，最好多做几组拉伸运动。</li><li><strong>配带泳镜</strong>，游泳学习必备，防止眼睛出结膜炎，泳池的水很脏，而眼睛很脆弱</li><li><strong>注意洗浴</strong>，否则皮肤和头皮在游泳后会很难受，防止头发和皮肤出问题。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>回顾这段时间的经历，真的是又是一种全新的生活体验，不讨厌，也谈不上喜欢。</p><p>这不仅仅是少吃一顿，或者是每天多运动几个小时这么简单的问题，因为时间分配的改变，自己平日的关注方向和日常喜好都开始往另一个方向偏移，感觉很微妙。</p><p>我会花费一年时间尽快完成这段经历，希望尽快恢复健康吧，我有点讨厌这种被一件事牵着鼻子走的感觉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酸辣鸡胸肉汤</title>
      <link href="/2023/12/04/%E9%85%B8%E8%BE%A3%E9%B8%A1%E8%83%B8%E8%82%89%E6%B1%A4/"/>
      <url>/2023/12/04/%E9%85%B8%E8%BE%A3%E9%B8%A1%E8%83%B8%E8%82%89%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<p>慢菜，不过容易做，价格便宜，且味道不错，可以作为休闲菜记录下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这个菜的起手方式比较通用，蒜，辣椒爆香，炒肉。</p><p>前半段算是常规的辣子鸡的做法，本来到此打算结束来着，但是是</p><p>至于加入蘑菇，加醋和水，这两个操作单纯是自己按照个人喜好调了一下，没想到味道意外的不错，有点大学时候吃酸汤肥牛的感觉。</p><p>所以，姑且就把这次的菜，命名为酸辣鸡胸肉汤吧。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>这里边的数据只能做个参考，实际情况按照每人调配的情况为准</p><table><thead><tr><th>指标</th><th>数据</th></tr></thead><tbody><tr><td>时间</td><td>30 min</td></tr><tr><td>价格</td><td>5元左右</td></tr><tr><td>重量</td><td>520 g</td></tr><tr><td>热量</td><td>300大卡左右</td></tr></tbody></table><h3 id="调料"><a href="#调料" class="headerlink" title="调料"></a>调料</h3><ul><li>植物油，铺锅底一点点就行</li><li>盐，捏点就行</li><li>蚝油，挑几筷子，稍微放点</li><li>醋，多加点</li><li>味精，捏点就行</li><li>烧烤料（辣椒粉，孜然粉，黑胡椒粉等）</li></ul><h3 id="备菜"><a href="#备菜" class="headerlink" title="备菜"></a>备菜</h3><p>之所以这里加蒜黄，是为了自己降血脂用，具体每种备菜的多少，按自己喜好稍微调整</p><ul><li>几颗辣椒，随便切切，如果是腌制辣椒更好</li><li>几颗蒜，拍平随便切切，</li><li>一瓣蘑菇，巴掌大，撕成条，最好是平菇</li><li>一块鸡胸肉，撕成条，空气炸锅热处理一下（160度 20 min）</li><li>蒜黄两颗，随便切切，半指长就行</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>这里我用的是电磁炉，全程2400度，最后煮的时候才是3500大火</p><ol><li>鸡胸肉焯水之后，用空气炸锅炸20 min做备用菜</li><li>热油，加入蚝油，听到油响声，加入辣椒和蒜，开炒</li><li>等到油开始炸了，放入炸好的鸡胸肉，蘑菇，醋，让肉和蘑菇入酸味</li><li>翻炒1 min左右，加水，煮5 min左右</li><li>最后撒上蒜黄，稍微煮一下</li><li>出锅，装盘</li></ol><p>建议配合面饼吃，这个鸡胸肉的嚼劲配合面饼还是带劲的，配饭吃的话，稍微浪费了这个口感。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是第一次在个人博客中记录自己做菜的经历，虽然有点怪，但排除刷锅和刷碗的麻烦，做菜真是一个让人心情放松的事情啊。</p><p>不过，这也许是因为这段时间闲着，才会有这种心态吧，不知道未来忙起来的我，会不会还认为做菜是个放松的事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 做菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次游泳</title>
      <link href="/2023/12/01/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%B3%B3/"/>
      <url>/2023/12/01/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%B8%E6%B3%B3/</url>
      
        <content type="html"><![CDATA[<p>关于游泳，在一开始设计骑行的时候，就规划了，但是真到了做起来的时候，还是有点期待和紧张。</p><p>特别记录一下自己这段时间的经历，说不定未来会用得上这次的经验，这里也分享出来，说不定有朋友用得上。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>市中心游泳馆距离自己所在位置是20公里，骑行过去一小时左右。</p><p>之后，再进行游泳这样的大体力消耗，以我现阶段200斤的肥肥体重，感觉力不从心，但还是血脂血压一直超标，需要尽早处理，我需要这个高效的运动方式。</p><p>所以，这个运动得尽快学会，这对将来会是个不错的选择。</p><h3 id="游泳优点"><a href="#游泳优点" class="headerlink" title="游泳优点"></a>游泳优点</h3><p>关于游泳的优点，很多人都已经吹过了。这里结合自己的体验，大致总结了一下自己感受到的优势</p><ol><li>散热快，水里很快就能把身体产生的热量散掉，流汗的感觉几乎没有</li><li>体感弱，因为游泳过程较为放松，虽然后边体力明显感到下降，但是你最后居然不会觉得很累</li><li>对腰好，平日其他运动锻炼不到背肌，但游泳确实对背部和腹部的锻炼效果很明显</li><li>换装快，不担心像常规运动一样换衣服，洗过澡后，穿衣服和平常一样，适合冬季这种衣服多的季节</li><li>效率高，热消耗速度很快，对时间要求不高，只要抽个整块的时间就好</li></ol><p>而且，在今后的工作里边，如果每周工作时间吃紧，游泳将会是很好的解压和消耗方式，对于热量消耗的效率来说，游泳也确实是最快的。</p><h3 id="场地选择"><a href="#场地选择" class="headerlink" title="场地选择"></a>场地选择</h3><p>市体育中心游泳馆，综合考量了本地的所有场地之后，最终选择了这里，优势如下</p><ul><li>有吹风机，保证游完之后可以吹干头发</li><li>冬季游泳人数少，空间大方便活动</li><li>室内保暖，水温恒温，水质看着还可以</li><li>有私教，而且支持一对一，一对多教学，方便时间安排</li><li>周边有体育用品的商店，缺设备了可以直接买</li><li>周边饭店较多，如果某天实在饿，可以考虑去补餐</li></ul><p>目前看来，唯一的缺陷就是没有微波炉，我本来想带点吃的过去直接打热补餐的，现在看来不需要了。</p><h3 id="游泳准备"><a href="#游泳准备" class="headerlink" title="游泳准备"></a>游泳准备</h3><ul><li><strong>泳裤，泳镜，泳帽，耳塞</strong>。泳裤不用说，耳塞是为了防止自己中耳炎的问题，泳帽尽可能减少头发沾水，因为还要回去的，至于泳镜，考虑到进水想看东西，防止眼睛受水刺激，我觉得还是得戴。</li><li><strong>大瓶装自制电解质水，煮鸡蛋，苹果</strong>。游泳之后会很饿，所以得加餐压肚子，补充蛋白质很重要，另外少部分的碳水也能缓解体内碳水丢失的问题</li><li><strong>入场前散步半小时。</strong>因为是长途骑车过去的，所以一开始身体热量很大，需要散热至常温再游泳，防止因为温差导致感冒。</li></ul><h3 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h3><p>为了保证自己的体力，至少保证自己没有过量运动，毕竟现在是大体重时间，运动要小心。</p><ul><li>单日休息，学习的时间就骑电动车过去。</li><li>双日骑行，保证每周骑行100公里以上。</li><li>保证每周游泳三公里以上</li></ul><h3 id="目标规划"><a href="#目标规划" class="headerlink" title="目标规划"></a>目标规划</h3><ul><li>学会蛙泳，能初步进行常规游泳的水平</li><li>尽可能一小时内游一公里的距离</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管知道短期高速减重对身体负荷很大，但是再不把体重压下去，过了30，估计身体真的要出问题。</p><p>已经到了今年的最后一年了，是该把年初的减重计划继续执行了。</p><p>之前耽误了不少时间，现在快到年底了，尽可能的完成一部分目标，亡羊补牢吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次长途骑行</title>
      <link href="/2023/11/28/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/"/>
      <url>/2023/11/28/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>没想到自从初中毕业之后，第一回骑行超过40公里。</p><p>这种距离的骑行，简直离谱，这里先记录一下本次骑行的感受。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次骑行目的单纯的是为了去驾校拿驾照，市车管所距离我所在的居住点22公里左右，来回也就是45KM左右。</p><p>这个距离通行很是问题，目前我的通行方式有如下几种方式。</p><ul><li>坐公交，来回大约需要付出5小时左右的时间，花钱不超过20</li><li>出租车，来回大约需要1.5小时左右的车程，花钱大约需要200</li><li>骑电动车，来回大约3小时，不要花钱，但基本上单趟可能就没电了，中间充电需要最起码两到三小时</li><li>骑自行车，预计需要4小时起步，不花钱，但是对意志和体力是个极大的考验</li></ul><p>考虑到我这次不需要考试，没有时间上的要求，而且我最近正在进行体能恢复期，最后我选择骑行。</p><h3 id="骑行准备"><a href="#骑行准备" class="headerlink" title="骑行准备"></a>骑行准备</h3><p>因为本次骑行是冬季，所以做的准备还蛮多的，这一套装备下来，还行，不算太贵，粗略算了一下，也就不到一千，属于丢了不心疼的类型。</p><ul><li><strong>500左右的自行车</strong>，摔着不心疼</li><li><strong>灯光配件</strong>，大灯和车尾灯，保证天黑的时候自己不会被撞</li><li><strong>骑行手机支架，</strong>保证路上有导航不会迷路</li><li><strong>软车垫</strong>，屁股不会硌得慌</li><li><strong>耳机，漫步者的X3air</strong>，便宜丢了不心疼，音质还不错，不过不能通话，而且入耳式有点难受</li><li><strong>充电宝</strong>，骑行距离较远的情况下使用，</li><li><strong>防风的厚衣服，骑行服也可以</strong>，保证自己不受冷</li><li><strong>防风护膝</strong>，保证膝盖不受冷</li><li><strong>骑行风帽，围脖，手套</strong>，保证路上不受冷</li><li><strong>骑行护腰</strong>，保证屁股和腰不受冷</li><li><strong>自制电解质水</strong>，用保温壶装的，保证自己骑行过程中可以及时补充电解质和水分</li></ul><h3 id="骑行数据"><a href="#骑行数据" class="headerlink" title="骑行数据"></a>骑行数据</h3><ul><li>单次极限最大骑行距离：30km</li><li>配速：12km&#x2F;h左右</li><li>消耗大卡：240大卡&#x2F;10km</li></ul><p>以上数据是根据高德地图的给出的数据总结的，不过最大骑行距离是我个人的体感，估计未来会随着身体适应会增长。</p><p><strong>超过30KM这个距离</strong>，四肢会发冷，身体会极度饥饿，思维会止不住的往食物上思考，意识难以正常思考，对食物的渴望一度让我回想起很早之前离家流浪的时间，而且身体热量无法维持衣物保温的感觉。</p><p>饥饿甚至让我不自觉的想哭，明明我不是一个这么脆弱的人，但是我在骑行的最后那段距离，真的有点绷不住，不是理性上的，是情绪上的不对劲。街边很长一段距离找不到一家开着的饭店，甚至是普通的便利店！才下午5点，天一黑久关门的吗？！</p><p>我尽力用意识驱动身体，但是奈何腿部就像是不听使唤的软了一样，一用力眼前就有点发晕发黑。</p><p>30KM，这个距离似乎就是意志的极限，无论怎样想强迫身体行动，我都用不上力。</p><p>果然，像小说中用意志突破身体极限这种事想想就行了，现实还是老老实实吃饭。</p><p>所以，接下来的骑行距离，必须控制在30km这个距离来处理。</p><p>幸亏这时候有个餐馆，一盘土豆丝加十张煎饼总算压住了饥饿感，顺便老板还借用了充电器，总算把手机的电量也补上了，这要是没补上手机的电量，之后的10KM，估计得抓瞎。</p><p><strong>总结，必须要做好骑行规划！</strong></p><h3 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h3><p>大方向依然是减重，但是思路得改改，光靠饿，确实不够。</p><p>之前，靠着减餐加些许的体力活，2个月极速减短了15公斤左右的体重，然后就很难再压下去了。</p><p>而且，可能是由于饿下来的体重，最近一个月，两餐恢复到三餐，体重又开始上升了。</p><p>看来，大体力的日常训练还是需要提上日程的，必须的早点在进入工作前，将自己的体重压到正常状态。</p><p>目前因体重较大，无法进行跳绳、跑步等运动，所以，接下来需要提升心肺能力，增加基础代谢，同时减少体重，保证之后这些运动不难么损伤膝盖。</p><p>综上，我大概确定自己的骑行的目标，除了体重，其他暂时模糊一些，保证自己能够便于调节。</p><ol><li>提升自己的心肺能力，为接下来的运动做准备</li><li>提升自己的基础代谢能力，增加脂肪的消耗</li><li>摸清楚自己骑行的行动范围，便于规划行程</li><li>明年一月前，体重减至95KG左右</li></ol><h3 id="地点规划"><a href="#地点规划" class="headerlink" title="地点规划"></a>地点规划</h3><p>关于老家周边的景点，暂时不做长期规划，就自己最近当短途骑行练手了。</p><p>这里先放一些未来打算长期光临的功能地点，作为骑行终点。</p><table><thead><tr><th>目的地</th><th>距离</th><th>作用</th></tr></thead><tbody><tr><td>翰景园</td><td>21.7km</td><td>朋友家，他是独居的，可以用来做整修的篝火点</td></tr><tr><td>市体育馆</td><td>20.3km</td><td>有恒温游泳馆，冬季可以游泳</td></tr><tr><td>市图书馆</td><td>21.6km</td><td>可以去借一些社科类书籍</td></tr></tbody></table><h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><ol><li>骑行尽可能选择有店面的路途，不至于路途上补水都困难。</li><li>出发时间尽可能选在早上10到12点，有太阳，不会冷</li><li>出发时候可以稍微吃点，但是骑行到30KM，停下随便吃点，喝点水也行，保证自己的胃不至于干扰到大脑的判断</li><li>减少对高油脂类的肉食摄入，不然累死累活减少的热量，一吃肉全补回来了</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>意志不是万能的，不要相信小说里边意志支配一切的说法，体能训练，必然是要循序渐进的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《程序员修炼之道》</title>
      <link href="/2023/10/27/%E8%AF%BB%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/"/>
      <url>/2023/10/27/%E8%AF%BB%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>很早之前，在初步工作的时候，我的上级推荐了这本书，但那时忙于工作，没有阅读。</p><p>最近闲下来了，无事读了一下，只觉得很鸡肋。倒不是书里边说的不对，而是很多话很务虚。</p><p>对于职场新人来说，这书是有用的，但对于老工具人来说，这些说的大概率是基本常识。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来想按照书中的目录来做摘要，但是想了想，我觉得还是按照自我理解进行总结比较好。</p><p>这本书的核心，是给新手上路的程序员梳理了一套工具人的做事准则和标准，讲的更多是偏向于思路和准则，而非具体的行事手段。</p><p>所以，这里也只是做个概括和总结，不会在细节上深入探讨。</p><h3 id="角色分类"><a href="#角色分类" class="headerlink" title="角色分类"></a>角色分类</h3><p>于个人而言，一个程序员能在开发团队中无非扮演三个角色：<strong>协调者</strong>，<strong>开发者</strong>，<strong>项目猎手</strong>。</p><p><strong>项目猎手</strong>：负责和甲方进行需求谈判，往往会承担一定的产品经理的功能。这个角色不要求有多少开发能力，更偏向于设计者和商务人员，需要非常强的沟通能力。如果有很深的商务或政治背景，那更是如虎添翼。因为我涉及的比较少，所以这里不会涉及更多的讲解。</p><p><strong>协调者</strong>：一般是项目组长，团队leader，负责协调工程开发的人员和工期安排，以及其他的资源调度。</p><p><strong>开发者</strong>：工具人，负责解决具体的目标的落实，高级开发会负责攻克技术难点，普通开发负责完成常规的堆量任务。</p><h3 id="通用准则"><a href="#通用准则" class="headerlink" title="通用准则"></a>通用准则</h3><p>这里首先列举一些通用准则，无论是协调者和开发者，都需要遵循的做事准则。</p><ol><li><strong>不断学习，提升个人开发能力</strong>，对个人开发能力的提升，都是毋庸置疑的，不过协调者只需要了解大概，后者则需要将开发技术用到纯熟。</li><li><strong>提供方案，而非借口</strong>，无论是推卸责任，还是挑起大梁，当项目发生问题的时候，需要的是一个至少是能说服大多数的解决方案，而不是随意的借口用来推脱，很多项目成员用借口来推脱工期，很容易造成项目整体的迟缓。</li><li><strong>防微杜渐，不要破窗</strong>，在项目工期允许的情况下，尽可能的不要留下烂代码，这些埋下的雷，早晚会让自己陷入项目崩溃。</li><li><strong>不要技术追星，稳定压到一切</strong>，项目中使用新技术，一定要保证自己能够把持住，否则新技术的使用，有可能让项目整体陷入停摆。</li><li><strong>模块不耦合，独立功能块</strong>，功能尽可能的独立分割，这会让工程问题的排查和联调方便很多，后续独立升级也会方便。</li><li><strong>学习项目领域的知识</strong>，无论是开发人还是协调人，对于项目涉及领域的知识都要有一定的学习，这样才不会被甲方牵着鼻子走。</li><li><strong>文本工具很重要</strong>，除非个人的记忆能力几乎达到过目不忘的地步，否则不推荐脑记，最好用本子或者是文本工具记录每日的需求及任务，管理好需求。</li></ol><h3 id="协调人角度"><a href="#协调人角度" class="headerlink" title="协调人角度"></a>协调人角度</h3><ol><li><strong>有敏锐的技术嗅觉，做项目的变革者</strong>，如果一项新技术能大幅缩短开发周期，减少工作量，那么在你能掌握的情况下，可以试着引入项目中，推动项目变革，这需要你来做这个决断，也需要靠谱的组员来执行，请确定自己的团队在整体有意愿升级的情况下，再做出这个决定。</li><li><strong>不做最终决定，尽可能做预案</strong>，如果你是甲方，可以无视。但是大多数情况下，我们只能不断和甲方做沟通，给出一个方案，然后在确定一个基础版本的情况下进行迭代，推进任务进度。</li><li><strong>牢记全景，关注进度</strong>，无论是每日的快速会议，或者是日报周报，都是为了增加对项目的掌控力，不至于让开发进度失控，目前常规的做法就是日报周报，但是如果你对团队足够信任，团队又足够的自律，其实只需要周报即可。</li><li><strong>做好版本管理</strong>，一个稳定的版本管理，会让所有的意外都有个回档点，这会让所有人的工作量有个读档位置，作为协调者，一定要管理好每人每日的工作量。不然团队工作量的丢失会让团队闹出很大的不愉快。</li><li><strong>做好评估，排好日程</strong>，安排任务的时候，如果时间允许，就要预留一些冗余的时间来防止意外，而任务一旦确定，就要在管理平台或者是文本上做好记录，这便于后续做工作量的评估和管理</li></ol><h3 id="开发人角度"><a href="#开发人角度" class="headerlink" title="开发人角度"></a>开发人角度</h3><p>相对于协调人的角色，我更多的扮演了开发人的角色，所以这里会更多的提到开发角色应做的事情。</p><h4 id="做事准则"><a href="#做事准则" class="headerlink" title="做事准则"></a>做事准则</h4><ol><li><strong>学会反馈，做好沟通</strong>，所谓的沟通不是那种世俗的拍马屁，那种狗屎一样的传统文化必须尽早放弃。这里的沟通，更像是游戏中的报点和卡位，你的反馈就是项目协调者的眼睛，哪怕你遇到了解决不了的问题，一定要反馈，这样协调人才知道给你批多少时间才能解决你遇到的问题，需要给你协调什么资源解决这个问题。</li><li><strong>不越雷池半步，不要画蛇添足</strong>，每次任务迭代，要做什么事情，在任务规划好之后，完成自己的任务即可，不是自己完成部分，不要动，哪怕你知道那里有问题，要和协调人反馈，告知他问题所在及解决时间和方案，由协调者确认后再开始评估。</li><li><strong>自行开荒，他人即地狱</strong>，不要随意让他人涉及你的代码！这是你的工作！哪怕是实在解决不了的地方，在和团队中的高手沟通后，你只有两个选择，要么这个模块不归你负责，要么此后独自开荒。哪怕是一片荆棘，这条路也必须是你来走。</li><li><strong>做好开发者的个人信用</strong>，如果你承担了任务，哪怕再难也只能完成。你的完成程度，将决定协调者对你的评级，决定同为开发人对你的评价，做好开发任务，会让你在团队中成为可靠的存在，这会让你在技术方案决策中拥有更好的话语权。</li><li><strong>不要动已经很稳定的东西</strong>，这点是违反书籍里的说法的，但是实际操作的过程中，无数次验证了这个信条，当一样代码运行的很稳定的时候，不要随意的改动。除非是协调人给了充足的时间去重构，否则这里的变动会让整个项目发生崩溃。</li></ol><h4 id="编码准则"><a href="#编码准则" class="headerlink" title="编码准则"></a>编码准则</h4><ol><li><strong>简单有意义的命名</strong>，开发过程中，不要随意命名，这会让团队和自己最后陷入迷魂阵，增加开发难度，拖延开发进度。</li><li><strong>用简单快速的算法实现任务</strong>，早年会对算法的速度有要求，但是现在机器性能上升，可以考虑用简单的算法，这样便于他人接手，也便于自己排查。当然，如果能明显的提升速度，那么就用更快速的算法实现任务。</li><li><strong>多做测试</strong>，虽然开发的最后会有测试来做评价，但是实际开发的过程中，如果自己测试好，保证自己的开发质量，那么在后续的联调中，将会非常容易的完成对接，减少工作量。</li><li><strong>保持简洁</strong>，代码的实现不要整的太过于复杂，在保质保量的情况下，越是简单的代码，越好排查。</li><li><strong>倾听直觉</strong>，当你觉得代码编写总是出问题，举步维艰的时候，可以停一停，和他人交流或者去搜索引擎查查方案，这是你的直觉在告诉你，有更简单的方案。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本书毫无疑问是新手程序员的上路指南，很全面，很基础，挺好的。</p><p>但阅读体验不佳，笔者似乎是奔着写论文的感觉来说的，行文很拧巴，也可能是翻译腔的问题。</p><p>只能说上级推荐的时候，对当时的我来说很有用，但是现在的我已经远不是当初的我了。</p><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《程序员修炼之道通向务实的最高境界(第2版)》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觅长生仙术渡劫</title>
      <link href="/2023/10/25/%E8%A7%85%E9%95%BF%E7%94%9F%E4%BB%99%E6%9C%AF%E6%B8%A1%E5%8A%AB/"/>
      <url>/2023/10/25/%E8%A7%85%E9%95%BF%E7%94%9F%E4%BB%99%E6%9C%AF%E6%B8%A1%E5%8A%AB/</url>
      
        <content type="html"><![CDATA[<p>本来是打算随便玩玩的游戏，却没想到仿佛真像是活过一世，大梦一场。</p><p>梦醒之时，依然是叹息，心态似乎也是超然了一些，人活一世，不过如此吧。</p><p>这里顺便也分享一下自己的渡劫心得，算是为这场大梦的画上终结的句号。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>火修渡劫是我考虑很久的想法了，终于玩到这最后的关卡了。</p><p>之前每次过境界关的时候，大多都是抄铁臂猿攻略的。</p><p>但渡劫这个关算是游戏的最后一关了，我拿着最好的资源，好不容易走到这里了，如果最后不是自己走完，实在是有些遗憾。</p><p>所以，我根据手里收集的功法，还有根据攻略的查找，我大致设计了一套。</p><p>经过半天的测试，这套思路基本上不怎么需要太凹，大多数仙术都非常容易获取。</p><p>不过，玩家要保证每回合仙术要准确使用灵气，只要使用得当，飞升不是问题。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>目前有两个思路，打击流和挨打反击流</p><ol><li>纯干，直接在最后的灭世劫之前干爆天劫，每个回合都先放积仙术，再用火仙术干就完事了。</li><li>叠血反打，前期叠血量上限，在最后的雷劫里，用火仙术打击，保证剩下的血量即使挨打也没有问题。</li></ol><p>最后权衡了一下，我决定用第二个，主要原因是第二个效果虽然没那么霸气，但是要求不高，不需要凹灵气获取的聚仙术和运仙术。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>血量最好在3.8万以上，尽量和道侣多双修增加血量上限</li><li>预留1000年以上的寿命，不然烬仙术会把自己烧死</li><li>准备好以上提到的仙术</li><li>化神大圆满，可以减伤12%</li><li>化劫丹，减伤10%（可以不用，因为我就没用这个）</li></ol><h3 id="雷劫"><a href="#雷劫" class="headerlink" title="雷劫"></a>雷劫</h3><p>大多数雷劫都不需要注意，只有以下几个雷劫需要注意。</p><h4 id="需要注意的雷劫"><a href="#需要注意的雷劫" class="headerlink" title="需要注意的雷劫"></a>需要注意的雷劫</h4><p><strong>风火劫</strong>，灵气多一点，伤害提升5%，不过基础伤害不高，而且是前期的雷劫，灵气不会存太多，所以还好说</p><p><strong>五行劫</strong>，第五回合回重置灵根权重，且消散所有灵气，第五道</p><p><strong>罡雷劫</strong>，每损失1%生命，则受到的伤害额外提升1%</p><p><strong>生死劫</strong>，附加剩余血量的一半的伤害，第七道</p><p><strong>灭世劫</strong>，附加1w点真实伤害，如果有声望-1000，本次攻略是没法过的，火的伤害不够</p><h4 id="渡劫流程"><a href="#渡劫流程" class="headerlink" title="渡劫流程"></a>渡劫流程</h4><p>随便让雷劈，除了最后一个，无论什么劫，随便劈，劈完之后，把血加上就行。</p><h5 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h5><ol><li>前八劫保证使用滞，气，烬，运，保证每回合的灵气获取，如果灵气多了，就用聚仙术把多余的灵气存到下回合。</li><li>第九劫之前，不要叠盾，要淬体加血量上限，尽可能不要去攻击雷劫，毕竟那都是血量上限</li><li>第九劫之前，尽可能的多存灵气，每回合多存点灵气到下一回合，最后一回合，一定要多存灵气，然后调出火灵气，能用火灵气打散雷劫的伤害，保证自己最后一回合不会被雷劫劈死。</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><h6 id="第一劫"><a href="#第一劫" class="headerlink" title="第一劫"></a><strong>第一劫</strong></h6><ol><li>本回合必须使用淬仙术</li><li>无论是什么劫，一定要在雷前后，把火木权重都加50，保证接下来大部分是这两种灵气，能使用大部分法术。</li></ol><h6 id="第五劫"><a href="#第五劫" class="headerlink" title="第五劫"></a><strong>第五劫</strong></h6><ol><li>保证自己的血量不会被劈到1w以下，尽可能的补血，如果感觉补血抗不下来，就用火灵气打散一部分劫云的伤害。（不过理论上不需要）</li><li>五行劫会重置权重消散所有的灵气，在第五雷劫之后，补上火灵气权重，在第六劫的时候，补上木灵气的权重</li></ol><h6 id="第六劫"><a href="#第六劫" class="headerlink" title="第六劫"></a><strong>第六劫</strong></h6><ol><li>让雷劫尽可能的劈，劈完之后，不要加血，剩下差不多8k容错就够了，因为第七劫血量越多，额外伤害越高</li><li>预留更多的灵气，在第七回合保证自己能打散主要的雷劫伤害</li></ol><h6 id="第七劫"><a href="#第七劫" class="headerlink" title="第七劫"></a>第七劫</h6><ol><li>适量打散雷劫，保证主要伤害加上额外伤害劈不死就行</li><li>第七劫之后，用体，丹仙术，增加血量和灵气，存到下回合</li></ol><h6 id="第八劫"><a href="#第八劫" class="headerlink" title="第八劫"></a>第八劫</h6><ol><li>存够足够的灵气，能压到最后的回合用来决战</li><li>在保证有足够的灵气，尽可能的回血，增加容错（体仙术回血不错）</li><li>可以不用气仙术了，因为这时候再增加灵气上限也没什么意义了，下回合直接决战了</li></ol><h6 id="第九劫"><a href="#第九劫" class="headerlink" title="第九劫"></a>第九劫</h6><ol><li>保证血量在3.5w左右基本上够数。</li><li>全力输出劫云，干就完事了，估计能把伤害压到3万没有问题。</li></ol><h3 id="仙术"><a href="#仙术" class="headerlink" title="仙术"></a>仙术</h3><h4 id="加牌仙术"><a href="#加牌仙术" class="headerlink" title="加牌仙术"></a>加牌仙术</h4><p>存牌，加牌，增加手牌上限</p><ol><li><strong>滞</strong>，受1000伤害，换本回合8点灵气，下回合少5点灵气</li><li><strong>聚</strong>，抽牌回合加牌加4点灵气，有人能做到5点灵气获取，但是我懒得凹了，就随便换了一个，用来存牌</li><li><strong>气</strong>，灵气上限+1，下回合多抽一点灵气</li><li><strong>烬</strong>，消耗50年寿元，1换2</li></ol><h4 id="洗牌仙术"><a href="#洗牌仙术" class="headerlink" title="洗牌仙术"></a>洗牌仙术</h4><p>一定要在使用转仙术改了权重之后，再去调灵气，增加灵气容错率</p><ol><li><strong>运</strong>，洗杂灵气，3换3，有人能做到3换4，但是我懒得凹了</li><li><strong>转</strong>，修改灵根权重+50，用来渡五行劫之后的问题</li></ol><h4 id="回血仙术"><a href="#回血仙术" class="headerlink" title="回血仙术"></a>回血仙术</h4><p><strong>淬，体</strong>仙术必带，<strong>焰，丹，愈</strong>带着是为了用来回血，增加容错率</p><p>这里推荐带愈仙术，补一下血量恢复，增加容错量，五行劫的时候，可以把多余的灵气用来补血。</p><p>如果感觉愈仙术难搞，可以整盾仙术，就是用来增加五行劫的容错率的，不然灵气消散实在可惜。</p><ol><li><strong>淬</strong>，10点雷劫伤害换1点血量上限</li><li><strong>体</strong>，恢复等同于已损失血量50%的生命</li><li><strong>焰</strong>，火灵气越多，回血效果越好，1点火灵气回400点</li><li><strong>丹</strong>，只能用一次，恢复4点灵气，10000点生命</li><li><strong>愈</strong>，5点灵气换5000血量</li></ol><h4 id="攻击仙术"><a href="#攻击仙术" class="headerlink" title="攻击仙术"></a>攻击仙术</h4><p>只要带火仙术就够了，存够足够的灵气，在最后的雷劫打伤害</p><ol><li><strong>火</strong>，3000点伤害。每剩1点火灵气，伤害提升200点</li></ol><h3 id="渡劫结果"><a href="#渡劫结果" class="headerlink" title="渡劫结果"></a>渡劫结果</h3><p><a href="https://www.bilibili.com/video/BV1Vp4y1w7Xj/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】首档飞升成功留念</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1Bo4y1i7hB/?share_source=copy_web&vd_source=a848031cce5c755167a3d6aa6bd87859">【浴火重生，怒焰焚天！觅长生火修渡劫通关（复活魏无极）】</a></p><p><a href="https://www.bilibili.com/video/BV1NF411f7jp/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】火修渡劫，只攻不防</a></p><p><a href="https://www.bilibili.com/video/BV18A411R7uC/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【觅长生】：解锁 逆天造化 七种常用仙术滚键盘渡劫成功（1）</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以前没有大段的时间来玩这种游戏，在考完试之后，尝试了一下，然后十分上头的玩完了。</p><p>可以说这个游戏是个真的好游戏，我仿佛真的是在修仙世界中活过一世，飞升之时也是久久难以释怀。</p><p>本来想写更多，还是当回文抄公，赋诗一首，以表心意吧。</p><p><strong>万般因缘皆是相，不教红尘惑心间。</strong></p><p><strong>千磨万击还坚劲，我命由我不由天!</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年第一次被骗</title>
      <link href="/2023/06/10/2023%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/"/>
      <url>/2023/06/10/2023%E5%B9%B4%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<p>万般皆是命，半点不由人，一波被清空了6.5万，是我自己亲手转过去的。</p><p>以前也有被骗过，但是金额如此之大，对我的生活影响如此之重，这是第一回。</p><p>现在想来，只能说事情已经被发生了，总结经验吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次的诈骗过程，我就不多说了，并未因为我贪心，而是我太信任官方了。</p><p>对方准备个人信息非常精准，甚至我的这段时间办理信用卡的事情都能知道，这太离谱了。</p><p>只能说是马老师遇上二百多斤大力士————有备而来，我也没有什么办法，只能说总结一下经验，避免下次在遇到吧。</p><h3 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h3><p>复盘了整个被骗的流程，只要涉及到金额转账，大概率按照以下的思维回路去想，应该是没错的。</p><ol><li><strong>大金额，到柜台操作</strong></li><li><strong>什么大事警局见，电话网络都不可信</strong></li><li>事情都是简单的，复杂的操作一切转柜台，不然转二</li><li>要做好对方知道你所有信息的准备，哪怕他报出了你的身份证号，银行卡号，还有所在学校，手机号，电子邮箱，都不要信，凡是转第二条</li><li>官方的态度一般很恶劣，平时银行都是爱吊不吊的，不会电话提供复杂操作的便利，出现什么复杂操作，一切转第二条。</li><li>尽可能的把钱多散在其他的几张卡中，哪怕真出现损失，也不会损失太多</li><li>最后，哪怕你不贪心，也不要嫌事情麻烦，如果遇到威胁，一切转二</li></ol><h3 id="拉斯格十诫"><a href="#拉斯格十诫" class="headerlink" title="拉斯格十诫"></a>拉斯格十诫</h3><p>这里放上经典杂种的话，虽然他做的事情都很狗，但是这确实是很有道理。</p><ol><li>永远耐心倾听对方诉说；</li><li>永远生机勃勃；</li><li>让对方先表明政治倾向，然后附和；</li><li>让对方先表明宗教立场，然后附和；</li><li>轻微地暗示性话题，但不要发挥，除非对方表现出强烈的兴趣；</li><li>不要谈论任何疾病，除非对方特别关注；</li><li>不要打听对方的私人情况（最终他自己会说）；</li><li>永远不要自吹自擂，自然明确地显示你的分量；</li><li>永远衣冠整洁；</li><li>永远不要喝醉。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>事情已经发生了，只能打乱计划重新来了。</p><p>原本计划到明年4月的内容，这次只能提速了，一切拉到今年10月份看看。</p><p>只要能做完计划中的任务，那也算是这趟休息没白休。</p><p>心里有着无尽的痛苦和愤怒，却最终只能无奈，这个世界，只有自己可以相信。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNF私服搭建指南——服务端部署</title>
      <link href="/2023/05/13/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/05/13/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>朋友最近想玩70版本的私服，正好腾讯云最近搞活动，想了想就搭建了这个服务器。</p><p>这里记录一下这个流程，毕竟私服搭建算是一个。</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你需要有以下的工具，在准备好以下内容之后，就可以进行服务端部署了。</p><ol><li><strong>一台linux云服务器</strong>，系统推荐使用CentOS 7.6 64bit，至于云服务的提供商，只要你是新人，随便哪家都可以，目前各家云服务商为了争新客户，对新人很优惠，老用户不如狗。</li><li><strong>一个SSH服务器链接工具</strong>。这里看到很多教程用Putty，但是用了几次感觉很难用，我个人推荐使用<a href="https://mobaxterm.mobatek.net/download.html">MobaxTerm</a>，下载使用free版本就行，免费可以连接十个服务器。</li><li><strong>一个服务端安装包</strong>。这里是推荐七月DNF的一键安装包，比很多教程中的各种安装好用了不少，我这里放一下<a href="https://pan.baidu.com/s/1BlY9OTYsUC5xpHuRO5mjtw?pwd=1234">百度云盘的链接</a></li><li>足够的有耐心，细心。整个服务端部署如果顺利，10分钟左右就能完成，不顺利的话，可能会有各种各样的意外</li></ol><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>这里略过服务器购买的过程了，这些东西就不讲了。</p><p>这里也默认大家将我以上的所有内容下载完毕，默认大家有一定的服务器使用知识，具体的细节我就不细讲了。</p><h4 id="连服务器"><a href="#连服务器" class="headerlink" title="连服务器"></a>连服务器</h4><p>如果对MobaXterm这里不清楚，可以参考<a href="https://www.bilibili.com/video/BV1NN4y1K7Np/?spm_id_from=333.337.search-card.all.click&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">教程</a>。</p><p>这里当然也可以使用其他的SSH链接工具，连接服务器。</p><h4 id="找到路径，上传服务包"><a href="#找到路径，上传服务包" class="headerlink" title="找到路径，上传服务包"></a>找到路径，上传服务包</h4><p>在服务器路径这里输入&#x2F;root，进入到服务器这个路径下。</p><p>然后将vip的服务端包放到&#x2F;root目录下，并在命令行中，启动该安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O dnf.7yvip.cn/vip;chmod +x vip;./vip</span><br></pre></td></tr></table></figure><p>剩下的，按照命令行的提示，无脑往下走就行，然后等待安装成功即可。</p><h4 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h4><p>如果我们需要在服务器端敲如下命令，启动安装包即可。</p><p>在linux中，.&#x2F;vip就代表执行这个安装包脚本，如果安装包的名字不一样，记得命令里边也换成安装包的名字，别弄错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vip</span><br></pre></td></tr></table></figure><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><p>我们这里需要进行<strong>数据备份</strong>，我们按照命令行选择对应的操作，然后一路按照提示设置下去即可。</p><p>备份好之后，我们服务器内会生成一个&#x2F;root&#x2F;mysqlbak&#x2F;的文件夹，之后，服务端会在我们设计的时长内进行一个备份，我们定期保存好这部分数据即可。</p><h4 id="服务重启"><a href="#服务重启" class="headerlink" title="服务重启"></a>服务重启</h4><p>数据回档或者其他的一些操作，可能需要停止服务器，这里可以按照如下操作。</p><p>注意，谨慎进行这些操作，不要随便执行，该操作容易对服务器内的数据造成影响。</p><p>如果方便，尽量让当前服务器内的玩家在对应时间段下线。</p><p><strong>停止服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stop</span><br></pre></td></tr></table></figure><p><strong>重启服务器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>SF运行真是个力气活，打死也不想参与这事儿。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/weixin_46526674/article/details/124864662">DNF单机版搭建（局域网、外网）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNF私服搭建指南——服务器选择</title>
      <link href="/2023/05/07/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/"/>
      <url>/2023/05/07/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>本文是转载帖，是在论坛正好看到的教程帖，非常不错，这里特地选择性的转载一下。</p><p>文末附上了原贴地址，有兴趣的可以参观原帖。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>朋友最近因为DNF官服和谐太多比较不爽，所以脱坑。</p><p>正好我手里有一台闲置的服务器，想了一下，决定搭建一个私服让朋友们私下玩玩。</p><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在线人数计算方式=带宽大小÷单人传输数据大小（360流量防火墙能看到具体数据值一般为50KB左右）</span><br></pre></td></tr></table></figure><h3 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h3><ul><li>处理器（核&#x2F;H）：处理器大小反映了服务器处理运算能力</li><li>内存（G）：内存大小关系到同时处理程序的数量多少</li><li>带宽（M）：  带宽会影响访问传输数据速度</li></ul><table><thead><tr><th>CPU</th><th>内存</th><th align="left">带宽</th><th>同时在线人数</th></tr></thead><tbody><tr><td>1</td><td>1</td><td align="left">1</td><td>10</td></tr><tr><td>1</td><td>2</td><td align="left">1</td><td>20</td></tr><tr><td>2</td><td>2</td><td align="left">2</td><td>50</td></tr><tr><td>2</td><td>4</td><td align="left">2</td><td>100</td></tr><tr><td>4</td><td>4</td><td align="left">5</td><td>200</td></tr><tr><td>4</td><td>8</td><td align="left">5</td><td>500</td></tr><tr><td>8</td><td>8</td><td align="left">10</td><td>1000</td></tr></tbody></table><h4 id="带宽备注"><a href="#带宽备注" class="headerlink" title="带宽备注"></a>带宽备注</h4><p>关于带宽，要注意，单位是M，不是mbps。</p><p>不了解的朋友可能会把带宽中的mpbs等同于M进行理解，这个是不对的，二者的换算关系如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8Mbps/8=1MB/S=1024KB/S</span><br></pre></td></tr></table></figure><p>如果有使用自家的服务器搭建的，大概能理解，比如千兆光纤对应的网络下载速度是125M&#x2F;s，就是这个意思。</p><p>所以，在挑选服务器的时候，一定要注意带宽单位，别选错了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的操作纯属玩票，预估100人左右就差不多了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bbs.aladedalu.com/thread-1265-1-1.html">DNF开服服务器配置如何选择参考指南 - DNF单机版 - DNF阿拉德游戏论坛 (aladedalu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> dnf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑装机及系统安装</title>
      <link href="/2023/05/05/%E7%94%B5%E8%84%91%E8%A3%85%E6%9C%BA%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>/2023/05/05/%E7%94%B5%E8%84%91%E8%A3%85%E6%9C%BA%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本来打算装完机就开始记录的，但是之后配置电脑环境和安装软件耽误了很多时间，一直忙到现在。</p><p>现在电脑安装一切就绪了，我也要记录这次多灾多难的安装过程。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，直接推荐<a href="https://www.bilibili.com/video/BV1BG4y137mG">硬件茶谈的教程</a>，确实做到了全网最细，没有之一。</p><p>但如果整个过程一步不差的按照他的流程走，大概率装机会出现一点小问题。所以，本次日志会记录自己的装机过程中的一些小插曲。</p><p>顺便，作为一个装机老白，也会记录自己整个装机过程的心得，以供参考。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>无论是让店家帮忙组装，还是自己挑选配置个人组装，都需要对自己的需求进行一波分析，合理规划，才不至于价格溢出。</p><p>这里放一下个人的需求及想法：</p><ol><li>电脑配置能游玩市面上大多数游戏，运行大型游戏时候，不会有硬件限制</li><li>能够运行AI跑图功能，本地安装实验性质的环境</li><li>运行速度足够快，不再使用机械硬盘（相对较慢）</li><li>剪辑视频的要快速读取素材，尽可能的加大内存（增加视频缓存量及读写速度）</li><li>外观要足够的漂亮，今年很长一段时间都会在家中，所以首选纯白海景房配合二次元套皮</li><li>配置要足够的稳定，寿命够长，五年内不会出现电源，冷排等硬件上的问题</li><li>声音尽可能的小，不要出现开机就是飞机起飞的状态</li><li>成本可以不计，但是尽可能的不要超过1万</li></ol><h3 id="硬件购买"><a href="#硬件购买" class="headerlink" title="硬件购买"></a>硬件购买</h3><p>根据上述需求，我大概选定了一些想法，从目前的市场来看，2023年说不定是最适合配电脑的一年。</p><p>这里浅谈一下我个人的理解，算是抛砖引玉吧，如果有不合理的地方，就做笑谈。</p><p>这里首先放一下配置表及具体购买原因。</p><table><thead><tr><th align="center">硬件名称</th><th align="center">型号</th><th align="center">购买原因</th><th>平台</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">主板</td><td align="center">华硕 PRIME Z690-P D4</td><td align="center">老厂商，值得信赖</td><td>京东</td><td align="center">3319</td></tr><tr><td align="center">CPU</td><td align="center">英特尔 12th Gen  Core i5-12600KF 十核</td><td align="center">主板套装</td><td>京东</td><td align="center">——</td></tr><tr><td align="center">散热</td><td align="center">利民冰封幻境360 瓦尔基里星环一体式水冷</td><td align="center">硬件茶谈店铺的货，质量有保证的</td><td>淘宝</td><td align="center">699</td></tr><tr><td align="center">内存</td><td align="center">威刚 64GB(2666 MHz &#x2F;  2666 MHz &#x2F;  2666 MHz &#x2F;  2666 MHz)</td><td align="center">国产，便宜，稳定</td><td>京东</td><td align="center">1067</td></tr><tr><td align="center">主硬盘</td><td align="center">致钛 2048 GB (ZHITAI TiPro7000 2TB)</td><td align="center">国产，便宜，稳定，有三个插槽，买了三个</td><td>京东</td><td align="center">3818</td></tr><tr><td align="center">显卡</td><td align="center">英伟达 NVIDIA GeForce RTX 3060 Ti (8192 MB)</td><td align="center">据说是一手货，而且外表够二次元</td><td>京东</td><td align="center">3248</td></tr><tr><td align="center">电源</td><td align="center">Seasonic 海韵电源80PLUS金牌FOCUS GX金牌全模1000W</td><td align="center">稳定，老牌子，没出过什么幺蛾子的厂商</td><td>京东</td><td align="center">1290</td></tr><tr><td align="center">机箱</td><td align="center">航嘉（Huntkey） S980龙卷风 全景侧透钢化玻璃 360水冷海景房游戏机箱</td><td align="center">性价比较高，买不起包豪斯</td><td>京东</td><td align="center">480</td></tr><tr><td align="center">显示器</td><td align="center">冠捷 AOC2701 27G1G4 (27.2英寸 &#x2F; 32位真彩色 &#x2F; 60Hz)</td><td align="center">之前剩的显示器</td><td>——</td><td align="center">——</td></tr></tbody></table><p><strong>合计13957，近1万4的价格，属实放大血，疼坏了。</strong></p><h4 id="核心套装"><a href="#核心套装" class="headerlink" title="核心套装"></a>核心套装</h4><p>关于Cpu和主板这个核心套装，本来是打算买散件拼的。</p><p>但是想了想，别费那个事儿了，我只是装机老白，又不是那种极客，没必要玩的太花，里边具体的门道我是不懂搭配的。</p><p>所以，这里直接上了华硕的车，华硕的板子，还是挺稳定得。</p><h4 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h4><p>矿潮差不多刚过去，现在的市面上，矿卡虽然也多，但是多少还是能用的。</p><p>那些屯卡的奸商，现在估计也看清形式了，卖便宜点儿至少有得赚，还按照矿潮时代卖是纯纯的傻子。</p><p>所以，如果要是想挑好用的矿卡，可以买<a href="https://kinology.world.tmall.com/shop/view_shop.htm?spm=a230r.1.14.14.718558d3jjB9Ek&user_number_id=1574891186">卡诺基</a>家的卡，人家是正儿八经的好用的翻新卡，出问题是可以换的。</p><p>本来我也打算弄一个，但是为了颜值（别问为什么，打了那么长时间的工，我就不能享受享受吗），我选择了铭瑄的小瑷珈。</p><p>据说这个3060TI不是矿卡，个人到手后测了一下，也没感觉有什么问题，所以应该信得过。</p><p>至于为什么是小瑷珈，不是大瑷珈，很简单，预算不足，而且需求也溢出了，我没必要上这么好的卡。</p><p>哦，对了<a href="https://item.taobao.com/item.htm?spm=a1z10.3-c-s.w4002-21402720416.28.72b5ccd8RB4e76&id=691104242791">硬件茶谈的店铺</a>里也有不错的显卡，当时我本来想弄一个来着，显存看着很大。</p><p>但是外观看了一下，感觉不够二次元，到最后还是退了换了小瑷珈。</p><p>有些时候，人确实容易着相啊。</p><h4 id="固态"><a href="#固态" class="headerlink" title="固态"></a>固态</h4><p>2023年的固态真的很便宜，m2类型的固态我年前买的时候，2t是近1000左右，现在我看了一下有些国产颗粒的固态已经掉到600不到了。</p><p>虽然不是最低价让我有些恼火，但是想到数年前，三星把固态当金条卖，天天动不动火龙烧仓，工人罢工，各家厂商就是死命抬价格的狗娘养的状态，我个人可以接受现在固态的价格。</p><p>就凭长鑫把固态和内存的价格打下来这点，我就得买它，而且，如果能让友商降价处理，那只能说明一点，这批货做的不错，被对家认可了。</p><p>如果长鑫颗粒一直和三星怼的话，大概率这种倾销价格还得持续不少时间。</p><p>我预感，这种低价至少今年应该一直会这样，价格很便宜，随便买。</p><p>而且，因为之前装机械盘用sata实在是太累，所以这次全部用M2，正好电脑上的固态位置比较多。</p><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>这个是我没怎么了解的地方，但是电源这个钱最好不要省，市面上有不少厂家虚标电源，实际用的时候，可能出现功耗不足的情况。</p><p>而且如果电源出问题，很容易导致所有硬件烧毁的可能，最好不要在电源这里用小聪明，建议买个好点儿的电源。</p><p>2023年，目前市面上口碑不错的电源是<a href="https://mall.jd.com/index-1000097385.html">海韵（SEASONIC）</a>家的，我到手后拆箱看了看，配件送的很齐全，客服也很有耐心，中间解答了不少电源相关的疑惑，而且官方的教程相对来说，很亲民，对于我这种老白来说，很友好。</p><h4 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h4><p>这点我不太好推荐，外设这些，看个人喜好吧，机箱和水冷，我是在京东和淘宝买的。</p><p>和我不同，我弟是在拼多多买的，他认为拼多多的效果还可以，我没有验证，但是我对拼多多的砍价很是膈应，被耍猴了几次一直不是很喜欢这个平台。</p><p>个人感觉京东的售后是值得的，我中间机箱选错了，隔了一个月，协商退货，人家很痛快的就答应了。</p><p>就这点来说，京东的售后还是不错的，这个价格我个人较为认可。</p><p>但是贵确实是贵，所以，我只推荐主机相关的外设在京东买，比如机箱，水冷这种。</p><p>键盘和鼠标，还有耳机什么的，这种就随缘吧，如果不是太贵，拼多多应该也不是不行。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>为了保证电脑的外观效果，安装顺利，还需要准备如下道具</p><ol><li>机箱风扇（白色）</li><li>显卡延长线（白色）</li><li>金士顿U盘，作PE系统安装盘</li><li>2T的希捷机械硬盘，给旧电脑做数据转移用</li></ol><h3 id="电脑安装"><a href="#电脑安装" class="headerlink" title="电脑安装"></a>电脑安装</h3><p>再次安利一下<a href="https://www.bilibili.com/video/BV1BG4y137mG">硬件茶谈的教程</a>，我这里作为补充要说一下我在安装过程遇到的问题。</p><p>如果是新手安装，最好看一下我遇到的这些坑。</p><p>茶谈的教程里边，虽然已经足够的细致，但是对于实际情况来说，意外还是有的，看看我遇到的这些问题，说不定对你装机会有帮助。</p><ol><li>安装的平台尽可能的大，放螺丝的盒子多备一些，自己要规划好，记清楚了，不然找螺丝就是一个很费时间的事。</li><li>主板，水冷这两个安装说明书一定要保存好。</li><li>在没有安装水冷，风冷背板支架之前，不要急着把主板安装在机箱上，如果不装支架，直接放在机箱上，待会还得拆，因为你需要在主板背部安装支架，这样你才能去安装主板正面的水冷。</li><li>风扇有正叶扇和反叶扇，购买的时候，看清楚，反叶扇是风扇面（没有支架的凹面）出风，马达面（有支架的凸面）吸风，正叶扇和反叶扇是完全相反的，不然安装错了需要重新拆装风扇，很麻烦。</li><li>水冷一般是自带风扇的，<strong>水冷盒子下边有个抽拉的小盒子</strong>，打开就是风扇！如果水冷没有风扇，厂家一般会注明！不要用自己的风扇去怼水冷！</li><li>水冷虽然自带了说明书，但是如果还是觉得不保险，可以看看别人是怎么装的，这里推荐<a href="https://www.bilibili.com/video/BV1hg411A7yG?p=1&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">装机不求人之基础水冷安装教程</a>，相对于茶谈的大纲，这个教程在装水冷这里，细节做的不错。</li><li>风道最好一开始就要自己设计好，不然在风扇规划安装的时候，会反复拆装，加大工作量</li><li>有些时候电源如果开机测试怎么测都没有效果，考虑一下是不是风扇声音太小的问题，我在测试电源的时候，一直按照教程走，客服也说没有问题，都打算退货了，结果我仔细看了一下，是风扇声音太小，加上我装机的地方光线昏暗，没有看到风扇在转，导致我以为风扇有问题。</li><li>电源有些时候不是规整的情况，可能是运输过程中，盒子错位了，可以自己用钳子什么的敲一下，把电源规整一下。</li><li>理线是个大活，但是非水冷风扇的线，可以买个集线器来整理。水冷的集线器是专门给水冷风扇插的，主板要检测CPU对应的风扇转速，所以，其他风扇可以另外买一个集线器来整理，不要和水冷的集线器混用。</li><li>如果有了集线器，就没要按照官方教程来做风扇的串接了，只要集线器的插口足够的富裕，可以直接全部都插一遍，我这里买的是<a href="https://item.jd.com/100031537714.html">利民的8组16口集线器</a>，因为我的风扇都是带灯光效果的，所以就买了这种双插口的集线器，具体需求情按照自己的配置来决定，不必按照我这个来。</li><li><strong>一定要保证风扇的公头针脚不外露</strong>，不然接触到主板和机箱，漏电可能会造成硬件损坏。</li><li>集线器对应主板的插口，各家的主板都有不一样的说法，如果你没有找到ARGB的接口，可能是名字不一样，比如华硕的主板中，argb的接口名称叫<strong>ADD_GEN2</strong>，在微星的板子上应该叫<strong>JRGB</strong>，这个需要自己看看主板的说明书来确认。</li><li>如果对自己的能力实在没有信心，尽可能的保证自己身边有个懂行的哥们儿，如果你装机装出问题了，哥们儿能帮你兜个底，但是装成了，记得请人家吃顿饭。</li></ol><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>个人之前是没接触过PE安装的，这次按照以下两个教程走了一遍之后，感觉这确实比官方自带的安装方式方便不少。</p><h4 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h4><p>如果不清楚原理，个人推荐看一下硬件茶谈的视频。</p><p>如果不清楚具体的操作方法，我推荐看机械师只只的安装教程，他的教程确实更加稳妥。</p><p><a href="https://www.bilibili.com/video/BV1DJ411D79y?p=2&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区</a></p><p><a href="https://www.bilibili.com/video/BV15e411x7nw">【U盘模式】Win10重装系统教程（10分钟装好）</a></p><h4 id="论坛推荐"><a href="#论坛推荐" class="headerlink" title="论坛推荐"></a>论坛推荐</h4><p>整理了一下装机论坛，朋友推荐的，很不错</p><ol><li><a href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn)</a></li><li><a href="https://www.itsk.com/">IT天空－新的十年，与您同行！ （已创建16年零10个月） (itsk.com)</a></li></ol><h4 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h4><p>这里整理了一下朋友推荐的pe工具，这是市面上推荐，比较好的PE工具包</p><ol><li>优启通</li><li>微PE</li></ol><p>最后，贴一下<a href="https://space.bilibili.com/409055282">机械师只只</a>大佬给的网盘工具链接</p><p><a href="https://www.123pan.com/s/wEeA-UiMmH">重装系统官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘 (123pan.com)</a></p><p>这里顺便贴一下我用的win10镜像文件，之前用他们给的镜像文件装上去一直有问题，要么就是装好了没有网络，用这个镜像文件倒是一步到位了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1CLi2gRlo7XqNZEFxQgKpoA?pwd=1234 </span><br><span class="line">提取码：1234 </span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>下次再也不装水冷了，风扇噪音也不小，而且还费事，据说还有水管破裂导致所有硬件瘫痪的风险。</p><p>这次装机装了两天多，中间安装软件刷系统，整个人都给这玩意整颓了，好几天都没缓过来。</p><p>但是，安装完成之后，点亮的那一刻，不得不说，真是有种前所未有的开心。</p><p>这次也是感谢客服和各路好兄弟帮忙了，更是谢谢各路UP的装机分享，不然这装机属实是个麻烦的事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————https认证</title>
      <link href="/2023/05/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94https%E8%AE%A4%E8%AF%81/"/>
      <url>/2023/05/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94https%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>之前同事搞了很久，本以为要弄很久的事，结果出乎意料的简单。</p><p>不过，这个过程知道了很多不了解的的东西，这里特别记录下。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来一开始没想搞https，但是浏览器上一直红字提示不安全，一直放在那里挺膈应人。</p><p>想来想去，还是弄吧，不然每次浏览的时候，都感觉怪怪的，后续分享我也不想让别人每次都注意到这个。</p><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><p>首先，我们要到服务商，申请到证书。</p><p>这里有付费证书和免费证书的说法，我看了很多人的教程，讲的很详尽，但是详尽的有点太过复杂了。</p><p>我这里就以我为例，说个简略版的，默认大家使用的是阿里云平台，并且已经完成了实名认证，然后参考如下流程。</p><ol><li>找到并打开域名控制台</li><li>选择你个人博客的域名，点击管理，进入博客，找到SSL证书，然后打开对应的链接，跳转到证书控制台</li><li>到了证书控制台之后，直接选择免费证书购买（阿里云目前是提供每年20个证书的量，对于常规用户来说够用了）</li><li>点击创建证书，完成表单填写，创建</li><li>阿里云很给力，直接会完成前几个步骤，你这里只需要点击签发就可以了</li></ol><p>好了，这里我们的个人博客就有了https认证的证书，这很简单。</p><p>如果博客是部署到自己服务器的朋友，可能还需要把证书下载下来部署，过程感觉还有点多，我个人不多做赘述。</p><p>可以参考<a href="https://tech.mindseed.cn/Website/%E7%BD%91%E7%AB%99HTTPS%E4%B9%8B%E8%B7%AF-%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E5%8F%8A%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFHTTPS.html">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 心站日志 | 心种子技术站 (mindseed.cn)</a></p><h3 id="修改pages设置"><a href="#修改pages设置" class="headerlink" title="修改pages设置"></a>修改pages设置</h3><p>在完成证书申请之后，我们需要让github完成对域名的https的使用。</p><p>我这里默认大家用的是github的个人网站，以我自己为例。</p><p>我所部署的项目是<strong>CrazyStudent13.github.io</strong>，打开之后，找到setting设置选项，找到左侧的pages选项。</p><p>这里，我们找到<strong>Custom domain</strong>，然后下边有个<strong>Enforce HTTPS</strong>的复选框，这里我们把它勾上。</p><p>它下边有一段小字，是可以忽略的提示，这里顺便提供下翻译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTPS provides a layer of encryption that prevents others from snooping on or tampering with traffic to your site.</span><br><span class="line">When HTTPS is enforced, your site will only be served over HTTPS</span><br><span class="line"></span><br><span class="line">HTTPS提供了一层加密，防止其他人窥探或篡改到您站点的流量。</span><br><span class="line">当HTTPS被强制执行时，您的站点将只能通过HTTPS提供服务</span><br></pre></td></tr></table></figure><h3 id="最后确认"><a href="#最后确认" class="headerlink" title="最后确认"></a>最后确认</h3><p>完成以上之后，我们只需要把自己的网页复制到浏览器上打开。</p><p>如果https认证通过，之前浏览器上处于爆红的、打开状态的锁，就会闭合并且成为常规的灰色。</p><p>我们点击那个锁，也会看到提示，表明连接安全。</p><h3 id="通过QQ认证"><a href="#通过QQ认证" class="headerlink" title="通过QQ认证"></a>通过QQ认证</h3><p>这个是额外的情况，我之前给一些QQ上的朋友发送博客的链接。</p><p>他们说打开总是提示需要复制再打开，之前我以为这是Https的问题。</p><p>但是结果浏览器上申请通过之后，QQ上还是要求我复制打开，等了半小时左右，效果还是不行。</p><p>后来，和朋友部署在国内服务器的情况对比了一下，感觉问题不是https的问题，他的博客甚至都没有通过https认证。</p><p>想了一圈，我估计我部署位置的问题，所以我试着直接给<a href="https://urlsec.qq.com/complain.html">腾讯安全-网址安全中心 (qq.com)</a>提了一下拦截申诉，很快，大约十分钟左右就有回应了。</p><p>所以，我猜测应该是腾讯封锁这种github部署的境外网站，一开始拦截没有通过，我这里的博客才打不开，现在申诉过后，通过审核了，才可以访问。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前看了一下，似乎证书有效期只有30天，具体什么情况，还得等到期之后看看。</p><p>至于付费证书，没打算搞，太贵了，这个博客就是个记录站点，没必要整的这么金贵，越金贵的东西，越舍不得动。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/110478585">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 知乎 (zhihu.com)</a></p><p><a href="https://tech.mindseed.cn/Website/%E7%BD%91%E7%AB%99HTTPS%E4%B9%8B%E8%B7%AF-%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%E5%8F%8A%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFHTTPS.html">网站HTTPS之路——安装、配置SSL证书及强制开启HTTPS - 心站日志 | 心种子技术站 (mindseed.cn)</a></p><p><a href="http://lhalcyon.com/hexo_ssl_netlify/">Hexo绑定自定义Https域名 | Halcyon Days (lhalcyon.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激光打印机安装及使用</title>
      <link href="/2023/04/20/%E6%BF%80%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/20/%E6%BF%80%E5%85%89%E6%89%93%E5%8D%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这玩意纯粹是小玩具，买了之后一直没组，最近有时间了才开始整的。</p><p>个人感觉，玩具确实是玩具，但是效果还是很不错的，后续可以用来刻印一些木板画做做手工</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文只介绍新人的注意事项，并不会详细写出安装过程。</p><p>本文会尽可能提出一些注意事项，规避安装中的坑点。</p><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><ul><li>刻印图画，在部分木材，铝材，不锈钢等的板材上烧刻图案，利用高温留下点线，组成图形。</li><li>切割板材，不过由于我这个激光器的功率不是很大，最多能切一些薄木板，其他的不太行，不过，按照平时的要求来说，够用了</li></ul><h3 id="配件安装"><a href="#配件安装" class="headerlink" title="配件安装"></a>配件安装</h3><p>因为没钱，所以尽可能的是用散件组装的，不过价格累计¥626，还是有点肉疼。</p><p>这里因为激光头是定焦的，所以老板松了一个调节平台，还有一些扎带，还好。</p><ol><li>10w蓝紫光激光器，¥288</li><li>12V2A的电源适配器，¥15</li><li>激光雕刻机机架，¥237</li><li>Arduino主板+4988驱动模块，¥86</li></ol><p>因为我不是电气相关专业，所以这里只能先当积木来拼了。</p><p>安装的时候，大部分时间接口其实和主板都是能对的上的，线材对接如下：</p><ol><li>红色对应VOC</li><li>黑色对应GND</li><li>绿色对应PWM</li></ol><p>主板上的X和Y，对应的是电机的X和Y轴</p><ol><li>X对应的是上方的轴，就是和激光器挂在一起的那个电机</li><li>Y对应的是下方的轴</li></ol><h3 id="主板驱动"><a href="#主板驱动" class="headerlink" title="主板驱动"></a>主板驱动</h3><p>主板还是要装驱动的，这里电脑注意最好是win10,8,7这样的，或者linux也可以。</p><p>个人首先推荐教程：<a href="https://wiki.dfrobot.com.cn/Arduino%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85">Arduino驱动的安装</a>，讲的很详细，很好用。</p><p>因为我买的是<strong>Arduino主板</strong>，这里推荐去<a href="https://arduino.me/download">软件下载 - Arduino中文社区</a>查查相关的帖子。</p><p>这个社区相对来说，还算是正经的社区，有不少靠谱的帖子。</p><p><strong>tips</strong>：不推荐使用驱动精灵之类的安装，一如既往的没用</p><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p><a href="https://lasergrbl.com/download/">laserGRBL</a>，这个是Up主<a href="https://space.bilibili.com/283644869">BD黑色蒲公英</a>推荐的激光器控制软件。</p><p>之前我买驱动的淘宝店家，也推荐了一个微雕精灵，个人找了一圈，不推荐。</p><p>在试用了好几个工具之后，我个人也用这个工具，理由如下：</p><ol><li>laserGRBL官网正规，微雕精灵没有官网，都是野路子下载，很多下载链接，都在一些乱七八糟的人论坛里。</li><li>laserGRBL引擎检索，微雕精灵名字检索混乱，是的，无论是用国内还是国外的搜索引擎，都能找到类似名字的软件，如微雕管家，微雕大师等等。这不像一个成熟的商业软件该有的样子，日后出问题，估计难以维护。</li><li>laserGRBL的视频教程很多，B站有很多教程，微雕精灵相关教程几乎没有，教程生态不行</li><li>就界面及功能来看，感觉微雕精灵像是盗版的laserGRBL，很难说这个软件的未来</li></ol><h3 id="机器使用"><a href="#机器使用" class="headerlink" title="机器使用"></a>机器使用</h3><p><a href="https://www.bilibili.com/video/BV1cP4y1478T/?vd_source=ee3784ffe5f760cb992921cb8c5c98e5">一分钟学会如何使用激光雕刻机进行灰度雕刻！</a></p><p><a href="https://b23.tv/lt4wFOd?share_medium=android&share_source=qq&bbid=XYA6C72AB48107F9A6238AE3F89C3CF8857C0&ts=1681962712197">GRBL入门到进阶教程 激光雕刻机扩展板入门指导 Arduino主控GRBL视频教程</a></p><p>详细教程可以参考上述教程，我个人这里稍微写个大致流程仅供参考。</p><ol><li>使用软件，完成驱动安装</li><li>选中对应的端口，连接主板</li><li>放置好板材，因为我是定焦，所以要调整好板材和激光头的焦距</li><li>点击电机方向，启动激光器测试是否靠谱</li><li>导入图片，配置好参数，放入打印机</li><li>扫一下打印的大致范围，确认打印机和电机不会超过板材的之外的范围</li><li>开窗通风，等待打印完成即可</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>保证桌面的水平，确定不会滑动</li><li>线材不要放在雕刻机的扫描范围内，容易有线材被切割的风险</li><li>机器周围不要放什么易燃物，水杯，或者是振动物品，有一定的风险</li><li>激光头在使用会出现较大噪音，这是正常现象，因为要散热</li><li>每次雕刻图案之前，记得先用软件扫一下图案的范围大小，不然很容易超出范围，烧到范围之外的地方，又或者卡在边缘位置，重复烧刻一条线，形成切割的效果，很糟糕</li><li>不要长时间直视激光器打印的光斑，如果有需要，可以考虑配一副眼镜</li><li>不要在木制桌板上刻印！切记！我桌子上被烧了两个黑斑，实在是难看</li><li>保持房间通风，不然烧刻木板的糊味儿实在不好闻</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里非常感谢<a href="https://space.bilibili.com/283644869">BD黑色蒲公英</a>的技术支持，中间安装和后续打印过程中，给了我这个新手不少指导。</p><p>如有错误，还请指正，在这里谢谢了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.dfrobot.com.cn/Arduino%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85">Arduino驱动的安装</a></p><p><a href="https://www.bilibili.com/video/BV1cP4y1478T/?vd_source=ee3784ffe5f760cb992921cb8c5c98e5">一分钟学会如何使用激光雕刻机进行灰度雕刻！</a></p><p><a href="https://b23.tv/lt4wFOd?share_medium=android&share_source=qq&bbid=XYA6C72AB48107F9A6238AE3F89C3CF8857C0&ts=1681962712197">GRBL入门到进阶教程 激光雕刻机扩展板入门指导 Arduino主控GRBL视频教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑软件下载清单整理</title>
      <link href="/2023/04/18/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86/"/>
      <url>/2023/04/18/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本来没打算整理的，结果打算给新电脑腾地方的时候，才发现要下载的软件也太多了。</p><p>考虑到后续可能会有可能继续升级新电脑，所以整理了该下载清单。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><p>新电脑几乎什么都没有，个人推荐先装这些必须得工具，便于后续使用</p><ul><li>edge浏览器，微软浏览器</li><li>chrome，谷歌浏览器</li><li>Opera浏览器，谷歌内核浏览器，主要是游戏方向的内容做的不错</li><li>bandzip，好用的文件压缩软件</li></ul><h3 id="游戏工具"><a href="#游戏工具" class="headerlink" title="游戏工具"></a>游戏工具</h3><p>这里大多数都是我自己常用的软件，酌情选择</p><ul><li>哔哩哔哩直播姬，bilibili直播软件</li><li>OBS Studio，电脑直播软件，相对稳定</li><li>网易UU，游戏加速器</li><li><a href="https://tly.com/zh/">TLY - Baacloud</a>，翻墙梯子（收费）</li><li><a href="https://cheatengine.org/">Cheat Engine</a>，游戏作弊器</li><li>steam，游戏平台</li><li>Epic Games，游戏平台</li><li>wegame，游戏平台</li><li>origin，游戏平台</li><li>ubisoft，游戏平台</li><li>夜神模拟器，手游模拟器</li></ul><h3 id="聊天相关"><a href="#聊天相关" class="headerlink" title="聊天相关"></a>聊天相关</h3><ul><li>QQ</li><li>微信</li><li>阿里旺旺</li><li>KOOK，开黑游戏用</li><li>钉钉，非工作用不推荐</li></ul><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>开发人员需要配置的环境，这个按照自己的需求酌情安装</p><ul><li>node，前端开发环境，用官方推荐的版本</li><li>java8，java开发环境，用8版本比较稳定，这里附上一份环境<a href="https://blog.csdn.net/Marvin_996_ICU/article/details/106240065">配置教程</a></li><li>python3，python开发环境</li><li>gitbash，git命令终端及环境</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>程序员大多数都会接触到的工具，有些工具的推荐并非我喜欢，而是不得已。</p><p>有时候为了实现需求，往往必须要用一些特殊的工具，没办法。</p><ul><li>VsCode，开发工具</li><li>IntelliJ IDEA，后端开发工具</li><li>eclipse，后端开发工具</li><li>hbuilderX，国产多平台代码开发工具，个人不太喜欢用</li><li>Dev-C++，C++开发工具，考试用</li><li>微信开发者工具，如果有小程序开发需要的朋友推荐使用</li><li>ApiPost&#x2F;postman，接口测试</li><li>GitHub Desktop，github代码管理工具，官方下载非常慢，推荐自己找好安装包</li><li>MobaXterm，服务器连接管理</li><li>WinSCP 5.21.2，服务器可视化操作工具</li></ul><h3 id="文档工具"><a href="#文档工具" class="headerlink" title="文档工具"></a>文档工具</h3><p>关于wps，个人觉得，如果有正版平替的话，还是用微软的吧。</p><p>现在微软的文档工具接入了AI，比起WPS的全家桶，好用了很多。</p><ul><li>typora，好用的markdown编辑器（收费）</li><li>有道云笔记，工作常用的备忘录</li><li>wpsoffice，一些文档打开工具</li><li>语雀，办公可能会用到</li></ul><h3 id="影音工具"><a href="#影音工具" class="headerlink" title="影音工具"></a>影音工具</h3><p>因为我用的是win系列的，所以这里主要会推荐adobe的工具</p><p>adobe全家桶工具，推荐一个<a href="https://baiyunju.cc/8602">破解版教程</a>，简单好用，下载解压，按教程安装即可</p><ul><li>网易云音乐</li><li>腾讯视频</li><li>爱奇艺</li><li>PotPlayer，视频播放器</li><li>万兴优转，视频格式转码，不推荐</li><li>小丸工具箱，视频格式转码</li><li>Adobe photoshop，图片编辑工具</li><li>Adobe premiere，视频编辑工具</li><li>Adobe Effects，视频特效工具</li></ul><h3 id="建模绘图"><a href="#建模绘图" class="headerlink" title="建模绘图"></a>建模绘图</h3><ul><li>草图大师（SketchUp），快速建模软件</li><li>SAI，绘画工具</li></ul><h3 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h3><ul><li>百度网盘</li><li>阿里云盘</li><li>SynologyAssistant，群晖电脑助手，记得配置好本地硬盘映射</li></ul><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>腾讯电脑管家和百度网盘这两个东西，说实话，不是很想用。</p><p>但是比起无序扩张的360，有些时候，确实这两个工具还是有必要使用的。</p><p>还有一些软件是个人设备需求，如果没有同样的需求，就不需要装。</p><ul><li>腾讯电脑管家，电脑新手推荐用</li><li>wallpaper相关</li><li>MAA（明日方舟自动化代理工具）</li><li>AVerMedia RECentral 4，圆钢的视频采集工具</li><li>Arduino主板驱动，激光打印机的主板驱动，个人设备要求</li><li>laserrgbl，激光打印机的工具</li></ul><h3 id="必要设置"><a href="#必要设置" class="headerlink" title="必要设置"></a>必要设置</h3><ol><li>window的机子，记得打开文件扩展名，文件隐藏项目</li><li>如果有nas，在局域网范围内，记得映射对应的网络</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本清单会不定期更新，按照需求调整。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一份计划总纲</title>
      <link href="/2023/04/16/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%AE%A1%E5%88%92%E6%80%BB%E7%BA%B2/"/>
      <url>/2023/04/16/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%AE%A1%E5%88%92%E6%80%BB%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<p>本来没打算放出来这份生活总纲的，毕竟有点私密的感觉。</p><p>但是想了想，这部分计划其实也算不上隐私，而且生活类的计划，放在博客里也不算什么。</p><p>所以大家有兴趣看个乐子就行，毕竟，往往计划赶不上变化，新年计划往往都是旧计划洗洗就能用。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果按照正常的计划，3月份这个计划总纲应该是要出来的。</p><p>但是，因为甲状腺切除的手术，牙龈刮治等一系列问题，在工作地耽误太久了。</p><p>回到老家已经是4月中了，考完自考之后，终于松了口气，现在算是可以做事了。</p><h3 id="房子基建"><a href="#房子基建" class="headerlink" title="房子基建"></a>房子基建</h3><h4 id="基建更新"><a href="#基建更新" class="headerlink" title="基建更新"></a>基建更新</h4><p>主要保证家里的房子，便于清理，同时兼具保温，美观，便于检修，成本低。</p><ol><li><del>添加空调</del></li><li><del>添加房间管线（恒温管替换空调），保证三间房子的电路和网络能走通，不是现在这种随便搭线的情况</del></li><li><del>更换房间吊顶，在管线铺设完成之后，确认没有问题，开始吊顶。</del></li><li><del>贴地砖，卧室+客厅+厨房+淋浴间（低成本贴一下就行，便于房间清理）</del></li><li>更换窗户，考虑换成更方便的推拉铝合金窗户</li><li><del>更换卧室的门，独立空间私密化，不要随便被人入侵，讨厌没有距离的感觉。</del></li><li><del>厕所+淋浴间一体化</del></li><li>厨房现代化（电器化，装修正规化，不需要多豪华，先达到正常农村装修水平就行，不能过的像工地）</li><li><del>洗衣房+洗漱间一体化（房间内要有足够的地方摆放衣物，摆放）</del></li><li><del>东屋暂时不拆除，暂时清空，改为工房仓库</del></li><li>添加15米靶场，射箭用</li><li>家庭供电自动化，加入光伏板，接入国家电网，不再使用外部供电（两年后的计划，这个太烧钱了）</li></ol><h4 id="家居更新"><a href="#家居更新" class="headerlink" title="家居更新"></a>家居更新</h4><p>保证家里的基础功能不会出问题，并且物品归类整理好后，便于寻找</p><ol><li><del>换掉洗衣机</del></li><li><del>电气化部分设备，淋浴热水器，电磁炉，空气炸锅（其他可以靠后，但是淋浴热水器和电磁炉必须今年考虑加入，不然冬天没法子过）</del></li><li><del>添加书柜，重要文件集中管理，在我的房间加入书架，集中管理所有人的重要文件（家用户口本等）</del></li><li><del>使用外卖货架整理东屋，堆放杂货</del></li><li><del>使用洞洞板，及其他桌搭工具，整理目前已有的工具</del></li></ol><h4 id="智能化"><a href="#智能化" class="headerlink" title="智能化"></a>智能化</h4><p>主要保证家里的娱乐设备没有问题，便于生产力设备的升级</p><ol><li>硬件的更替，<del>出售旧的电脑，nas，拼装新电脑</del></li><li>升级新nas（下半年，和朋友确认硬盘坏道情况，如果没问题准备入手黑群晖）</li><li><del>升级网络，替换路由器，扩大覆盖范围</del></li><li><del>卧室灯光设计合理改造，插线板要符合房间的布局，不能按照现有情况胡乱布线</del></li></ol><h2 id="身体调理"><a href="#身体调理" class="headerlink" title="身体调理"></a>身体调理</h2><h3 id="减重"><a href="#减重" class="headerlink" title="减重"></a>减重</h3><p>降重到合理的程度，恢复正常BMI（重中之重！血压的事不能再拖了！）</p><ol><li>制定正常的食谱</li><li>制定正常的运动计划</li></ol><h3 id="情绪控制"><a href="#情绪控制" class="headerlink" title="情绪控制"></a>情绪控制</h3><p>调理至甲状腺切除之前的正常状态，最好是大学时候的状态。</p><p>不是用暴力的药物调理方式，而是用缓和的情绪方式，最好是运动类的。</p><ol><li>体重回复之后，定期射箭，来调控自己对身体的控制力</li><li><del>减少对负面新闻的观看，虽然这个狗屎一样的社会总是会增加负面新闻</del></li><li><del>多和外界沟通交流，保证自己能快速融入到外界中</del></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>去找医生正骨，在重量下降之后再做，不然没法调整（下半年的事情）</li></ol><h2 id="技术升级"><a href="#技术升级" class="headerlink" title="技术升级"></a>技术升级</h2><h3 id="自考"><a href="#自考" class="headerlink" title="自考"></a>自考</h3><ol><li>7月中旬，必须得进行高数的学习，平时有事儿没事就看一下数学相关的内容，别真到了那时候不会了</li><li>挑一部分难搞的课程，十月份处理掉</li></ol><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ol><li>全面接入智能化，使用Copilot，辅助代码书写</li><li><del>搭建自用的图片生成工具</del></li><li>完善开源工具cat-tools，做到自动化测试用例，自动化部署，文档自动化，并搭建开源工具包的帮助文档，建立issue</li><li>搭建番剧，电影wiki检索系统，二者对外是两个业务，但是后台可以考虑使用一套业务来整合到一起，这个要好好做，因为主要是未来刮削影视信息不方便，必须得有个集中化的地方</li><li>学习使用python,着手抓取第三方数据（尽快，6月之前要有能学明白，做到图片爬虫工具，网站信息抓取工具）</li><li>学习使用vue3+vite，搭建论坛，类贴吧，主要交流硬件相关知识</li><li>学习Electron，尝试写一个硬件配置工具系统（如果有更好的平替工具，就不用做了）</li></ol><h3 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h3><ol><li><del>弄清楚考试流程，最好准备一口气过完，我怕拖了之后容易出问题</del></li></ol><h3 id="写小说"><a href="#写小说" class="headerlink" title="写小说"></a>写小说</h3><ol><li>每月编个千字小故事，随便什么小故事，但是要精妙完整</li><li>将一些比较精品的点子，组合起来，定期写一下，投稿一些科幻论坛</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><ol><li>《重构》</li><li>《人月神话》</li><li><del>《程序员的自我修养》</del></li><li>《孙子兵法》</li><li>《腰背维修师》</li></ol><h3 id="B站出视频"><a href="#B站出视频" class="headerlink" title="B站出视频"></a>B站出视频</h3><ol><li><p>记录一些房间生活改造内容</p></li><li><p>写一些番剧，电影小作文锐评一波，蹭蹭热度，也不图啥，就是想图个热闹，不然这些东西没有人一块看，总是很孤单，随缘写，看喜欢了就写</p></li></ol><h3 id="完善保险"><a href="#完善保险" class="headerlink" title="完善保险"></a>完善保险</h3><ol><li><del>完善医保</del></li><li>完善父母养老保险</li><li>带爸妈去做体检，做好预防措施</li><li><del>失业人员是否可以领补助金（小城镇很难领到，不要相信国家）</del></li><li><del>查一下社保问题，所谓的灵活就业人员是否可以和失业人员补助金冲突（交社保很麻烦，而且在老家小病用不上，大病没地用）</del></li></ol><h3 id="学习硬件修理"><a href="#学习硬件修理" class="headerlink" title="学习硬件修理"></a>学习硬件修理</h3><ol><li>学习显卡的维修（这个留到明年吧）</li><li>学习硬件维修相关技能（这个下半年再考虑）</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>该文档年内不定期更新，会有实际调整。</p><p>虽然是计划总纲，但实际情况可能会有很多出入，所以目前仅参考用。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 年计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册及使用chatGPT</title>
      <link href="/2023/04/02/%E6%B3%A8%E5%86%8C%E5%8F%8A%E4%BD%BF%E7%94%A8chatGPT/"/>
      <url>/2023/04/02/%E6%B3%A8%E5%86%8C%E5%8F%8A%E4%BD%BF%E7%94%A8chatGPT/</url>
      
        <content type="html"><![CDATA[<p>风云激荡，时代变幻，人工智能，你终于来了。</p><p>本来以为这玩意，会和核聚变一样永远差50年，但是没想到，他现在就来了，而且以如此呼啸的方式。</p><p>不过，既来之，则安之，我们这里记录一下注册方式，当然，随着形式变化，该文档会不定期修改。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本来以为会很麻烦，但是没想到很简单，整个流程不过就十分钟左右就完了。</p><p>如果是经常使用这些墙外软件的朋友，估计会更快。</p><h3 id="邮箱注册"><a href="#邮箱注册" class="headerlink" title="邮箱注册"></a>邮箱注册</h3><p>在注册之前，先注意满足以下的前提</p><ul><li>更换梯子节点，尽量不要选择东亚和俄罗斯，选择东南亚和欧洲节点</li><li>最好清理一下页面缓存</li></ul><p>如果不确定自己IP已经切换到境外，可以使用<a href="https://ipinfo.io/">ipinfo.io</a>看一下，只要信息框中的timezone显示不是china就行。</p><p>满足以上条件之后，在<a href="https://openai.com/blog/chatgpt">chatGPT</a>官网，点击<a href="https://chat.openai.com/auth/login">Try chatGPT</a>，之后sign up进入注册流程就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signup is currently unavailable, please try again later！</span><br></pre></td></tr></table></figure><p>如果你正常填写邮箱和密码之后，出现上述提示，那你排查注册的邮箱有无如下情况</p><ul><li>QQ邮箱，foxmail邮箱</li><li>163邮箱，网易邮箱yeah.net，126邮箱</li><li>新浪邮箱</li><li>Outlook、hotmail邮箱（<del>只能通过快捷登录，也就是Continue with Microsoft Account</del>）2023年4月2日更新：目前微软邮箱已经不能注册ChatGPT，使用Continue with Microsoft Account这种方式也不行。</li><li>eud.cn邮箱</li><li>Gmail(只能通过快捷登录，也就是Continue with Google）</li></ul><p>主要是现在chatGPT封禁了东亚区的注册，所以，以上邮箱会无效。</p><p>如果你暂时没有好的解决办法，我推荐你使用自定义域名的邮箱，或者公司提供的企业邮箱即可。</p><h3 id="获取手机验证码"><a href="#获取手机验证码" class="headerlink" title="获取手机验证码"></a>获取手机验证码</h3><p>完成了上述的邮箱注册之后，可能会需要当前用户提供手机号，这里主要用境外手机号，填写验证码就行。</p><ol><li>选择好自己手机号对应的国家</li><li>尽可能的不选择东亚这块的国家注册手机号</li></ol><p>针对墙内用户，如果有自己的海外手机号，那没什么好说的，用自己的海外手机号验证码注册一下就行。</p><p>但是如果你没有海外手机号，可以注册<a href="https://sms-activate.org/">sms-activate</a>，充值就可以，允许使用支付宝的。</p><p>推荐这里参考这个文档：<a href="https://zhuanlan.zhihu.com/p/615585092">如何使用sms-activate服务 - 知乎 (zhihu.com)</a></p><p>进入页面之后，左侧选择OpenAI，然后选一个国家，按照教程的流程注册一下就行。</p><p>这里推荐选择东欧的一些国家，比如罗马尼亚（Romania）之类的，因为最近似乎有针对亚洲国家封禁的情况，这个还是挺尬的。</p><p>填入验证码之后，chatGPT就注册好了，之后就可以用了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对于如此强劲的新技术，在初步体验之后，我实在是无法拒绝。</p><p>也许，新的技术奇点已经到了，未来真是值得期待啊。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.vpsdawanjia.com/6251.html">ChatGPT无法注册的原因错误提示：Signup is currently unavailable, please try again later</a></p><p><a href="https://zhuanlan.zhihu.com/p/615585092">如何使用sms-activate服务 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次手术（后）</title>
      <link href="/2023/03/31/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%90%8E%EF%BC%89/"/>
      <url>/2023/03/31/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%90%8E%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>因乳头状细胞癌，所以需要切除右侧甲状腺，折腾了快两周，伤口终于快好了。</p><p>这里记录一下术后的日子，也算是缅怀一下这段不同寻常的时光吧。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>梳理了一下住院前后流程，真是感觉这段时间蛮让人感慨的。</p><p>果然，就算说是小手术，对于身体来说，还是相当的遭罪啊。</p><h3 id="术前问题"><a href="#术前问题" class="headerlink" title="术前问题"></a>术前问题</h3><p>因为这个病查出来的挺突然，手术前，心里还是做了一段时间的博弈，整理了如下问题。</p><p>我感觉后续如果再遇到大病了，都可以按照这个思考逻辑来，这里也给大家做个参考。</p><ol><li>治疗方式具体都有什么？</li><li>拖着不做可以吗？</li><li>这个手术的后遗症是什么？</li><li>手术费用是否会很多？医保能报多少？（有钱人不必考虑）</li><li>手术后调理恢复要多久？是否会耽误日常生活？</li></ol><p>我的手术是甲状腺切除，咨询了医生的意见之后，我自己评估了一下，可以接受，确实不是啥大问题。</p><ol><li>只要手术切除甲状腺即可，不需要化疗，这病是危险性最小的癌症。</li><li>我这个甲状腺细胞乳头状癌拖着没啥，但癌细胞有扩散风险，尽管不高，但是要做。</li><li>后遗症就是以后都要吃优碘乐，而且手术如果出了意料外的情况，说不定会干扰声带的音色，但是医生自信9成可能不会出这种问题。</li><li>手术费用反而最不用担心，医保报了6成费用之后，自己缴费即可，术后结账我算了一下，拢共也就近4千。</li><li>手术调理按照医嘱即可，两周就差不多正常行动。</li></ol><h3 id="住院准备"><a href="#住院准备" class="headerlink" title="住院准备"></a>住院准备</h3><p>在确认必须要做手术后，事情就好办了。</p><p>和有住院经历的朋友确认了相关事宜后，我大概做了如下的准备。</p><ul><li>带本子和笔，护士的嘱托会很多，如果不记录，后续忙起来容易忘</li><li>准备住院金，提前和医生确定好预期金额，到时候交就可以</li><li>确认医院附近的食堂和外卖取餐点，不然术后，自己和家人吃饭，找起来会是个问题</li><li>确认好手术时间之后，让家人在手术当天陪同就可以，如无必要，不必第一天让家人在医院就开始等着</li><li>如有必要，让家人带一床被褥，夜里如果保持通风，房间会偏冷</li><li>带一身换洗衣服，不过我住院时间很短，所以这个不需要</li><li>医院里有褪黑素，不过没用到，那天我靠着自己强大的意志力，在同房的呼噜声中睡着了</li></ul><h3 id="提前出院"><a href="#提前出院" class="headerlink" title="提前出院"></a>提前出院</h3><p>本来想写写手术的感觉，但是吧，手术全麻太给力。</p><p>医生说让我吸两口氧，结果吸完我就没意识了。</p><p>等到再醒我就被推出来了，好家伙，手术已经结束了？这过程，就是把我腰子拿了，我估计我都没有反应。</p><p>所以，手术没啥好说的。</p><p>反而是术后，我住院时候没细说多久，结果上午刚手术完，下午就和我说，第二天上午可以出院了。</p><p>这个速度快的我有点无语，当时为了吸出伤口内的血液，我脖子还插着一个导流管呢，根本不方便行动。</p><p>然而就是这么个状态，就让我出院了，属实离谱，后来我考虑了一下，觉得可能是医院床位不足的问题。</p><p>剩下的就没啥好说的了，第二天麻药劲儿过了，伤口也愈合的可以简单行动，就按照医生说的，交钱，收拾房间，走人。</p><h3 id="术后恢复"><a href="#术后恢复" class="headerlink" title="术后恢复"></a>术后恢复</h3><p>本来以为三两天就能恢复，但是没想到花了快两周时间，现在才差不多恢复结束。</p><ul><li>两天后拆导流管</li><li>每三天换药，需要去医院</li><li>一周后拆线</li></ul><p>如上，过了一周，然后又在家里躺了一周，嗓子吃饭和说话都不太好使，还是怪难受的。</p><p>不过，现在伤口恢复的差不多了，甚至吃了个火锅，挺好，一周没有吃点辣味，简直要死了。</p><p>但是目前没有完全恢复，稍微走动就会累，而且容易困，并且如果药稍微吃晚点，就容易腿疼。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次的手术蛮让我感慨的，不论这次的病症是不是一开始的不规律作息及饮食，我都要考虑身体的稳定了。</p><p>我只是普通人，所以这也算是足够幸运了，虽然这个病出乎意料，却没有造成太大的困扰。</p><p>随着年龄越来越大，身体愈发破败，苍老是肉眼可见的，如果再这么玩下去，我确实必死无疑。</p><p>这像是命运的警告，亦是命运的垂怜。</p><p>希望接下来身体会好起来，希望我不会是个短命鬼。</p><p>人世间很精彩，现在正是时代交界的时刻，我很想见证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nas使用心得笔记————入门篇</title>
      <link href="/2023/03/11/nas%E4%BD%BF%E7%94%A8%E5%BE%97%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2023/03/11/nas%E4%BD%BF%E7%94%A8%E5%BE%97%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>本系列文档给还没入坑的小伙伴一个介绍引导，如有说错，还请在评论区多多指教。</p><p>如果你是个整准备入坑的小白，可以试着和群里的大家交流搞机心得（哎嘿）。</p><p>当然，欢迎老手指正，也欢迎新手提问。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本篇内容作为入门内容，只告诉大家怎么选购，选购后可能会遇到哪些坑。</p><p>所以，这里并不会详细的深入探讨内网穿透，家庭音影搭建，脚本部署等问题。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>nas的详细定义去看<a href="https://baike.baidu.com/item/NAS/3465615?fr=aladdin">百度百科</a>，就我个人来看，这个东西就是私有的个人云盘。</p><p>正常的电脑轻度用户，一般是不会有这种需求的。所以，我们首先分析需求，这里我列一下可能的方向。</p><ol><li><strong>家庭影院</strong>，有很多电影资源，不仅在局域网看，也想在公网远程观看</li><li><strong>大文件备份</strong>，手里有很多照片，文档，压缩包之类的文件需要备份</li><li><strong>后台下载</strong>，有很多本机存不下，又想要下载的时候，可以使用。</li><li><strong>担心网盘检测</strong>，被净网行动教育过，不安心厂商网盘的检验</li></ol><p>如果有以上的一种或者多种需求，那么，我个人建议，可以考虑综合实力使用nas。</p><p>作为私人云盘来说，nas的存在，确实让很多事情方便了很多。</p><p>当然，如果你只是想存备份，不考虑远程备份。我推荐考虑<strong>硬盘柜</strong>，只要共振问题不大，就可入手。</p><h3 id="入门条件"><a href="#入门条件" class="headerlink" title="入门条件"></a>入门条件</h3><p>在需求分析之后，我们确认如果有以下硬性条件，的就可以考虑入门了。</p><ol><li>时间较充裕，如果您每日加班到深夜，就略过吧，这玩意如果想折腾的合心意，较为花时间</li><li>金钱较为充裕，至少保证有4k以上的预算，不会说因为买个机器，接下来几个月都要吃咸菜馒头算日子</li><li>有一个较为稳定的住所，保证网络和供电，可长期规划，毕竟nas更偏向于远程访问</li><li>有一定的搞机常识，对于软硬件知识有基础的了解</li><li>动手能力强，善用搜索引擎，能保证在B站或者其他论坛解决一些问题</li></ol><h3 id="主机挑选"><a href="#主机挑选" class="headerlink" title="主机挑选"></a>主机挑选</h3><p>在正式罗列之前，我先列出nas机器的评判标准（个人主观意见）。</p><p>后续如果我们选购nas，拿不定评价方向，可以参考如下思路进行评测，权重按照自己的要求衡量。</p><ol><li>系统生态，这个对于比较喜欢折腾的人来说，比较重要，社区的活力一般决定厂商是否走的长远</li><li>是否耗电，不要产品便宜，设备烧电，不然长久下来，电费也是一笔大开支</li><li>硬件损耗，是否会对机械硬盘造成强烈损耗，不然数据损毁恢复起来，也是一笔不小的开支</li><li>噪音问题，家用nas虽然设备垃圾，但是相对的，散热要求不高，所以噪音一般不大</li><li>产品价格，性价比也是个比较重要的参考项，不过一定要在满足硬件标准的情况下考虑</li></ol><h4 id="群晖系列"><a href="#群晖系列" class="headerlink" title="群晖系列"></a><a href="https://mall.jd.com/index-1000002032.html?from=pc">群晖系列</a></h4><p>不差钱的富哥首选，高薪打工人的备选，穷鬼别沾，真的太贵了！</p><p>光价格，如果要是六盘位，八盘位，就足足赶得上一台高配电脑了，这还不算硬盘的裸机价格。</p><p>我个人觉得这实在是高的离谱，即便我买的也是这个系列，但我依然感觉这个价格很咋舌，实在是有种智商税的感觉了。</p><p>不过，我当时主要是没太多时间折腾，而且，它贵确实有贵的理由，我这里罗列一下原因</p><ol><li>正版系统，不担心各种软件使用不稳定的问题，不折腾</li><li>功耗足够低，不会担心成为国家电网的合作伙伴</li><li>噪音相对不大，卧室可以放，不至于和服务器一样，一开就是飞机起飞</li><li>盗版系统社区发展好，社区足够的强大，大多数偏门的社区套件，都是从盗版社区发源来的</li><li>有客服，真出了搞不定的问题，我能找客服帮忙做事</li></ol><p>当然，不是没有缺陷，群晖的机器用的设备较拉胯，一般来说，个人组的黑群晖能吊着打正版群晖，这个看个人取舍。</p><h4 id="其他厂商"><a href="#其他厂商" class="headerlink" title="其他厂商"></a>其他厂商</h4><p>除了群晖，市面上确实之后其他厂商了，毕竟盗版系统刷群晖的居多，有什么问题都好解决。</p><p>尽管市面上<a href="https://item.jd.com/100016638665.html">威联通</a>，<a href="https://item.jd.com/100039880211.html">绿联</a>，还有各种厂商都做了很多自家的nas，尤其是威联通的性价比还不错。</p><p>但是，如果系统出了啥问题，大多数都只能去各种社区论坛找方案，找客服进度缓慢，所以这里不是很推荐。</p><h4 id="黑群晖"><a href="#黑群晖" class="headerlink" title="黑群晖"></a>黑群晖</h4><p>现在市面上是有一些自售的成品，我看了一下价格，性价比非常高。</p><p>而且，烧盘问题已经解决了，早期黑群晖系统因为系统休眠问题，对硬盘损耗极大，几个月就能烧掉一个新硬盘。</p><p>在解决掉烧盘问题之后，现在的黑群晖，几乎算是没有短板，我个人十分推荐组一个，推荐理由我这里也列一下。</p><ol><li>性能好，硬件自选，不用被官方束缚，所以很多人组的快赶上服务器了</li><li>价格超低，基本上800-1000，就能组一台暴打正版的高性能设备，盘位还多</li><li>社区解决方案多，因为早期折腾的人多，所以问题也多，所以解决方案就多</li><li>基本上和正版没什么差别的系统，现在基本上和官方一样了，只要刷白，问题不大</li><li>噪音也不大，卧室可用</li></ol><p>这里，也列一下大佬给出的组合作为参考（2023）</p><ol><li>主板，b365</li><li>cpu，g4560</li><li>机箱，蜜獾超存机箱（闲鱼上找，其他平台要么没有要么很贵） </li><li>内存条，威刚万紫千红8&#x2F;16G</li></ol><h3 id="硬盘相关"><a href="#硬盘相关" class="headerlink" title="硬盘相关"></a>硬盘相关</h3><p>硬盘是nas的核心，毕竟作为特化存储的设备，必然是要用机械硬盘的，固态盘的虽然快，但因为它的结构，所以它不能作为长久存储方案。</p><p>我个人推荐先看完<a href="https://www.bilibili.com/video/BV1rE411Q71m/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">硬件茶谈的科普</a>，这个科普详尽而且务实，弄明白了，相信你自己心中也有一套选购标准。</p><p>我这里主要说一些我已经整理到的入门信息，仅供参考使用</p><ol><li>不选瓦楞盘(SMR)，<strong>选垂直盘（CMR）！</strong>具体参考<a href="https://www.bilibili.com/video/BV1rE411Q71m/?spm_id_from=333.999.0.0&vd_source=ee3784ffe5f760cb992921cb8c5c98e5">硬件茶谈的科普</a></li><li>硬盘缓存尽可能的选大的，硬盘在写入数据的时候，大缓存硬盘相对来说频率会低一些，响声不会太大，当然出问题的概率也更高</li><li>机械盘如果没有特别价位参考的话，推荐按照180&#x2F;T的单价来算，一般来说，16-18T左右的硬盘性价比最高</li><li>具体容量大小自行决定，如果只想组家庭影院，推荐上企业盘</li><li>是否组raid，要看自己整理的数据是否重要，性价比是否值得，如果是企业数据，推荐组Raid1</li><li>不要无脑Raid0，组Raid0虽然读写速度快，但是一旦出问题，所有数据会全部崩盘，所以不要乱来</li><li>机械硬盘的寿命很长，据说有十年都没问题的，你也可以选择冷备份，每隔两三年拿出来读写一次就可以</li></ol><h3 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h3><ol><li>尽量放在网络稳定的环境里，使用舒心，硬盘如果长期上传下载也不会出现问题</li><li>使用环境避免潮湿，灰尘，保持通风，硬盘还是蛮娇贵的，机器无所谓</li><li>电力尽可能的稳定，能够保证不会因硬关机导致机械硬盘损坏</li><li>尽量不要放在频繁振动的地方，不然会影响硬盘的指针精度，导致硬盘损毁</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来只是打算简单写篇入门文档，没想到一写就写了一天。</p><p>信息收集不易，后续如果有机会，我会继续更新nas相关文档。</p><p>如果有兴趣，可以加群813222463，大家一起讨论。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次手术（前）</title>
      <link href="/2023/03/09/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%89%8D%EF%BC%89/"/>
      <url>/2023/03/09/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%8B%E6%9C%AF%EF%BC%88%E5%89%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>虽然做好了这次体检很糟糕的情况，但是没想到会这么糟糕。</p><p>甲状腺结节，穿刺验证之后，病理科给出判断——<strong>乳头状癌</strong>，考虑手术。</p><p>嗯，真是开年有惊喜的捏。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一开始查出来这结果，人懵了，毕竟只要沾上癌症之类的字样，基本等同于宣判死刑。</p><p>不过后来去找医生咨询了结果之后，大致可以接受。</p><p>这里把近况稍微做个梳理，也把我术前的心态记录一下。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><ul><li>问题不是很严重，是一种较为常见病症，不是需要特殊命名的情况</li><li>手术可以解决，复发率不高，且对寿命等无影响，不会遗传</li><li>如果长期不解决的话，大致情况就是可能随淋巴扩散，产生其他问题</li><li>医保范围覆盖了该手术，报销之后，估计也就2-3k左右，不用考虑金钱的问题</li></ul><h3 id="难处"><a href="#难处" class="headerlink" title="难处"></a>难处</h3><ul><li>我周边没有空闲的朋友能帮忙，所以最终只能让家人来帮忙</li><li>离职后正处于搬完东西的时候，现在手里基本上没有什么日用品，不方便疗养</li><li>离职后，和预期不一样，所以房租没交，现在房东没说话，所以不稳定，不好规划</li><li>因为一开始挂号不在三甲医院，这个时候，想换医院做手术，要等不少时间，较为繁琐</li><li>下个月就要开始考试了，接下来复习和调理都很费事</li><li>苏州物价偏高，花销上可能会稍微出点问题</li></ul><h3 id="备选"><a href="#备选" class="headerlink" title="备选"></a>备选</h3><p>因为我没在三甲挂号，导致现在很多事情难以处理，如果接下来能够换到三甲医院，一切自然万事大吉。</p><p>但是如果没法换过去，只能按照如下三种备选方案做事了。</p><ol><li>在相城人民医院直接准备手术，让家人过来帮忙照顾</li><li>回老家，动用老家的人脉在三甲医院手术</li><li>拖，等到手边的事情忙完了，再考虑手术</li></ol><p>以上三种方案，都有不小的弊端，但是也只能是目前的无奈之选了。</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ol><li>如果体检出麻烦的问题，<strong>一定要去三甲挂号！</strong>听人劝，吃饱饭，别为了省事绕远路，到头来只会更麻烦</li><li>第一次挂完号之后，后续可以直接拿着检测报告找医生，医生也不喜欢别人一直挂号</li><li>检测结果整理成档案，这便于下一位医生接手</li><li>医院在手术前，需要安排床位，据之前的同事的住院经验，这个时间等待的不是很长（希望如此）</li><li>确实需要一位能够相互扶持的亲近之人，不然真出了问题，朋友们是有自己的事的，他们可以帮你，但是无法陪伴你</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>身体永远是做事的本钱，无论你心中有着何等疯狂的想法，一定要有一副野蛮的体魄才能实现。</p><p>现在这个时间点，也完全不建议用身体去交换金钱————回报太低了。</p><p>最近把所有苏州同事推荐的有意思的点逛了一下，不过，最终还是觉得观前街的美食街有意思，<strong>要得火锅</strong>的番茄汤好喝。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm工具包————发布</title>
      <link href="/2023/03/05/npm%E5%B7%A5%E5%85%B7%E5%8C%85%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83/"/>
      <url>/2023/03/05/npm%E5%B7%A5%E5%85%B7%E5%8C%85%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>本次开源的方法是<a href="https://demo.assetech.com.cn/">cat-tools</a>，目前该工具包已经在npm上可下载，公司多个项目使用，没出什么问题。</p><p>尽管市面上开源了<a href="https://www.lodashjs.com/">loadsh</a>，<a href="http://momentjs.cn/">moment.js</a>，<a href="https://dayjs.fenxianglu.cn/">day.js</a>这类的工具包，但是总有不能满足需求的时候。</p><p>所以，我觉得，还是得造一个趁手的工具包。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一开始，是不同的项目中，有一些独立的工具类方法的整合。</p><p>后来，独立项目越来越多，不同项目之间，同步工具类方法是个大问题。</p><p>如果某项目加入了新的方法，我就要同步复制到很多项目！</p><p>折腾很多次之后，实在感觉耽误时间，且犯错太多，所有就有了本次流程记录。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>在项目开发完成之后，我们首先要打包项目，生成一个能够发布的dist包。</p><p>当然，ui包可能有自己的结构，这个只要开发那边确认之后就行。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>然后，我们需要到<a href="https://www.npmjs.com/">npm官网</a>注册一个账号。</p><p>如果之前<strong>有npm账号的人</strong>，可以略过这步。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>在登录之前需要保证你现在使用的 <code>npm源</code> 是指向 <code>npm</code> 的。</p><p>先安装 <code>nrm</code> 工具查看和切换 <code>npm</code> 源</p><p><code>nrm</code> 安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure><p>查看当前使用的 <code>npm</code> 源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm ls #查看包源列表</span><br><span class="line">nrm use npm  #切换包源列表</span><br></pre></td></tr></table></figure><p>在执行nrm use npm之后，如果命令行中有如下提示，代表切换成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry has been set to: https://registry.npmjs.org/</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在终端使用一下命令登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure><p>然后根据提示输入账号、密码、邮箱，同时还有注册邮箱的一次验证码。</p><p>以我为例，我按照下边的完成填写之后，就算是登录了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Username: *********</span><br><span class="line">Password: ********</span><br><span class="line">Email: (this IS public) *********@qq.com</span><br><span class="line">npm notice Please check your email for a one-time password (OTP)</span><br><span class="line">Enter one-time password from your authenticator app: 04471694</span><br><span class="line">Logged in as crazystudent13 on https://registry.npmjs.org/.</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm publish # 发布公有包</span><br><span class="line">或</span><br><span class="line">npm publish --access public # 发布带命名空间的包，npm publish默认私有需要付费</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="迭代需要修改版本号"><a href="#迭代需要修改版本号" class="headerlink" title="迭代需要修改版本号"></a>迭代需要修改版本号</h4><p>如果项目更新需要重新发布，必须修改 <code>package.json</code> 里的版本号。</p><p>版本号只能不断往上增加，哪怕你后边版本号拖的很长也可以。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="包权限管理"><a href="#包权限管理" class="headerlink" title="包权限管理"></a>包权限管理</h4><p>很多时候，一个项目包往往不只是你一个人在管理的，这时需要给其他一起维护的同学开通发布的权限，相关使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看模块 owner, 其中 demo 为模块名称</span></span><br><span class="line">$ npm owner <span class="built_in">ls</span> demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个发布者, 其中 xxx 为要添加同学的 npm 账号</span></span><br><span class="line">$ npm owner add xxx demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个发布者</span></span><br><span class="line">$ npm owner <span class="built_in">rm</span> xxx demo</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>选择npm，也是因为用的人多，出了问题，论坛的解决方案应该多。</p><p>其实一开始想过其他的同步方案，比如用一个Git来做同步管理。</p><p>但是后来考虑到用的人少，隐患大，而且，这玩意也许不止我们一个人可以用，干脆开源吧。</p><p>开源的项目，如果别人用出了问题，他们也会提示，方便了别人，也促进了自己，挺好的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6991300926099357709">原生 node 搭建最基础的 npm 工具包</a></p><p><a href="https://juejin.cn/post/6844903918414102535">使用npm发布一个vue组件</a></p><p><a href="https://juejin.cn/post/6920231981834108942">一文搞定 npm 包发布与管理</a></p><p><a href="https://juejin.cn/post/7074116683673108493">规范化开发并发布npm包</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————自动部署</title>
      <link href="/2023/03/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>之前写博客的时候还没注意，后来在修改博客的时候，发现不停的敲命令发布确实烦。</p><p>为了解决博客发布占用时间的问题，查了一圈论坛，和相关人员的解决方案。</p><p>最终，我选中了<a href="https://docs.github.com/zh/actions/quickstart">github Action</a>，对于托管在github上的hexo来说，这玩意真是好用。</p><p>另外，我目前只部署到github上，暂时不考虑部署到gitee和coding上。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>在正式确立工作流之前，这里是有两个方案的。</p><ol><li>在GIthub.io那个仓库中新建源码分支，等到分支提交时候，触发命令，然后github流程化部署，博客上线</li><li>新建一个仓库，用来管理博客，博客每次提交，就会触发命令，然后github流程化的自动部署，博客上线</li></ol><p>这两种方案，一开始我更倾向于第一种，因为没什么必要，不多开项目，总是好的。</p><p>但是后来考虑到源码内容中，总会有这种隐私性质的秘钥之类的，放在开源项目确实不好。</p><p>而且，目前很多论坛都倾向于第二种方案，想了想，那这里选择<strong>新建仓库</strong>吧。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>参考市面上大多数人的选择，我在<a href="https://github.com/">github</a>建了一个<strong>blog</strong>仓库，注意新仓库是<strong>私有的</strong>。</p><p>因为，这个仓库是用来存博客源码的，为了规避秘钥被别人看到，所以<strong>不能设置为public！</strong></p><p>在新仓库准备完成之后，我们清空本地仓库的远程链接，然后，让本地的hexo博客源码和远程新仓库完成对接。</p><p>这里我魔改了一下<a href="https://anzhiy.cn/posts/asdx.html#%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%92%8C%E5%88%86%E6%94%AF">安知鱼大佬的流程</a>，咳咳，如果要新建仓库的话，就参考他的教程，我这是对已有的源码修改。</p><ol><li><p>删除博客主题的git文件，比如我这里是<a href="https://github.com/Lhcfl/hexo-theme-anatolo">anatolo</a>。我删除了<code>/themes/anatolo/.git</code>文件，避免主题文件夹下的<code>.git</code>文件夹其被识别成子项目，无法被上传到源码仓库。</p></li><li><p>在博客根目录下，运行指令，我这里是在E:\gitPro\blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化</span><br><span class="line">git remote add origin git@github.com:crazystudent13/blog.git</span><br><span class="line">git checkout -b main # 切换到main分支，</span><br></pre></td></tr></table></figure></li><li><p>添加屏蔽项</p><p>因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到 github 上。这样可以显著减少需要提交的文件量和加快提交速度。</p><p>我再<code>E:\gitPro\blog\.gitignore</code>,屏蔽了以下文件，如果你应用了主题里边的配置项，记得，主题里边的gitignore文件也要完成修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TXT.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure></li><li><p>之后再运行 git 提交指令，将博客源码提交到 github 上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;github action update&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li><li><p>此时你的主题文件夹若已经被正常上传，并且你也添加了主题文件夹下的.git 文件夹的屏蔽项。那你可以考虑把第二步移走或删除的<code>.git</code>放回来，用作以后升级。（个人觉得这种升级方式不是很好）</p></li></ol><h3 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a>获取权限</h3><p>为了确保交由<code>Github Action</code>来持续部署时，<code>Github Action</code> 具备足够的权限来进行 <code>hexo deploy</code> 操作,需要先获取 <code>Token</code></p><p>访问 Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token。</p><p>注意事项：</p><ol><li>名称自己琢磨功能随便填下就行，我这里填的是自动部署。</li><li>必须勾选 repo 项 和 workflows 项。</li><li>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</li></ol><h3 id="建立流程"><a href="#建立流程" class="headerlink" title="建立流程"></a>建立流程</h3><p>打开github在项目的actions下，点击new workflow，新建一个autodeploy.yml的文件就行，然后把我下边的脚本放上去，就能完成博客的自动化部署了。</p><p>我之前用别人的脚本并未一次通关，所以自己查资料调整了一下，这里放调整结果。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"><span class="comment"># 当有改动推送到main分支时，启动Action</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;mian&quot;</span> ]</span><br><span class="line">      <span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">mian</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;16.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">cache-npm</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">cache-name:</span> <span class="string">cache-node-modules</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-build-$&#123;&#123;</span> <span class="string">env.cache-name</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.cache-npm.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install gulp-cli -g #全局安装gulp</span></span><br><span class="line"><span class="string">          npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署到Github</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">ghp_*****************************</span></span><br><span class="line">          <span class="attr">repository-name:</span> <span class="string">CrazyStudent13/CrazyStudent13.github.io</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">folder:</span> <span class="string">public</span></span><br><span class="line">          <span class="attr">commit-message:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; github.event.head_commit.message &#125;&#125;</span> Updated By Github Actions&quot;</span></span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>这里有很多人直接按照教程走会出现有些坑，我这里稍微提一下我遇到的情况：</p><ol><li>不要乱改命令，上述代码中checkout@v2，这个对应的是功能，不是版本。</li><li><strong>注意本地和远端的冲突</strong>，在提交完成代码之后，可以在github远端创建自动部署脚本，不用本地新建文件夹，去产生冲突。</li><li><strong>注意博客源码分支名称</strong>，2021年修改之后，新建的项目主分支应该是main，如果你用到的脚本中有些地方写的是master，记得改成main。</li><li><strong>注意博客分支名称</strong>，也不要完全都改成main分支，我的博客是2019年部署的，废弃很久不用，现在又捡起来，所以分支依然还是master，最后提交的脚本，如果是提交到main，就会报错。</li><li><strong>自己主题内的配置要提交</strong>，不然构建博客的时候，页面构造命令可能会出现跑不通的情况。</li><li><strong>移除不需要的依赖</strong>，不然可能会造成不必要的错误，另外这样也减少下载时间。</li><li><strong>尝试AI帮忙写脚本</strong>，目前2023年，chatgpt发展的还不够狂野，但是我试过，是可以书写这类脚本的。</li></ol><h3 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h3><p>在完成上述内容之后，基本上应该是一步到位的完成。</p><p>如果要是不成，可以打开actions，一步步点进去，看到一个类似shell命令行的界面，里边会将哪个脚本报错，具体步骤的问题提示出来，按照报错排查就行。</p><p>具体操作参考<a href="https://www.bilibili.com/video/BV19P41157no?t=487.7">安知鱼的视频讲解</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在2019年知道有这个，但是没怎么用过。</p><p>没想到几年不见，自动化部署流程这么好用了，看来我这几年的工作，导致我的眼界太不宽阔了。</p><p>这里也非常感谢大佬安知鱼这篇文档的指路，真的对我的自动化部署要求产生了很大的助力。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://anzhiy.cn/posts/asdx.html">使用 Github Action 自动部署 | 安知鱼 (anzhiy.cn)</a></p><p><a href="https://www.bilibili.com/video/BV19P41157no?t=487.7">hexo完成github action自动部署</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年的第一次体检</title>
      <link href="/2023/03/03/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%93%E6%A3%80/"/>
      <url>/2023/03/03/2023%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%93%E6%A3%80/</url>
      
        <content type="html"><![CDATA[<p>23年终于进入到了休息阶段，身体不行，打算休息一下了。</p><p>本来按照人生规划，这段时间是要进入职场中高层，开始弄大钱，过城市生活的，但是身体实在顶不住了。</p><p>而且看病这个事儿吧，我从来没想到会这么麻烦，特别记录一下，如果后续在遇到这种事，有个心理准备。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>看病这个流程是个相当消耗时间的活儿，放在工作的时候，我还真没那么多时间。</p><p>现在算是离职状态，所以时间较为充足，而且终于能挂的上专家号了。之前周六周日都挂不上，现在终于能放心的等一回了。</p><h3 id="挂号"><a href="#挂号" class="headerlink" title="挂号"></a><strong>挂号</strong></h3><ul><li>尽可能的网上挂号，地方的公众号，小程序都有相关的功能</li><li>如果不是血检相关的事情，不要挂早上的，下午的相对来说人比较少</li><li>一般只有周一到周五能挂专家号，尽可能的提前查好</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>常规的流程如下</p><ol><li>挂号，等叫号</li><li>医生诊断后，开药方</li><li>拿着单子去缴费</li><li>缴费完成后，去开药的药房拿药</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>挂号可以用电子医保卡缴费，不必用真社保卡</li><li>挂号，如果当日值班的医生专家还在，依然可以提挂号排队</li><li>叫号如果错过，只要不是当天错过医生的在职时间，都可以商量，在叫号期间稍微商量下，可以补叫号。</li><li>中间流程如果要查B超，血检之类的，那时间可就长了。最好预估自己的病症，若涉及到这类检测，自己要预估时间，最好起步做好一天甚至两天的时间准备。</li><li>如果有些小手术之类的说法，最好问清是否会干扰行动能力，只要不干扰行动能力，一切都可启动孤胆英雄模式，硬抗就可以。</li><li>身体能力不能太过虚弱，过于肥胖，老迈，都需要其他人陪同，不能自己单独行动</li></ol><h3 id="病情"><a href="#病情" class="headerlink" title="病情"></a>病情</h3><p>今年这年初的检测，我都不知道自己这个身体是什么年纪的，高血压高血脂，中度脂肪肝，甲状腺结节，肾结石。</p><p>这一堆问题几乎让我以为自己是老年人，亏得自己年轻，看来不能太卷了。</p><h4 id="甲状腺结节"><a href="#甲状腺结节" class="headerlink" title="甲状腺结节"></a>甲状腺结节</h4><p>目前还没有出现病理检测，所以不知道是什么情况，希望问题不大。</p><p>主要是做甲状腺穿刺之后，嗓子上就像是有根针顶着，稍微剧烈的吞咽，说话等动作，或者情绪激动，嗓子就疼的不行。</p><p>2023-03-10，检测结果出现，疑似乳头状癌，需要手术（艹）</p><h4 id="左肾结石"><a href="#左肾结石" class="headerlink" title="左肾结石"></a>左肾结石</h4><p>这个目前看来问题不大，医生的意思是多喝点水，定期检查就行。这个还是得注意的，毕竟是肾。</p><h4 id="中度至重度脂肪肝"><a href="#中度至重度脂肪肝" class="headerlink" title="中度至重度脂肪肝"></a>中度至重度脂肪肝</h4><p>荤食得忌口了，这一年，疗养时间怕是吃不到几次荤食了。</p><h4 id="高血压，高血脂"><a href="#高血压，高血脂" class="headerlink" title="高血压，高血脂"></a>高血压，高血脂</h4><p>盐，油估计都得节制了，医生的桌上写着，不要超过7g盐，感觉有点离谱。</p><p>因尿酸偏高，多吃低嘌呤食物，粗粮，减少饮酒。</p><h4 id="颈部曲度消失"><a href="#颈部曲度消失" class="headerlink" title="颈部曲度消失"></a>颈部曲度消失</h4><p>这个只能去找正骨科的医生问问了，现在脖子确实很难受</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因为医保在苏州，在没有弄清楚医保机制的前提下，只能先在这边用医保了。</p><p>对病症的确诊，远比想象的麻烦，作为没有什么关系的凡人，没想到看病这么麻烦啊，看来以后真的得好好学习身体的保养了。</p><p>如果对养生这块比较了解的朋友，可以在评论区留言，如果能推荐几本书就更好了，在这里提前谢谢了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 养生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————命令整理</title>
      <link href="/2019/02/11/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2019/02/11/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>虽然Hexo确实很好用，但是由于我对命令和配置的不熟悉，导致很多东西都不是很好用。</p><p>建议参考<a href="https://hexo.io/themes/">官网</a>的文档，我梳理了一份属于自己的命令文档。</p> <span id="more"></span> <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装</span><br><span class="line">npm update hexo -g #升级 </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览，会监视文件变动并自动更新，您无须重启服务器</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br></pre></td></tr></table></figure><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">标题</td></tr><tr><td align="center">layout</td><td align="center">布局</td></tr><tr><td align="center">date</td><td align="center">文件建立日期</td></tr><tr><td align="center">title</td><td align="center">标题</td></tr><tr><td align="center">categories</td><td align="center">分类</td></tr><tr><td align="center">tags</td><td align="center">标签</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">categories: Blog</span><br><span class="line">tags: [Hexo]</span><br></pre></td></tr></table></figure><h3 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上是文章摘要 </span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">以下是余下全文</span><br></pre></td></tr></table></figure><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &lt;title&gt;</span><br><span class="line">hexo new post &lt;title&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:title</td><td align="center">标题</td></tr><tr><td align="center">:year</td><td align="center">建立的年份（4 位数）</td></tr><tr><td align="center">:month</td><td align="center">建立的月份（2 位数）</td></tr><tr><td align="center">:i_month</td><td align="center">建立的月份（去掉开头的零）</td></tr><tr><td align="center">:day</td><td align="center">建立的日期（2 位数）</td></tr><tr><td align="center">:i_day</td><td align="center">建立的日期（去掉开头的零）</td></tr></tbody></table><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="语雀同步插件"><a href="#语雀同步插件" class="headerlink" title="语雀同步插件"></a>语雀同步插件</h3><p>之前个人使用了<a href="https://blog.lxstart.net/">小冷</a>的<a href="https://github.com/x-cold/yuque-hexo#Example">语雀对接插件</a>，感觉很不错，这里也整理一下。</p><p>不过，现在语雀用我已经停用了，它总给我一种难受的感觉，我说不上来。</p><p>虽然语雀他们各方面整的都挺好，但是不知道为啥，用起来就是膈应。</p><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g yuque-hexo</span><br><span class="line"># or</span><br><span class="line">npm i --save-dev yuque-hexo</span><br></pre></td></tr></table></figure><p><strong>Sync</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuque-hexo sync</span><br></pre></td></tr></table></figure><p><strong>Clean</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yuque-hexo clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————基础流程</title>
      <link href="/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建的流程几乎烂大街了，19年的时候搭建时候写的，没想到现在又用上了。</p><p>这是老早之前的文档，这次翻出来重新梳理搭建流程，完善几个细节，为了后续给其他人提供便利。</p><span id="more"></span><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>安装并配置好Node.js环境，只要常规的输入以下命令，如果输出版本号了，证明已经安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装Git和配置好Git环境，同上，用git版本号来确定以下有没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h4 id="注册项目"><a href="#注册项目" class="headerlink" title="注册项目"></a>注册项目</h4><p>Github账户注册，新建项目：账户名.github.io，并且需要勾选Initialize this repository with a README</p><p>比如我这里，是在GitHub上，建的<a href="https://github.com/CrazyStudent14/CrazyStudent14.github.io">CrazyStudent14.github.io</a>项目。</p><p><strong>注意</strong>：国内的码云实际上也是支持这个操作的，不过码云有个缺陷，就是如果你后续想绑定域名来访问这个博客的话，码云因为国内的政策问题，无法绑定，而github无所谓，所以，部署的时候，考虑清楚自己的需求。</p><h4 id="本地准备"><a href="#本地准备" class="headerlink" title="本地准备"></a>本地准备</h4><p>这个流程有点长，主要是在本地完成博客的准备和构建</p><p>以下流程尽可能的全程命令行操作</p><p>本地自己先部署Hexo项目，在自己认为合适的地方创个文件夹。</p><p>我是在E盘建了一个blog文件夹，然后npm全局安装一个Hexo依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;cd gitpro/blog</span><br><span class="line">E:\gitPro\blog&gt;npm install hexo -g</span><br></pre></td></tr></table></figure><p>安装完成hexo之后，hexo -v，查hexo的版本号，检查hexo是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo -v</span><br></pre></td></tr></table></figure><p>至此，本地部署的前期工作完成，输入hexo init，初始化该文件夹（有点漫长的等待。。。）</p><p>完成安装后，出现Start blogging with Hexo！这就代表Hexo已经在这个文件夹下初始化成功可，在本地完成项目新建了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo init</span><br></pre></td></tr></table></figure><p>这时候的项目，是个架子，没有安装依赖，相当于炒菜有锅没买菜一样，所以，需要npm来安装依赖。</p><p>输入npm install，安装所需要的组件，等安装成功之后就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>输入hexo g，先完成项目构建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo g</span><br></pre></td></tr></table></figure><p>输入hexo s，开启服务器，访问本地化网址，如果没有端口占用的话，一般是<a href="http://localhost:4000/">http://localhost:4000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo s</span><br></pre></td></tr></table></figure><p>假如页面一直无法跳转，那么可能端口被占用了，输入“hexo server -p 端口号”来改变端口号。</p><p>这样的话，我们会直接启动<a href="http://localhost:5000/">http://localhost:5000/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;hexo s -p 5000</span><br></pre></td></tr></table></figure><h4 id="准备秘钥"><a href="#准备秘钥" class="headerlink" title="准备秘钥"></a>准备秘钥</h4><p>这一步操作有点繁琐，我的教程只是个大纲，如果要是不清楚细节，可以在<a href="https://juejin.cn/">掘金</a>详细搜一下这里的小标题，里边应该有很多详细操作。</p><p><strong>注意</strong>：如果是首次设置git本地的秘钥，请按照如下流程操作，如果已经有秘钥了，其实生成部分可以跳过。</p><h5 id="设置Git的user-name和email"><a href="#设置Git的user-name和email" class="headerlink" title="设置Git的user name和email"></a>设置Git的user name和email</h5><p>我这里随便取个crazystudent14的假名字做演示，如果自己部署，不要抄名字，名字和邮箱换成自己的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\gitPro\blog&gt;git config --global user.name &quot;crazystudent14&quot;</span><br><span class="line">E:\gitPro\blog&gt;git config --global user.name &quot;crazystudent14@test.com&quot;</span><br></pre></td></tr></table></figure><h5 id="Git生成SSH密钥"><a href="#Git生成SSH密钥" class="headerlink" title="Git生成SSH密钥"></a>Git生成SSH密钥</h5><p>为了将Hexo与Github page联系起来，切换到C盘，准备生成秘钥文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\crazystudent14&gt;cd C:\Users\crazystudent14\.ssh</span><br><span class="line">C:\Users\crazystudent14&gt;ssh-keygen -t rsa -C &quot;crazystudent14@163.com&quot;</span><br></pre></td></tr></table></figure><p>判断<strong>id_rsa</strong>，<strong>id_rsa.pub</strong>，<strong>known_hosts</strong>这三个文件是否存在。</p><p>我这里是win系统，如果是linux和mac系统，自己查一下相关的命令，或者到对应的文件夹去看一下。反正就是看看这个文件夹下边有没有这是三个文件，有的话，可以继续做。</p><h5 id="在github上添加key"><a href="#在github上添加key" class="headerlink" title="在github上添加key"></a>在github上添加key</h5><p>登录Github，点击头像下的settings，找到左侧的SSH and GPG keys。</p><p>点击new ssh key按钮，将id_rsa.pub文件里的内容复制上去，title就填写blog（这个title就是告诉你，这个Key是做什么用的，相当于备注）</p><h5 id="检测Key是否添加成功"><a href="#检测Key是否添加成功" class="headerlink" title="检测Key是否添加成功"></a>检测Key是否添加成功</h5><p>输入ssh -T <a href="">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@coding.net</span><br></pre></td></tr></table></figure><h4 id="准备发布"><a href="#准备发布" class="headerlink" title="准备发布"></a>准备发布</h4><p>好了，一切终于快结束了，我们再确认下流程。</p><ol><li>配置完成本地环境</li><li>在github注册好项目</li><li>本地完成Hexo博客的准备</li><li>在github添加自己的本地生成的key</li></ol><p>确认以上流程完成后，我们可以进行最后一步了。</p><h5 id="设置deploy"><a href="#设置deploy" class="headerlink" title="设置deploy"></a>设置deploy</h5><p>在博客项目的根件夹中，我这里是E:\gitPro\blog，找到_config.yml文件。</p><p>配置Deployment，修改repo值（在末尾），repo值是你在github项目里的ssh（右下角）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repository: &#x27;git@github.com:CrazyStudent14/CrazyStudent14.github.io.git&#x27;</span><br><span class="line">  branch: &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h5 id="部署deploy"><a href="#部署deploy" class="headerlink" title="部署deploy"></a>部署deploy</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>项目根目录中，执行命令hexo d -g，生成以及部署了（记住这个命令，这是用来把文章提交到Github上的命令，以后会经常用的）</p><p>部署成功后访问你的地址：<a href="http://用户名.github.io/">http:&#x2F;&#x2F;用户名.github.io</a>。那么将看到生成的文章</p><h5 id="写新博客"><a href="#写新博客" class="headerlink" title="写新博客"></a>写新博客</h5><p>通过以下命令创建新文件，我们会在source&#x2F;_posts目录下将会看到已经创建的文件，然后在新文件中写文章就行了。</p><p>写完之后，继续部署ok。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;博客名&quot;</span><br></pre></td></tr></table></figure><p>好了，到此为止，最基本的hexo+github搭建流程结束了。</p><p>我们看看效果吧。</p><h4 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h4><p>在建好的项目，点击右侧settings的tab栏目，向下拉到GitHub Pages，你会看到那边有个网址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://CrazyStudent14.github.io</span><br></pre></td></tr></table></figure><p>这时候，你已经有了一个部署在github上的hexo博客了。</p>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo个人博客搭建————域名绑定</title>
      <link href="/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"/>
      <url>/2019/02/10/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>电脑系统为window 10专业版，64位</p><p>这里默认大家已经完成了git博客的部署，接下来的操作，就是将git的地址，绑定到我们的个人域名</p><span id="more"></span><p>接下里的教程，我大致将过程分为三个阶段</p><ul><li>准备阶段：准备自己购买<strong>自己的域名</strong>，配置<strong>域名解析</strong></li><li>绑定阶段：<strong>在github上绑定自己的域名</strong>，并在本地<strong>设置CNAME文件</strong>，提交，完成域名的固定绑定</li><li>验证阶段：收尾，测试绑定是否成功</li></ul><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>需要实名认证，然后购买，不过域名不贵，推荐随便买个cn的域名就行。</p><p>购买渠道很多，腾讯，阿里，华为等，我个人在阿里云买的域名。</p><blockquote><p>crazystudent13.cn</p></blockquote><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>以我使用的阿里云为例，我会打开管理控制台，点击<strong>解析</strong>。</p><p>按照下边的记录，配置解析，按照下方的表格去操作。</p><p>记录类型为A的，是github的网址，CNAME是个人博客的仓库。</p><table><thead><tr><th align="center">主机记录</th><th align="center">记录类型</th><th align="center">解析请求来源</th><th align="center">记录值</th></tr></thead><tbody><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.108.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.109.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.110.153</td></tr><tr><td align="center">@</td><td align="center">A</td><td align="center">默认</td><td align="center">185.199.111.153</td></tr><tr><td align="center">www</td><td align="center">CNAME</td><td align="center">默认</td><td align="center">crazystudent13.github.io</td></tr></tbody></table><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>进入自己的Git博客项目中，打开setting，下拉，找到Github Pages。</p><p>在输入框中输入我们买的域名（不要输入www.），完成内容。</p><p>如果没有立刻生效，等10分钟左右（dns的解析时间差不多是这个时间，具体可以看域名控制台的说明）。</p><h4 id="固定域名"><a href="#固定域名" class="headerlink" title="固定域名"></a>固定域名</h4><p>这一步本来是不必要的，但是每次发布，域名就会失效。为了一劳永逸，这个得做。</p><p>在博客的source文件夹中，新建文件CNAME(没有后缀，什么后缀都没有，字母必须大写)。</p><p>将个人域名存入文件中，然后发布，等待。</p><blockquote><p>crazystudent13.cn</p></blockquote><h4 id="验证绑定"><a href="#验证绑定" class="headerlink" title="验证绑定"></a>验证绑定</h4><p>浏览器输入自己的域名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.crazystudent13.cn</span><br></pre></td></tr></table></figure><p>如果您像以上我的博客那样，您也跳转到了自己的git博客，那就代表成功了。</p><p>而且就算提交文件，也不会覆盖掉域名设置。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，所有的工作全部做完了，一路看下来，其实利用Github创建博客是个很简单的事。</p><p>其实一开始，我是想利用VUE和语雀的接口做一个博客来锻炼自己技术的。</p><p>但是后来我觉得太过麻烦，而且过年又犯懒，加之网上不止一个人以个人博客为项目写了DEMO，这里自己再做，恐怕也有点过于重复，没多少意义了。</p><p>时隔数年，没想到还是用这玩意了，真的是有些令人唏嘘。</p>]]></content>
      
      
      <categories>
          
          <category> 非工作技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
